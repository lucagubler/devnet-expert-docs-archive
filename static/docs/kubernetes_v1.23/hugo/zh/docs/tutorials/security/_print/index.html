<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/tutorials/security/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/tutorials/security/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/tutorials/security/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>安全 | Kubernetes</title><meta property="og:title" content="安全" />
<meta property="og:description" content="生产级别的容器编排系统" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/tutorials/security/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="安全">
<meta itemprop="description" content="生产级别的容器编排系统"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="安全"/>
<meta name="twitter:description" content="生产级别的容器编排系统"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:url" content="http://localhost:1313/zh/docs/tutorials/security/">
<meta property="og:title" content="安全">
<meta name="twitter:title" content="安全">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tutorials/security/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/tutorials/security/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tutorials/security/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tutorials/security/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tutorials/security/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tutorials/security/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tutorials/security/">한국어 Korean</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tutorials/security/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">安全</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-fca078b8ac6b82352ed52187a2da91b7">使用 AppArmor 限制容器对资源的访问</a></li>


    
  
    
    
	
<li>2: <a href="#pg-31a6c137cfc5bfea9d88f4b109109465">在名字空间级别应用 Pod 安全标准</a></li>


    
  
    
    
	
<li>3: <a href="#pg-d5f847bcdb6f7efbfc9c8a180d73e29a">在集群级别应用 Pod 安全标准</a></li>


    
  
    
    
	
<li>4: <a href="#pg-8b105172a11322c70d0223bc9dff1904">使用 seccomp 限制容器的系统调用</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-fca078b8ac6b82352ed52187a2da91b7">1 - 使用 AppArmor 限制容器对资源的访问</h1>
    
	<!--
title: Restrict a Container's Access to Resources with AppArmor
content_type: tutorial
weight: 10
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.4 [beta]</code>
</div>


<!-- 
AppArmor is a Linux kernel security module that supplements the standard Linux user and group based
permissions to confine programs to a limited set of resources. AppArmor can be configured for any
application to reduce its potential attack surface and provide greater in-depth defense. It is
configured through profiles tuned to allow the access needed by a specific program or container,
such as Linux capabilities, network access, file permissions, etc. Each profile can be run in either
*enforcing* mode, which blocks access to disallowed resources, or *complain* mode, which only reports
violations. 
-->
<p>AppArmor 是一个 Linux 内核安全模块，
它补充了基于标准 Linux 用户和组的权限，将程序限制在一组有限的资源中。
AppArmor 可以配置为任何应用程序减少潜在的攻击面，并且提供更加深入的防御。
它通过调整配置文件进行配置，以允许特定程序或容器所需的访问，
如 Linux 权能字、网络访问、文件权限等。
每个配置文件都可以在
<em>强制（enforcing）</em> 模式（阻止访问不允许的资源）或
<em>投诉（complain）</em> 模式（仅报告冲突）下运行。</p>
<!-- 
AppArmor can help you to run a more secure deployment by restricting what containers are allowed to
do, and/or provide better auditing through system logs. However, it is important to keep in mind
that AppArmor is not a silver bullet and can only do so much to protect against exploits in your
application code. It is important to provide good, restrictive profiles, and harden your
applications and cluster from other angles as well.
-->
<p>AppArmor 可以通过限制允许容器执行的操作，
和/或通过系统日志提供更好的审计来帮助你运行更安全的部署。
但是，重要的是要记住 AppArmor 不是灵丹妙药，
只能做部分事情来防止应用程序代码中的漏洞。
提供良好的限制性配置文件，并从其他角度强化你的应用程序和集群非常重要。</p>
<h2 id="objectives">Objectives</h2>
<!-- 
* See an example of how to load a profile on a node
* Learn how to enforce the profile on a Pod
* Learn how to check that the profile is loaded
* See what happens when a profile is violated
* See what happens when a profile cannot be loaded 
-->
<ul>
<li>查看如何在节点上加载配置文件示例</li>
<li>了解如何在 Pod 上强制执行配置文件</li>
<li>了解如何检查配置文件是否已加载</li>
<li>查看违反配置文件时会发生什么</li>
<li>查看无法加载配置文件时会发生什么</li>
</ul>
<h2 id="before-you-begin">Before you begin</h2>
<!-- Make sure: -->
<p>确保：</p>
<!-- 
1. Kubernetes version is at least v1.4 -- Kubernetes support for AppArmor was added in
   v1.4. Kubernetes components older than v1.4 are not aware of the new AppArmor annotations, and
   will **silently ignore** any AppArmor settings that are provided. To ensure that your Pods are
   receiving the expected protections, it is important to verify the Kubelet version of your nodes:

   ```shell
   kubectl get nodes -o=jsonpath=$'{range .items[*]}{@.metadata.name}: {@.status.nodeInfo.kubeletVersion}\n{end}'
   ```
   ```
   gke-test-default-pool-239f5d02-gyn2: v1.4.0
   gke-test-default-pool-239f5d02-x1kf: v1.4.0
   gke-test-default-pool-239f5d02-xwux: v1.4.0
   ```
-->
<ol>
<li>
<p>Kubernetes 版本至少是 v1.4 —— AppArmor 在 Kubernetes v1.4 版本中才添加了对 AppArmor 的支持。
早于 v1.4 版本的 Kubernetes 组件不知道新的 AppArmor 注解
并且将会 <strong>默认忽略</strong> 提供的任何 AppArmor 设置。
为了确保你的 Pod 能够得到预期的保护，必须验证节点的 Kubelet 版本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">$&#39;{range .items[*]}{@.metadata.name}: {@.status.nodeInfo.kubeletVersion}\n{end}&#39;</span>
</code></pre></div><pre><code>gke-test-default-pool-239f5d02-gyn2: v1.4.0
gke-test-default-pool-239f5d02-x1kf: v1.4.0
gke-test-default-pool-239f5d02-xwux: v1.4.0
</code></pre></li>
</ol>
<!-- 
2. AppArmor kernel module is enabled -- For the Linux kernel to enforce an AppArmor profile, the
   AppArmor kernel module must be installed and enabled. Several distributions enable the module by
   default, such as Ubuntu and SUSE, and many others provide optional support. To check whether the
   module is enabled, check the `/sys/module/apparmor/parameters/enabled` file:

   ```shell
   cat /sys/module/apparmor/parameters/enabled
   Y
   ```

   If the Kubelet contains AppArmor support (>= v1.4), it will refuse to run a Pod with AppArmor
   options if the kernel module is not enabled.

  <div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Ubuntu carries many AppArmor patches that have not been merged into the upstream Linux
kernel, including patches that add additional hooks and features. Kubernetes has only been
tested with the upstream version, and does not promise support for other features.
</div>
-->
<ol start="2">
<li>
<p>AppArmor 内核模块已启用 —— 要使 Linux 内核强制执行 AppArmor 配置文件，
必须安装并且启动 AppArmor 内核模块。默认情况下，有几个发行版支持该模块，
如 Ubuntu 和 SUSE，还有许多发行版提供可选支持。要检查模块是否已启用，请检查
<code>/sys/module/apparmor/parameters/enabled</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat /sys/module/apparmor/parameters/enabled
Y
</code></pre></div><p>如果 Kubelet 包含 AppArmor 支持（&gt;= v1.4），
但是内核模块未启用，它将拒绝运行带有 AppArmor 选项的 Pod。</p>
</li>
</ol>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Ubuntu 携带了许多没有合并到上游 Linux 内核中的 AppArmor 补丁，
包括添加附加钩子和特性的补丁。Kubernetes 只在上游版本中测试过，不承诺支持其他特性。
</div>
<!--
3. Container runtime supports AppArmor -- Currently all common Kubernetes-supported container
   runtimes should support AppArmor, like <a class='glossary-tooltip' title='Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/kubectl/docker-cli-to-kubectl/' target='_blank' aria-label='Docker'>Docker</a>,
   <a class='glossary-tooltip' title='专用于 Kubernetes 的轻量级容器运行时软件' data-toggle='tooltip' data-placement='top' href='https://cri-o.io/#what-is-cri-o' target='_blank' aria-label='CRI-O'>CRI-O</a> or <a class='glossary-tooltip' title='强调简单性、健壮性和可移植性的一种容器运行时' data-toggle='tooltip' data-placement='top' href='https://containerd.io/docs/' target='_blank' aria-label='containerd'>containerd</a>.
   Please refer to the corresponding runtime documentation and verify that the cluster fulfills
   the requirements to use AppArmor.
-->
<ol start="3">
<li>容器运行时支持 AppArmor —— 目前所有常见的 Kubernetes 支持的容器运行时都应该支持 AppArmor，
像 <a class='glossary-tooltip' title='Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/kubectl/docker-cli-to-kubectl/' target='_blank' aria-label='Docker'>Docker</a>，<a class='glossary-tooltip' title='专用于 Kubernetes 的轻量级容器运行时软件' data-toggle='tooltip' data-placement='top' href='https://cri-o.io/#what-is-cri-o' target='_blank' aria-label='CRI-O'>CRI-O</a>
或 <a class='glossary-tooltip' title='强调简单性、健壮性和可移植性的一种容器运行时' data-toggle='tooltip' data-placement='top' href='https://containerd.io/docs/' target='_blank' aria-label='containerd'>containerd</a>。
请参考相应的运行时文档并验证集群是否满足使用 AppArmor 的要求。</li>
</ol>
<!-- 
4. Profile is loaded -- AppArmor is applied to a Pod by specifying an AppArmor profile that each
   container should be run with. If any of the specified profiles is not already loaded in the
   kernel, the Kubelet (>= v1.4) will reject the Pod. You can view which profiles are loaded on a
   node by checking the `/sys/kernel/security/apparmor/profiles` file. For example:

   ```shell
   ssh gke-test-default-pool-239f5d02-gyn2 "sudo cat /sys/kernel/security/apparmor/profiles | sort"
   ```
   ```
   apparmor-test-deny-write (enforce)
   apparmor-test-audit-write (enforce)
   docker-default (enforce)
   k8s-nginx (enforce)
   ```

   For more details on loading profiles on nodes, see
   [Setting up nodes with profiles](#setting-up-nodes-with-profiles).
-->
<ol start="4">
<li>
<p>配置文件已加载 —— 通过指定每个容器都应使用的 AppArmor 配置文件，
AppArmor 会被应用到 Pod 上。如果指定的任何配置文件尚未加载到内核，
Kubelet（&gt;= v1.4） 将拒绝 Pod。
通过检查 <code>/sys/kernel/security/apparmor/profiles</code> 文件，
可以查看节点加载了哪些配置文件。例如:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ssh gke-test-default-pool-239f5d02-gyn2 <span style="color:#b44">&#34;sudo cat /sys/kernel/security/apparmor/profiles | sort&#34;</span>
</code></pre></div><pre><code>apparmor-test-deny-write (enforce)
apparmor-test-audit-write (enforce)
docker-default (enforce)
k8s-nginx (enforce)
</code></pre><p>有关在节点上加载配置文件的详细信息，请参见<a href="#setting-up-nodes-with-profiles">使用配置文件设置节点</a>。</p>
</li>
</ol>
<!-- 
As long as the Kubelet version includes AppArmor support (>= v1.4), the Kubelet will reject a Pod
with AppArmor options if any of the prerequisites are not met. You can also verify AppArmor support
on nodes by checking the node ready condition message (though this is likely to be removed in a
later release): 
-->
<p>只要 Kubelet 版本包含 AppArmor 支持(&gt;=v1.4)，
如果不满足这些先决条件，Kubelet 将拒绝带有 AppArmor 选项的 Pod。
你还可以通过检查节点就绪状况消息来验证节点上的 AppArmor 支持（尽管这可能会在以后的版本中删除）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes -o<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">$&#39;{range .items[*]}{@.metadata.name}: {.status.conditions[?(@.reason==&#34;KubeletReady&#34;)].message}\n{end}&#39;</span>
</code></pre></div><pre><code>gke-test-default-pool-239f5d02-gyn2: kubelet is posting ready status. AppArmor enabled
gke-test-default-pool-239f5d02-x1kf: kubelet is posting ready status. AppArmor enabled
gke-test-default-pool-239f5d02-xwux: kubelet is posting ready status. AppArmor enabled
</code></pre><!-- lessoncontent -->
<!-- ## Securing a Pod -->
<h2 id="securing-a-pod">保护 Pod</h2>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
AppArmor is currently in beta, so options are specified as annotations. Once support graduates to
general availability, the annotations will be replaced with first-class fields (more details in
[Upgrade path to GA](#upgrade-path-to-general-availability)).
-->
<p>AppArmor 目前处于 Beta 阶段，因此选项以注解形式设定。
一旦 AppArmor 支持进入正式发布阶段，注解将被替换为一阶的资源字段
（更多详情参见<a href="#upgrade-path-to-general-availability">升级到 GA 的途径</a>）。
</div>
<!--
AppArmor profiles are specified *per-container*. To specify the AppArmor profile to run a Pod
container with, add an annotation to the Pod's metadata: 
-->
<p>AppArmor 配置文件是按 <em>逐个容器</em> 的形式来设置的。
要指定用来运行 Pod 容器的 AppArmor 配置文件，请向 Pod 的 metadata 添加注解：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;</span>:<span style="color:#bbb"> </span>&lt;profile_ref&gt;<span style="color:#bbb">
</span></code></pre></div><!-- 
Where `<container_name>` is the name of the container to apply the profile to, and `<profile_ref>`
specifies the profile to apply. The `profile_ref` can be one of: 
-->
<p><code>&lt;container_name&gt;</code> 的名称是配置文件所针对的容器的名称，<code>&lt;profile_def&gt;</code> 则设置要应用的配置文件。
<code>&lt;profile_ref&gt;</code> 可以是以下取值之一：</p>
<!-- 
* `runtime/default` to apply the runtime's default profile
* `localhost/<profile_name>` to apply the profile loaded on the host with the name `<profile_name>`
* `unconfined` to indicate that no profiles will be loaded 
-->
<ul>
<li><code>runtime/default</code> 应用运行时的默认配置</li>
<li><code>localhost/&lt;profile_name&gt;</code> 应用在主机上加载的名为 <code>&lt;profile_name&gt;</code> 的配置文件</li>
<li><code>unconfined</code> 表示不加载配置文件</li>
</ul>
<!-- 
See the [API Reference](#api-reference) for the full details on the annotation and profile name formats.
-->
<p>有关注解和配置文件名称格式的详细信息，请参阅<a href="#api-reference">API 参考</a>。</p>
<!-- 
Kubernetes AppArmor enforcement works by first checking that all the prerequisites have been
met, and then forwarding the profile selection to the container runtime for enforcement. If the
prerequisites have not been met, the Pod will be rejected, and will not run. 
-->
<p>Kubernetes AppArmor 强制执行机制首先检查所有先决条件都已满足，
然后将所选的配置文件转发到容器运行时进行强制执行。
如果未满足先决条件，Pod 将被拒绝，并且不会运行。</p>
<!-- 
To verify that the profile was applied, you can look for the AppArmor security option listed in the container created event: 
-->
<p>要验证是否应用了配置文件，可以在容器创建事件中查找所列出的 AppArmor 安全选项：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get events | grep Created
</code></pre></div><pre><code>22s        22s         1         hello-apparmor     Pod       spec.containers{hello}   Normal    Created     {kubelet e2e-test-stclair-node-pool-31nt}   Created container with docker id 269a53b202d3; Security:[seccomp=unconfined apparmor=k8s-apparmor-example-deny-write]
</code></pre><!-- 
You can also verify directly that the container's root process is running with the correct profile by checking its proc attr: 
-->
<p>你还可以通过检查容器的 proc attr，直接验证容器的根进程是否以正确的配置文件运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> &lt;pod_name&gt; cat /proc/1/attr/current
</code></pre></div><pre><code>k8s-apparmor-example-deny-write (enforce)
</code></pre><!-- ## Example -->
<h2 id="example">举例</h2>
<!-- *This example assumes you have already set up a cluster with AppArmor support.* -->
<p><em>本例假设你已经设置了一个集群使用 AppArmor 支持。</em></p>
<!-- 
First, we need to load the profile we want to use onto our nodes. This profile denies all file writes: 
-->
<p>首先，我们需要将要使用的配置文件加载到节点上。配置文件拒绝所有文件写入：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic">#include &lt;tunables/global&gt;</span>

profile k8s-apparmor-example-deny-write <span style="color:#b8860b">flags</span><span style="color:#666">=(</span>attach_disconnected<span style="color:#666">)</span> <span style="color:#666">{</span>
  <span style="color:#080;font-style:italic">#include &lt;abstractions/base&gt;</span>

  file,

  <span style="color:#080;font-style:italic"># Deny all file writes.</span>
  deny /** w,
<span style="color:#666">}</span>
</code></pre></div><!-- 
Since we don't know where the Pod will be scheduled, we'll need to load the profile on all our
nodes. For this example we'll use SSH to install the profiles, but other approaches are
discussed in [Setting up nodes with profiles](#setting-up-nodes-with-profiles). 
-->
<p>由于我们不知道 Pod 将被调度到哪里，我们需要在所有节点上加载配置文件。
在本例中，我们将使用 SSH 来安装概要文件，
但是在<a href="#setting-up-nodes-with-profiles">使用配置文件设置节点</a>中讨论了其他方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">NODES</span><span style="color:#666">=(</span>
    <span style="color:#080;font-style:italic"># The SSH-accessible domain names of your nodes</span>
    gke-test-default-pool-239f5d02-gyn2.us-central1-a.my-k8s
    gke-test-default-pool-239f5d02-x1kf.us-central1-a.my-k8s
    gke-test-default-pool-239f5d02-xwux.us-central1-a.my-k8s<span style="color:#666">)</span>
<span style="color:#a2f;font-weight:bold">for</span> NODE in <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">NODES</span>[*]<span style="color:#b68;font-weight:bold">}</span>; <span style="color:#a2f;font-weight:bold">do</span> ssh <span style="color:#b8860b">$NODE</span> <span style="color:#b44">&#39;sudo apparmor_parser -q &lt;&lt;EOF
</span><span style="color:#b44">#include &lt;tunables/global&gt;
</span><span style="color:#b44">
</span><span style="color:#b44">profile k8s-apparmor-example-deny-write flags=(attach_disconnected) {
</span><span style="color:#b44">  #include &lt;abstractions/base&gt;
</span><span style="color:#b44">
</span><span style="color:#b44">  file,
</span><span style="color:#b44">
</span><span style="color:#b44">  # Deny all file writes.
</span><span style="color:#b44">  deny /** w,
</span><span style="color:#b44">}
</span><span style="color:#b44">EOF&#39;</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!-- Next, we'll run a simple "Hello AppArmor" pod with the deny-write profile: -->
<p>接下来，我们将运行一个带有拒绝写入配置文件的简单 “Hello AppArmor” Pod：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/hello-apparmor.yaml" download="pods/security/hello-apparmor.yaml"><code>pods/security/hello-apparmor.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-hello-apparmor-yaml')" title="Copy pods/security/hello-apparmor.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-hello-apparmor-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello-apparmor<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># Tell Kubernetes to apply the AppArmor profile &#34;k8s-apparmor-example-deny-write&#34;.</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># Note that this is ignored if the Kubernetes node is not running version 1.4 or greater.</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">container.apparmor.security.beta.kubernetes.io/hello</span>:<span style="color:#bbb"> </span>localhost/k8s-apparmor-example-deny-write<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>busybox:1.28<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span>[<span style="color:#bbb"> </span><span style="color:#b44">&#34;sh&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;-c&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;echo &#39;Hello AppArmor!&#39; &amp;&amp; sleep 1h&#34;</span><span style="color:#bbb"> </span>]<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./hello-apparmor.yaml
</code></pre></div><!-- 
If we look at the pod events, we can see that the Pod container was created with the AppArmor
profile "k8s-apparmor-example-deny-write": 
-->
<p>如果我们查看 Pod 事件，我们可以看到 Pod 容器是用 AppArmor
配置文件 “k8s-apparmor-example-deny-write” 所创建的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get events | grep hello-apparmor
</code></pre></div><pre><code>14s        14s         1         hello-apparmor   Pod                                Normal    Scheduled   {default-scheduler }                           Successfully assigned hello-apparmor to gke-test-default-pool-239f5d02-gyn2
14s        14s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Pulling     {kubelet gke-test-default-pool-239f5d02-gyn2}   pulling image &quot;busybox&quot;
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Pulled      {kubelet gke-test-default-pool-239f5d02-gyn2}   Successfully pulled image &quot;busybox&quot;
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Created     {kubelet gke-test-default-pool-239f5d02-gyn2}   Created container with docker id 06b6cd1c0989; Security:[seccomp=unconfined apparmor=k8s-apparmor-example-deny-write]
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Started     {kubelet gke-test-default-pool-239f5d02-gyn2}   Started container with docker id 06b6cd1c0989
</code></pre><!-- We can verify that the container is actually running with that profile by checking its proc attr: -->
<p>我们可以通过检查该配置文件的 proc attr 来验证容器是否实际使用该配置文件运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> hello-apparmor -- cat /proc/1/attr/current
</code></pre></div><pre><code>k8s-apparmor-example-deny-write (enforce)
</code></pre><!-- Finally, we can see what happens if we try to violate the profile by writing to a file: -->
<p>最后，我们可以看到，如果我们尝试通过写入文件来违反配置文件会发生什么：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> hello-apparmor -- touch /tmp/test
</code></pre></div><pre><code>touch: /tmp/test: Permission denied
error: error executing remote command: command terminated with non-zero exit code: Error executing in Docker Container: 1
</code></pre><!-- To wrap up, let's look at what happens if we try to specify a profile that hasn't been loaded: -->
<p>最后，让我们看看如果我们试图指定一个尚未加载的配置文件会发生什么：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f /dev/stdin &lt;&lt;EOF
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello-apparmor-2<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">container.apparmor.security.beta.kubernetes.io/hello</span>:<span style="color:#bbb"> </span>localhost/k8s-apparmor-example-allow-write<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>busybox:1.28<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span>[<span style="color:#bbb"> </span><span style="color:#b44">&#34;sh&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;-c&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;echo &#39;Hello AppArmor!&#39; &amp;&amp; sleep 1h&#34;</span><span style="color:#bbb"> </span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>EOF<span style="color:#bbb">
</span><span style="color:#bbb"></span>pod/hello-apparmor-2 created<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe pod hello-apparmor-2
</code></pre></div><pre><code>Name:          hello-apparmor-2
Namespace:     default
Node:          gke-test-default-pool-239f5d02-x1kf/
Start Time:    Tue, 30 Aug 2016 17:58:56 -0700
Labels:        &lt;none&gt;
Annotations:   container.apparmor.security.beta.kubernetes.io/hello=localhost/k8s-apparmor-example-allow-write
Status:        Pending
Reason:        AppArmor
Message:       Pod Cannot enforce AppArmor: profile &quot;k8s-apparmor-example-allow-write&quot; is not loaded
IP:
Controllers:   &lt;none&gt;
Containers:
  hello:
    Container ID:
    Image:     busybox
    Image ID:
    Port:
    Command:
      sh
      -c
      echo 'Hello AppArmor!' &amp;&amp; sleep 1h
    State:              Waiting
      Reason:           Blocked
    Ready:              False
    Restart Count:      0
    Environment:        &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-dnz7v (ro)
Conditions:
  Type          Status
  Initialized   True
  Ready         False
  PodScheduled  True
Volumes:
  default-token-dnz7v:
    Type:    Secret (a volume populated by a Secret)
    SecretName:    default-token-dnz7v
    Optional:   false
QoS Class:      BestEffort
Node-Selectors: &lt;none&gt;
Tolerations:    &lt;none&gt;
Events:
  FirstSeen    LastSeen    Count    From                        SubobjectPath    Type        Reason        Message
  ---------    --------    -----    ----                        -------------    --------    ------        -------
  23s          23s         1        {default-scheduler }                         Normal      Scheduled     Successfully assigned hello-apparmor-2 to e2e-test-stclair-node-pool-t1f5
  23s          23s         1        {kubelet e2e-test-stclair-node-pool-t1f5}             Warning        AppArmor    Cannot enforce AppArmor: profile &quot;k8s-apparmor-example-allow-write&quot; is not loaded
</code></pre><!-- 
Note the pod status is Pending, with a helpful error message: `Pod Cannot enforce AppArmor: profile
"k8s-apparmor-example-allow-write" is not loaded`. An event was also recorded with the same message. 
-->
<p>注意 Pod 呈现 Pending 状态，并且显示一条有用的错误信息：
<code>Pod Cannot enforce AppArmor: profile &quot;k8s-apparmor-example-allow-write&quot; is not loaded</code>。
还用相同的消息记录了一个事件。</p>
<!-- ## Administration -->
<h2 id="administration">管理</h2>
<!-- ### Setting up nodes with profiles -->
<h3 id="setting-up-nodes-with-profiles">使用配置文件设置节点</h3>
<!-- 
Kubernetes does not currently provide any native mechanisms for loading AppArmor profiles onto
nodes. There are lots of ways to setup the profiles though, such as: 
-->
<p>Kubernetes 目前不提供任何本地机制来将 AppArmor 配置文件加载到节点上。
有很多方法可以设置配置文件，例如：</p>
<!-- 
* Through a [DaemonSet](/docs/concepts/workloads/controllers/daemonset/) that runs a Pod on each node to
  ensure the correct profiles are loaded. An example implementation can be found
  [here](https://git.k8s.io/kubernetes/test/images/apparmor-loader).
* At node initialization time, using your node initialization scripts (e.g. Salt, Ansible, etc.) or
  image.
* By copying the profiles to each node and loading them through SSH, as demonstrated in the
  [Example](#example). 
-->
<ul>
<li>通过在每个节点上运行 Pod 的
<a href="/zh/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>来确保加载了正确的配置文件。
可以在<a href="https://git.k8s.io/kubernetes/test/images/apparmor-loader">这里</a>找到实现示例。</li>
<li>在节点初始化时，使用节点初始化脚本(例如 Salt、Ansible 等)或镜像。</li>
<li>通过将配置文件复制到每个节点并通过 SSH 加载它们，如<a href="#example">示例</a>。</li>
</ul>
<!-- 
The scheduler is not aware of which profiles are loaded onto which node, so the full set of profiles
must be loaded onto every node.  An alternative approach is to add a node label for each profile (or
class of profiles) on the node, and use a
[node selector](/docs/concepts/configuration/assign-pod-node/) to ensure the Pod is run on a
node with the required profile. 
-->
<p>调度程序不知道哪些配置文件加载到哪个节点上，因此必须将全套配置文件加载到每个节点上。
另一种方法是为节点上的每个配置文件（或配置文件类）添加节点标签，
并使用<a href="/zh/docs/concepts/configuration/assign-pod-node/">节点选择器</a>确保
Pod 在具有所需配置文件的节点上运行。</p>
<!-- ### Restricting profiles with the PodSecurityPolicy -->
<h3 id="restricting-profiles-with-the-podsecuritypolicy">使用 PodSecurityPolicy 限制配置文件</h3>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
PodSecurityPolicy is deprecated in Kubernetes v1.21, and will be removed in v1.25.
See [PodSecurityPolicy](/docs/concepts/security/pod-security-policy/) documentation for more information.
-->
<p>PodSecurityPolicy 在 Kubernetes v1.21 版本中已被废弃，将在 v1.25 版本移除。
查看 <a href="/zh/docs/concepts/security/pod-security-policy/">PodSecurityPolicy</a> 文档获取更多信息。
</div>
<!-- 
If the PodSecurityPolicy extension is enabled, cluster-wide AppArmor restrictions can be applied. To
enable the PodSecurityPolicy, the following flag must be set on the `apiserver`: 
-->
<p>如果启用了 PodSecurityPolicy 扩展，则可以应用群集范围的 AppArmor 限制。
要启用 PodSecurityPolicy，必须在 <code>apiserver</code> 上设置以下标志：</p>
<pre><code>--enable-admission-plugins=PodSecurityPolicy[,others...]
</code></pre><!-- The AppArmor options can be specified as annotations on the PodSecurityPolicy: -->
<p>AppArmor 选项可以指定为 PodSecurityPolicy 上的注解：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apparmor.security.beta.kubernetes.io/defaultProfileName</span>:<span style="color:#bbb"> </span>&lt;profile_ref&gt;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apparmor.security.beta.kubernetes.io/allowedProfileNames</span>:<span style="color:#bbb"> </span>&lt;profile_ref&gt;[,others...]<span style="color:#bbb">
</span></code></pre></div><!-- 
The default profile name option specifies the profile to apply to containers by default when none is
specified. The allowed profile names option specifies a list of profiles that Pod containers are
allowed to be run with. If both options are provided, the default must be allowed. The profiles are
specified in the same format as on containers. See the [API Reference](#api-reference) for the full
specification. 
-->
<p>默认配置文件名选项指定默认情况下在未指定任何配置文件时应用于容器的配置文件。
所允许的配置文件名称选项指定允许 Pod 容器运行期间所对应的配置文件列表。
如果同时提供了这两个选项，则必须允许默认值。
配置文件的指定格式与容器上的相同。有关完整规范，请参阅 <a href="#api-reference">API 参考</a>。</p>
<!-- ### Disabling AppArmor -->
<h3 id="disabling-apparmor">禁用 AppArmor</h3>
<!-- If you do not want AppArmor to be available on your cluster, it can be disabled by a command-line flag: -->
<p>如果你不希望 AppArmor 在集群上可用，可以通过命令行标志禁用它：</p>
<pre><code>--feature-gates=AppArmor=false
</code></pre><!-- 
When disabled, any Pod that includes an AppArmor profile will fail validation with a "Forbidden"
error. 
-->
<p>禁用时，任何包含 AppArmor 配置文件的 Pod 都将导致验证失败，且返回 “Forbidden” 错误。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Even if the Kubernetes feature is disabled, runtimes may still enforce the default profile. The
option to disable the AppArmor feature will be removed when AppArmor graduates to general
availability (GA).
-->
<p>即使此 Kubernetes 特性被禁用，运行时仍可能强制执行默认配置文件。
当 AppArmor 升级为正式版 (GA) 时，禁用 AppArmor 功能的选项将被删除。
</div>
<!-- ## Authoring Profiles -->
<h2 id="authoring-profiles">编写配置文件</h2>
<!-- 
Getting AppArmor profiles specified correctly can be a tricky business. Fortunately there are some
tools to help with that: 
-->
<p>获得正确指定的 AppArmor 配置文件可能是一件棘手的事情。幸运的是，有一些工具可以帮助你做到这一点：</p>
<!-- 
* `aa-genprof` and `aa-logprof` generate profile rules by monitoring an application's activity and
  logs, and admitting the actions it takes. Further instructions are provided by the
  [AppArmor documentation](https://gitlab.com/apparmor/apparmor/wikis/Profiling_with_tools).
* [bane](https://github.com/jfrazelle/bane) is an AppArmor profile generator for Docker that uses a
  simplified profile language. 
-->
<ul>
<li><code>aa-genprof</code> 和 <code>aa-logprof</code>
通过监视应用程序的活动和日志并准许它所执行的操作来生成配置文件规则。
<a href="https://gitlab.com/apparmor/apparmor/wikis/Profiling_with_tools">AppArmor 文档</a>提供了进一步的指导。</li>
<li><a href="https://github.com/jfrazelle/bane">bane</a>
是一个用于 Docker的 AppArmor 配置文件生成器，它使用一种简化的画像语言（profile language）</li>
</ul>
<!-- 
To debug problems with AppArmor, you can check the system logs to see what, specifically, was
denied. AppArmor logs verbose messages to `dmesg`, and errors can usually be found in the system
logs or through `journalctl`. More information is provided in
[AppArmor failures](https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Failures). 
-->
<p>想要调试 AppArmor 的问题，你可以检查系统日志，查看具体拒绝了什么。
AppArmor 将详细消息记录到 <code>dmesg</code>，
错误通常可以在系统日志中或通过 <code>journalctl</code> 找到。
更多详细信息见 <a href="https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Failures">AppArmor 失败</a>。</p>
<!-- ## API Reference -->
<h2 id="api-reference">API 参考</h2>
<!-- ### Pod Annotation -->
<h3 id="pod-annotation">Pod 注解</h3>
<!-- Specifying the profile a container will run with: -->
<p>指定容器将使用的配置文件：</p>
<!-- 
- **key**: `container.apparmor.security.beta.kubernetes.io/<container_name>`
  Where `<container_name>` matches the name of a container in the Pod.
  A separate profile can be specified for each container in the Pod.
- **value**: a profile reference, described below 
-->
<ul>
<li><strong>键名</strong>: <code>container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;</code>
，其中 <code>&lt;container_name&gt;</code> 与 Pod 中某容器的名称匹配。
可以为 Pod 中的每个容器指定单独的配置文件。</li>
<li><strong>键值</strong>: 对配置文件的引用，如下所述</li>
</ul>
<!-- ### Profile Reference -->
<h3 id="profile-reference">配置文件引用</h3>
<!-- 
- `runtime/default`: Refers to the default runtime profile.
  - Equivalent to not specifying a profile (without a PodSecurityPolicy default), except it still
    requires AppArmor to be enabled.
  - In practice, many container runtimes use the same OCI default profile, defined here:
    https://github.com/containers/common/blob/main/pkg/apparmor/apparmor_linux_template.go
- `localhost/<profile_name>`: Refers to a profile loaded on the node (localhost) by name.
  - The possible profile names are detailed in the
    [core policy reference](https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Core_Policy_Reference#profile-names-and-attachment-specifications).
- `unconfined`: This effectively disables AppArmor on the container. 
-->
<ul>
<li><code>runtime/default</code>: 指默认运行时配置文件。
<ul>
<li>等同于不指定配置文件（没有 PodSecurityPolicy 默认值），只是它仍然需要启用 AppArmor。</li>
<li>实际上，许多容器运行时使用相同的 OCI 默认配置文件，在此处定义：
<a href="https://github.com/containers/common/blob/main/pkg/apparmor/apparmor_linux_template.go">https://github.com/containers/common/blob/main/pkg/apparmor/apparmor_linux_template.go</a></li>
</ul>
</li>
<li><code>localhost/&lt;profile_name&gt;</code>: 按名称引用加载到节点（localhost）上的配置文件。
<ul>
<li>可能的配置文件名在<a href="https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Core_Policy_Reference#profile-names-and-attachment-specifications">核心策略参考</a>。</li>
</ul>
</li>
<li><code>unconfined</code>: 这相当于为容器禁用 AppArmor。</li>
</ul>
<!-- Any other profile reference format is invalid. -->
<p>任何其他配置文件引用格式无效。</p>
<!-- ### PodSecurityPolicy Annotations -->
<h3 id="podsecuritypolicy-annotations">PodSecurityPolicy 注解</h3>
<!-- Specifying the default profile to apply to containers when none is provided: -->
<p>指定在未提供容器时应用于容器的默认配置文件：</p>
<!-- 
* **key**: `apparmor.security.beta.kubernetes.io/defaultProfileName`
* **value**: a profile reference, described above 
-->
<ul>
<li><strong>键名</strong>: <code>apparmor.security.beta.kubernetes.io/defaultProfileName</code></li>
<li><strong>键值</strong>: 如上述文件参考所述</li>
</ul>
<!-- Specifying the list of profiles Pod containers is allowed to specify: -->
<p>上面描述的指定配置文件，Pod 容器列表的配置文件引用允许指定：</p>
<!-- 
* **key**: `apparmor.security.beta.kubernetes.io/allowedProfileNames`
* **value**: a comma-separated list of profile references (described above)
  - Although an escaped comma is a legal character in a profile name, it cannot be explicitly
    allowed here. 
-->
<ul>
<li><strong>键名</strong>: <code>apparmor.security.beta.kubernetes.io/allowedProfileNames</code></li>
<li><strong>键值</strong>: 配置文件引用的逗号分隔列表（如上所述）
<ul>
<li>尽管转义逗号是配置文件名中的合法字符，但此处不能显式允许。</li>
</ul>
</li>
</ul>
<h2 id="what-s-next">What's next</h2>
<!-- Additional resources: -->
<p>其他资源：</p>
<!-- 
* [Quick guide to the AppArmor profile language](https://gitlab.com/apparmor/apparmor/wikis/QuickProfileLanguage)
* [AppArmor core policy reference](https://gitlab.com/apparmor/apparmor/wikis/Policy_Layout) 
-->
<ul>
<li><a href="https://gitlab.com/apparmor/apparmor/wikis/QuickProfileLanguage">Apparmor 配置文件语言快速指南</a></li>
<li><a href="https://gitlab.com/apparmor/apparmor/wikis/Policy_Layout">Apparmor 核心策略参考</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-31a6c137cfc5bfea9d88f4b109109465">2 - 在名字空间级别应用 Pod 安全标准</h1>
    
	<!--
title: Apply Pod Security Standards at the Namespace Level
content_type: tutorial
weight: 10
-->


<div class="alert alert-primary" role="alert">
<h4 class="alert-heading">Note</h4>

    <!-- This tutorial applies only for new clusters. -->
<p>本教程仅适用于新集群。

</div>

<!--
Pod Security admission (PSA) is enabled by default in v1.23 and later, as it
[graduated to beta](/blog/2021/12/09/pod-security-admission-beta/). Pod Security Admission
is an admission controller that applies 
[Pod Security Standards](/docs/concepts/security/pod-security-standards/) 
when pods are created. In this tutorial, you will enforce the `baseline` Pod Security Standard,
one namespace at a time.

You can also apply Pod Security Standards to multiple namespaces at once at the cluster
level. For instructions, refer to 
[Apply Pod Security Standards at the cluster level](/docs/tutorials/security/cluster-level-pss).
-->
<p>Pod 安全准入（PSA）在 v1.23 及更高版本默认启用，
因为它<a href="/blog/2021/12/09/pod-security-admission-beta/">升级到测试版（beta）</a>。
Pod 安全准入是在创建 Pod 时应用
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>的准入控制器。
在本教程中，你将应用 <code>baseline</code> Pod 安全标准，每次一个名字空间。</p>
<p>你还可以在集群级别一次将 Pod 安全标准应用于多个名称空间。
有关说明，请参阅<a href="/zh/docs/tutorials/security/cluster-level-pss">在集群级别应用 Pod 安全标准</a>。</p>
<h2 id="before-you-begin">Before you begin</h2>
<!-- 
Install the following on your workstation:

- [KinD](https://kind.sigs.k8s.io/docs/user/quick-start/#installation)
- [kubectl](/docs/tasks/tools/)
-->
<p>在你的工作站中安装以下内容：</p>
<ul>
<li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation">KinD</a></li>
<li><a href="/zh/docs/tasks/tools/">kubectl</a></li>
</ul>
<!--
## Create cluster

1. Create a `KinD` cluster as follows:
-->
<h2 id="create-cluster">创建集群 </h2>
<ol start="2">
<li>
<p>按照如下方式创建一个 <code>KinD</code> 集群：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kind create cluster --name psa-ns-level --image kindest/node:v1.23.0
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Creating cluster &quot;psa-ns-level&quot; ...
 ✓ Ensuring node image (kindest/node:v1.23.0) 🖼 
 ✓ Preparing nodes 📦  
 ✓ Writing configuration 📜 
 ✓ Starting control-plane 🕹️ 
 ✓ Installing CNI 🔌 
 ✓ Installing StorageClass 💾 
Set kubectl context to &quot;kind-psa-ns-level&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-psa-ns-level

Not sure what to do next? 😅  Check out https://kind.sigs.k8s.io/docs/user/quick-start/
</code></pre></li>
</ol>
<!-- 1. Set the kubectl context to the new cluster: -->
<ol>
<li>将 kubectl 上下文设置为新集群：
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info --context kind-psa-ns-level
</code></pre></div> <!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Kubernetes control plane is running at https://127.0.0.1:50996
CoreDNS is running at https://127.0.0.1:50996/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li>
</ol>
<!--
## Create a namespace

Create a new namespace called `example`:
-->
<h2 id="create-a-namespace">创建名字空间 </h2>
<p>创建一个名为 <code>example</code> 的新名字空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create ns example
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>namespace/example created
</code></pre><!-- 
## Apply Pod Security Standards

1. Enable Pod Security Standards on this namespace using labels supported by
   built-in Pod Security Admission. In this step we will warn on baseline pod
   security standard as per the latest version (default value)
-->
<h2 id="apply-pod-security-standards">应用 Pod 安全标准 </h2>
<ol>
<li>
<p>使用内置 Pod 安全准入所支持的标签在此名字空间上启用 Pod 安全标准。
在这一步中，我们将根据最新版本（默认值）对基线 Pod 安全标准发出警告。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl label --overwrite ns example <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  pod-security.kubernetes.io/warn<span style="color:#666">=</span>baseline <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  pod-security.kubernetes.io/warn-version<span style="color:#666">=</span>latest
</code></pre></div></li>
</ol>
<!-- 
2. Multiple pod security standards can be enabled on any namespace, using labels.
   Following command will `enforce` the `baseline` Pod Security Standard, but
   `warn` and `audit` for `restricted` Pod Security Standards as per the latest
   version (default value)
-->
<ol start="2">
<li>
<p>可以使用标签在任何名字空间上启用多个 Pod 安全标准。
以下命令将强制（<code>enforce</code>） 执行基线（<code>baseline</code>）Pod 安全标准，
但根据最新版本（默认值）对受限（<code>restricted</code>）Pod 安全标准执行警告（<code>warn</code>）和审核（<code>audit</code>）。</p>
<pre><code>kubectl label --overwrite ns example \
  pod-security.kubernetes.io/enforce=baseline \
  pod-security.kubernetes.io/enforce-version=latest \
  pod-security.kubernetes.io/warn=restricted \
  pod-security.kubernetes.io/warn-version=latest \
  pod-security.kubernetes.io/audit=restricted \
  pod-security.kubernetes.io/audit-version=latest
</code></pre></li>
</ol>
<!-- 
## Verify the Pod Security Standards

1. Create a minimal pod in `example` namespace:
-->
<h2 id="verify-the-pod-security-standards">验证 Pod 安全标准 </h2>
<ol>
<li>
<p>在 <code>example</code> 名字空间中创建一个最小的 pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF &gt; /tmp/pss/nginx-pod.yaml
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Pod
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: nginx
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  containers:
</span><span style="color:#b44">    - image: nginx
</span><span style="color:#b44">      name: nginx
</span><span style="color:#b44">      ports:
</span><span style="color:#b44">        - containerPort: 80
</span><span style="color:#b44">EOF</span>
</code></pre></div></li>
</ol>
<!-- 
2. Apply the pod spec to the cluster in `example` namespace: 
-->
<ol>
<li>将 Pod 规约应用到集群中的 <code>example</code> 名字空间中：
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -n example -f /tmp/pss/nginx-pod.yaml
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Warning: would violate PodSecurity &quot;restricted:latest&quot;: allowPrivilegeEscalation != false (container &quot;nginx&quot; must set securityContext allowPrivilegeEscalation=false), unrestricted capabilities (container &quot;nginx&quot; must set securityContext.capabilities.drop=[&quot;ALL&quot;]), runAsNonRoot != true (pod or container &quot;nginx&quot; must set securityContext.runAsNonRoot=true), seccompProfile (pod or container &quot;nginx&quot; must set securityContext seccompProfile.type to &quot;RuntimeDefault&quot; or &quot;Localhost&quot;)
pod/nginx created
</code></pre></li>
</ol>
<!-- 
1. Apply the pod spec to the cluster in `default` namespace:
-->
<ol start="3">
<li>
<p>将 Pod 规约应用到集群中的 <code>default</code> 名字空间中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -n default -f /tmp/pss/nginx-pod.yaml
</code></pre></div><!-- Output is similar to this: -->
<p>输出类似于：</p>
<pre><code>pod/nginx created
</code></pre></li>
</ol>
<!-- 
The Pod Security Standards were applied only to the `example`
namespace. You could create the same Pod in the `default` namespace
with no warnings.
-->
<p>以上 Pod 安全标准仅被应用到 <code>example</code> 名字空间。
你可以在没有警告的情况下在 <code>default</code> 名字空间中创建相同的 Pod。</p>
<!-- 
## Clean up

Run `kind delete cluster -name psa-ns-level` to delete the cluster created.
-->
<h2 id="clean-up">清理 </h2>
<p>运行 <code>kind delete cluster -name psa-ns-level</code> 删除创建的集群。</p>
<h2 id="what-s-next">What's next</h2>
<!-- 
- Run a
  [shell script](/examples/security/kind-with-namespace-level-baseline-pod-security.sh)
  to perform all the preceding steps all at once.

  1. Create KinD cluster
  2. Create new namespace
  3. Apply `baseline` Pod Security Standard in `enforce` mode while applying
     `restricted` Pod Security Standard also in `warn` and `audit` mode.
  4. Create a new pod with the following pod security standards applied
- [Pod Security Admission](/docs/concepts/security/pod-security-admission/)
- [Pod Security Standards](/docs/concepts/security/pod-security-standards/)
- [Apply Pod Security Standards at the cluster level](/docs/tutorials/security/cluster-level-pss/)
-->
<ul>
<li>
<p>运行一个 <a href="/examples/security/kind-with-namespace-level-baseline-pod-security.sh">shell 脚本</a>
一次执行所有前面的步骤。</p>
<ol>
<li>创建 KinD 集群</li>
<li>创建新的名字空间</li>
<li>在 <code>enforce</code> 模式下应用 <code>baseline</code> Pod 安全标准，
同时在 <code>warn</code> 和 <code>audit</code> 模式下应用 <code>restricted</code> Pod 安全标准。</li>
<li>创建一个应用以下 Pod 安全标准的新 Pod</li>
</ol>
</li>
<li>
<p><a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全准入</a></p>
</li>
<li>
<p><a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a></p>
</li>
<li>
<p><a href="/zh/docs/tutorials/security/cluster-level-pss/">在集群级别应用 Pod 安全标准</a></p>
</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d5f847bcdb6f7efbfc9c8a180d73e29a">3 - 在集群级别应用 Pod 安全标准</h1>
    
	<!-- 
title: Apply Pod Security Standards at the Cluster Level
content_type: tutorial
weight: 10
-->


<div class="alert alert-primary" role="alert">
<h4 class="alert-heading">Note</h4>

    <!-- This tutorial applies only for new clusters. -->
<p>本教程仅适用于新集群。

</div>

<!-- 
Pod Security admission (PSA) is enabled by default in v1.23 and later, as it has
[graduated to beta](/blog/2021/12/09/pod-security-admission-beta/).
Pod Security
is an admission controller that carries out checks against the Kubernetes
[Pod Security Standards](/docs/concepts/security/pod-security-standards/) when new pods are
created. This tutorial shows you how to enforce the `baseline` Pod Security
Standard at the cluster level which applies a standard configuration
to all namespaces in a cluster.

To apply Pod Security Standards to specific namespaces, refer to [Apply Pod Security Standards at the namespace level](/docs/tutorials/security/ns-level-pss).
-->
<p>Pod 安全准入（PSA）在 v1.23 及更高版本默认启用，
因为它<a href="/blog/2021/12/09/pod-security-admission-beta/">升级到测试版（beta）</a>。
Pod 安全准入是在创建 Pod 时应用
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>的准入控制器。
本教程将向你展示如何在集群级别实施 <code>baseline</code> Pod 安全标准，
该标准将标准配置应用于集群中的所有名称空间。</p>
<p>要将 Pod 安全标准应用于特定名字空间，
请参阅<a href="/zh/docs/tutorials/security/ns-level-pss">在名字空间级别应用 Pod 安全标准</a>。</p>
<h2 id="before-you-begin">Before you begin</h2>
<!-- 
Install the following on your workstation:

- [KinD](https://kind.sigs.k8s.io/docs/user/quick-start/#installation)
- [kubectl](https://kubernetes.io/docs/tasks/tools/)
-->
<p>在你的工作站中安装以下内容：</p>
<ul>
<li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation">KinD</a></li>
<li><a href="https://kubernetes.io/docs/tasks/tools/">kubectl</a></li>
</ul>
<!--
## Choose the right Pod Security Standard to apply

[Pod Security Admission](/docs/concepts/security/pod-security-admission/)
lets you apply built-in [Pod Security Standards](/docs/concepts/security/pod-security-standards/)
with the following modes: `enforce`, `audit`, and `warn`.

To gather information that helps you to choose the Pod Security Standards
that are most appropriate for your configuration, do the following: 
-->
<h2 id="choose-the-right-pod-security-standard-to-apply">正确选择要应用的 Pod 安全标准 </h2>
<p><a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全准入</a>
允许你使用以下模式应用内置的
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>:
<code>enforce</code>、<code>audit</code> 和 <code>warn</code>。</p>
<p>要收集信息以便选择最适合你的配置的 Pod 安全标准，请执行以下操作：</p>
<!-- 
1. Create a cluster with no Pod Security Standards applied:
 -->
<ol>
<li>
<p>创建一个没有应用 Pod 安全标准的集群：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kind create cluster --name psa-wo-cluster-pss --image kindest/node:v1.23.0
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Creating cluster &quot;psa-wo-cluster-pss&quot; ...
✓ Ensuring node image (kindest/node:v1.23.0) 🖼
✓ Preparing nodes 📦  
✓ Writing configuration 📜
✓ Starting control-plane 🕹️
✓ Installing CNI 🔌
✓ Installing StorageClass 💾
Set kubectl context to &quot;kind-psa-wo-cluster-pss&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-psa-wo-cluster-pss

Thanks for using kind! 😊

</code></pre></li>
</ol>
<!-- 
1. Set the kubectl context to the new cluster:
-->
<ol start="2">
<li>
<p>将 kubectl 上下文设置为新集群：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info --context kind-psa-wo-cluster-pss
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Kubernetes control plane is running at https://127.0.0.1:61350 
CoreDNS is running at https://127.0.0.1:61350/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li>
</ol>
<!-- 
1. Get a list of namespaces in the cluster:
-->
<ol start="3">
<li>
<p>获取集群中的名字空间列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get ns
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>NAME                 STATUS   AGE
default              Active   9m30s
kube-node-lease      Active   9m32s
kube-public          Active   9m32s
kube-system          Active   9m32s
local-path-storage   Active   9m26s
</code></pre></li>
</ol>
<!-- 
1. Use `--dry-run=server` to understand what happens when different Pod Security Standards
   are applied:
 -->
<ol start="4">
<li>
<p>使用 <code>--dry-run=server</code> 来了解应用不同的 Pod 安全标准时会发生什么：</p>
<ol>
<li>
<p>Privileged</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl label --dry-run<span style="color:#666">=</span>server --overwrite ns --all <span style="color:#b62;font-weight:bold">\ </span>                   
pod-security.kubernetes.io/enforce<span style="color:#666">=</span>privileged
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
namespace/kube-system labeled
namespace/local-path-storage labeled
</code></pre></li>
<li>
<p>Baseline</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl label --dry-run<span style="color:#666">=</span>server --overwrite ns --all <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>pod-security.kubernetes.io/enforce<span style="color:#666">=</span>baseline
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
Warning: existing pods in namespace &quot;kube-system&quot; violate the new PodSecurity enforce level &quot;baseline:latest&quot;
Warning: etcd-psa-wo-cluster-pss-control-plane (and 3 other pods): host namespaces, hostPath volumes
Warning: kindnet-vzj42: non-default capabilities, host namespaces, hostPath volumes
Warning: kube-proxy-m6hwf: host namespaces, hostPath volumes, privileged
namespace/kube-system labeled
namespace/local-path-storage labeled
</code></pre></li>
<li>
<p>Restricted</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl label --dry-run<span style="color:#666">=</span>server --overwrite ns --all <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>pod-security.kubernetes.io/enforce<span style="color:#666">=</span>restricted
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>namespace/default labeled
namespace/kube-node-lease labeled
namespace/kube-public labeled
Warning: existing pods in namespace &quot;kube-system&quot; violate the new PodSecurity enforce level &quot;restricted:latest&quot;
Warning: coredns-7bb9c7b568-hsptc (and 1 other pod): unrestricted capabilities, runAsNonRoot != true, seccompProfile
Warning: etcd-psa-wo-cluster-pss-control-plane (and 3 other pods): host namespaces, hostPath volumes, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true
Warning: kindnet-vzj42: non-default capabilities, host namespaces, hostPath volumes, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true, seccompProfile
Warning: kube-proxy-m6hwf: host namespaces, hostPath volumes, privileged, allowPrivilegeEscalation != false, unrestricted capabilities, restricted volume types, runAsNonRoot != true, seccompProfile
namespace/kube-system labeled
Warning: existing pods in namespace &quot;local-path-storage&quot; violate the new PodSecurity enforce level &quot;restricted:latest&quot;
Warning: local-path-provisioner-d6d9f7ffc-lw9lh: allowPrivilegeEscalation != false, unrestricted capabilities, runAsNonRoot != true, seccompProfile
namespace/local-path-storage labeled
</code></pre></li>
</ol>
</li>
</ol>
<!-- 
From the previous output, you'll notice that applying the `privileged` Pod Security Standard shows no warnings
for any namespaces. However, `baseline` and `restricted` standards both have
warnings, specifically in the `kube-system` namespace.
-->
<p>从前面的输出中，你会注意到应用 <code>privileged</code> Pod 安全标准不会显示任何名字空间的警告。
然而，<code>baseline</code> 和 <code>restricted</code> 标准都有警告，特别是在 <code>kube-system</code> 名字空间中。</p>
<!-- 
## Set modes, versions and standards

In this section, you apply the following Pod Security Standards to the `latest` version:

* `baseline` standard in `enforce` mode.
* `restricted` standard in `warn` and `audit` mode.
-->
<h2 id="set-modes-versions-and-standards">设置模式、版本和标准 </h2>
<p>在本节中，你将以下 Pod 安全标准应用于最新（<code>latest</code>）版本：</p>
<ul>
<li>在 <code>enforce</code> 模式下的 <code>baseline</code> 标准。</li>
<li><code>warn</code> 和 <code>audit</code> 模式下的 <code>restricted</code> 标准。</li>
</ul>
<!-- 
The `baseline` Pod Security Standard provides a convenient
middle ground that allows keeping the exemption list short and prevents known
privilege escalations.

Additionally, to prevent pods from failing in `kube-system`, you'll exempt the namespace
from having Pod Security Standards applied.

When you implement Pod Security Admission in your own environment, consider the
following:
-->
<p><code>baseline</code> Pod 安全标准提供了一个方便的中间立场，能够保持豁免列表简短并防止已知的特权升级。</p>
<p>此外，为了防止 <code>kube-system</code> 中的 Pod 失败，你将免除该名字空间应用 Pod 安全标准。</p>
<p>在你自己的环境中实施 Pod 安全准入时，请考虑以下事项：</p>
<!-- 
1. Based on the risk posture applied to a cluster, a stricter Pod Security
   Standard like `restricted` might be a better choice.
1. Exempting the `kube-system` namespace allows pods to run as
   `privileged` in this namespace. For real world use, the Kubernetes project
   strongly recommends that you apply strict RBAC
   policies that limit access to `kube-system`, following the principle of least
   privilege.
   To implement the preceding standards, do the following:
1. Create a configuration file that can be consumed by the Pod Security
   Admission Controller to implement these Pod Security Standards:
-->
<ol>
<li>
<p>根据应用于集群的风险状况，更严格的 Pod 安全标准（如 <code>restricted</code>）可能是更好的选择。</p>
</li>
<li>
<p>对 <code>kube-system</code> 名字空间进行赦免会允许 Pod 在其中以 <code>privileged</code> 模式运行。
对于实际使用，Kubernetes 项目强烈建议你应用严格的 RBAC 策略来限制对 <code>kube-system</code> 的访问，
遵循最小特权原则。</p>
</li>
<li>
<p>创建一个配置文件，Pod 安全准入控制器可以使用该文件来实现这些 Pod 安全标准：</p>
<pre><code>mkdir -p /tmp/pss
cat &lt;&lt;EOF &gt; /tmp/pss/cluster-level-pss.yaml 
apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
  configuration:
    apiVersion: pod-security.admission.config.k8s.io/v1beta1
    kind: PodSecurityConfiguration
    defaults:
      enforce: &quot;baseline&quot;
      enforce-version: &quot;latest&quot;
      audit: &quot;restricted&quot;
      audit-version: &quot;latest&quot;
      warn: &quot;restricted&quot;
      warn-version: &quot;latest&quot;
    exemptions:
      usernames: []
      runtimeClasses: []
      namespaces: [kube-system]
EOF
</code></pre></li>
</ol>
<!-- 
1. Configure the API server to consume this file during cluster creation:
-->
<ol start="4">
<li>
<p>在创建集群时配置 API 服务器使用此文件：</p>
<pre><code>cat &lt;&lt;EOF &gt; /tmp/pss/cluster-config.yaml 
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
        extraArgs:
          admission-control-config-file: /etc/config/cluster-level-pss.yaml
        extraVolumes:
          - name: accf
            hostPath: /etc/config
            mountPath: /etc/config
            readOnly: false
            pathType: &quot;DirectoryOrCreate&quot;
  extraMounts:
  - hostPath: /tmp/pss
    containerPath: /etc/config
    # optional: if set, the mount is read-only.
    # default false
    readOnly: false
    # optional: if set, the mount needs SELinux relabeling.
    # default false
    selinuxRelabel: false
    # optional: set propagation mode (None, HostToContainer or Bidirectional)
    # see https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation
    # default None
    propagation: None
EOF
</code></pre><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
   If you use Docker Desktop with KinD on macOS, you can
   add `/tmp` as a Shared Directory under the menu item
   **Preferences > Resources > File Sharing**.
   -->
<p>如果你在 macOS 上使用 Docker Desktop 和 KinD，
你可以在菜单项 <strong>Preferences &gt; Resources &gt; File Sharing</strong>
下添加 <code>/tmp</code> 作为共享目录。
</div>
</li>
</ol>
<!-- 
1. Create a cluster that uses Pod Security Admission to apply
   these Pod Security Standards:
-->
<ol start="5">
<li>
<p>创建一个使用 Pod 安全准入的集群来应用这些 Pod 安全标准：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kind create cluster --name psa-with-cluster-pss --image kindest/node:v1.23.0 --config /tmp/pss/cluster-config.yaml
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Creating cluster &quot;psa-with-cluster-pss&quot; ...
 ✓ Ensuring node image (kindest/node:v1.23.0) 🖼 
 ✓ Preparing nodes 📦  
 ✓ Writing configuration 📜 
 ✓ Starting control-plane 🕹️ 
 ✓ Installing CNI 🔌 
 ✓ Installing StorageClass 💾 
Set kubectl context to &quot;kind-psa-with-cluster-pss&quot;
You can now use your cluster with:

kubectl cluster-info --context kind-psa-with-cluster-pss

Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community 🙂
</code></pre></li>
</ol>
<!-- 
1. Point kubectl to the cluster
-->
<ol start="6">
<li>
<p>将 kubectl 指向集群</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info --context kind-psa-with-cluster-pss
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Kubernetes control plane is running at https://127.0.0.1:63855
CoreDNS is running at https://127.0.0.1:63855/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre></li>
</ol>
<!-- 
1. Create the following Pod specification for a minimal configuration in the default namespace:
-->
<ol start="7">
<li>
<p>创建以下 Pod 规约作为在 default 名字空间中的一个最小配置：</p>
<pre><code>cat &lt;&lt;EOF &gt; /tmp/pss/nginx-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - image: nginx
      name: nginx
      ports:
        - containerPort: 80
EOF
</code></pre></li>
</ol>
<!-- 
1. Create the Pod in the cluster:
-->
<ol start="8">
<li>
<p>在集群中创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f /tmp/pss/nginx-pod.yaml
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>Warning: would violate PodSecurity &quot;restricted:latest&quot;: allowPrivilegeEscalation != false (container &quot;nginx&quot; must set securityContext allowPrivilegeEscalation=false), unrestricted capabilities (container &quot;nginx&quot; must set securityContext.capabilities.drop=[&quot;ALL&quot;]), runAsNonRoot != true (pod or container &quot;nginx&quot; must set securityContext.runAsNonRoot=true), seccompProfile (pod or container &quot;nginx&quot; must set securityContext seccompProfile.type to &quot;RuntimeDefault&quot; or &quot;Localhost&quot;)
pod/nginx created
</code></pre></li>
</ol>
<!-- 
## Clean up

Run `kind delete cluster --name psa-with-cluster-pss` and
`kind delete cluster --name psa-wo-cluster-pss` to delete the clusters you
created.
-->
<h2 id="clean-up">清理 </h2>
<p>运行 <code>kind delete cluster --name psa-with-cluster-pss</code> 和
<code>kind delete cluster --name psa-wo-cluster-pss</code> 来删除你创建的集群。</p>
<h2 id="what-s-next">What's next</h2>
<!-- 
- Run a
  [shell script](/examples/security/kind-with-cluster-level-baseline-pod-security.sh)
  to perform all the preceding steps at once:
  1. Create a Pod Security Standards based cluster level Configuration
  2. Create a file to let API server consumes this configuration
  3. Create a cluster that creates an API server with this configuration
  4. Set kubectl context to this new cluster
  5. Create a minimal pod yaml file
  6. Apply this file to create a Pod in the new cluster
- [Pod Security Admission](/docs/concepts/security/pod-security-admission/)
- [Pod Security Standards](/docs/concepts/security/pod-security-standards/)
- [Apply Pod Security Standards at the namespace level](/docs/tutorials/security/ns-level-pss/)
-->
<ul>
<li>运行一个 <a href="/zh/examples/security/kind-with-cluster-level-baseline-pod-security.sh">shell 脚本</a>
一次执行前面的所有步骤：
<ol>
<li>创建一个基于 Pod 安全标准的集群级别配置</li>
<li>创建一个文件让 API 服务器消费这个配置</li>
<li>创建一个集群，用这个配置创建一个 API 服务器</li>
<li>设置 kubectl 上下文为这个新集群</li>
<li>创建一个最小的 Pod yaml 文件</li>
<li>应用这个文件，在新集群中创建一个 Pod</li>
</ol>
</li>
<li><a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全准入</a></li>
<li><a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a></li>
<li><a href="/zh/docs/tutorials/security/ns-level-pss/">在名字空间级别应用 Pod 安全标准</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8b105172a11322c70d0223bc9dff1904">4 - 使用 seccomp 限制容器的系统调用</h1>
    
	<!-- 
reviewers:
- hasheddan
- pjbgf
- saschagrunert
title: Restrict a Container's Syscalls with seccomp
content_type: tutorial
weight: 20
min-kubernetes-server-version: v1.22
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>


<!-- 
Seccomp stands for secure computing mode and has been a feature of the Linux
kernel since version 2.6.12. It can be used to sandbox the privileges of a
process, restricting the calls it is able to make from userspace into the
kernel. Kubernetes lets you automatically apply seccomp profiles loaded onto a
<a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='node'>node</a> to your Pods and containers.

Identifying the privileges required for your workloads can be difficult. In this
tutorial, you will go through how to load seccomp profiles into a local
Kubernetes cluster, how to apply them to a Pod, and how you can begin to craft
profiles that give only the necessary privileges to your container processes.
-->
<p>Seccomp 代表安全计算（Secure Computing）模式，自 2.6.12 版本以来，一直是 Linux 内核的一个特性。
它可以用来沙箱化进程的权限，限制进程从用户态到内核态的调用。
Kubernetes 能使你自动将加载到 <a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='节点'>节点</a>上的
seccomp 配置文件应用到你的 Pod 和容器。</p>
<p>识别你的工作负载所需要的权限是很困难的。在本篇教程中，
你将了解如何将 seccomp 配置文件加载到本地的 Kubernetes 集群中，
如何将它们应用到 Pod，以及如何开始制作只为容器进程提供必要的权限的配置文件。</p>
<h2 id="objectives">Objectives</h2>
<!-- 
* Learn how to load seccomp profiles on a node
* Learn how to apply a seccomp profile to a container
* Observe auditing of syscalls made by a container process
* Observe behavior when a missing profile is specified
* Observe a violation of a seccomp profile
* Learn how to create fine-grained seccomp profiles
* Learn how to apply a container runtime default seccomp profile
-->
<ul>
<li>了解如何在节点上加载 seccomp 配置文件</li>
<li>了解如何将 seccomp 配置文件应用到容器上</li>
<li>观察容器进程对系统调用的审计</li>
<li>观察指定的配置文件缺失时的行为</li>
<li>观察违反 seccomp 配置文件的行为</li>
<li>了解如何创建细粒度的 seccomp 配置文件</li>
<li>了解如何应用容器运行时所默认的 seccomp 配置文件</li>
</ul>
<h2 id="before-you-begin">Before you begin</h2>
<!-- 
In order to complete all steps in this tutorial, you must install
[kind](/docs/tasks/tools/#kind) and [kubectl](/docs/tasks/tools/#kubectl).

This tutorial shows some examples that are still alpha (since v1.22) and
others that use only generally available seccomp functionality. You should
make sure that your cluster is
[configured correctly](https://kind.sigs.k8s.io/docs/user/quick-start/#setting-kubernetes-version)
for the version you are using.

The tutorial also uses the `curl` tool for downloading examples to your computer.
You can adapt the steps to use a different tool if you prefer.
-->
<p>为了完成本篇教程中的所有步骤，你必须安装 <a href="/zh/docs/tasks/tools/#kind">kind</a>
和 <a href="/zh/docs/tasks/tools/#kubectl">kubectl</a>。</p>
<p>本篇教程演示的某些示例仍然是 alpha 状态（自 v1.22 起），另一些示例则仅使用 seccomp 正式发布的功能。
你应该确保，针对你使用的版本，
<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#setting-kubernetes-version">正确配置</a>了集群。</p>
<p>本篇教程也使用了 <code>curl</code> 工具来下载示例到你的计算机上。
你可以使用其他自己偏好的工具来自适应这些步骤。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
It is not possible to apply a seccomp profile to a container running with
`privileged: true` set in the container's `securityContext`. Privileged containers always
run as `Unconfined`.
-->
<p>无法将 seccomp 配置文件应用于在容器的 <code>securityContext</code> 中设置了 <code>privileged: true</code> 的容器。
特权容器始终以 <code>Unconfined</code> 的方式运行。
</div>
<!-- steps -->
<!-- 
## Download example seccomp profiles {#download-profiles}

The contents of these profiles will be explored later on, but for now go ahead
and download them into a directory named `profiles/` so that they can be loaded
into the cluster.
-->
<h2 id="download-profiles">下载示例 seccomp 配置文件 </h2>
<p>这些配置文件的内容将在稍后进行分析，
现在先将它们下载到名为 <code>profiles/</code> 的目录中，以便将它们加载到集群中。</p>
<ul class="nav nav-tabs" id="tab-with-code" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-with-code-0" role="tab" aria-controls="tab-with-code-0" aria-selected="true">audit.json</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-with-code-1" role="tab" aria-controls="tab-with-code-1">violation.json</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-with-code-2" role="tab" aria-controls="tab-with-code-2">fine-grained.json</a></li></ul>
<div class="tab-content" id="tab-with-code"><div id="tab-with-code-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-with-code-0">

<p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/profiles/audit.json" download="pods/security/seccomp/profiles/audit.json"><code>pods/security/seccomp/profiles/audit.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-profiles-audit-json')" title="Copy pods/security/seccomp/profiles/audit.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-profiles-audit-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#008000;font-weight:bold">&#34;defaultAction&#34;</span>: <span style="color:#b44">&#34;SCMP_ACT_LOG&#34;</span>
}</code></pre></div>
    </div>
</div>


</div>
  <div id="tab-with-code-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-with-code-1">

<p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/profiles/violation.json" download="pods/security/seccomp/profiles/violation.json"><code>pods/security/seccomp/profiles/violation.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-profiles-violation-json')" title="Copy pods/security/seccomp/profiles/violation.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-profiles-violation-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#008000;font-weight:bold">&#34;defaultAction&#34;</span>: <span style="color:#b44">&#34;SCMP_ACT_ERRNO&#34;</span>
}</code></pre></div>
    </div>
</div>


</div>
  <div id="tab-with-code-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-with-code-2">

<p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/profiles/fine-grained.json" download="pods/security/seccomp/profiles/fine-grained.json"><code>pods/security/seccomp/profiles/fine-grained.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-profiles-fine-grained-json')" title="Copy pods/security/seccomp/profiles/fine-grained.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-profiles-fine-grained-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#008000;font-weight:bold">&#34;defaultAction&#34;</span>: <span style="color:#b44">&#34;SCMP_ACT_ERRNO&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;architectures&#34;</span>: [
        <span style="color:#b44">&#34;SCMP_ARCH_X86_64&#34;</span>,
        <span style="color:#b44">&#34;SCMP_ARCH_X86&#34;</span>,
        <span style="color:#b44">&#34;SCMP_ARCH_X32&#34;</span>
    ],
    <span style="color:#008000;font-weight:bold">&#34;syscalls&#34;</span>: [
        {
            <span style="color:#008000;font-weight:bold">&#34;names&#34;</span>: [
                <span style="color:#b44">&#34;accept4&#34;</span>,
                <span style="color:#b44">&#34;epoll_wait&#34;</span>,
                <span style="color:#b44">&#34;pselect6&#34;</span>,
                <span style="color:#b44">&#34;futex&#34;</span>,
                <span style="color:#b44">&#34;madvise&#34;</span>,
                <span style="color:#b44">&#34;epoll_ctl&#34;</span>,
                <span style="color:#b44">&#34;getsockname&#34;</span>,
                <span style="color:#b44">&#34;setsockopt&#34;</span>,
                <span style="color:#b44">&#34;vfork&#34;</span>,
                <span style="color:#b44">&#34;mmap&#34;</span>,
                <span style="color:#b44">&#34;read&#34;</span>,
                <span style="color:#b44">&#34;write&#34;</span>,
                <span style="color:#b44">&#34;close&#34;</span>,
                <span style="color:#b44">&#34;arch_prctl&#34;</span>,
                <span style="color:#b44">&#34;sched_getaffinity&#34;</span>,
                <span style="color:#b44">&#34;munmap&#34;</span>,
                <span style="color:#b44">&#34;brk&#34;</span>,
                <span style="color:#b44">&#34;rt_sigaction&#34;</span>,
                <span style="color:#b44">&#34;rt_sigprocmask&#34;</span>,
                <span style="color:#b44">&#34;sigaltstack&#34;</span>,
                <span style="color:#b44">&#34;gettid&#34;</span>,
                <span style="color:#b44">&#34;clone&#34;</span>,
                <span style="color:#b44">&#34;bind&#34;</span>,
                <span style="color:#b44">&#34;socket&#34;</span>,
                <span style="color:#b44">&#34;openat&#34;</span>,
                <span style="color:#b44">&#34;readlinkat&#34;</span>,
                <span style="color:#b44">&#34;exit_group&#34;</span>,
                <span style="color:#b44">&#34;epoll_create1&#34;</span>,
                <span style="color:#b44">&#34;listen&#34;</span>,
                <span style="color:#b44">&#34;rt_sigreturn&#34;</span>,
                <span style="color:#b44">&#34;sched_yield&#34;</span>,
                <span style="color:#b44">&#34;clock_gettime&#34;</span>,
                <span style="color:#b44">&#34;connect&#34;</span>,
                <span style="color:#b44">&#34;dup2&#34;</span>,
                <span style="color:#b44">&#34;epoll_pwait&#34;</span>,
                <span style="color:#b44">&#34;execve&#34;</span>,
                <span style="color:#b44">&#34;exit&#34;</span>,
                <span style="color:#b44">&#34;fcntl&#34;</span>,
                <span style="color:#b44">&#34;getpid&#34;</span>,
                <span style="color:#b44">&#34;getuid&#34;</span>,
                <span style="color:#b44">&#34;ioctl&#34;</span>,
                <span style="color:#b44">&#34;mprotect&#34;</span>,
                <span style="color:#b44">&#34;nanosleep&#34;</span>,
                <span style="color:#b44">&#34;open&#34;</span>,
                <span style="color:#b44">&#34;poll&#34;</span>,
                <span style="color:#b44">&#34;recvfrom&#34;</span>,
                <span style="color:#b44">&#34;sendto&#34;</span>,
                <span style="color:#b44">&#34;set_tid_address&#34;</span>,
                <span style="color:#b44">&#34;setitimer&#34;</span>,
                <span style="color:#b44">&#34;writev&#34;</span>
            ],
            <span style="color:#008000;font-weight:bold">&#34;action&#34;</span>: <span style="color:#b44">&#34;SCMP_ACT_ALLOW&#34;</span>
        }
    ]
}</code></pre></div>
    </div>
</div>


</div></div>

<!-- Run these commands: -->
<p>执行这些命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mkdir ./profiles
curl -L -o profiles/audit.json https://k8s.io/examples/pods/security/seccomp/profiles/audit.json
curl -L -o profiles/violation.json https://k8s.io/examples/pods/security/seccomp/profiles/violation.json
curl -L -o profiles/fine-grained.json https://k8s.io/examples/pods/security/seccomp/profiles/fine-grained.json
ls profiles
</code></pre></div><!-- You should see three profiles listed at the end of the final step: -->
<p>你应该看到在最后一步的末尾列出有三个配置文件：</p>
<pre><code>audit.json  fine-grained.json  violation.json
</code></pre><!-- 
## Create a local Kubernetes cluster with kind

For simplicity, [kind](https://kind.sigs.k8s.io/) can be used to create a single
node cluster with the seccomp profiles loaded. Kind runs Kubernetes in Docker,
so each node of the cluster is a container. This allows for files
to be mounted in the filesystem of each container similar to loading files
onto a node.
-->
<h2 id="create-a-local-kubernetes-cluster-with-kind">使用 kind 创建本地 Kubernetes 集群</h2>
<p>为简单起见，<a href="https://kind.sigs.k8s.io/">kind</a> 可用来创建加载了 seccomp 配置文件的单节点集群。
Kind 在 Docker 中运行 Kubernetes，因此集群的每个节点都是一个容器。
这允许将文件挂载到每个容器的文件系统中，类似于将文件加载到节点上。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/kind.yaml" download="pods/security/seccomp/kind.yaml"><code>pods/security/seccomp/kind.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-kind-yaml')" title="Copy pods/security/seccomp/kind.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-kind-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kind.x-k8s.io/v1alpha4<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Cluster<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">nodes</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">role</span>:<span style="color:#bbb"> </span>control-plane<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">extraMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">hostPath</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;./profiles&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">containerPath</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;/var/lib/kubelet/seccomp/profiles&#34;</span></code></pre></div>
    </div>
</div>


<!-- 
Download that example kind configuration, and save it to a file named `kind.yaml`:
-->
<p>下载该示例 kind 配置，并将其保存到名为 <code>kind.yaml</code> 的文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -L -O https://k8s.io/examples/pods/security/seccomp/kind.yaml
</code></pre></div><!-- 
You can set a specific Kubernetes version by setting the node's container image.
See [Nodes](https://kind.sigs.k8s.io/docs/user/configuration/#nodes) within the
kind documentation about configuration for more details on this.
This tutorial assumes you are using Kubernetes v1.23.
-->
<p>你可以通过设置节点的容器镜像来设置特定的 Kubernetes 版本。
有关此类配置的更多信息，
参阅 kind 文档中<a href="https://kind.sigs.k8s.io/docs/user/configuration/#nodes">节点</a>小节。
本篇教程假定你正在使用 Kubernetes v1.23。</p>
<!-- 
As an alpha feature, you can configure Kubernetes to use the profile that the
<a class='glossary-tooltip' title='容器运行时是负责运行容器的软件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/setup/production-environment/container-runtimes' target='_blank' aria-label='container runtime'>container runtime</a>
prefers by default, rather than falling back to `Unconfined`.
If you want to try that, see
[enable the use of `RuntimeDefault` as the default seccomp profile for all workloads](#enable-the-use-of-runtimedefault-as-the-default-seccomp-profile-for-all-workloads)
before you continue.
-->
<p>作为 alpha 特性，你可以将 Kubernetes 配置为使用
<a class='glossary-tooltip' title='容器运行时是负责运行容器的软件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/setup/production-environment/container-runtimes' target='_blank' aria-label='容器运行时'>容器运行时</a>
默认首选的配置文件，而不是回退到 <code>Unconfined</code>。
如果你想尝试，请在继续之前参阅
<a href="#enable-runtimedefault-as-default">启用使用 <code>RuntimeDefault</code> 作为所有工作负载的默认 seccomp 配置文件</a></p>
<!--
Once you have a kind configuration in place, create the kind cluster with
that configuration: 
-->
<p>有了 kind 配置后，使用该配置创建 kind 集群：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kind create cluster --config<span style="color:#666">=</span>kind.yaml
</code></pre></div><!--
After the new Kubernetes cluster is ready, identify the Docker container running
as the single node cluster:
-->
<p>新的 Kubernetes 集群准备就绪后，找出作为单节点集群运行的 Docker 容器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker ps
</code></pre></div><!--
You should see output indicating that a container is running with name
`kind-control-plane`. The output is similar to:
-->
<p>你应该看到输出中名为 <code>kind-control-plane</code> 的容器正在运行。
输出类似于：</p>
<pre><code>CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                       NAMES
6a96207fed4b        kindest/node:v1.18.2   &quot;/usr/local/bin/entr…&quot;   27 seconds ago      Up 24 seconds       127.0.0.1:42223-&gt;6443/tcp   kind-control-plane
</code></pre><!--
If observing the filesystem of that container, you should see that the
`profiles/` directory has been successfully loaded into the default seccomp path
of the kubelet. Use `docker exec` to run a command in the Pod:
-->
<p>如果观察该容器的文件系统，
你应该会看到 <code>profiles/</code> 目录已成功加载到 kubelet 的默认 seccomp 路径中。
使用 <code>docker exec</code> 在 Pod 中运行命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 6a96207fed4b 更改为你从 “docker ps” 看到的容器 ID</span>
docker <span style="color:#a2f">exec</span> -it 6a96207fed4b ls /var/lib/kubelet/seccomp/profiles
</code></pre></div><pre><code>audit.json  fine-grained.json  violation.json
</code></pre><!-- 
You have verified that these seccomp profiles are available to the kubelet
running within kind.
-->
<p>你已验证这些 seccomp 配置文件可用于在 kind 中运行的 kubelet。</p>
<!-- 
## Enable the use of `RuntimeDefault` as the default seccomp profile for all workloads
-->
<h2 id="enable-runtimedefault-as-default">启用使用 <code>RuntimeDefault</code> 作为所有工作负载的默认 seccomp 配置文件</h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>


<!-- 
`SeccompDefault` is an optional kubelet
[feature gate](/docs/reference/command-line-tools-reference/feature-gates) as
well as corresponding `--seccomp-default`
[command line flag](/docs/reference/command-line-tools-reference/kubelet).
Both have to be enabled simultaneously to use the feature.
-->
<p><code>SeccompDefault</code> 是一个可选的 kubelet <a href="/zh/docs/reference/command-line-tools-reference/feature-gates">特性门控</a>
以及相应的 <code>--seccomp-default</code> <a href="/zh/docs/reference/command-line-tools-reference/kubelet">命令行标志</a>。
两者必须同时启用才能使用该功能。</p>
<!-- 
If enabled, the kubelet will use the `RuntimeDefault` seccomp profile by default, which is
defined by the container runtime, instead of using the `Unconfined` (seccomp disabled) mode.
The default profiles aim to provide a strong set
of security defaults while preserving the functionality of the workload. It is
possible that the default profiles differ between container runtimes and their
release versions, for example when comparing those from CRI-O and containerd.
-->
<p>如果启用，kubelet 将会默认使用 <code>RuntimeDefault</code> seccomp 配置文件，
（这一配置文明是由容器运行时定义的），而不是使用 <code>Unconfined</code>（禁用 seccomp）模式。
默认的配置文件旨在提供一组限制性较强且能保留工作负载功能的安全默认值。
不同容器运行时及其不同发布版本之间的默认配置文件可能有所不同，
例如在比较来自 CRI-O 和 containerd 的配置文件时。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
Enabling the feature will neither change the Kubernetes
`securityContext.seccompProfile` API field nor add the deprecated annotations of
the workload. This provides users the possibility to rollback anytime without
actually changing the workload configuration. Tools like
[`crictl inspect`](https://github.com/kubernetes-sigs/cri-tools) can be used to
verify which seccomp profile is being used by a container.
-->
<p>启用该功能既不会更改 Kubernetes <code>securityContext.seccompProfile</code> API 字段，
也不会添加已弃用的工作负载注解。
这为用户提供了随时回滚的可能性，而且无需实际更改工作负载配置。
<a href="https://github.com/kubernetes-sigs/cri-tools"><code>crictl inspect</code></a>
之类的工具可用于验证容器正在使用哪个 seccomp 配置文件。
</div>
<!-- 
Some workloads may require a lower amount of syscall restrictions than others.
This means that they can fail during runtime even with the `RuntimeDefault`
profile. To mitigate such a failure, you can:

- Run the workload explicitly as `Unconfined`.
- Disable the `SeccompDefault` feature for the nodes. Also making sure that
  workloads get scheduled on nodes where the feature is disabled.
- Create a custom seccomp profile for the workload.
-->
<p>与其他工作负载相比，某些工作负载可能需要更少的系统调用限制。
这意味着即使使用 <code>RuntimeDefault</code> 配置文件，它们也可能在运行时失败。
要应对此类故障，你可以：</p>
<ul>
<li>将工作负载显式运行为 <code>Unconfined</code>。</li>
<li>禁用节点的 <code>SeccompDefault</code> 功能。还要确保工作负载被调度到禁用该功能的节点上。</li>
<li>为工作负载创建自定义 seccomp 配置文件。</li>
</ul>
<!-- 
If you were introducing this feature into production-like cluster, the Kubernetes project
recommends that you enable this feature gate on a subset of your nodes and then
test workload execution before rolling the change out cluster-wide.

More detailed information about a possible upgrade and downgrade strategy can be
found in the [related Kubernetes Enhancement Proposal (KEP)](https://github.com/kubernetes/enhancements/tree/a70cc18/keps/sig-node/2413-seccomp-by-default#upgrade--downgrade-strategy).
-->
<p>如果你将此功能引入到类似生产的集群中，
Kubernetes 项目建议你在部分节点上启用此特性门控，
然后在整个集群范围内推出更改之前，测试工作负载执行情况。</p>
<p>有关可能的升级和降级策略的更多详细信息，
请参阅<a href="https://github.com/kubernetes/enhancements/tree/a70cc18/keps/sig-node/2413-seccomp-by-default#upgrade--downgrade-strategy">相关的 Kubernetes 增强提案 (KEP)</a>。</p>
<!-- 
Since the feature is in alpha state it is disabled per default. To enable it,
pass the flags `--feature-gates=SeccompDefault=true --seccomp-default` to the
`kubelet` CLI or enable it via the [kubelet configuration
file](/docs/tasks/administer-cluster/kubelet-config-file/). To enable the
feature gate in [kind](https://kind.sigs.k8s.io), ensure that `kind` provides
the minimum required Kubernetes version and enables the `SeccompDefault` feature
[in the kind configuration](https://kind.sigs.k8s.io/docs/user/quick-start/#enable-feature-gates-in-your-cluster):
-->
<p>由于此特性处于 alpha 阶段，默认是被禁用的。
要启用它，传递标志 <code>--feature-gates=SeccompDefault=true --seccomp-default</code> 到
kubelet CLI 或者通过 <a href="/docs/tasks/administer-cluster/kubelet-config-file/">kubelet 配置文件</a>启用。
要在 <a href="https://kind.sigs.k8s.io">kind</a> 启用特性门控，
请确保 <code>kind</code> 提供所需的最低 Kubernetes 版本，
并<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#enable-feature-gates-in-your-cluster">在 kind 配置中</a>
启用了 <code>SeccompDefault</code> 特性：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Cluster<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>kind.x-k8s.io/v1alpha4<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">featureGates</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">SeccompDefault</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">nodes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">role</span>:<span style="color:#bbb"> </span>control-plane<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>kindest/node:v1.23.0@sha256:49824ab1727c04e56a21a5d8372a402fcd32ea51ac96a2706a12af38934f81ac<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeadmConfigPatches</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- |<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        kind: JoinConfiguration
</span><span style="color:#b44;font-style:italic">        nodeRegistration:
</span><span style="color:#b44;font-style:italic">          kubeletExtraArgs:
</span><span style="color:#b44;font-style:italic">            seccomp-default: &#34;true&#34;</span><span style="color:#bbb">        
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">role</span>:<span style="color:#bbb"> </span>worker<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>kindest/node:v1.23.0@sha256:49824ab1727c04e56a21a5d8372a402fcd32ea51ac96a2706a12af38934f81ac<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeadmConfigPatches</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- |<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        kind: JoinConfiguration
</span><span style="color:#b44;font-style:italic">        nodeRegistration:
</span><span style="color:#b44;font-style:italic">          kubeletExtraArgs:
</span><span style="color:#b44;font-style:italic">            feature-gates: SeccompDefault=true
</span><span style="color:#b44;font-style:italic">            seccomp-default: &#34;true&#34;</span><span style="color:#bbb">        
</span></code></pre></div><!-- If the cluster is ready, then running a pod: -->
<p>如果集群已就绪，则运行一个 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run --rm -it --restart<span style="color:#666">=</span>Never --image<span style="color:#666">=</span>alpine alpine -- sh
</code></pre></div><!-- 
Should now have the default seccomp profile attached. This can be verified by
using `docker exec` to run `crictl inspect` for the container on the kind
worker:
-->
<p>现在应该附加了默认的 seccomp 配置文件。
这可以通过使用 <code>docker exec</code> 为 kind 上的容器运行 <code>crictl inspect</code> 来验证：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker <span style="color:#a2f">exec</span> -it kind-worker bash -c <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    <span style="color:#b44">&#39;crictl inspect $(crictl ps --name=alpine -q) | jq .info.runtimeSpec.linux.seccomp&#39;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;defaultAction&#34;</span>: <span style="color:#b44">&#34;SCMP_ACT_ERRNO&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;architectures&#34;</span>: [<span style="color:#b44">&#34;SCMP_ARCH_X86_64&#34;</span>, <span style="color:#b44">&#34;SCMP_ARCH_X86&#34;</span>, <span style="color:#b44">&#34;SCMP_ARCH_X32&#34;</span>],
  <span style="color:#008000;font-weight:bold">&#34;syscalls&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;names&#34;</span>: [<span style="color:#b44">&#34;...&#34;</span>]
    }
  ]
}
</code></pre></div><!-- 
## Create a Pod with a seccomp profile for syscall auditing

To start off, apply the `audit.json` profile, which will log all syscalls of the
process, to a new Pod.

Here's a manifest for that Pod:
-->
<h2 id="create-a-pod-with-a-seccomp-profile-for-syscall-auditing">使用 seccomp 配置文件创建 Pod 以进行系统调用审计</h2>
<p>首先，将 <code>audit.json</code> 配置文件应用到新的 Pod 上，该配置文件将记录进程的所有系统调用。</p>
<p>这是该 Pod 的清单：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/ga/audit-pod.yaml" download="pods/security/seccomp/ga/audit-pod.yaml"><code>pods/security/seccomp/ga/audit-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-ga-audit-pod-yaml')" title="Copy pods/security/seccomp/ga/audit-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-ga-audit-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>audit-pod<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>audit-pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">seccompProfile</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Localhost<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">localhostProfile</span>:<span style="color:#bbb"> </span>profiles/audit.json<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>hashicorp/http-echo:0.2.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#b44">&#34;-text=just made some syscalls!&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowPrivilegeEscalation</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span></code></pre></div>
    </div>
</div>


<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
The functional support for the already deprecated seccomp annotations
`seccomp.security.alpha.kubernetes.io/pod` (for the whole pod) and
`container.seccomp.security.alpha.kubernetes.io/[name]` (for a single container)
is going to be removed with the release of Kubernetes v1.25. Please always use
the native API fields in favor of the annotations.
-->
<p>已弃用的 seccomp 注解 <code>seccomp.security.alpha.kubernetes.io/pod</code>（针对整个 Pod）和
<code>container.seccomp.security.alpha.kubernetes.io/[name]</code>（针对单个容器）
将随着 Kubernetes v1.25 的发布而被删除。
请在可能的情况下使用原生 API 字段而不是注解。
</div>
<!-- Create the Pod in the cluster: -->
<p>在集群中创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/audit-pod.yaml
</code></pre></div><!-- 
This profile does not restrict any syscalls, so the Pod should start
successfully.
-->
<p>此配置文件不限制任何系统调用，因此 Pod 应该成功启动。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod/audit-pod
</code></pre></div><pre><code>NAME        READY   STATUS    RESTARTS   AGE
audit-pod   1/1     Running   0          30s
</code></pre><!-- 
In order to be able to interact with this endpoint exposed by this
container, create a NodePort <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Services'>Services</a>
that allows access to the endpoint from inside the kind control plane container.
-->
<p>为了能够与容器暴露的端点交互，
创建一个 NodePort 类型的 <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='Service'>Service</a>，
允许从 kind 控制平面容器内部访问端点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose pod audit-pod --type NodePort --port <span style="color:#666">5678</span>
</code></pre></div><!-- Check what port the Service has been assigned on the node. -->
<p>检查 Service 在节点上分配的端口。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service audit-pod
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
audit-pod   NodePort   10.111.36.142   &lt;none&gt;        5678:32373/TCP   72s
</code></pre><!-- 
Now you can use `curl` to access that endpoint from inside the kind control plane container,
at the port exposed by this Service. Use `docker exec` to run the `curl` command within the
container belonging to that control plane container:
-->
<p>现在，你可以使用 <code>curl</code> 从 kind 控制平面容器内部访问该端点，位于该服务所公开的端口上。
使用 <code>docker exec</code> 在属于该控制平面容器的容器中运行 <code>curl</code> 命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 6a96207fed4b 更改为你从 “docker ps” 看到的控制平面容器 ID</span>
docker <span style="color:#a2f">exec</span> -it 6a96207fed4b curl localhost:32373
</code></pre></div><pre><code>just made some syscalls!
</code></pre><!-- 
You can see that the process is running, but what syscalls did it actually make?
Because this Pod is running in a local cluster, you should be able to see those
in `/var/log/syslog`. Open up a new terminal window and `tail` the output for
calls from `http-echo`:
-->
<p>你可以看到该进程正在运行，但它实际上进行了哪些系统调用？
因为这个 Pod 在本地集群中运行，你应该能够在 <code>/var/log/syslog</code> 中看到它们。
打开一个新的终端窗口并 <code>tail</code> 来自 <code>http-echo</code> 的调用的输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">tail -f /var/log/syslog | grep <span style="color:#b44">&#39;http-echo&#39;</span>
</code></pre></div><!-- 
You should already see some logs of syscalls made by `http-echo`, and if you
`curl` the endpoint in the control plane container you will see more written.

For example:
-->
<p>你应该已经看到了一些由 <code>http-echo</code> 进行的系统调用的日志，
如果你在控制平面容器中 <code>curl</code> 端点，你会看到更多的写入。</p>
<p>例如：</p>
<pre><code>Jul  6 15:37:40 my-machine kernel: [369128.669452] audit: type=1326 audit(1594067860.484:14536): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=51 compat=0 ip=0x46fe1f code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669453] audit: type=1326 audit(1594067860.484:14537): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=54 compat=0 ip=0x46fdba code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669455] audit: type=1326 audit(1594067860.484:14538): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=202 compat=0 ip=0x455e53 code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669456] audit: type=1326 audit(1594067860.484:14539): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=288 compat=0 ip=0x46fdba code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669517] audit: type=1326 audit(1594067860.484:14540): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=0 compat=0 ip=0x46fd44 code=0x7ffc0000
Jul  6 15:37:40 my-machine kernel: [369128.669519] audit: type=1326 audit(1594067860.484:14541): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=270 compat=0 ip=0x4559b1 code=0x7ffc0000
Jul  6 15:38:40 my-machine kernel: [369188.671648] audit: type=1326 audit(1594067920.488:14559): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=270 compat=0 ip=0x4559b1 code=0x7ffc0000
Jul  6 15:38:40 my-machine kernel: [369188.671726] audit: type=1326 audit(1594067920.488:14560): auid=4294967295 uid=0 gid=0 ses=4294967295 pid=29064 comm=&quot;http-echo&quot; exe=&quot;/http-echo&quot; sig=0 arch=c000003e syscall=202 compat=0 ip=0x455e53 code=0x7ffc0000
</code></pre><!-- 
You can begin to understand the syscalls required by the `http-echo` process by
looking at the `syscall=` entry on each line. While these are unlikely to
encompass all syscalls it uses, it can serve as a basis for a seccomp profile
for this container.

Clean up that Pod and Service before moving to the next section:
-->
<p>通过查看每一行的 <code>syscall=</code> 条目，你可以开始了解 <code>http-echo</code> 进程所需的系统调用。
虽然这些不太可能包含它使用的所有系统调用，但它可以作为此容器的 seccomp 配置文件的基础。</p>
<p>在转到下一部分之前清理该 Pod 和 Service：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete service audit-pod --wait
kubectl delete pod audit-pod --wait --now
</code></pre></div><!-- 
## Create Pod with seccomp profile that causes violation

For demonstration, apply a profile to the Pod that does not allow for any
syscalls.

The manifest for this demonstration is:
-->
<h2 id="create-pod-with-seccomp-profile-that-causes-violation">使用导致违规的 seccomp 配置文件创建 Pod</h2>
<p>出于演示目的，将配置文件应用于不允许任何系统调用的 Pod 上。</p>
<p>此演示的清单是：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/ga/violation-pod.yaml" download="pods/security/seccomp/ga/violation-pod.yaml"><code>pods/security/seccomp/ga/violation-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-ga-violation-pod-yaml')" title="Copy pods/security/seccomp/ga/violation-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-ga-violation-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>violation-pod<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>violation-pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">seccompProfile</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Localhost<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">localhostProfile</span>:<span style="color:#bbb"> </span>profiles/violation.json<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>hashicorp/http-echo:0.2.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#b44">&#34;-text=just made some syscalls!&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowPrivilegeEscalation</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span></code></pre></div>
    </div>
</div>


<!-- Attempt to create the Pod in the cluster: -->
<p>尝试在集群中创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/violation-pod.yaml
</code></pre></div><!-- 
The Pod creates, but there is an issue.
If you check the status of the Pod, you should see that it failed to start.
-->
<p>Pod 创建，但存在问题。
如果你检查 Pod 状态，你应该看到它没有启动。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod/violation-pod
</code></pre></div><pre><code>NAME            READY   STATUS             RESTARTS   AGE
violation-pod   0/1     CrashLoopBackOff   1          6s
</code></pre><!-- 
As seen in the previous example, the `http-echo` process requires quite a few
syscalls. Here seccomp has been instructed to error on any syscall by setting
`"defaultAction": "SCMP_ACT_ERRNO"`. This is extremely secure, but removes the
ability to do anything meaningful. What you really want is to give workloads
only the privileges they need.

Clean up that Pod before moving to the next section:
-->
<p>如上例所示，<code>http-echo</code> 进程需要相当多的系统调用。
这里 seccomp 已通过设置 <code>&quot;defaultAction&quot;: &quot;SCMP_ACT_ERRNO&quot;</code> 被指示为在发生任何系统调用时报错。
这是非常安全的，但消除了做任何有意义的事情的能力。
你真正想要的是只给工作负载它们所需要的权限。</p>
<p>在转到下一部分之前清理该 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod violation-pod --wait --now
</code></pre></div><!-- 
## Create Pod with seccomp profile that only allows necessary syscalls

If you take a look at the `fine-grained.json` profile, you will notice some of the syscalls
seen in syslog of the first example where the profile set `"defaultAction":
"SCMP_ACT_LOG"`. Now the profile is setting `"defaultAction": "SCMP_ACT_ERRNO"`,
but explicitly allowing a set of syscalls in the `"action": "SCMP_ACT_ALLOW"`
block. Ideally, the container will run successfully and you will see no messages
sent to `syslog`.

The manifest for this example is:
-->
<h2 id="create-pod-with-seccomp-profile-that-only-allows-necessary-syscalls">使用只允许必要的系统调用的 seccomp 配置文件创建 Pod</h2>
<p>如果你看一看 <code>fine-grained.json</code> 配置文件，
你会注意到第一个示例的 syslog 中看到的一些系统调用，
其中配置文件设置为 <code>&quot;defaultAction&quot;: &quot;SCMP_ACT_LOG&quot;</code>。
现在的配置文件设置 <code>&quot;defaultAction&quot;: &quot;SCMP_ACT_ERRNO&quot;</code>,
但在 <code>&quot;action&quot;: &quot;SCMP_ACT_ALLOW&quot;</code> 块中明确允许一组系统调用。
理想情况下，容器将成功运行，并且你看到没有消息发送到 <code>syslog</code>。</p>
<p>此示例的清单是：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/ga/fine-pod.yaml" download="pods/security/seccomp/ga/fine-pod.yaml"><code>pods/security/seccomp/ga/fine-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-ga-fine-pod-yaml')" title="Copy pods/security/seccomp/ga/fine-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-ga-fine-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>fine-pod<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>fine-pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">seccompProfile</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Localhost<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">localhostProfile</span>:<span style="color:#bbb"> </span>profiles/fine-grained.json<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>hashicorp/http-echo:0.2.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#b44">&#34;-text=just made some syscalls!&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowPrivilegeEscalation</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span></code></pre></div>
    </div>
</div>


<!-- Create the Pod in your cluster: -->
<p>在你的集群中创建 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/fine-pod.yaml
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod fine-pod
</code></pre></div><!-- The Pod should be showing as having started successfully: -->
<p>此 Pod 应该显示为已成功启动：</p>
<pre><code>NAME        READY   STATUS    RESTARTS   AGE
fine-pod   1/1     Running   0          30s
</code></pre><!-- 
Open up a new terminal window and use `tail` to monitor for log entries that
mention calls from `http-echo`:
-->
<p>打开一个新的终端窗口并使用 <code>tail</code> 来监视提到来自 <code>http-echo</code> 的调用的日志条目：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 你计算机上的日志路径可能与 “/var/log/syslog” 不同</span>
tail -f /var/log/syslog | grep <span style="color:#b44">&#39;http-echo&#39;</span>
</code></pre></div><!-- Next, expose the Pod with a NodePort Service: -->
<p>接着，使用 NodePort Service 公开 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose pod fine-pod --type NodePort --port <span style="color:#666">5678</span>
</code></pre></div><!-- Check what port the Service has been assigned on the node: -->
<p>检查节点上的 Service 分配了什么端口：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service fine-pod
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>NAME        TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
fine-pod    NodePort   10.111.36.142   &lt;none&gt;        5678:32373/TCP   72s
</code></pre><!-- Use `curl` to access that endpoint from inside the kind control plane container: -->
<p>使用 <code>curl</code> 从 kind 控制平面容器内部访问端点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 将 6a96207fed4b 更改为你从 “docker ps” 看到的控制平面容器 ID</span>
docker <span style="color:#a2f">exec</span> -it 6a96207fed4b curl localhost:32373
</code></pre></div><pre><code>just made some syscalls!
</code></pre><!-- 
You should see no output in the `syslog`. This is because the profile allowed all
necessary syscalls and specified that an error should occur if one outside of
the list is invoked. This is an ideal situation from a security perspective, but
required some effort in analyzing the program. It would be nice if there was a
simple way to get closer to this security without requiring as much effort.

Clean up that Pod and Service before moving to the next section:
-->
<p>你应该在 <code>syslog</code> 中看不到任何输出。
这是因为配置文件允许所有必要的系统调用，并指定如果调用列表之外的系统调用应发生错误。
从安全角度来看，这是一种理想的情况，但需要在分析程序时付出一些努力。
如果有一种简单的方法可以在不需要太多努力的情况下更接近这种安全性，那就太好了。</p>
<p>在转到下一部分之前清理该 Pod 和服务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete service fine-pod --wait
kubectl delete pod fine-pod --wait --now
</code></pre></div><!--
## Create Pod that uses the container runtime default seccomp profile

Most container runtimes provide a sane set of default syscalls that are allowed
or not. You can adopt these defaults for your workload by setting the seccomp
type in the security context of a pod or container to `RuntimeDefault`. 
-->
<h2 id="create-pod-that-uses-the-container-runtime-default-seccomp-profile">创建使用容器运行时默认 seccomp 配置文件的 Pod</h2>
<p>大多数容器运行时都提供了一组合理的默认系统调用，以及是否允许执行这些系统调用。
你可以通过将 Pod 或容器的安全上下文中的 seccomp 类型设置为 <code>RuntimeDefault</code>
来为你的工作负载采用这些默认值。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
If you have the `SeccompDefault` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) enabled, then Pods use the `RuntimeDefault` seccomp profile whenever
no other seccomp profile is specified. Otherwise, the default is `Unconfined`.
-->
<p>如果你已经启用了 <code>SeccompDefault</code> <a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>，
只要没有指定其他 seccomp 配置文件，那么 Pod 就会使用 <code>SeccompDefault</code> 的 seccomp 配置文件。
否则，默认值为 <code>Unconfined</code>。
</div>
<!-- 
Here's a manifest for a Pod that requests the `RuntimeDefault` seccomp profile
for all its containers:
-->
<p>这是一个 Pod 的清单，它要求其所有容器使用 <code>RuntimeDefault</code> seccomp 配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/seccomp/ga/default-pod.yaml" download="pods/security/seccomp/ga/default-pod.yaml"><code>pods/security/seccomp/ga/default-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-security-seccomp-ga-default-pod-yaml')" title="Copy pods/security/seccomp/ga/default-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-security-seccomp-ga-default-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default-pod<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>default-pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">seccompProfile</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>RuntimeDefault<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>hashicorp/http-echo:0.2.3<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#b44">&#34;-text=just made some more syscalls!&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">securityContext</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowPrivilegeEscalation</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span></code></pre></div>
    </div>
</div>


<!-- Create that Pod: -->
<p>创建此 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/pods/security/seccomp/ga/default-pod.yaml
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod default-pod
</code></pre></div><!-- The Pod should be showing as having started successfully: -->
<p>此 Pod 应该显示为成功启动：</p>
<pre><code>NAME        READY   STATUS    RESTARTS   AGE
default-pod 1/1     Running   0          20s
</code></pre><!-- Finally, now that you saw that work OK, clean up: -->
<p>最后，你看到一切正常之后，请清理：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete pod default-pod --wait --now
</code></pre></div><h2 id="what-s-next">What's next</h2>
<!-- 
You can learn more about Linux seccomp:

* [A seccomp Overview](https://lwn.net/Articles/656307/)
* [Seccomp Security Profiles for Docker](https://docs.docker.com/engine/security/seccomp/)
-->
<p>你可以了解有关 Linux seccomp 的更多信息：</p>
<ul>
<li><a href="https://lwn.net/Articles/656307/">seccomp 概述</a></li>
<li><a href="https://docs.docker.com/engine/security/seccomp/">Docker 的 Seccomp 安全配置文件</a></li>
</ul>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
