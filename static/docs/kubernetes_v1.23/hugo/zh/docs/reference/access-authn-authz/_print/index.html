<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/reference/access-authn-authz/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/reference/access-authn-authz/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/reference/access-authn-authz/">
<link rel="alternate" hreflang="de" href="http://localhost:1313/de/docs/reference/access-authn-authz/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/reference/access-authn-authz/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/reference/access-authn-authz/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/reference/access-authn-authz/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>API 访问控制 | Kubernetes</title><meta property="og:title" content="API 访问控制" />
<meta property="og:description" content="生产级别的容器编排系统" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/access-authn-authz/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="API 访问控制">
<meta itemprop="description" content="生产级别的容器编排系统"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="API 访问控制"/>
<meta name="twitter:description" content="生产级别的容器编排系统"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读 控制 Kubernetes API 的访问。
参考文档：
 身份认证  使用启动引导令牌来执行身份认证   准入控制器  动态准入控制   鉴权与授权  基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权   证书签名请求  包含 CSR 的批复 和证书签名   服务账号  开发者指南 管理文档    ">
<meta property="og:description" content="关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读 控制 Kubernetes API 的访问。
参考文档：
 身份认证  使用启动引导令牌来执行身份认证   准入控制器  动态准入控制   鉴权与授权  基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权   证书签名请求  包含 CSR 的批复 和证书签名   服务账号  开发者指南 管理文档    ">
<meta name="twitter:description" content="关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读 控制 Kubernetes API 的访问。
参考文档：
 身份认证  使用启动引导令牌来执行身份认证   准入控制器  动态准入控制   鉴权与授权  基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权   证书签名请求  包含 CSR 的批复 和证书签名   服务账号  开发者指南 管理文档    ">
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/access-authn-authz/">
<meta property="og:title" content="API 访问控制">
<meta name="twitter:title" content="API 访问控制">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/reference/access-authn-authz/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/reference/access-authn-authz/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/reference/access-authn-authz/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/reference/access-authn-authz/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/reference/access-authn-authz/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/reference/access-authn-authz/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/reference/access-authn-authz/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/fr/docs/reference/access-authn-authz/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/reference/access-authn-authz/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/reference/access-authn-authz/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/reference/access-authn-authz/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/reference/access-authn-authz/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">API 访问控制</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b">用户认证</a></li>


    
  
    
    
	
<li>2: <a href="#pg-de45b6ca7419a0e308044425b2ac52bb">使用启动引导令牌（Bootstrap Tokens）认证</a></li>


    
  
    
    
	
<li>3: <a href="#pg-3d0c14d1e3cfade38febc343cd044c73">证书签名请求</a></li>


    
  
    
    
	
<li>4: <a href="#pg-518807b9b00bda46d7c7e6e0b17c18f8">使用准入控制器</a></li>


    
  
    
    
	
<li>5: <a href="#pg-d04751f776f1faa6a82bbb7f0a200950">动态准入控制</a></li>


    
  
    
    
	
<li>6: <a href="#pg-bea207258f3576b8ec7444a20d498e1d">管理服务账号</a></li>


    
  
    
    
	
<li>7: <a href="#pg-342be69d36f174f762c36f4fe11fcb20">鉴权概述</a></li>


    
  
    
    
	
<li>8: <a href="#pg-954776b47f2d90515f375623a0ce98e1">使用 RBAC 鉴权</a></li>


    
  
    
    
	
<li>9: <a href="#pg-9cbb97d4d9f08d67931a1baae4e6519c">使用 Node 鉴权</a></li>


    
  
    
    
	
<li>10: <a href="#pg-215c25173044b8f97e9b0494b0c7e53f">Webhook 模式</a></li>


    
  
    
    
	
<li>11: <a href="#pg-643e4cec52a8577e9454649bdaac84d0">从 PodSecurityPolicy 映射到 Pod 安全性标准</a></li>


    
  
    
    
	
<li>12: <a href="#pg-a5bdc757c01991e5e6ab1a82b90639ea">使用 ABAC 鉴权</a></li>


    
  

    </ul>


<div class="content">
      <!--
title: API Access Control
weight: 15
no_list: true
-->
<!--
For an introduction to how Kubernetes implements and controls API access,
read [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/).

Reference documentation:
-->
<p>关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读
<a href="/zh/docs/concepts/security/controlling-access/">控制 Kubernetes API 的访问</a>。</p>
<p>参考文档：</p>
<!--
- [Authenticating](/docs/reference/access-authn-authz/authentication/)
   - [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/)
- [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/)
   - [Dynamic Admission Control](/docs/reference/access-authn-authz/extensible-admission-controllers/)
- [Authorization](/docs/reference/access-authn-authz/authorization/)
   - [Role Based Access Control](/docs/reference/access-authn-authz/rbac/)
   - [Attribute Based Access Control](/docs/reference/access-authn-authz/abac/)
   - [Node Authorization](/docs/reference/access-authn-authz/node/)
   - [Webhook Authorization](/docs/reference/access-authn-authz/webhook/)
- [Certificate Signing Requests](/docs/reference/access-authn-authz/certificate-signing-requests/)
   - including [CSR approval](/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection)
     and [certificate signing](/docs/reference/access-authn-authz/certificate-signing-requests/#signing)
- Service accounts
  - [Developer guide](/docs/tasks/configure-pod-container/configure-service-account/)
  - [Administration](/docs/reference/access-authn-authz/service-accounts-admin/)
-->
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用启动引导令牌来执行身份认证</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">动态准入控制</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权与授权</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/rbac/">基于角色的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/abac/">基于属性的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/webhook/">Webhook 鉴权</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a>
<ul>
<li>包含 <a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection">CSR 的批复</a>
和<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signing">证书签名</a></li>
</ul>
</li>
<li>服务账号
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">开发者指南</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/service-accounts-admin/">管理文档</a></li>
</ul>
</li>
</ul>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b">1 - 用户认证</h1>
    
	<!--
reviewers:
- erictune
- lavalamp
- ericchiang
- deads2k
- liggitt
title: Authenticating
content_type: concept
weight: 10
-->
<!-- overview -->
<!--
This page provides an overview of authenticating.
-->
<p>本页提供身份认证有关的概述。</p>
<!-- body -->
<!--
## Users in Kubernetes

All Kubernetes clusters have two categories of users: service accounts managed
by Kubernetes, and normal users.

It is assumed that a cluster-independent service manages normal users in the following ways:

- an administrator distributing private keys
- a user store like Keystone or Google Accounts
- a file with a list of usernames and passwords

In this regard, _Kubernetes does not have objects which represent normal user
accounts._ Normal users cannot be added to a cluster through an API call.
-->
<h2 id="users-in-kubernetes">Kubernetes 中的用户 </h2>
<p>所有 Kubernetes 集群都有两类用户：由 Kubernetes 管理的服务账号和普通用户。</p>
<p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p>
<ul>
<li>负责分发私钥的管理员</li>
<li>类似 Keystone 或者 Google Accounts 这类用户数据库</li>
<li>包含用户名和密码列表的文件</li>
</ul>
<p>有鉴于此，<em>Kubernetes 并不包含用来代表普通用户账号的对象</em>。
普通用户的信息无法通过 API 调用添加到集群中。</p>
<!--
Even though normal user cannot be added via an API call, but any user that
presents a valid certificate signed by the cluster’s certificate authority
(CA) is considered authenticated. In this configuration, Kubernetes determines
the username from the common name field in the ‘subject’ of the cert (e.g.,
“/CN=bob”). From there, the role based access control (RBAC) sub-system would
determine whether the user is authorized to perform a specific operation on a
resource. For more details, refer to the normal users topic in
[certificate request](/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user)
for more details about this.
-->
<p>尽管无法通过 API 调用来添加普通用户，Kubernetes 仍然认为能够提供由集群的证书
机构签名的合法证书的用户是通过身份认证的用户。基于这样的配置，Kubernetes
使用证书中的 'subject' 的通用名称（Common Name）字段（例如，&quot;/CN=bob&quot;）来
确定用户名。接下来，基于角色访问控制（RBAC）子系统会确定用户是否有权针对
某资源执行特定的操作。进一步的细节可参阅
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user">证书请求</a>
下普通用户主题。</p>
<!--
In contrast, service accounts are users managed by the Kubernetes API. They are
bound to specific namespaces, and created automatically by the API server or
manually through API calls. Service accounts are tied to a set of credentials
stored as `Secrets`, which are mounted into pods allowing in-cluster processes
to talk to the Kubernetes API.

API requests are tied to either a normal user or a service account, or are treated
as [anonymous requests](#anonymous-requests). This means every process inside or outside the cluster, from
a human user typing `kubectl` on a workstation, to `kubelets` on nodes, to members
of the control plane, must authenticate when making requests to the API server,
or be treated as an anonymous user.
-->
<p>与此不同，服务账号是 Kubernetes API 所管理的用户。它们被绑定到特定的名字空间，
或者由 API 服务器自动创建，或者通过 API 调用创建。服务账号与一组以 Secret 保存
的凭据相关，这些凭据会被挂载到 Pod 中，从而允许集群内的进程访问 Kubernetes
API。</p>
<p>API 请求则或者与某普通用户相关联，或者与某服务账号相关联，亦或者被视作
<a href="#anonymous-requests">匿名请求</a>。这意味着集群内外的每个进程在向 API 服务器发起
请求时都必须通过身份认证，否则会被视作匿名用户。这里的进程可以是在某工作站上
输入 <code>kubectl</code> 命令的操作人员，也可以是节点上的 <code>kubelet</code> 组件，还可以是控制面
的成员。</p>
<!--
## Authentication strategies

Kubernetes uses client certificates, bearer tokens, or an authenticating proxy to
authenticate API requests through authentication plugins. As HTTP requests are
made to the API server, plugins attempt to associate the following attributes
with the request:
-->
<h2 id="authentication-strategies">身份认证策略 </h2>
<p>Kubernetes 通过身份认证插件利用客户端证书、持有者令牌（Bearer Token）或身份认证代理（Proxy）
来认证 API 请求的身份。HTTP 请求发给 API 服务器时，插件会将以下属性关联到请求本身：</p>
<!--
* Username: a string which identifies the end user. Common values might be `kube-admin` or `jane@example.com`.
* UID: a string which identifies the end user and attempts to be more consistent and unique than username.
* Groups: a set of strings, each of which indicates the user's membership in a named logical collection of users. Common values might be `system:masters` or `devops-team`.
* Extra fields: a map of strings to list of strings which holds additional information authorizers may find useful.
-->
<ul>
<li>用户名：用来辩识最终用户的字符串。常见的值可以是 <code>kube-admin</code> 或 <code>jane@example.com</code>。</li>
<li>用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。</li>
<li>用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。
常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li>
<li>附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；用来保存一些鉴权组件可能
觉得有用的额外信息。</li>
</ul>
<!--
All values are opaque to the authentication system and only hold significance
when interpreted by an [authorizer](/docs/reference/access-authn-authz/authorization/).

You can enable multiple authentication methods at once. You should usually use at least two methods:

- service account tokens for service accounts
- at least one other method for user authentication.
-->
<p>所有（属性）值对于身份认证系统而言都是不透明的，只有被
<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权组件</a>
解释过之后才有意义。</p>
<p>你可以同时启用多种身份认证方法，并且你通常会至少使用两种方法：</p>
<ul>
<li>针对服务账号使用服务账号令牌</li>
<li>至少另外一种方法对用户的身份进行认证</li>
</ul>
<!--
When multiple authenticator modules are enabled, the first module
to successfully authenticate the request short-circuits evaluation.
The API server does not guarantee the order authenticators run in.

The `system:authenticated` group is included in the list of groups for all authenticated users.

Integrations with other authentication protocols (LDAP, SAML, Kerberos, alternate x509 schemes, etc)
can be accomplished using an [authenticating proxy](#authenticating-proxy) or the
[authentication webhook](#webhook-token-authentication).
-->
<p>当集群中启用了多个身份认证模块时，第一个成功地对请求完成身份认证的模块会
直接做出评估决定。API 服务器并不保证身份认证模块的运行顺序。</p>
<p>对于所有通过身份认证的用户，<code>system:authenticated</code> 组都会被添加到其组列表中。</p>
<p>与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）都可以通过
使用一个<a href="#authenticating-proxy">身份认证代理</a>或
<a href="#webhook-token-authentication">身份认证 Webhoook</a>来实现。</p>
<!--
### X509 Client Certs

Client certificate authentication is enabled by passing the `-client-ca-file=SOMEFILE`
option to API server. The referenced file must contain one or more certificate authorities
to use to validate client certificates presented to the API server. If a client certificate
is presented and verified, the common name of the subject is used as the user name for the
request. As of Kubernetes 1.4, client certificates can also indicate a user's group memberships
using the certificate's organization fields. To include multiple group memberships for a user,
include multiple organization fields in the certificate.

For example, using the `openssl` command line tool to generate a certificate signing request:
-->
<h3 id="x509-client-certs">X509 客户证书  </h3>
<p>通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。
所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。
如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）就被
作为请求的用户名。
自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。
要包含用户的多个组成员信息，可以在证书种包含多个 organization 字段。</p>
<p>例如，使用 <code>openssl</code> 命令行工具生成一个证书签名请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style="color:#b44">&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div><!--
This would create a CSR for the username "jbeda", belonging to two groups, "app1" and "app2".

See [Managing Certificates](/docs/tasks/administer-cluster/certificates/) for how to generate a client cert.
-->
<p>此命令将使用用户名 <code>jbeda</code> 生成一个证书签名请求（CSR），且该用户属于 &quot;app&quot; 和
&quot;app2&quot; 两个用户组。</p>
<p>参阅<a href="/zh/docs/tasks/administer-cluster/certificates/">管理证书</a>了解如何生成客户端证书。</p>
<!--
### Static Token File

The API server reads bearer tokens from a file when given the `-token-auth-file=SOMEFILE` option on the command line.  Currently, tokens last indefinitely, and the token list cannot be
changed without restarting the API server.

The token file is a csv file with a minimum of 3 columns: token, user name, user uid,
followed by optional group names.
-->
<h3 id="static-token-file">静态令牌文件 </h3>
<p>当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中
读取持有者令牌。目前，令牌会长期有效，并且在不重启 API 服务器的情况下
无法更改令牌列表。</p>
<p>令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。
其余列被视为可选的组名。</p>
<!--
If you have more than one group the column must be double quoted e.g.

```conf
token,user,uid,"group1,group2,group3"
```
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <p>如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如</p>
<pre><code class="language-conf" data-lang="conf">token,user,uid,&quot;group1,group2,group3&quot;
</code></pre>
</div>
<!--
#### Putting a Bearer Token in a Request

When using bearer token authentication from an http client, the API
server expects an `Authorization` header with a value of `Bearer
<token>`.  The bearer token must be a character sequence that can be
put in an HTTP header value using no more than the encoding and
quoting facilities of HTTP.  For example: if the bearer token is
`31ada4fd-adec-460c-809a-9e56ceb75269` then it would appear in an HTTP
header as shown below.
-->
<h4 id="putting-a-bearer-token-in-a-request">在请求中放入持有者令牌  </h4>
<p>当使用持有者令牌来对某 HTTP 客户端执行身份认证时，API 服务器希望看到
一个名为 <code>Authorization</code> 的 HTTP 头，其值格式为 <code>Bearer &lt;token&gt;</code>。
持有者令牌必须是一个可以放入 HTTP 头部值字段的字符序列，至多可使用
HTTP 的编码和引用机制。
例如：如果持有者令牌为 <code>31ada4fd-adec-460c-809a-9e56ceb75269</code>，则其
出现在 HTTP 头部时如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div><!--
### Bootstrap Tokens
-->
<h3 id="bootstrap-tokens">启动引导令牌   </h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>


<!--
To allow for streamlined bootstrapping for new clusters, Kubernetes includes a
dynamically-managed Bearer token type called a *Bootstrap Token*. These tokens
are stored as Secrets in the `kube-system` namespace, where they can be
dynamically managed and created. Controller Manager contains a TokenCleaner
controller that deletes bootstrap tokens as they expire.
-->
<p>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型，
称作 <em>启动引导令牌（Bootstrap Token）</em>。
这些令牌以 Secret 的形式保存在 <code>kube-system</code> 名字空间中，可以被动态管理和创建。
控制器管理器包含的 <code>TokenCleaner</code> 控制器能够在启动引导令牌过期时将其删除。</p>
<!--
The tokens are of the form `[a-z0-9]{6}.[a-z0-9]{16}`.  The first component is a
Token ID and the second component is the Token Secret.  You specify the token
in an HTTP header as follows:
-->
<p>这些令牌的格式为 <code>[a-z0-9]{6}.[a-z0-9]{16}</code>。第一个部分是令牌的 ID；第二个部分
是令牌的 Secret。你可以用如下所示的方式来在 HTTP 头部设置令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div><!--
You must enable the Bootstrap Token Authenticator with the
`-enable-bootstrap-token-auth` flag on the API Server.  You must enable
the TokenCleaner controller via the `-controllers` flag on the Controller
Manager.  This is done with something like `-controllers=*,tokencleaner`.
`kubeadm` will do this for you if you are using it to bootstrap a cluster.
-->
<p>你必须在 API 服务器上设置 <code>--enable-bootstrap-token-auth</code> 标志来启用基于启动
引导令牌的身份认证组件。
你必须通过控制器管理器的 <code>--controllers</code> 标志来启用 TokenCleaner 控制器；
这可以通过类似 <code>--controllers=*,tokencleaner</code> 这种设置来做到。
如果你使用 <code>kubeadm</code> 来启动引导新的集群，该工具会帮你完成这些设置。</p>
<!--
The authenticator authenticates as `system:bootstrap:<Token ID>`.  It is
included in the `system:bootstrappers` group.  The naming and groups are
intentionally limited to discourage users from using these tokens past
bootstrapping.  The user names and group can be used (and are used by `kubeadm`)
to craft the appropriate authorization policies to support bootstrapping a
cluster.
-->
<p>身份认证组件的认证结果为 <code>system:bootstrap:&lt;令牌 ID&gt;</code>，该用户属于
<code>system:bootstrappers</code> 用户组。
这里的用户名和组设置都是有意设计成这样，其目的是阻止用户在启动引导集群之后
继续使用这些令牌。
这里的用户名和组名可以用来（并且已经被 <code>kubeadm</code> 用来）构造合适的鉴权
策略，以完成启动引导新集群的工作。</p>
<!--
Please see [Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) for in depth
documentation on the Bootstrap Token authenticator and controllers along with
how to manage these tokens with `kubeadm`.
-->
<p>请参阅<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">启动引导令牌</a>
以了解关于启动引导令牌身份认证组件与控制器的更深入的信息，以及如何使用
<code>kubeadm</code> 来管理这些令牌。</p>
<!--
### Service Account Tokens

A service account is an automatically enabled authenticator that uses signed
bearer tokens to verify requests. The plugin takes two optional flags:

* `--service-account-key-file` A file containing a PEM encoded key for signing bearer tokens.
If unspecified, the API server's TLS private key will be used.
* `--service-account-lookup` If enabled, tokens which are deleted from the API will be revoked.
-->
<h3 id="service-account-tokens">服务账号令牌  </h3>
<p>服务账号（Service Account）是一种自动被启用的用户认证机制，使用经过签名的
持有者令牌来验证请求。该插件可接受两个可选参数：</p>
<ul>
<li><code>--service-account-key-file</code> 一个包含用来为持有者令牌签名的 PEM 编码密钥。
若未指定，则使用 API 服务器的 TLS 私钥。</li>
<li><code>--service-account-lookup</code> 如果启用，则从 API 删除的令牌会被回收。</li>
</ul>
<!--
Service accounts are usually created automatically by the API server and
associated with pods running in the cluster through the `ServiceAccount`
[Admission Controller](/docs/reference/access-authn-authz/admission-controllers/). Bearer tokens are
mounted into pods at well-known locations, and allow in-cluster processes to
talk to the API server. Accounts may be explicitly associated with pods using the
`serviceAccountName` field of a `PodSpec`.
-->
<p>服务账号通常由 API 服务器自动创建并通过 <code>ServiceAccount</code>
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
关联到集群中运行的 Pod 上。
持有者令牌会挂载到 Pod 中可预知的位置，允许集群内进程与 API 服务器通信。
服务账号也可以使用 Pod 规约的 <code>serviceAccountName</code> 字段显式地关联到 Pod 上。</p>
<!--
`serviceAccountName` is usually omitted because this is done automatically.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <code>serviceAccountName</code> 通常会被忽略，因为关联关系是自动建立的。
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">serviceAccountName</span>:<span style="color:#bbb"> </span>bob-the-bot<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div><!--
Service account bearer tokens are perfectly valid to use outside the cluster and
can be used to create identities for long standing jobs that wish to talk to the
Kubernetes API. To manually create a service account, use the `kubectl create
serviceaccount (NAME)` command. This creates a service account in the current
namespace and an associated secret.
-->
<p>在集群外部使用服务账号持有者令牌也是完全合法的，且可用来为长时间运行的、需要与
Kubernetes  API 服务器通信的任务创建标识。要手动创建服务账号，可以使用
<code>kubectl create serviceaccount &lt;名称&gt;</code> 命令。此命令会在当前的名字空间中生成一个
服务账号和一个与之关联的 Secret。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl create serviceaccount jenkins
</code></pre></div><pre><code>serviceaccount/jenkins created
</code></pre><!--
Check an associated secret:
-->
<p>查验相关联的 Secret：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">secrets</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>jenkins-token-1yvwg<span style="color:#bbb">
</span></code></pre></div><!--
The created secret holds the public CA of the API server and a signed JSON Web
Token (JWT).
-->
<p>所创建的 Secret 中会保存 API 服务器的公开的 CA 证书和一个已签名的 JSON Web
令牌（JWT）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div><!--
```yaml
apiVersion: v1
data:
  ca.crt: (APISERVER'S CA BASE64 ENCODED)
  namespace: ZGVmYXVsdA==
  token: (BEARER TOKEN BASE64 ENCODED)
kind: Secret
metadata:
  # ...
type: kubernetes.io/service-account-token
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ca.crt</span>:<span style="color:#bbb"> </span>&lt;Base64 编码的 API 服务器 CA&gt;<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>ZGVmYXVsdA==<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span>&lt;Base64 编码的持有者令牌&gt;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></code></pre></div><!--
Values are base64 encoded because secrets are always base64 encoded.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 字段值是按 Base64 编码的，这是因为 Secret 数据总是采用 Base64 编码来存储。
</div>
<!--
The signed JWT can be used as a bearer token to authenticate as the given service
account. See [above](#putting-a-bearer-token-in-a-request) for how the token is included
in a request.  Normally these secrets are mounted into pods for in-cluster access to
the API server, but can be used from outside the cluster as well.
-->
<p>已签名的 JWT 可以用作持有者令牌，并将被认证为所给的服务账号。
关于如何在请求中包含令牌，请参阅<a href="#putting-a-bearer-token-in-a-request">前文</a>。
通常，这些 Secret 数据会被挂载到 Pod 中以便集群内访问 API 服务器时使用，
不过也可以在集群外部使用。</p>
<!--
Service accounts authenticate with the username `system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)`,
and are assigned to the groups `system:serviceaccounts` and `system:serviceaccounts:(NAMESPACE)`.

WARNING: Because service account tokens are stored in secrets, any user with
read access to those secrets can authenticate as the service account. Be cautious
when granting permissions to service accounts and read capabilities for secrets.
-->
<p>服务账号被身份认证后，所确定的用户名为 <code>system:serviceaccount:&lt;名字空间&gt;:&lt;服务账号&gt;</code>，
并被分配到用户组 <code>system:serviceaccounts</code> 和 <code>system:serviceaccounts:&lt;名字空间&gt;</code>。</p>
<p>警告：由于服务账号令牌保存在 Secret 对象中，任何能够读取这些 Secret 的用户
都可以被认证为对应的服务账号。在为用户授予访问服务账号的权限时，以及对 Secret
的读权限时，要格外小心。</p>
<!--
### OpenID Connect Tokens

[OpenID Connect](https://openid.net/connect/) is a flavor of OAuth2 supported by
some OAuth2 providers, notably Azure Active Directory, Salesforce, and Google.
The protocol's main extension of OAuth2 is an additional field returned with
the access token called an [ID Token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken).
This token is a JSON Web Token (JWT) with well known fields, such as a user's
email, signed by the server.
-->
<h3 id="openid-connect-tokens">OpenID Connect（OIDC）令牌  </h3>
<p><a href="https://openid.net/connect/">OpenID Connect</a> 是一种 OAuth2  认证方式，
被某些 OAuth2 提供者支持，例如 Azure 活动目录、Salesforce 和 Google。
协议对 OAuth2 的主要扩充体现在有一个附加字段会和访问令牌一起返回，
这一字段称作 <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID Token（ID 令牌）</a>。
ID 令牌是一种由服务器签名的 JSON Web 令牌（JWT），其中包含一些可预知的字段，
例如用户的邮箱地址，</p>
<!--
To identify the user, the authenticator uses the `id_token` (not the `access_token`)
from the OAuth2 [token response](https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse)
as a bearer token.  See [above](#putting-a-bearer-token-in-a-request) for how the token
is included in a request.
-->
<p>要识别用户，身份认证组件使用 OAuth2
<a href="https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse">令牌响应</a>
中的 <code>id_token</code>（而非 <code>access_token</code>）作为持有者令牌。
关于如何在请求中设置令牌，可参见<a href="#putting-a-bearer-token-in-a-request">前文</a>。</p>
<figure>
<div class="mermaid">
    
sequenceDiagram
    participant user as 用户
    participant idp as 身份提供者 
    participant kube as Kubectl
    participant api as API 服务器

    user ->> idp: 1. 登录到 IdP
    activate idp
    idp -->> user: 2. 提供 access_token,<br>id_token, 和 refresh_token
    deactivate idp
    activate user
    user ->> kube: 3. 调用 Kubectl 并<br>设置 --token 为 id_token<br>或者将令牌添加到 .kube/config
    deactivate user
    activate kube
    kube ->> api: 4. Authorization: Bearer...
    deactivate kube
    activate api
    api ->> api: 5. JWT 签名合法么？
    api ->> api: 6. JWT 是否已过期？(iat+exp)
    api ->> api: 7. 用户被授权了么？
    api -->> kube: 8. 已授权：执行<br>操作并返回结果
    deactivate api
    activate kube
    kube --x user: 9. 返回结果
    deactivate kube

</div>
</figure>

<noscript>
  <div class="alert alert-secondary callout" role="alert">
    <em class="javascript-required">JavaScript must be <a href="https://www.enable-javascript.com/">enabled</a> to view this content</em>
  </div>
</noscript>
<!--
1.  Login to your identity provider
2.  Your identity provider will provide you with an `access_token`, `id_token` and a `refresh_token`
3.  When using `kubectl`, use your `id_token` with the `-token` flag or add it directly to your `kubeconfig`
4.  `kubectl` sends your `id_token` in a header called Authorization to the API server
5.  The API server will make sure the JWT signature is valid by checking against the certificate named in the configuration
6.  Check to make sure the `id_token` hasn't expired
7.  Make sure the user is authorized
8.  Once authorized the API server returns a response to `kubectl`
9.  `kubectl` provides feedback to the user
-->
<ol>
<li>登录到你的身份服务（Identity Provider）</li>
<li>你的身份服务将为你提供 <code>access_token</code>、<code>id_token</code> 和 <code>refresh_token</code></li>
<li>在使用 <code>kubectl</code> 时，将 <code>id_token</code> 设置为 <code>--token</code> 标志值，或者将其直接添加到
<code>kubeconfig</code> 中</li>
<li><code>kubectl</code> 将你的 <code>id_token</code> 放到一个称作 <code>Authorization</code> 的头部，发送给 API 服务器</li>
<li>API 服务器将负责通过检查配置中引用的证书来确认 JWT 的签名是合法的</li>
<li>检查确认 <code>id_token</code> 尚未过期</li>
<li>确认用户有权限执行操作</li>
<li>鉴权成功之后，API 服务器向 <code>kubectl</code> 返回响应</li>
<li><code>kubectl</code> 向用户提供反馈信息</li>
</ol>
<!--
Since all of the data needed to validate who you are is in the `id_token`, Kubernetes doesn't need to
"phone home" to the identity provider.  In a model where every request is stateless this provides a very scalable solution for authentication.  It does offer a few challenges:
-->
<p>由于用来验证你是谁的所有数据都在 <code>id_token</code> 中，Kubernetes 不需要再去联系身份服务。
在一个所有请求都是无状态请求的模型中，这一工作方式可以使得身份认证的解决方案更容易处理大规模请求。
不过，此访问也有一些挑战：</p>
<!--
1. Kubernetes has no "web interface" to trigger the authentication process.  There is no browser or interface to collect credentials which is why you need to authenticate to your identity provider first.
2. The `id_token` can't be revoked, it's like a certificate so it should be short-lived (only a few minutes) so it can be very annoying to have to get a new token every few minutes.
3. To authenticate to the Kubernetes dashboard, you must use the `kubectl proxy` command or a reverse proxy that injects the `id_token`.
-->
<ol>
<li>Kubernetes 没有提供用来触发身份认证过程的 &quot;Web 界面&quot;。
因为不存在用来收集用户凭据的浏览器或用户接口，你必须自己先行完成对身份服务的认证过程。</li>
<li><code>id_token</code> 令牌不可收回。因其属性类似于证书，其生命期一般很短（只有几分钟），
所以，每隔几分钟就要获得一个新的令牌这件事可能很让人头疼。</li>
<li>如果需要向 Kubernetes 控制面板执行身份认证，你必须使用 <code>kubectl proxy</code>
命令或者一个能够注入 <code>id_token</code> 的反向代理。</li>
</ol>
<!--
#### Configuring the API Server

To enable the plugin, configure the following flags on the API server:
-->
<h4 id="configuring-the-api-server">配置 API 服务器   </h4>
<p>要启用此插件，须在 API 服务器上配置以下标志：</p>
<!--
| Parameter | Description | Example | Required |
| --------- | ----------- | ------- | ------- |
| `--oidc-issuer-url` | URL of the provider which allows the API server to discover public signing keys. Only URLs which use the `https://` scheme are accepted.  This is typically the provider's discovery URL without a path, for example "https://accounts.google.com" or "https://login.salesforce.com".  This URL should point to the level below .well-known/openid-configuration | If the discovery URL is `https://accounts.google.com/.well-known/openid-configuration`, the value should be `https://accounts.google.com` | Yes |
| `--oidc-client-id` |  A client id that all tokens must be issued for. | kubernetes | Yes |
| `--oidc-username-claim` | JWT claim to use as the user name. By default `sub`, which is expected to be a unique identifier of the end user. Admins can choose other claims, such as `email` or `name`, depending on their provider. However, claims other than `email` will be prefixed with the issuer URL to prevent naming clashes with other plugins. | sub | No |
| `--oidc-username-prefix` | Prefix prepended to username claims to prevent clashes with existing names (such as `system:` users). For example, the value `oidc:` will create usernames like `oidc:jane.doe`. If this flag isn't provided and `--oidc-username-claim` is a value other than `email` the prefix defaults to `( Issuer URL )#` where `( Issuer URL )` is the value of `--oidc-issuer-url`. The value `-` can be used to disable all prefixing. | `oidc:` | No |
| `--oidc-groups-claim` | JWT claim to use as the user's group. If the claim is present it must be an array of strings. | groups | No |
| `--oidc-groups-prefix` | Prefix prepended to group claims to prevent clashes with existing names (such as `system:` groups). For example, the value `oidc:` will create group names like `oidc:engineering` and `oidc:infra`. | `oidc:` | No |
| `--oidc-required-claim` | A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims. | `claim=value` | No |
| `--oidc-ca-file` | The path to the certificate for the CA that signed your identity provider's web certificate.  Defaults to the host's root CAs. | `/etc/kubernetes/ssl/kc-ca.pem` | No |
-->
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>示例</th>
<th>必需？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>允许 API 服务器发现公开的签名密钥的服务的 URL。只接受模式为 <code>https://</code> 的 URL。此值通常设置为服务的发现 URL，不含路径。例如：&quot;https://accounts.google.com&quot; 或 &quot;https://login.salesforce.com&quot;。此 URL 应指向 .well-known/openid-configuration 下一层的路径。</td>
<td>如果发现 URL 是 <code>https://accounts.google.com/.well-known/openid-configuration</code>，则此值应为 <code>https://accounts.google.com</code></td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>所有令牌都应发放给此客户 ID。</td>
<td>kubernetes</td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>用作用户名的 JWT 申领（JWT Claim）。默认情况下使用 <code>sub</code> 值，即最终用户的一个唯一的标识符。管理员也可以选择其他申领，例如 <code>email</code> 或者 <code>name</code>，取决于所用的身份服务。不过，除了 <code>email</code> 之外的申领都会被添加令牌发放者的 URL 作为前缀，以免与其他插件产生命名冲突。</td>
<td>sub</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>要添加到用户名申领之前的前缀，用来避免与现有用户名发生冲突（例如：<code>system:</code> 用户）。例如，此标志值为 <code>oidc:</code> 时将创建形如 <code>oidc:jane.doe</code> 的用户名。如果此标志未设置，且 <code>--oidc-username-claim</code> 标志值不是 <code>email</code>，则默认前缀为 <code>&lt;令牌发放者的 URL&gt;#</code>，其中 <code>&lt;令牌发放者 URL &gt;</code> 的值取自 <code>--oidc-issuer-url</code> 标志的设定。此标志值为 <code>-</code> 时，意味着禁止添加用户名前缀。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>用作用户组名的 JWT 申领。如果所指定的申领确实存在，则其值必须是一个字符串数组。</td>
<td>groups</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>添加到组申领的前缀，用来避免与现有用户组名（如：<code>system:</code> 组）发生冲突。例如，此标志值为 <code>oidc:</code> 时，所得到的用户组名形如 <code>oidc:engineering</code> 和 <code>oidc:infra</code>。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>取值为一个 key=value 偶对，意为 ID 令牌中必须存在的申领。如果设置了此标志，则 ID 令牌会被检查以确定是否包含取值匹配的申领。此标志可多次重复，以指定多个申领。</td>
<td><code>claim=value</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>指向一个 CA 证书的路径，该 CA 负责对你的身份服务的 Web 证书提供签名。默认值为宿主系统的根 CA。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>否</td>
</tr>
</tbody>
</table>
<!--
Importantly, the API server is not an OAuth2 client, rather it can only be
configured to trust a single issuer. This allows the use of public providers,
such as Google, without trusting credentials issued to third parties. Admins who
wish to utilize multiple OAuth clients should explore providers which support the
`azp` (authorized party) claim, a mechanism for allowing one client to issue
tokens on behalf of another.
-->
<p>很重要的一点是，API 服务器并非一个 OAuth2 客户端，相反，它只能被配置为
信任某一个令牌发放者。这使得使用公共服务（如 Google）的用户可以不信任发放给
第三方的凭据。
如果管理员希望使用多个 OAuth 客户端，他们应该研究一下那些支持 <code>azp</code>
（Authorized Party，被授权方）申领的服务。
<code>azp</code> 是一种允许某客户端代替另一客户端发放令牌的机制。</p>
<!--
Kubernetes does not provide an OpenID Connect Identity Provider.
You can use an existing public OpenID Connect Identity Provider (such as Google, or
[others](https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers)).
Or, you can run your own Identity Provider, such as CoreOS [dex](https://github.com/coreos/dex),
[Keycloak](https://github.com/keycloak/keycloak),
CloudFoundry [UAA](https://github.com/cloudfoundry/uaa), or
Tremolo Security's [OpenUnison](https://openunison.github.io/).
-->
<p>Kubernetes 并未提供 OpenID Connect 的身份服务。
你可以使用现有的公共的 OpenID Connect 身份服务（例如 Google 或者
<a href="https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers">其他服务</a>）。
或者，你也可以选择自己运行一个身份服务，例如
CoreOS <a href="https://github.com/coreos/dex">dex</a>、
<a href="https://github.com/keycloak/keycloak">Keycloak</a>、
CloudFoundry <a href="https://github.com/cloudfoundry/uaa">UAA</a> 或者
Tremolo Security 的 <a href="https://openunison.github.io/">OpenUnison</a>。</p>
<!--
For an identity provider to work with Kubernetes it must:

1.  Support [OpenID connect discovery](https://openid.net/specs/openid-connect-discovery-1_0.html); not all do.
2.  Run in TLS with non-obsolete ciphers
3.  Have a CA signed certificate (even if the CA is not a commercial CA or is self signed)
-->
<p>要在 Kubernetes 环境中使用某身份服务，该服务必须：</p>
<ol>
<li>支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID connect 发现</a>；
但事实上并非所有服务都具备此能力</li>
<li>运行 TLS 协议且所使用的加密组件都未过时</li>
<li>拥有由 CA 签名的证书（即使 CA 不是商业 CA 或者是自签名的 CA 也可以）</li>
</ol>
<!--
A note about requirement #3 above, requiring a CA signed certificate.  If you deploy your own identity provider (as opposed to one of the cloud providers like Google or Microsoft) you MUST have your identity provider's web server certificate signed by a certificate with the `CA` flag set to `TRUE`, even if it is self signed.  This is due to GoLang's TLS client implementation being very strict to the standards around certificate validation.  If you don't have a CA handy, you can use [this script](https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh) from the Dex team to create a simple CA and a signed certificate and key pair.
Or you can use [this similar script](https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh) that generates SHA256 certs with a longer life and larger key size.
-->
<p>关于上述第三条需求，即要求具备 CA 签名的证书，有一些额外的注意事项。
如果你部署了自己的身份服务，而不是使用云厂商（如 Google 或 Microsoft）所提供的服务，
你必须对身份服务的 Web 服务器证书进行签名，签名所用证书的 <code>CA</code> 标志要设置为
<code>TRUE</code>，即使用的是自签名证书。这是因为 GoLang 的 TLS 客户端实现对证书验证
标准方面有非常严格的要求。如果你手头没有现成的 CA 证书，可以使用 CoreOS
团队所开发的<a href="https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh">这个脚本</a>
来创建一个简单的 CA 和被签了名的证书与密钥对。
或者你也可以使用
<a href="https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh">这个类似的脚本</a>，
生成一个合法期更长、密钥尺寸更大的 SHA256 证书。</p>
<!--
Setup instructions for specific systems:
-->
<p>特定系统的安装指令：</p>
<ul>
<li><a href="https://docs.cloudfoundry.org/concepts/architecture/uaa.html">UAA</a></li>
<li><a href="https://dexidp.io/docs/kubernetes/">Dex</a></li>
<li><a href="https://www.tremolosecurity.com/orchestra-k8s/">OpenUnison</a></li>
</ul>
<!--
#### Using kubectl

##### Option 1 - OIDC Authenticator

The first option is to use the kubectl `oidc` authenticator, which sets the `id_token` as a bearer token for all requests and refreshes the token once it expires. After you've logged into your provider, use kubectl to add your `id_token`, `refresh_token`, `client_id`, and `client_secret` to configure the plugin.

Providers that don't return an `id_token` as part of their refresh token response aren't supported by this plugin and should use "Option 2" below.
-->
<h4 id="using-kubectl">使用 kubectl  </h4>
<h5 id="选项一-oidc-身份认证组件">选项一 - OIDC 身份认证组件</h5>
<p>第一种方案是使用 kubectl 的 <code>oidc</code> 身份认证组件，该组件将 <code>id_token</code> 设置
为所有请求的持有者令牌，并且在令牌过期时自动刷新。在你登录到你的身份服务之后，
可以使用 kubectl 来添加你的 <code>id_token</code>、<code>refresh_token</code>、<code>client_id</code> 和
<code>client_secret</code>，以配置该插件。</p>
<p>如果服务在其刷新令牌响应中不包含 <code>id_token</code>，则此插件无法支持该服务。
这时你应该考虑下面的选项二。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl config set-credentials USER_NAME <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider<span style="color:#666">=</span>oidc <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>idp-issuer-url<span style="color:#666">=(</span> issuer url <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>client-id<span style="color:#666">=(</span> your client id <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>client-secret<span style="color:#666">=(</span> your client secret <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>refresh-token<span style="color:#666">=(</span> your refresh token <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>idp-certificate-authority<span style="color:#666">=(</span> path to your ca certificate <span style="color:#666">)</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>   --auth-provider-arg<span style="color:#666">=</span>id-token<span style="color:#666">=(</span> your id_token <span style="color:#666">)</span>
</code></pre></div><!--
As an example, running the below command after authenticating to your identity provider:
-->
<p>作为示例，在完成对你的身份服务的身份认证之后，运行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl config set-credentials mmosley  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider<span style="color:#666">=</span>oidc  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>idp-issuer-url<span style="color:#666">=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>client-id<span style="color:#666">=</span>kubernetes  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>client-secret<span style="color:#666">=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>refresh-token<span style="color:#666">=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style="color:#666">=</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>idp-certificate-authority<span style="color:#666">=</span>/root/ca.pem <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --auth-provider-arg<span style="color:#666">=</span>id-token<span style="color:#666">=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div><!--
Which would produce the below configuration:
-->
<p>此操作会生成以下配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mmosley<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">auth-provider</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">config</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">client-id</span>:<span style="color:#bbb"> </span>kubernetes<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">client-secret</span>:<span style="color:#bbb"> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">id-token</span>:<span style="color:#bbb"> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">idp-certificate-authority</span>:<span style="color:#bbb"> </span>/root/ca.pem<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">idp-issuer-url</span>:<span style="color:#bbb"> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">refresh-token</span>:<span style="color:#bbb"> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>oidc<span style="color:#bbb">
</span></code></pre></div><!--
Once your `id_token` expires, `kubectl` will attempt to refresh your `id_token` using your `refresh_token` and `client_secret` storing the new values for the `refresh_token` and `id_token` in your `.kube/config`.
-->
<p>当你的 <code>id_token</code> 过期时，<code>kubectl</code> 会尝试使用你的 <code>refresh_token</code> 来刷新你的
<code>id_token</code>，并且在 <code>.kube/config</code> 文件的 <code>client_secret</code> 中存放 <code>refresh_token</code>
和 <code>id_token</code> 的新值。</p>
<!--
##### Option 2 - Use the `--token` Option

The `kubectl` command lets you pass in a token using the `--token` option. Copy and paste the `id_token` into this option:
-->
<h5 id="选项二-使用-token-选项">选项二 - 使用 <code>--token</code> 选项</h5>
<p><code>kubectl</code> 命令允许你使用 <code>--token</code> 选项传递一个令牌。
你可以将 <code>id_token</code> 的内容复制粘贴过来，作为此标志的取值：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl --token<span style="color:#666">=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div><!--
### Webhook Token Authentication

Webhook authentication is a hook for verifying bearer tokens.

* `--authentication-token-webhook-config-file` a configuration file describing how to access the remote webhook service.
* `--authentication-token-webhook-cache-ttl` how long to cache authentication decisions. Defaults to two minutes.
-->
<h3 id="webhook-token-authentication">Webhook 令牌身份认证  </h3>
<p>Webhook 身份认证是一种用来验证持有者令牌的回调机制。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code> 指向一个配置文件，其中描述
如何访问远程的 Webhook 服务。</li>
<li><code>--authentication-token-webhook-cache-ttl</code> 用来设定身份认证决定的缓存时间。
默认时长为 2 分钟。</li>
</ul>
<!--
The configuration file uses the [kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
file format. Within the file, `clusters` refers to the remote service and
`users` refers to the API server webhook. An example would be:
-->
<p>配置文件使用 <a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
文件的格式。文件中，<code>clusters</code> 指代远程服务，<code>users</code> 指代远程 API 服务
Webhook。下面是一个例子：</p>
<!--
```yaml
# Kubernetes API version
apiVersion: v1
# kind of the API object
kind: Config
# clusters refers to the remote service.
clusters:
  - name: name-of-remote-authn-service
    cluster:
      certificate-authority: /path/to/ca.pem         # CA for verifying the remote service.
      server: https://authn.example.com/authenticate # URL of remote service to query. 'https' recommended for production.

# users refers to the API server's webhook configuration.
users:
  - name: name-of-api-server
    user:
      client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
      client-key: /path/to/key.pem          # key matching the cert

# kubeconfig files require a context. Provide one for the API server.
current-context: webhook
contexts:
- context:
    cluster: name-of-remote-authn-service
    user: name-of-api-sever
  name: webhook
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Kubernetes API 版本</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># API 对象类别</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># clusters 指代远程服务</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-authn-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem        <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 用来验证远程服务的 CA</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://authn.example.com/authenticate<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 要查询的远程服务 URL。生产环境中建议使用 &#39;https&#39;。</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 指代 API 服务的 Webhook 配置</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># Webhook 插件要使用的证书</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 与证书匹配的密钥</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>name-of-remote-authn-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>name-of-api-sever<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span></code></pre></div><!--
When a client attempts to authenticate with the API server using a bearer token
as discussed [above](#putting-a-bearer-token-in-a-request),
the authentication webhook POSTs a JSON-serialized `authentication.k8s.io/v1beta1` `TokenReview` object containing the token
to the remote service. Kubernetes will not challenge a request that lacks such a header.
-->
<p>当客户端尝试在 API 服务器上使用持有者令牌完成身份认证（
如<a href="#putting-a-bearer-token-in-a-request">前</a>所述）时，
身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。
该对象是 <code>authentication.k8s.io/v1beta1</code> 组的 <code>TokenReview</code> 对象，
其中包含持有者令牌。
Kubernetes 不会强制请求提供此 HTTP 头部。</p>
<!--
Note that webhook API objects are subject to the same [versioning compatibility rules](/docs/concepts/overview/kubernetes-api/)
as other Kubernetes API objects. Implementers should be aware of looser
compatibility promises for beta objects and check the "apiVersion" field of the
request to ensure correct deserialization. Additionally, the API server must
enable the `authentication.k8s.io/v1beta1` API extensions group (`--runtime-config=authentication.k8s.io/v1beta1=true`).

The POST body will be of the following format:
-->
<p>要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，也要受到同一
<a href="/zh/docs/concepts/overview/kubernetes-api/">版本兼容规则</a>约束。
实现者要了解对 Beta 阶段对象的兼容性承诺，并检查请求的 <code>apiVersion</code> 字段，
以确保数据结构能够正常反序列化解析。此外，API 服务器必须启用
<code>authentication.k8s.io/v1beta1</code> API 扩展组
（<code>--runtime-config=authentication.k8s.io/v1beta1=true</code>）。</p>
<p>POST 请求的 Body 部分将是如下格式：</p>
<!--
```json
{
  "apiVersion": "authentication.k8s.io/v1beta1",
  "kind": "TokenReview",
  "spec": {
    "token": "(BEARERTOKEN)"
  }
}
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;&lt;持有者令牌&gt;&#34;</span>
  }
}
</code></pre></div><!--
The remote service is expected to fill the `status` field of
the request to indicate the success of the login. The response body's `spec`
field is ignored and may be omitted. A successful validation of the bearer
token would return:
-->
<p>远程服务应该会填充请求的 <code>status</code> 字段，以标明登录操作是否成功。
响应的 Body 中的 <code>spec</code> 字段会被忽略，因此可以省略。
如果持有者令牌验证成功，应该返回如下所示的响应：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;authenticated&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;username&#34;</span>: <span style="color:#b44">&#34;janedoe@example.com&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;42&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;groups&#34;</span>: [
        <span style="color:#b44">&#34;developers&#34;</span>,
        <span style="color:#b44">&#34;qa&#34;</span>
      ],
      <span style="color:#008000;font-weight:bold">&#34;extra&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;extrafield1&#34;</span>: [
          <span style="color:#b44">&#34;extravalue1&#34;</span>,
          <span style="color:#b44">&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div><!--
An unsuccessful request would return:
-->
<p>而不成功的请求会返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;TokenReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;authenticated&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div><!--
HTTP status codes can be used to supply additional error context.
-->
<p>HTTP 状态码可用来提供进一步的错误语境信息。</p>
<!--
### Authenticating Proxy

The API server can be configured to identify users from request header values, such as `X-Remote-User`.
It is designed for use in combination with an authenticating proxy, which sets the request header value.
-->
<h3 id="authenticating-proxy">身份认证代理  </h3>
<p>API 服务器可以配置成从请求的头部字段值（如 <code>X-Remote-User</code>）中辩识用户。
这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。</p>
<!--
* `--requestheader-username-headers` Required, case-insensitive. Header names to check, in order, for the user identity. The first header containing a value is used as the username.
* `--requestheader-group-headers` 1.6+. Optional, case-insensitive. "X-Remote-Group" is suggested. Header names to check, in order, for the user's groups. All values in all specified headers are used as group names.
* `-requestheader-extra-headers-prefix` 1.6+. Optional, case-insensitive. "X-Remote-Extra-" is suggested. Header prefixes to look for to determine extra information about the user (typically used by the configured authorization plugin). Any headers beginning with any of the specified prefixes have the prefix removed. The remainder of the header name is lowercased and [percent-decoded](https://tools.ietf.org/html/rfc3986#section-2.1) and becomes the extra key, and the header value is the extra value.
-->
<ul>
<li><code>--requestheader-username-headers</code> 必需字段，大小写不敏感。用来设置要获得用户身份所要检查的头部字段名称列表（有序）。第一个包含数值的字段会被用来提取用户名。</li>
<li><code>--requestheader-group-headers</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 &quot;X-Remote-Group&quot;。用来指定一组头部字段名称列表，以供检查用户所属的组名称。
所找到的全部头部字段的取值都会被用作用户组名。</li>
<li><code>--requestheader-extra-headers-prefix</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 &quot;X-Remote-Extra-&quot;。用来设置一个头部字段的前缀字符串，API 服务器会基于所给
前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。
API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分
转换为小写字符串并在必要时执行<a href="https://tools.ietf.org/html/rfc3986#section-2.1">百分号解码</a>
后，构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。</li>
</ul>
<!--
Prior to 1.11.3 (and 1.10.7, 1.9.11), the extra key could only contain characters which were [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6).
For example, with this configuration:
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 在 1.13.3 版本之前（包括 1.10.7、1.9.11），附加字段的键名只能包含
<a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">HTTP 头部标签的合法字符</a>。
</div>
<p>例如，使用下面的配置：</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><!--
this request:
-->
<p>针对所收到的如下请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#00a000">GET</span> <span style="color:#00f;font-weight:bold">/</span> <span style="color:#a2f;font-weight:bold">HTTP</span><span style="color:#666">/</span><span style="color:#666">1.1</span>
X-Remote-User<span style="color:#666">:</span> fido
X-Remote-Group<span style="color:#666">:</span> dogs
X-Remote-Group<span style="color:#666">:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style="color:#666">:</span> some-project
X-Remote-Extra-Scopes<span style="color:#666">:</span> openid
X-Remote-Extra-Scopes<span style="color:#666">:</span> profile
</code></pre></div><!--
would result in this user info:
-->
<p>会生成下面的用户信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>fido<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">groups</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- dogs<span style="color:#bbb">
</span><span style="color:#bbb"></span>- dachshunds<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">extra</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">acme.com/project</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- some-project<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">scopes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- openid<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- profile<span style="color:#bbb">
</span></code></pre></div><!--
In order to prevent header spoofing, the authenticating proxy is required to present a valid client
certificate to the API server for validation against the specified CA before the request headers are
checked. WARNING: do **not** reuse a CA that is used in a different context unless you understand
the risks and the mechanisms to protect the CA's usage.

* `--requestheader-client-ca-file` Required. PEM-encoded certificate bundle. A valid client certificate must be presented and validated against the certificate authorities in the specified file before the request headers are checked for user names.
* `--requestheader-allowed-names` Optional. List of Common Name values (CNs). If set, a valid client certificate with a CN in the specified list must be presented before the request headers are checked for user names. If empty, any CN is allowed.
-->
<p>为了防范头部信息侦听，在请求中的头部字段被检视之前，
身份认证代理需要向 API 服务器提供一份合法的客户端证书，
供后者使用所给的 CA 来执行验证。
警告：<em>不要</em> 在不同的上下文中复用 CA 证书，除非你清楚这样做的风险是什么以及
应如何保护 CA 用法的机制。</p>
<ul>
<li><code>--requestheader-client-ca-file</code> 必需字段，给出 PEM 编码的证书包。
在检查请求的头部字段以提取用户名信息之前，必须提供一个合法的客户端证书，
且该证书要能够被所给文件中的机构所验证。</li>
<li><code>--requestheader-allowed-names</code> 可选字段，用来给出一组公共名称（CN）。
如果此标志被设置，则在检视请求中的头部以提取用户信息之前，必须提供
包含此列表中所给的 CN 名的、合法的客户端证书。</li>
</ul>
<!--
## Anonymous requests

When enabled, requests that are not rejected by other configured authentication methods are
treated as anonymous requests, and given a username of `system:anonymous` and a group of
`system:unauthenticated`.
-->
<h2 id="anonymous-requests">匿名请求  </h2>
<p>启用匿名请求支持之后，如果请求没有被已配置的其他身份认证方法拒绝，则被视作
匿名请求（Anonymous Requests）。这类请求获得用户名 <code>system:anonymous</code> 和
对应的用户组 <code>system:unauthenticated</code>。</p>
<!--
For example, on a server with token authentication configured, and anonymous access enabled,
a request providing an invalid bearer token would receive a `401 Unauthorized` error.
A request providing no bearer token would be treated as an anonymous request.

In 1.5.1-1.5.x, anonymous access is disabled by default, and can be enabled by
passing the `--anonymous-auth=true` option to the API server.
-->
<p>例如，在一个配置了令牌身份认证且启用了匿名访问的服务器上，如果请求提供了非法的
持有者令牌，则会返回 <code>401 Unauthorized</code> 错误。
如果请求没有提供持有者令牌，则被视为匿名请求。</p>
<p>在 1.5.1-1.5.x 版本中，匿名访问默认情况下是被禁用的，可以通过为 API 服务器设定
<code>--anonymous-auth=true</code> 来启用。</p>
<!--
In 1.6+, anonymous access is enabled by default if an authorization mode other than `AlwaysAllow`
is used, and can be disabled by passing the `-anonymous-auth=false` option to the API server.
Starting in 1.6, the ABAC and RBAC authorizers require explicit authorization of the
`system:anonymous` user or the `system:unauthenticated` group, so legacy policy rules
that grant access to the `*` user or `*` group do not include anonymous users.
-->
<p>在 1.6 及之后版本中，如果所使用的鉴权模式不是 <code>AlwaysAllow</code>，则匿名访问默认是被启用的。
从 1.6 版本开始，ABAC 和 RBAC 鉴权模块要求对 <code>system:anonymous</code> 用户或者
<code>system:unauthenticated</code> 用户组执行显式的权限判定，所以之前的为 <code>*</code> 用户或
<code>*</code> 用户组赋予访问权限的策略规则都不再包含匿名用户。</p>
<!--
## User impersonation

A user can act as another user through impersonation headers. These let requests
manually override the user info a request authenticates as. For example, an admin
could use this feature to debug an authorization policy by temporarily
impersonating another user and seeing if a request was denied.
-->
<h2 id="user-impersonation">用户伪装 </h2>
<p>一个用户可以通过伪装（Impersonation）头部字段来以另一个用户的身份执行操作。
使用这一能力，你可以手动重载请求被身份认证所识别出来的用户信息。
例如，管理员可以使用这一功能特性来临时伪装成另一个用户，查看请求是否被拒绝，
从而调试鉴权策略中的问题，</p>
<!--
Impersonation requests first authenticate as the requesting user, then switch
to the impersonated user info.

* A user makes an API call with their credentials _and_ impersonation headers.
* API server authenticates the user.
* API server ensures the authenticated users have impersonation privileges.
* Request user info is replaced with impersonation values.
* Request is evaluated, authorization acts on impersonated user info.
-->
<p>带伪装的请求首先会被身份认证识别为发出请求的用户，之后会切换到使用被伪装的用户
的用户信息。</p>
<ul>
<li>用户发起 API 调用时 <em>同时</em> 提供自身的凭据和伪装头部字段信息</li>
<li>API 服务器对用户执行身份认证</li>
<li>API 服务器确认通过认证的用户具有伪装特权</li>
<li>请求用户的信息被替换成伪装字段的值</li>
<li>评估请求，鉴权组件针对所伪装的用户信息执行操作</li>
</ul>
<!--
The following HTTP headers can be used to performing an impersonation request:

* `Impersonate-User`: The username to act as.
* `Impersonate-Group`: A group name to act as. Can be provided multiple times to set multiple groups. Optional. Requires "Impersonate-User".
* `Impersonate-Extra-( extra name )`: A dynamic header used to associate extra fields with the user. Optional. Requires "Impersonate-User". In order to be preserved consistently, `( extra name )` must be lower-case, and any characters which aren't [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6) MUST be utf8 and [percent-encoded](https://tools.ietf.org/html/rfc3986#section-2.1).
* `Impersonate-Uid`: A unique identifier that represents the user being impersonated. Optional. Requires "Impersonate-User". Kubernetes does not impose any format requirements on this string.
-->
<p>以下 HTTP 头部字段可用来执行伪装请求：</p>
<ul>
<li><code>Impersonate-User</code>：要伪装成的用户名</li>
<li><code>Impersonate-Group</code>：要伪装成的用户组名。可以多次指定以设置多个用户组。
可选字段；要求 &quot;Impersonate-User&quot; 必须被设置。</li>
<li><code>Impersonate-Extra-&lt;附加名称&gt;</code>：一个动态的头部字段，用来设置与用户相关的附加字段。
此字段可选；要求 &quot;Impersonate-User&quot; 被设置。为了能够以一致的形式保留，
<code>&lt;附加名称&gt;</code>部分必须是小写字符，如果有任何字符不是
<a href="https://tools.ietf.org/html/rfc7230#section-3.2.6">合法的 HTTP 头部标签字符</a>，
则必须是 utf8 字符，且转换为<a href="https://tools.ietf.org/html/rfc3986#section-2.1">百分号编码</a>。</li>
<li><code>Impersonate-Uid</code>：一个唯一标识符，用来表示所伪装的用户。此头部可选。
如果设置，则要求 &quot;Impersonate-User&quot; 也存在。
Kubernetes 对此字符串没有格式要求。</li>
</ul>
<!--
Prior to 1.11.3 (and 1.10.7, 1.9.11), `( extra name )` could only contain characters which were [legal in HTTP header labels](https://tools.ietf.org/html/rfc7230#section-3.2.6).
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 在 1.11.3 版本之前（以及 1.10.7、1.9.11），<code>&lt;附加名称&gt;</code> 只能包含
合法的 HTTP 标签字符。
</div>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
`Impersonate-Uid` is only available in versions 1.22.0 and higher.
-->
<p><code>Impersonate-Uid</code> 仅在 1.22.0 及更高版本中可用。
</div>
<!--
An example of the impersonation headers used when impersonating a user with groups:
-->
<p>伪装带有用户组的用户时，所使用的伪装头部字段示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Impersonate-User: jane.doe@example.com
</span><span style="">Impersonate-Group: developers
</span><span style="">Impersonate-Group: admins
</span></code></pre></div><!--
An example of the impersonation headers used when impersonating a user with a UID and
extra fields:
-->
<p>伪装带有 UID 和附加字段的用户时，所使用的伪装头部字段示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Impersonate-User: jane.doe@example.com
</span><span style="">Impersonate-Group: developers
</span><span style="">Impersonate-Group: admins
</span><span style="">Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span style="">Impersonate-Extra-acme.com%2Fproject: some-project
</span><span style="">Impersonate-Extra-scopes: view
</span><span style="">Impersonate-Extra-scopes: development
</span></code></pre></div><!--
When using `kubectl` set the `--as` flag to configure the `Impersonate-User`
header, set the `--as-group` flag to configure the `Impersonate-Group` header.
-->
<p>在使用 <code>kubectl</code> 时，可以使用 <code>--as</code> 标志来配置 <code>Impersonate-User</code> 头部字段值，
使用 <code>--as-group</code> 标志配置 <code>Impersonate-Group</code> 头部字段值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl drain mynode
</code></pre></div><pre><code class="language-none" data-lang="none">Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><!--
Set the `--as` and `--as-group` flag:
-->
<p>设置 <code>--as</code> 和 <code>--as-group</code> 标志：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl drain mynode --as<span style="color:#666">=</span>superman --as-group<span style="color:#666">=</span>system:masters
</code></pre></div><pre><code class="language-none" data-lang="none">node/mynode cordoned
node/mynode drained
</code></pre><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
`kubectl` cannot impersonate extra fields or UIDs.
-->
<p><code>kubectl</code> 不能对附加字段或 UID 执行伪装。
</div>
<!--
To impersonate a user, group, user identifier (UID) or extra fields, the impersonating user must
have the ability to perform the "impersonate" verb on the kind of attribute
being impersonated ("user", "group", "uid", etc.). For clusters that enable the RBAC
authorization plugin, the following ClusterRole encompasses the rules needed to
set user and group impersonation headers:
-->
<p>若要伪装成某个用户、某个组、用户标识符（UID））或者设置附加字段，
执行伪装操作的用户必须具有对所伪装的类别（“user”、“group”、“uid” 等）执行 “impersonate”
动词操作的能力。
对于启用了 RBAC 鉴权插件的集群，下面的 ClusterRole 封装了设置用户和组伪装字段所需的规则：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;users&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;groups&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;serviceaccounts&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
For impersonation, extra fields and impersonated UIDs are both under the "authentication.k8s.io" `apiGroup`.
Extra fields are evaluated as sub-resources of the resource "userextras". To
allow a user to use impersonation headers for the extra field "scopes" and
for UIDs, a user should be granted the following role:
-->
<p>为了执行伪装，附加字段和所伪装的 UID 都位于 &quot;authorization.k8s.io&quot; <code>apiGroup</code> 中。
附加字段会被作为 <code>userextras</code> 资源的子资源来执行权限评估。
如果要允许用户为附加字段 “scopes” 和 UID 设置伪装头部，该用户需要被授予以下角色：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>scopes-and-uid-impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以设置 &#34;Impersonate-Extra-scopes&#34; 和 &#34;Impersonate-Uid&#34; 头部</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;authentication.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;userextras/scopes&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;uids&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The values of impersonation headers can also be restricted by limiting the set
of `resourceNames` a resource can take.
-->
<p>你也可以通过约束资源可能对应的 <code>resourceNames</code> 限制伪装头部的取值：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>limited-impersonator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以伪装成用户 &#34;jane.doe@example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;users&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;jane.doe@example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以伪装成用户组 &#34;developers&#34; 和 &#34;admins&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;groups&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;developers&#34;</span>,<span style="color:#b44">&#34;admins&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以将附加字段 &#34;scopes&#34; 伪装成 &#34;view&#34; 和 &#34;development&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;authentication.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;userextras/scopes&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;view&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;development&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 可以伪装 UID &#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;authentication.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;uids&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;impersonate&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
## client-go credential plugins
-->
<h2 id="client-go-credential-plugins">client-go 凭据插件 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>


<!--
`k8s.io/client-go` and tools using it such as `kubectl` and `kubelet` are able to execute an
external command to receive user credentials.

This feature is intended for client side integrations with authentication protocols not natively
supported by `k8s.io/client-go` (LDAP, Kerberos, OAuth2, SAML, etc.). The plugin implements the
protocol specific logic, then returns opaque credentials to use. Almost all credential plugin
use cases require a server side component with support for the [webhook token authenticator](#webhook-token-authentication)
to interpret the credential format produced by the client plugin.
-->
<p><code>k8s.io/client-go</code> 及使用它的工具（如 <code>kubectl</code> 和 <code>kubelet</code>）可以执行某个外部
命令来获得用户的凭据信息。</p>
<p>这一特性的目的是便于客户端与 <code>k8s.io/client-go</code> 并不支持的身份认证协议（LDAP、
Kerberos、OAuth2、SAML 等）继承。
插件实现特定于协议的逻辑，之后返回不透明的凭据以供使用。
几乎所有的凭据插件使用场景中都需要在服务器端存在一个支持
<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>的模块，
负责解析客户端插件所生成的凭据格式。</p>
<!--
### Example use case

In a hypothetical use case, an organization would run an external service that exchanges LDAP credentials
for user specific, signed tokens. The service would also be capable of responding to [webhook token
authenticator](#webhook-token-authentication) requests to validate the tokens. Users would be required
to install a credential plugin on their workstation.
-->
<h3 id="example-use-case">示例应用场景  </h3>
<p>在一个假想的应用场景中，某组织运行这一个外部的服务，能够将特定用户的已签名的
令牌转换成 LDAP 凭据。此服务还能够对
<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>的请求做出响应以
验证所提供的令牌。用户需要在自己的工作站上安装一个凭据插件。</p>
<!--
To authenticate against the API:

* The user issues a `kubectl` command.
* Credential plugin prompts the user for LDAP credentials, exchanges credentials with external service for a token.
* Credential plugin returns token to client-go, which uses it as a bearer token against the API server.
* API server uses the [webhook token authenticator](#webhook-token-authentication) to submit a `TokenReview` to the external service.
* External service verifies the signature on the token and returns the user's username and groups.
-->
<p>要对 API 服务器认证身份时：</p>
<ul>
<li>用户发出 <code>kubectl</code> 命令。</li>
<li>凭据插件提示用户输入 LDAP 凭据，并与外部服务交互，获得令牌。</li>
<li>凭据插件将令牌返回该 client-go，后者将其用作持有者令牌提交给 API 服务器。</li>
<li>API 服务器使用<a href="#webhook-token-authentication">Webhook 令牌身份认证组件</a>向
外部服务发出 <code>TokenReview</code> 请求。</li>
<li>外部服务检查令牌上的签名，返回用户的用户名和用户组信息。</li>
</ul>
<!--
### Configuration

Credential plugins are configured through [kubectl config files](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
as part of the user fields.
-->
<h3 id="configuration">配置 </h3>
<p>凭据插件通过 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubectl 配置文件</a>
来作为 user 字段的一部分设置。</p>
<ul class="nav nav-tabs" id="exec-plugin-kubeconfig-example-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#exec-plugin-kubeconfig-example-1-0" role="tab" aria-controls="exec-plugin-kubeconfig-example-1-0" aria-selected="true">client.authentication.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#exec-plugin-kubeconfig-example-1-1" role="tab" aria-controls="exec-plugin-kubeconfig-example-1-1">client.authentication.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="exec-plugin-kubeconfig-example-1"><div id="exec-plugin-kubeconfig-example-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="exec-plugin-kubeconfig-example-1-0">

<p><!--
```yaml
apiVersion: v1
kind: Config
users:
- name: my-user
  user:
    exec:
      # Command to execute. Required.
      command: "example-client-go-exec-plugin"

      # API version to use when decoding the ExecCredentials resource. Required.
      #
      # The API version returned by the plugin MUST match the version listed here.
      #
      # To integrate with tools that support multiple versions (such as client.authentication.k8s.io/v1alpha1),
      # set an environment variable, pass an argument to the tool that indicates which version the exec plugin expects,
      # or read the version from the ExecCredential object in the KUBERNETES_EXEC_INFO environment variable.
      apiVersion: "client.authentication.k8s.io/v1"

      # Environment variables to set when executing the plugin. Optional.
      env:
      - name: "FOO"
        value: "bar"

      # Arguments to pass when executing the plugin. Optional.
      args:
      - "arg1"
      - "arg2"

      # Text shown to the user when the executable doesn't seem to be present. Optional.
      installHint: |
        example-client-go-exec-plugin is required to authenticate
        to the current cluster.  It can be installed:

        On macOS: brew install example-client-go-exec-plugin

        On Ubuntu: apt-get install example-client-go-exec-plugin

        On Fedora: dnf install example-client-go-exec-plugin

        ...

      # Whether or not to provide cluster information, which could potentially contain
      # very large CA data, to this exec plugin as a part of the KUBERNETES_EXEC_INFO
      # environment variable.
      provideClusterInfo: true

      # The contract between the exec plugin and the standard input I/O stream. If the
      # contract cannot be satisfied, this plugin will not be run and an error will be
      # returned. Valid values are "Never" (this exec plugin never uses standard input),
      # "IfAvailable" (this exec plugin wants to use standard input if it is available),
      # or "Always" (this exec plugin requires standard input to function). Required.
      interactiveMode: Never
clusters:
- name: my-cluster
  cluster:
    server: "https://172.17.4.100:6443"
    certificate-authority: "/etc/kubernetes/ca.pem"
    extensions:
    - name: client.authentication.k8s.io/exec # reserved extension name for per cluster exec config
      extension:
        arbitrary: config
        this: can be provided via the KUBERNETES_EXEC_INFO environment variable upon setting provideClusterInfo
        you: ["can", "put", "anything", "here"]
contexts:
- name: my-cluster
  context:
    cluster: my-cluster
    user: my-user
current-context: my-cluster
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要执行的命令。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-client-go-exec-plugin&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行此插件时要设置的环境变量。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">env</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;FOO&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;bar&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行插件时要传递的参数。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">installHint</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        MacOS: brew install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Fedora: dnf install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        ...</span><span style="color:#bbb">        
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 提供集群信息（可能包含非常大的 CA 数据）</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">provideClusterInfo</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。必需字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">interactiveMode</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;/etc/kubernetes/ca.pem&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">extensions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>client.authentication.k8s.io/exec<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 为每个集群 exec 配置保留的扩展名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">extension</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">arbitrary</span>:<span style="color:#bbb"> </span>config<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">this</span>:<span style="color:#bbb"> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">you</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;can&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;put&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;anything&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;here&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="exec-plugin-kubeconfig-example-1-1" class="tab-pane" role="tabpanel" aria-labelledby="exec-plugin-kubeconfig-example-1-1">

<p><!--
```yaml
apiVersion: v1
kind: Config
users:
- name: my-user
  user:
    exec:
      # Command to execute. Required.
      command: "example-client-go-exec-plugin"

      # API version to use when decoding the ExecCredentials resource. Required.
      #
      # The API version returned by the plugin MUST match the version listed here.
      #
      # To integrate with tools that support multiple versions (such as client.authentication.k8s.io/v1alpha1),
      # set an environment variable, pass an argument to the tool that indicates which version the exec plugin expects,
      # or read the version from the ExecCredential object in the KUBERNETES_EXEC_INFO environment variable.
      apiVersion: "client.authentication.k8s.io/v1beta1"

      # Environment variables to set when executing the plugin. Optional.
      env:
      - name: "FOO"
        value: "bar"

      # Arguments to pass when executing the plugin. Optional.
      args:
      - "arg1"
      - "arg2"

      # Text shown to the user when the executable doesn't seem to be present. Optional.
      installHint: |
        example-client-go-exec-plugin is required to authenticate
        to the current cluster.  It can be installed:

        On macOS: brew install example-client-go-exec-plugin

        On Ubuntu: apt-get install example-client-go-exec-plugin

        On Fedora: dnf install example-client-go-exec-plugin

        ...

      # Whether or not to provide cluster information, which could potentially contain
      # very large CA data, to this exec plugin as a part of the KUBERNETES_EXEC_INFO
      # environment variable.
      provideClusterInfo: true

      # The contract between the exec plugin and the standard input I/O stream. If the
      # contract cannot be satisfied, this plugin will not be run and an error will be
      # returned. Valid values are "Never" (this exec plugin never uses standard input),
      # "IfAvailable" (this exec plugin wants to use standard input if it is available),
      # or "Always" (this exec plugin requires standard input to function). Optional.
      # Defaults to "IfAvailable".
      interactiveMode: Never
clusters:
- name: my-cluster
  cluster:
    server: "https://172.17.4.100:6443"
    certificate-authority: "/etc/kubernetes/ca.pem"
    extensions:
    - name: client.authentication.k8s.io/exec # reserved extension name for per cluster exec config
      extension:
        arbitrary: config
        this: can be provided via the KUBERNETES_EXEC_INFO environment variable upon setting provideClusterInfo
        you: ["can", "put", "anything", "here"]
contexts:
- name: my-cluster
  context:
    cluster: my-cluster
    user: my-user
current-context: my-cluster
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要执行的命令。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-client-go-exec-plugin&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行此插件时要设置的环境变量。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">env</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;FOO&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;bar&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 执行插件时要传递的参数。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#b44">&#34;arg2&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">installHint</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        MacOS: brew install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        Fedora: dnf install example-client-go-exec-plugin
</span><span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">        ...</span><span style="color:#bbb">        
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 提供集群信息（可能包含非常大的 CA 数据）</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">provideClusterInfo</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。可选字段。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 默认值为 &#34;IfAvailable&#34;。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">interactiveMode</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;/etc/kubernetes/ca.pem&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">extensions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>client.authentication.k8s.io/exec<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 为每个集群 exec 配置保留的扩展名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">extension</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">arbitrary</span>:<span style="color:#bbb"> </span>config<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">this</span>:<span style="color:#bbb"> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">you</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;can&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;put&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;anything&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;here&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>my-cluster<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Relative command paths are interpreted as relative to the directory of the config file. If
KUBECONFIG is set to `/home/jane/kubeconfig` and the exec command is `./bin/example-client-go-exec-plugin`,
the binary `/home/jane/bin/example-client-go-exec-plugin` is executed.
-->
<p>解析相对命令路径时，kubectl 将其视为与配置文件比较而言的相对路径。
如果 KUBECONFIG 被设置为 <code>/home/jane/kubeconfig</code>，而 exec 命令为
<code>./bin/example-client-go-exec-plugin</code>，则要执行的可执行文件为
<code>/home/jane/bin/example-client-go-exec-plugin</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-user<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 对 kubeconfig 目录而言的相对路径</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;./bin/example-client-go-exec-plugin&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">interactiveMode</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span></code></pre></div><!--
### Input and output formats

The executed command prints an `ExecCredential` object to `stdout`. `k8s.io/client-go`
authenticates against the Kubernetes API using the returned credentials in the `status`.
The executed command is passed an `ExecCredential` object as input via the `KUBERNETES_EXEC_INFO`
environment variable. This input contains helpful information like the expected API version
of the returned `ExecCredential` object and whether or not the plugin can use `stdin` to interact
with the user.
-->
<h3 id="input-and-output-formats">输出和输出格式  </h3>
<p>所执行的命令会在 <code>stdout</code> 打印 <code>ExecCredential</code> 对象。
<code>k8s.io/client-go</code> 使用 <code>status</code> 中返回的凭据信息向 Kubernetes API 服务器执行身份认证。
所执行的命令会通过环境变量 <code>KUBERNETES_EXEC_INFO</code> 收到一个 <code>ExecCredential</code> 对象作为其输入。
此输入中包含类似于所返回的 <code>ExecCredential</code> 对象的预期 API 版本，
以及是否插件可以使用 <code>stdin</code> 与用户交互这类信息。</p>
<!--
When run from an interactive session (i.e., a terminal), `stdin` can be exposed directly
to the plugin. Plugins should use the `spec.interactive` field of the input
`ExecCredential` object from the `KUBERNETES_EXEC_INFO` environment variable in order to
determine if `stdin` has been provided. A plugin's `stdin` requirements (i.e., whether
`stdin` is optional, strictly required, or never used in order for the plugin
to run successfully) is declared via the `user.exec.interactiveMode` field in the
[kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/) (see table
below for valid values). The `user.exec.interactiveMode` field is optional in `client.authentication.k8s.io/v1beta1`
and required in `client.authentication.k8s.io/v1`.
-->
<p>在交互式会话（即，某终端）中运行时，<code>stdin</code> 是直接暴露给插件使用的。
插件应该使用来自 <code>KUBERNETES_EXEC_INFO</code> 环境变量的 <code>ExecCredential</code>
输入对象中的 <code>spec.interactive</code> 字段来确定是否提供了 <code>stdin</code>。
插件的 <code>stdin</code> 需求（即，为了能够让插件成功运行，是否 <code>stdin</code> 是可选的、
必须提供的或者从不会被使用的）是通过
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
中的 <code>user.exec.interactiveMode</code> 来声明的（参见下面的表格了解合法值）。
字段 <code>user.exec.interactiveMode</code> 在 <code>client.authentication.k8s.io/v1beta1</code>
中是可选的，在 <code>client.authentication.k8s.io/v1</code> 中是必需的。</p>
<!--
| `interactiveMode` Value | Meaning |
| ----------------------- | ------- |
| `Never` | This exec plugin never needs to use standard input, and therefore the exec plugin will be run regardless of whether standard input is available for user input. |
| `IfAvailable` | This exec plugin would like to use standard input if it is available, but can still operate if standard input is not available. Therefore, the exec plugin will be run regardless of whether stdin is available for user input. If standard input is available for user input, then it will be provided to this exec plugin. |
| `Always` | This exec plugin requires standard input in order to run, and therefore the exec plugin will only be run if standard input is available for user input. If standard input is not available for user input, then the exec plugin will not be run and an error will be returned by the exec plugin runner. |
-->





<table><caption style="display: none;">interactiveMode 取值</caption>
<thead>
<tr>
<th><code>interactiveMode</code> 取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Never</code></td>
<td>此 exec 插件从不需要使用标准输入，因此如论是否有标准输入提供给用户输入，该 exec 插件都能运行。</td>
</tr>
<tr>
<td><code>IfAvailable</code></td>
<td>此 exec 插件希望在标准输入可用的情况下使用标准输入，但在标准输入不存在时也可运行。因此，无论是否存在给用户提供输入的标准输入，此 exec 插件都会运行。如果存在供用户输入的标准输入，则该标准输入会被提供给 exec 插件。</td>
</tr>
<tr>
<td><code>Always</code></td>
<td>此 exec 插件需要标准输入才能正常运行，因此只有存在供用户输入的标准输入时，此 exec 插件才会运行。如果不存在供用户输入的标准输入，则 exec 插件无法运行，并且 exec 插件的执行者会因此返回错误信息。</td>
</tr>
</tbody>
</table>

<!--
To use bearer token credentials, the plugin returns a token in the status of the
[`ExecCredential`](/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-ExecCredential)
-->
<p>与使用持有者令牌凭据，插件在 <a href="/zh/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-ExecCredential"><code>ExecCredential</code></a>
的状态中返回一个令牌：</p>
<ul class="nav nav-tabs" id="exec-plugin-execcredential-example-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#exec-plugin-execcredential-example-1-0" role="tab" aria-controls="exec-plugin-execcredential-example-1-0" aria-selected="true">client.authentication.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#exec-plugin-execcredential-example-1-1" role="tab" aria-controls="exec-plugin-execcredential-example-1-1">client.authentication.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="exec-plugin-execcredential-example-1"><div id="exec-plugin-execcredential-example-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div></div>
  <div id="exec-plugin-execcredential-example-1-1" class="tab-pane" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div></div></div>

<!--
Alternatively, a PEM-encoded client certificate and key can be returned to use TLS client auth.
If the plugin returns a different certificate and key on a subsequent call, `k8s.io/client-go`
will close existing connections with the server to force a new TLS handshake.

If specified, `clientKeyData` and `clientCertificateData` must both must be present.

`clientCertificateData` may contain additional intermediate certificates to send to the server.
-->
<p>另一种方案是，返回 PEM 编码的客户端证书和密钥，以便执行 TLS 客户端身份认证。
如果插件在后续调用中返回了不同的证书或密钥，<code>k8s.io/client-go</code>
会终止其与服务器的连接，从而强制执行新的 TLS 握手过程。</p>
<p>如果指定了这种方式，则 <code>clientKeyData</code> 和 <code>clientCertificateData</code> 字段都必需存在。</p>
<p><code>clientCertificateData</code> 字段可能包含一些要发送给服务器的中间证书（Intermediate
Certificates）。</p>
<ul class="nav nav-tabs" id="exec-plugin-execcredential-example-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#exec-plugin-execcredential-example-2-0" role="tab" aria-controls="exec-plugin-execcredential-example-2-0" aria-selected="true">client.authentication.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#exec-plugin-execcredential-example-2-1" role="tab" aria-controls="exec-plugin-execcredential-example-2-1">client.authentication.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="exec-plugin-execcredential-example-2"><div id="exec-plugin-execcredential-example-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;clientCertificateData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;clientKeyData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div></div>
  <div id="exec-plugin-execcredential-example-2-1" class="tab-pane" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;clientCertificateData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;clientKeyData&#34;</span>: <span style="color:#b44">&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div></div></div>

<!--
Optionally, the response can include the expiry of the credential formatted as a
[RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) timestamp.
Presence or absence of an expiry has the following impact:

- If an expiry is included, the bearer token and TLS credentials are cached until
  the expiry time is reached, or if the server responds with a 401 HTTP status code,
  or when the process exits.
- If an expiry is omitted, the bearer token and TLS credentials are cached until
  the server responds with a 401 HTTP status code or until the process exits.
-->
<p>作为一种可选方案，响应中还可以包含以
<a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</a>
时间戳格式给出的证书到期时间。
证书到期时间的有无会有如下影响：</p>
<ul>
<li>如果响应中包含了到期时间，持有者令牌和 TLS 凭据会被缓存，直到到期期限到来、
或者服务器返回 401 HTTP 状态码，或者进程退出。</li>
<li>如果未指定到期时间，则持有者令牌和 TLS 凭据会被缓存，直到服务器返回 401
HTTP 状态码或者进程退出。</li>
</ul>
<ul class="nav nav-tabs" id="exec-plugin-execcredential-example-3" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#exec-plugin-execcredential-example-3-0" role="tab" aria-controls="exec-plugin-execcredential-example-3-0" aria-selected="true">client.authentication.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#exec-plugin-execcredential-example-3-1" role="tab" aria-controls="exec-plugin-execcredential-example-3-1">client.authentication.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="exec-plugin-execcredential-example-3"><div id="exec-plugin-execcredential-example-3-0" class="tab-pane show active" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-3-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;expirationTimestamp&#34;</span>: <span style="color:#b44">&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div></div>
  <div id="exec-plugin-execcredential-example-3-1" class="tab-pane" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-3-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;token&#34;</span>: <span style="color:#b44">&#34;my-bearer-token&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;expirationTimestamp&#34;</span>: <span style="color:#b44">&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div></div></div>

<!--
To enable the exec plugin to obtain cluster-specific information, set `provideClusterInfo` on the `user.exec`
field in the [kubeconfig](/docs/concepts/configuration/organize-cluster-access-kubeconfig/).
The plugin will then be supplied this cluster-specific information in the `KUBERNETES_EXEC_INFO` environment variable.
Information from this environment variable can be used to perform cluster-specific
credential acquisition logic.
The following `ExecCredential` manifest describes a cluster information sample.
-->
<p>为了让 exec 插件能够获得特定与集群的信息，可以在
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a>
中的 <code>user.exec</code> 设置 <code>provideClusterInfo</code>。
这一特定于集群的信息就会通过 <code>KUBERNETES_EXEC_INFO</code> 环境变量传递给插件。
此环境变量中的信息可以用来执行特定于集群的凭据获取逻辑。
下面的 <code>ExecCredential</code> 清单描述的是一个示例集群信息。</p>
<ul class="nav nav-tabs" id="exec-plugin-execcredential-example-4" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#exec-plugin-execcredential-example-4-0" role="tab" aria-controls="exec-plugin-execcredential-example-4-0" aria-selected="true">client.authentication.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#exec-plugin-execcredential-example-4-1" role="tab" aria-controls="exec-plugin-execcredential-example-4-1">client.authentication.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="exec-plugin-execcredential-example-4"><div id="exec-plugin-execcredential-example-4-0" class="tab-pane show active" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-4-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;cluster&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;server&#34;</span>: <span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;certificate-authority-data&#34;</span>: <span style="color:#b44">&#34;LS0t...&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;config&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;arbitrary&#34;</span>: <span style="color:#b44">&#34;config&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;this&#34;</span>: <span style="color:#b44">&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;you&#34;</span>: [<span style="color:#b44">&#34;can&#34;</span>, <span style="color:#b44">&#34;put&#34;</span>, <span style="color:#b44">&#34;anything&#34;</span>, <span style="color:#b44">&#34;here&#34;</span>]
      }
    },
    <span style="color:#008000;font-weight:bold">&#34;interactive&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div>
  <div id="exec-plugin-execcredential-example-4-1" class="tab-pane" role="tabpanel" aria-labelledby="exec-plugin-execcredential-example-4-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ExecCredential&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;cluster&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;server&#34;</span>: <span style="color:#b44">&#34;https://172.17.4.100:6443&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;certificate-authority-data&#34;</span>: <span style="color:#b44">&#34;LS0t...&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;config&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;arbitrary&#34;</span>: <span style="color:#b44">&#34;config&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;this&#34;</span>: <span style="color:#b44">&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;you&#34;</span>: [<span style="color:#b44">&#34;can&#34;</span>, <span style="color:#b44">&#34;put&#34;</span>, <span style="color:#b44">&#34;anything&#34;</span>, <span style="color:#b44">&#34;here&#34;</span>]
      }
    },
    <span style="color:#008000;font-weight:bold">&#34;interactive&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div></div>

<h2 id="what-s-next">What's next</h2>
<!--
* Read the [client authentication reference (v1beta1)](/docs/reference/config-api/client-authentication.v1beta1/)
* Read the [client authentication reference (v1)](/docs/reference/config-api/client-authentication.v1/)
-->
<ul>
<li>阅读<a href="/zh/docs/reference/config-api/client-authentication.v1beta1/">客户端认证参考文档 (v1beta1)</a></li>
<li>阅读<a href="/zh/docs/reference/config-api/client-authentication.v1/">客户端认证参考文档 (v1)</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-de45b6ca7419a0e308044425b2ac52bb">2 - 使用启动引导令牌（Bootstrap Tokens）认证</h1>
    
	<!--
reviewers:
- jbeda
title: Authenticating with Bootstrap Tokens
content_type: concept
weight: 20
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>


<!--
Bootstrap tokens are a simple bearer token that is meant to be used when
creating new clusters or joining new nodes to an existing cluster.  It was built
to support [kubeadm](/docs/reference/setup-tools/kubeadm/), but can be used in other contexts
for users that wish to start clusters without `kubeadm`. It is also built to
work, via RBAC policy, with the
[Kubelet TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) system.
-->
<p>启动引导令牌是一种简单的持有者令牌（Bearer Token），这种令牌是在新建集群
或者在现有集群中添加新节点时使用的。
它被设计成能够支持 <a href="/zh/docs/reference/setup-tools/kubeadm/"><code>kubeadm</code></a>，
但是也可以被用在其他的案例中以便用户在不使用 <code>kubeadm</code> 的情况下启动集群。
它也被设计成可以通过 RBAC 策略，结合
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">Kubelet TLS 启动引导</a>
系统进行工作。</p>
<!-- body -->
<!--
## Bootstrap Tokens Overview

Bootstrap Tokens are defined with a specific type
(`bootstrap.kubernetes.io/token`) of secrets that lives in the `kube-system`
namespace.  These Secrets are then read by the Bootstrap Authenticator in the
API Server.  Expired tokens are removed with the TokenCleaner controller in the
Controller Manager.  The tokens are also used to create a signature for a
specific ConfigMap used in a "discovery" process through a BootstrapSigner
controller.
-->
<p>启动引导令牌被定义成一个特定类型的 Secret（<code>bootstrap.kubernetes.io/token</code>），
并存在于 <code>kube-system</code> 名字空间中。
这些 Secret 会被 API 服务器上的启动引导认证组件（Bootstrap Authenticator）读取。
控制器管理器中的控制器 TokenCleaner 能够删除过期的令牌。
这些令牌也被用来在节点发现的过程中会使用的一个特殊的 ConfigMap 对象。
BootstrapSigner 控制器也会使用这一 ConfigMap。</p>
<!--
## Token Format

Bootstrap Tokens take the form of `abcdef.0123456789abcdef`.  More formally,
they must match the regular expression `[a-z0-9]{6}\.[a-z0-9]{16}`.

The first part of the token is the "Token ID" and is considered public
information.  It is used when referring to a token without leaking the secret
part used for authentication. The second part is the "Token Secret" and should
only be shared with trusted parties.
-->
<h2 id="令牌格式">令牌格式</h2>
<p>启动引导令牌使用 <code>abcdef.0123456789abcdef</code> 的形式。
更加规范地说，它们必须符合正则表达式 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>令牌的第一部分是 “Token ID”，它是一种公开信息，用于引用令牌并确保不会
泄露认证所使用的秘密信息。
第二部分是“令牌秘密（Token Secret）”，它应该被共享给受信的第三方。</p>
<h2 id="启用启动引导令牌">启用启动引导令牌</h2>
<!--
## Enabling Bootstrap Token Authentication

The Bootstrap Token authenticator can be enabled using the following flag on the
API server:
-->
<h2 id="enabling-bootstrap-token-authentication">启用启动引导令牌身份认证  </h2>
<p>启动引导令牌认证组件可以通过 API 服务器上的如下标志启用：</p>
<pre><code>--enable-bootstrap-token-auth
</code></pre><!--
When enabled, bootstrapping tokens can be used as bearer token credentials to
authenticate requests against the API server.
-->
<p>启动引导令牌被启用后，可以作为持有者令牌的凭据，用于 API 服务器请求的身份认证。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">Authorization: Bearer 07401b.f395accd246ae52d
</span></code></pre></div><!--
Tokens authenticate as the username `system:bootstrap:<token id>` and are members
of the group `system:bootstrappers`.  Additional groups may be specified in the
token's Secret.

Expired tokens can be deleted automatically by enabling the `tokencleaner`
controller on the controller manager.
-->
<p>令牌认证为用户名 <code>system:bootstrap:&lt;token id&gt;</code> 并且是组 <code>system:bootstrappers</code>
的成员。额外的组信息可以通过令牌的 Secret 来设置。</p>
<p>过期的令牌可以通过启用控制器管理器中的 <code>tokencleaner</code> 控制器来删除。</p>
<!--
## Bootstrap Token Secret Format

Each valid token is backed by a secret in the `kube-system` namespace.  You can
find the full design doc
[here](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md).

Here is what the secret looks like.
-->
<h2 id="bootstrap-token-secret-format">启动引导令牌的 Secret 格式 </h2>
<p>每个合法的令牌背后对应着 <code>kube-system</code> 名字空间中的某个 Secret 对象。
你可以从
<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">这里</a>
找到完整设计文档。</p>
<p>这是 Secret 看起来的样子。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># name 必须是 &#34;bootstrap-token-&lt;token id&gt;&#34; 格式的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>bootstrap-token-07401b<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># type 必须是 &#39;bootstrap.kubernetes.io/token&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>bootstrap.kubernetes.io/token<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">stringData</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 供人阅读的描述，可选。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">description</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 令牌 ID 和秘密信息，必需。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token-id</span>:<span style="color:#bbb"> </span>07401b<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">token-secret</span>:<span style="color:#bbb"> </span>base64(f395accd246ae52d)<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 可选的过期时间字段</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">expiration</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2017-03-10T03:22:11Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 允许的用法</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">usage-bootstrap-authentication</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">usage-bootstrap-signing</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 令牌要认证为的额外组，必须以 &#34;system:bootstrappers:&#34; 开头</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">auth-extra-groups</span>:<span style="color:#bbb"> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style="color:#bbb">
</span></code></pre></div><!--
The type of the secret must be `bootstrap.kubernetes.io/token` and the name must
be `bootstrap-token-<token id>`.  It must also exist in the `kube-system`
namespace.

The `usage-bootstrap-*` members indicate what this secret is intended to be used
for.  A value must be set to `true` to be enabled.
-->
<p>Secret 的类型必须是 <code>bootstrap.kubernetes.io/token</code>，而且名字必须是 <code>bootstrap-token-&lt;token id&gt;</code>。
令牌必须存在于 <code>kube-system</code> 名字空间中。</p>
<p><code>usage-bootstrap-*</code> 成员表明这个 Secret 的用途。启用时，值必须设置为 <code>true</code>。</p>
<!--
* `usage-bootstrap-authentication` indicates that the token can be used to
authenticate to the API server as a bearer token.
* `usage-bootstrap-signing` indicates that the token may be used to sign the
`cluster-info` ConfigMap as described below.
-->
<ul>
<li><code>usage-bootstrap-authentication</code> 表示令牌可以作为持有者令牌用于 API 服务器的身份认证。</li>
<li><code>usage-bootstrap-signing</code> 表示令牌可被用于 <code>cluster-info</code> ConfigMap 的签名，
就像下面描述的那样。</li>
</ul>
<!--
The `expiration` field controls the expiry of the token.  Expired tokens are
rejected when used for authentication and ignored during ConfigMap signing.
The expiry value is encoded as an absolute UTC time using RFC3339.  Enable the
`tokencleaner` controller to automatically delete expired tokens.
-->
<p><code>expiration</code> 字段控制令牌的失效期。过期的令牌在用于身份认证时会被拒绝，在用于
ConfigMap 签名时会被忽略。
过期时间值是遵循 RFC3339 进行编码的 UTC 时间。
启用 TokenCleaner 控制器会自动删除过期的令牌。</p>
<!--
## Token Management with kubeadm

You can use the `kubeadm` tool to manage tokens on a running cluster. See the
[kubeadm token docs](/docs/reference/setup-tools/kubeadm/kubeadm-token/) for details.
-->
<h2 id="token-management-with-kubeadm">使用 <code>kubeadm</code> 管理令牌  </h2>
<p>你可以使用 <code>kubeadm</code> 工具管理运行中集群上的令牌。
参见 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token 文档</a>
以了解详细信息。</p>
<!--
## ConfigMap Signing

In addition to authentication, the tokens can be used to sign a ConfigMap.  This
is used early in a cluster bootstrap process before the client trusts the API
server.  The signed ConfigMap can be authenticated by the shared token.

Enable ConfigMap signing by enabling the `bootstrapsigner` controller on the
Controller Manager.
-->
<h3 id="configmap-signing">ConfigMap 签名 </h3>
<p>除了身份认证，令牌还可以用于签名 ConfigMap。
这一用法发生在集群启动过程的早期，在客户端信任 API 服务器之前。
被签名的 ConfigMap 可以被共享令牌完成身份认证。</p>
<p>通过在控制器管理器上启用 <code>bootstrapsigner</code> 控制器可以启用 ConfigMap 签名特性。</p>
<pre><code>--controllers=*,bootstrapsigner
</code></pre><!--
The ConfigMap that is signed is `cluster-info` in the `kube-public` namespace.
The typical flow is that a client reads this ConfigMap while unauthenticated and
ignoring TLS errors.  It then validates the payload of the ConfigMap by looking
at a signature embedded in the ConfigMap.

The ConfigMap may look like this:
-->
<p>被签名的 ConfigMap 是 <code>kube-public</code> 名字空间中的 <code>cluster-info</code>。
典型的工作流中，客户端在未经认证和忽略 TLS 报错的状态下读取这个 ConfigMap。
通过检查 ConfigMap 中嵌入的签名校验 ConfigMap 的载荷。</p>
<p>ConfigMap 会是这个样子的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cluster-info<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-public<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">jws-kubeconfig-07401b</span>:<span style="color:#bbb"> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubeconfig</span>:<span style="color:#bbb"> </span>|<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">    apiVersion: v1
</span><span style="color:#b44;font-style:italic">    clusters:
</span><span style="color:#b44;font-style:italic">    - cluster:
</span><span style="color:#b44;font-style:italic">        certificate-authority-data: &lt;非常长的证书数据&gt;
</span><span style="color:#b44;font-style:italic">        server: https://10.138.0.2:6443
</span><span style="color:#b44;font-style:italic">      name: &#34;&#34;
</span><span style="color:#b44;font-style:italic">    contexts: []
</span><span style="color:#b44;font-style:italic">    current-context: &#34;&#34;
</span><span style="color:#b44;font-style:italic">    kind: Config
</span><span style="color:#b44;font-style:italic">    preferences: {}
</span><span style="color:#b44;font-style:italic">    users: []</span><span style="color:#bbb">    
</span></code></pre></div><!--
The `kubeconfig` member of the ConfigMap is a config file with just the cluster
information filled out.  The key thing being communicated here is the
`certificate-authority-data`.  This may be expanded in the future.
-->
<p>ConfigMap 的 <code>kubeconfig</code> 成员是一个填好了集群信息的配置文件。
这里主要交换的信息是 <code>certificate-authority-data</code>。在将来可能会有扩展。</p>
<!--
The signature is a JWS signature using the "detached" mode.  To validate the
signature, the user should encode the `kubeconfig` payload according to JWS
rules (base64 encoded while discarding any trailing `=`).  That encoded payload
is then used to form a whole JWS by inserting it between the 2 dots.  You can
verify the JWS using the `HS256` scheme (HMAC-SHA256) with the full token (e.g.
`07401b.f395accd246ae52d`) as the shared secret.  Users _must_ verify that HS256
is used.
-->
<p>签名是一个使用 “detached” 模式生成的 JWS 签名。
为了检验签名，用户应该按照 JWS 规则（base64 编码且丢掉结尾的 <code>=</code>）对
<code>kubeconfig</code> 的载荷进行编码。完成编码的载荷会被插入到两个句点中间，形成完整的
JWS。你可以使用完整的令牌（比如 <code>07401b.f395accd246ae52d</code>）作为共享密钥，
通过 <code>HS256</code> 方式 (HMAC-SHA256) 对 JWS 进行校验。
用户 <em>必须</em> 确保使用了 HS256。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <!--
Any party with a bootstrapping token can create a valid signature for that
token. When using ConfigMap signing it's discouraged to share the same token with
many clients, since a compromised client can potentially man-in-the middle another
client relying on the signature to bootstrap TLS trust.
-->
<p>任何拥有了启动引导令牌的主体都可以为该令牌生成一个合法的签名。
当使用 ConfigMap 签名时，非常不建议针对很多客户使用相同的令牌，因为某个被攻击的
客户可能对另一个一来签名来开启 TLS 信任的客户发起中间人攻击。
</div>


<!--
Consult the [kubeadm implementation details](/docs/reference/setup-tools/kubeadm/implementation-details/)
section for more information.
-->
<p>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/implementation-details/">kubeadm 实现细节</a>
了解更多信息。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3d0c14d1e3cfade38febc343cd044c73">3 - 证书签名请求</h1>
    
	<!--
reviewers:
- liggitt
- mikedanese
- munnerz
- enj
title: Certificate Signing Requests
content_type: concept
weight: 20
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>


<!--
The Certificates API enables automation of
[X.509](https://www.itu.int/rec/T-REC-X.509) credential provisioning by providing
a programmatic interface for clients of the Kubernetes API to request and obtain
X.509 <a class='glossary-tooltip' title='证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/tls/managing-tls-in-a-cluster/' target='_blank' aria-label='certificates'>certificates</a>
from a Certificate Authority (CA).

A CertificateSigningRequest (CSR) resource is used to request that a certificate be signed
by a denoted signer, after which the request may be approved or denied before
finally being signed.
-->
<p>证书 API 支持
<a href="https://www.itu.int/rec/T-REC-X.509">X.509</a>
的自动化配置，
它为 Kubernetes API 的客户端提供一个编程接口，
用于从证书颁发机构（CA）请求并获取 X.509
<a class='glossary-tooltip' title='证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/tls/managing-tls-in-a-cluster/' target='_blank' aria-label='证书'>证书</a>。</p>
<p>CertificateSigningRequest（CSR）资源用来向指定的签名者申请证书签名，
在最终签名之前，申请可能被批准，也可能被拒绝。</p>
<!-- body -->
<!--
## Request signing process

The CertificateSigningRequest resource type allows a client to ask for an X.509 certificate
be issued, based on a signing request.

The CertificateSigningRequest object includes a PEM-encoded PKCS#10 signing request in
the `spec.request` field. The CertificateSigningRequest denotes the _signer_ (the
recipient that the request is being made to) using the `spec.signerName` field.
Note that `spec.signerName` is a required key after api version `certificates.k8s.io/v1`.
In Kubernetes v1.22 and later, clients may optionally set the `spec.expirationSeconds`
field to request a particular lifetime for the issued certificate.  The minimum valid
value for this field is `600`, i.e. ten minutes.
-->
<h2 id="request-signing-process">请求签名流程</h2>
<p>CertificateSigningRequest 资源类型允许客户使用它申请发放 X.509 证书。
CertificateSigningRequest 对象 在 <code>spec.request</code> 中包含一个 PEM 编码的 PKCS#10 签名请求。
CertificateSigningRequest 使用 <code>spec.signerName</code> 字段标示 <em>签名者</em>（请求的接收方）。
注意，<code>spec.signerName</code> 在 <code>certificates.k8s.io/v1</code> 之后的 API 版本是必填项。
在 Kubernetes v1.22 和以后的版本，客户可以可选地设置 <code>spec.expirationSeconds</code>
字段来为颁发的证书设定一个特定的有效期。该字段的最小有效值是 <code>600</code>，也就是 10 分钟。</p>
<!--
Once created, a CertificateSigningRequest must be approved before it can be signed.
Depending on the signer selected, a CertificateSigningRequest may be automatically approved
by a <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a>.
Otherwise, a CertificateSigningRequest must be manually approved
either via the REST API (or client-go)
or by running `kubectl certificate approve`.
Likewise, a CertificateSigningRequest may also be denied,
which tells the configured signer that it must not sign the request.
-->
<p>创建完成的 CertificateSigningRequest，要先通过批准，然后才能签名。
根据所选的签名者，CertificateSigningRequest 可能会被
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>自动批准。
否则，就必须人工批准，
人工批准可以使用 REST API（或 go 客户端），也可以执行 <code>kubectl certificate approve</code> 命令。
同样，CertificateSigningRequest 也可能被驳回，
这就相当于通知了指定的签名者，这个证书不能签名。</p>
<!--  
For certificates that have been approved, the next step is signing.
The relevant signing controller
first validates that the signing conditions are met and then creates a certificate.
The signing controller then updates the CertificateSigningRequest,
storing the new certificate into
the `status.certificate` field of the existing CertificateSigningRequest object. The
`status.certificate` field is either empty or contains a X.509 certificate,
encoded in PEM format.
The CertificateSigningRequest `status.certificate` field is empty until the signer does this.
-->
<p>对于已批准的证书，下一步是签名。
对应的签名控制器首先验证签名条件是否满足，然后才创建证书。
签名控制器然后更新 CertificateSigningRequest，
将新证书保存到现有 CertificateSigningRequest 对象的 <code>status.certificate</code> 字段中。
此时，字段 <code>status.certificate</code> 要么为空，要么包含一个用 PEM 编码的 X.509 证书。
直到签名完成前，CertificateSigningRequest 的字段 <code>status.certificate</code> 都为空。</p>
<!--
Once the `status.certificate` field has been populated,
the request has been completed and clients can now
fetch the signed certificate PEM data from the CertificateSigningRequest resource.
The signers can instead deny certificate signing if the approval conditions are not met.
-->
<p>一旦 <code>status.certificate</code> 字段完成填充，请求既算完成，
客户端现在可以从 CertificateSigningRequest 资源中获取已签名的证书的 PEM 数据。
当然如果不满足签名条件，签名者可以拒签。</p>
<!--
In order to reduce the number of old CertificateSigningRequest resources left
in a cluster, a garbage collection
controller runs periodically.
The garbage collection removes CertificateSigningRequests that have not changed
state for some duration:

* Approved requests: automatically deleted after 1 hour
* Denied requests: automatically deleted after 1 hour
* Failed requests: automatically deleted after 1 hour
* Pending requests: automatically deleted after 24 hours
* All requests: automatically deleted after the issued certificate has expired
-->
<p>为了减少集群中遗留的过时的 CertificateSigningRequest 资源的数量，
一个垃圾收集控制器将会周期性地运行。
此垃圾收集器会清除在一段时间内没有改变过状态的 CertificateSigningRequests：</p>
<ul>
<li>已批准的请求：1小时后自动删除</li>
<li>已拒绝的请求：1小时后自动删除</li>
<li>已失败的请求：1小时后自动删除</li>
<li>挂起的请求：24小时后自动删除</li>
<li>所有请求：在颁发的证书过期后自动删除</li>
</ul>
<!--
## Signers

Custom signerNames can also be specified. All signers should provide information about how they work
so that clients can predict what will happen to their CSRs.
This includes:
-->
<h2 id="signers">签名者</h2>
<p>也可以指定自定义 signerName。
所有签名者都应该提供自己工作方式的信息，
以便客户端可以预期到他们的 CSR 将发生什么。
此类信息包括：</p>
<!--
1. **Trust distribution**: how trust (CA bundles) are distributed.
2.  **Permitted subjects**: any restrictions on and behavior
   when a disallowed subject is requested.
3. **Permitted x509 extensions**: including IP subjectAltNames, DNS subjectAltNames,
   Email subjectAltNames, URI subjectAltNames etc,
   and behavior when a disallowed extension is requested.
4. **Permitted key usages / extended key usages**: any restrictions on and behavior
   when usages different than the signer-determined usages are specified in the CSR.
5. **Expiration/certificate lifetime**: whether it is fixed by the signer, configurable by the admin, determined by the CSR `spec.expirationSeconds` field, etc
   and the behavior when the signer-determined expiration is different from the CSR `spec.expirationSeconds` field.
6. **CA bit allowed/disallowed**: and behavior if a CSR contains a request
   a for a CA certificate when the signer does not permit it.
-->
<ol>
<li><strong>信任分发</strong>：信任（CA 证书包）是如何分发的。</li>
<li><strong>许可的主体</strong>：当一个受限制的主体（subject）发送请求时，相应的限制和应对手段。</li>
<li><strong>许可的 x509 扩展</strong>：包括 IP subjectAltNames、DNS subjectAltNames、
Email subjectAltNames、URI subjectAltNames 等，请求一个受限制的扩展项时的应对手段。</li>
<li><strong>许可的密钥用途/扩展的密钥用途</strong>：当用途和签名者在 CSR 中指定的用途不同时，
相应的限制和应对手段。</li>
<li><strong>过期时间/证书有效期</strong>：过期时间由签名者确定、由管理员配置、还是由 CSR <code>spec.expirationSeconds</code> 字段指定等，
以及签名者决定的过期时间与 CSR <code>spec.expirationSeconds</code> 字段不同时的应对手段。</li>
<li><strong>允许/不允许 CA 位</strong>：当 CSR 包含一个签名者并不允许的 CA 证书的请求时，相应的应对手段。</li>
</ol>
<!--
Commonly, the `status.certificate` field contains a single PEM-encoded X.509
certificate once the CSR is approved and the certificate is issued. Some
signers store multiple certificates into the `status.certificate` field. In
that case, the documentation for the signer should specify the meaning of
additional certificates; for example, this might be the certificate plus
intermediates to be presented during TLS handshakes.
-->
<p>一般来说，当 CSR 被批准通过，且证书被签名后，<code>status.certificate</code> 字段
将包含一个 PEM 编码的 X.509 证书。
有些签名者在 <code>status.certificate</code> 字段中存储多个证书。
在这种情况下，签名者的说明文档应当指明附加证书的含义。
例如，这是要在 TLS 握手时提供的证书和中继证书。</p>
<!--
The PKCS#10 signing request format does not have a standard mechanism to specify a
certificate expiration or lifetime. The expiration or lifetime therefore has to be set
through the `spec.expirationSeconds` field of the CSR object. The built-in signers
use the `ClusterSigningDuration` configuration option, which defaults to 1 year,
(the `--cluster-signing-duration` command-line flag of the kube-controller-manager)
as the default when no `spec.expirationSeconds` is specified.  When `spec.expirationSeconds`
is specified, the minimum of `spec.expirationSeconds` and `ClusterSigningDuration` is
used.
-->
<p>PKCS#10 签名请求格式并没有一种标准的方法去设置证书的过期时间或者生命期。
因此，证书的过期时间或者生命期必须通过 CSR 对象的 <code>spec.expirationSeconds</code> 字段来设置。
当 <code>spec.expirationSeconds</code> 没有被指定时，内置的签名者默认使用 <code>ClusterSigningDuration</code> 配置选项
（kube-controller-manager 的命令行选项 <code>--cluster-signing-duration</code>），该选项的默认值设为 1 年。
当 <code>spec.expirationSeconds</code> 被指定时，<code>spec.expirationSeconds</code> 和 <code>ClusterSigningDuration</code>
中的最小值会被使用。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The `spec.expirationSeconds` field was added in Kubernetes v1.22.  Earlier versions of Kubernetes do not honor this field.
Kubernetes API servers prior to v1.22 will silently drop this field when the object is created.
-->
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<!--
### Kubernetes signers

Kubernetes provides built-in signers that each have a well-known `signerName`:
-->
<h3 id="kubernetes-signers">Kubernetes 签名者</h3>
<p>Kubernetes提供了内置的签名者，每个签名者都有一个众所周知的 <code>signerName</code>:</p>
<!--
1. `kubernetes.io/kube-apiserver-client`: signs certificates that will be honored as client certificates by the API server.
  Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
    1. Trust distribution: signed certificates must be honored as client-certificates by the kube-apiserver. The CA bundle is not distributed by any other means.
    1. Permitted subjects - no subject restrictions, but approvers and signers may choose not to approve or sign.
       Certain subjects like cluster-admin level users or groups vary between distributions and installations,
       but deserve additional scrutiny before approval and signing.
       The `CertificateSubjectRestriction` admission plugin is enabled by default to restrict `system:masters`,
       but it is often not the only cluster-admin subject in a cluster.
    1. Permitted x509 extensions - honors subjectAltName and key usage extensions and discards other extensions.
    1. Permitted key usages - must include `["client auth"]`. Must not include key usages beyond `["digital signature", "key encipherment", "client auth"]`.
    1. Expiration/certificate lifetime - for the kube-controller-manager implementation of this signer, set to the minimum
       of the `--cluster-signing-duration` option or, if specified, the `spec.expirationSeconds` field of the CSR object.
    1. CA bit allowed/disallowed - not allowed.
-->
<ol>
<li><code>kubernetes.io/kube-apiserver-client</code>：签名的证书将被 API 服务器视为客户证书。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：没有主体限制，但审核人和签名者可以选择不批准或不签署。
某些主体，比如集群管理员级别的用户或组因部署和安装方式不同而不同，
所以批准和签署之前需要进行额外仔细审查。
用来限制 <code>system:masters</code> 的 CertificateSubjectRestriction 准入插件默认处于启用状态，
但它通常不是集群中唯一的集群管理员主体。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 扩展，弃用其他扩展。</li>
<li>许可的密钥用途：必须包含 <code>[&quot;client auth&quot;]</code>，但不能包含
<code>[&quot;digital signature&quot;, &quot;key encipherment&quot;, &quot;client auth&quot;]</code> 之外的键。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!--
1. `kubernetes.io/kube-apiserver-client-kubelet`: signs client certificates that will be honored as client certificates by the
   API server.
   May be auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: signed certificates must be honored as client certificates by the API server. The CA bundle
      is not distributed by any other means.
   1. Permitted subjects - organizations are exactly `["system:nodes"]`, common name starts with "`system:node:`".
   1. Permitted x509 extensions - honors key usage extensions, forbids subjectAltName extensions and drops other extensions.
   1. Permitted key usages - exactly `["key encipherment", "digital signature", "client auth"]`.
   1. Expiration/certificate lifetime - for the kube-controller-manager implementation of this signer, set to the minimum
      of the `--cluster-signing-duration` option or, if specified, the `spec.expirationSeconds` field of the CSR object.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="2">
<li>
<p><code>kubernetes.io/kube-apiserver-client-kubelet</code>: 签名的证书将被 kube-apiserver 视为客户证书。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 可以自动批准它。</p>
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>[&quot;system:nodes&quot;]</code>，用户名以 &quot;<code>system:node:</code>&quot; 开头</li>
<li>许可的 x509 扩展：允许 key usage 扩展，禁用 subjectAltName 扩展，并删除其他扩展。</li>
<li>许可的密钥用途：必须是 <code>[&quot;key encipherment&quot;, &quot;digital signature&quot;, &quot;client auth&quot;]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!--
1. `kubernetes.io/kubelet-serving`: signs serving certificates that are honored as a valid kubelet serving certificate
   by the API server, but has no other guarantees.
   Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: signed certificates must be honored by the kube-apiserver as valid to terminate connections to a kubelet. The CA bundle is not distributed by any other means.
   1. Permitted subjects - organizations are exactly `["system:nodes"]`, common name starts with "`system:node:`".
   1. Permitted x509 extensions - honors key usage and DNSName/IPAddress subjectAltName extensions, forbids EmailAddress and
      URI subjectAltName extensions, drops other extensions. At least one DNS or IP subjectAltName must be present.
   1. Permitted key usages - exactly `["key encipherment", "digital signature", "server auth"]`.
   1. Expiration/certificate lifetime - for the kube-controller-manager implementation of this signer, set to the minimum
      of the `--cluster-signing-duration` option or, if specified, the `spec.expirationSeconds` field of the CSR object.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="3">
<li><code>kubernetes.io/kubelet-serving</code>: 签名服务证书，该服务证书被 API 服务器视为有效的 kubelet 服务证书，
但没有其他保证。<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书必须被 kube-apiserver 认可，可有效的中止 kubelet 连接。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>[&quot;system:nodes&quot;]</code>，用户名以 &quot;<code>system:node:</code>&quot; 开头</li>
<li>许可的 x509 扩展：允许 key usage、DNSName/IPAddress subjectAltName 等扩展，
禁止  EmailAddress、URI subjectAltName 等扩展，并丢弃其他扩展。
至少有一个 DNS 或 IP 的 SubjectAltName 存在。</li>
<li>许可的密钥用途：必须是 <code>[&quot;key encipherment&quot;, &quot;digital signature&quot;, &quot;server auth&quot;]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<!--
1. `kubernetes.io/legacy-unknown`:  has no guarantees for trust at all. Some third-party distributions of Kubernetes
   may honor client certificates signed by it. The stable CertificateSigningRequest API (version `certificates.k8s.io/v1` and later)
   does not allow to set the `signerName` as `kubernetes.io/legacy-unknown`.
   Never auto-approved by <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>.
   1. Trust distribution: None.  There is no standard trust or distribution for this signer in a Kubernetes cluster.
   1. Permitted subjects - any
   1. Permitted x509 extensions - honors subjectAltName and key usage extensions and discards other extensions.
   1. Permitted key usages - any
   1. Expiration/certificate lifetime - for the kube-controller-manager implementation of this signer, set to the minimum
      of the `--cluster-signing-duration` option or, if specified, the `spec.expirationSeconds` field of the CSR object.
   1. CA bit allowed/disallowed - not allowed.
-->
<ol start="4">
<li><code>kubernetes.io/legacy-unknown</code>: 不保证信任。Kubernetes 的一些第三方发行版可能会使用它签署的客户端证书。
稳定版的 CertificateSigningRequest API（<code>certificates.k8s.io/v1</code> 以及之后的版本）不允许将
<code>signerName</code> 设置为 <code>kubernetes.io/legacy-unknown</code>。
<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 不会自动批准这类请求。
<ol>
<li>信任分发：没有。这个签名者在 Kubernetes 集群中没有标准的信任或分发。</li>
<li>许可的主体：全部。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 等扩展，并弃用其他扩展。</li>
<li>许可的密钥用途：全部。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位 - 不允许。</li>
</ol>
</li>
</ol>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Failures for all of these are only reported in kube-controller-manager logs.
-->
<p>注意：所有这些故障仅在 kube-controller-manager 日志中报告。
</div>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The `spec.expirationSeconds` field was added in Kubernetes v1.22.  Earlier versions of Kubernetes do not honor this field.
Kubernetes API servers prior to v1.22 will silently drop this field when the object is created.
-->
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<!--
Distribution of trust happens out of band for these signers.  Any trust outside of those described above are strictly
coincidental. For instance, some distributions may honor `kubernetes.io/legacy-unknown` as client certificates for the
kube-apiserver, but this is not a standard.
None of these usages are related to ServiceAccount token secrets `.data[ca.crt]` in any way.  That CA bundle is only
guaranteed to verify a connection to the API server using the default service (`kubernetes.default.svc`).
-->
<p>对于这些签名者，信任的分发发生在带外（out of band）。上述信任之外的任何信任都是完全巧合的。
例如，一些发行版可能会将 <code>kubernetes.io/legacy-unknown</code> 作为 kube-apiserver 的客户端证书，
但这个做法并不标准。
这些用途都没有以任何方式涉及到 ServiceAccount 中的 Secrets <code>.data[ca.crt]</code>。
此 CA 证书包只保证使用默认的服务（<code>kubernetes.default.svc</code>）来验证到 API 服务器的连接。</p>
<!--
## Authorization

To allow creating a CertificateSigningRequest and retrieving any CertificateSigningRequest:

* Verbs: `create`, `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`

For example:
-->
<h2 id="authorization">鉴权</h2>
<p>授权创建 CertificateSigningRequest 和检索 CertificateSigningRequest:</p>
<ul>
<li>verbs（动词）: <code>create</code>、<code>get</code>、<code>list</code>、<code>watch</code>,
group（组）：<code>certificates.k8s.io</code>，
resources：<code>certificatesigningrequests</code></li>
</ul>
<p>例如：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-create.yaml" download="access/certificate-signing-request/clusterrole-create.yaml"><code>access/certificate-signing-request/clusterrole-create.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-create-yaml')" title="Copy access/certificate-signing-request/clusterrole-create.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-create-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-creator<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- create<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
To allow approving a CertificateSigningRequest:

* Verbs: `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`
* Verbs: `update`, group: `certificates.k8s.io`, resource: `certificatesigningrequests/approval`
* Verbs: `approve`, group: `certificates.k8s.io`, resource: `signers`, resourceName: `<signerNameDomain>/<signerNamePath>` or `<signerNameDomain>/*`

For example:
-->
<p>授权批准 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）: <code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）: <code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/approval</code></li>
<li>verbs（动词）：<code>approve</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain&gt;/&lt;signerNamePath&gt;</code> 或 <code>&lt;signerNameDomain&gt;/*</code></li>
</ul>
<p>例如：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-approve.yaml" download="access/certificate-signing-request/clusterrole-approve.yaml"><code>access/certificate-signing-request/clusterrole-approve.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-approve-yaml')" title="Copy access/certificate-signing-request/clusterrole-approve.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-approve-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-approver<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests/approval<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- update<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- signers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- example.com/my-signer-name<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- approve<span style="color:#bbb">
</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
To allow signing a CertificateSigningRequest:

* Verbs: `get`, `list`, `watch`, group: `certificates.k8s.io`, resource: `certificatesigningrequests`
* Verbs: `update`, group: `certificates.k8s.io`, resource: `certificatesigningrequests/status`
* Verbs: `sign`, group: `certificates.k8s.io`, resource: `signers`, resourceName: `<signerNameDomain>/<signerNamePath>` or `<signerNameDomain>/*`
-->
<p>授权签名 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）：<code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）：<code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/status</code></li>
<li>verbs（动词）：<code>sign</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain&gt;/&lt;signerNamePath&gt;</code> 或 <code>&lt;signerNameDomain&gt;/*</code></li>
</ul>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-sign.yaml" download="access/certificate-signing-request/clusterrole-sign.yaml"><code>access/certificate-signing-request/clusterrole-sign.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-certificate-signing-request-clusterrole-sign-yaml')" title="Copy access/certificate-signing-request/clusterrole-sign.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-certificate-signing-request-clusterrole-sign-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>csr-signer<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- get<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- list<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- watch<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificatesigningrequests/status<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- update<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- certificates.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- signers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- example.com/my-signer-name<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- sign<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
## Normal User

A few steps are required in order to get a normal user to be able to
authenticate and invoke an API. First, this user must have a certificate issued
by the Kubernetes cluster, and then present that certificate to the Kubernetes API.
-->
<h2 id="normal-user">普通用户</h2>
<p>为了让普通用户能够通过认证并调用 API，需要执行几个步骤。
首先，该用户必须拥有 Kubernetes 集群签发的证书，
然后将该证书提供给 Kubernetes API。</p>
<!--
### Create private key

The following scripts show how to generate PKI private key and CSR. It is
important to set CN and O attribute of the CSR. CN is the name of the user and
O is the group that this user will belong to. You can refer to
[RBAC](/docs/reference/access-authn-authz/rbac/) for standard groups.
-->
<h3 id="create-private-key">创建私钥</h3>
<p>下面的脚本展示了如何生成 PKI 私钥和 CSR。
设置 CSR 的 CN 和 O 属性很重要。CN 是用户名，O 是该用户归属的组。
你可以参考 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC</a> 了解标准组的信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">openssl genrsa -out myuser.key <span style="color:#666">2048</span>
openssl req -new -key myuser.key -out myuser.csr
</code></pre></div><!--
### Create CertificateSigningRequest

Create a CertificateSigningRequest and submit it to a Kubernetes Cluster via kubectl.
Below is a script to generate the CertificateSigningRequest.
-->
<h3 id="create-certificatesigningrequest">创建 CertificateSigningRequest</h3>
<p>创建一个 CertificateSigningRequest，并通过 kubectl 将其提交到 Kubernetes 集群。
下面是生成 CertificateSigningRequest 的脚本。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: certificates.k8s.io/v1
</span><span style="color:#b44">kind: CertificateSigningRequest
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: myuser
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZVzVuWld4aE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJDZ0tDQVFFQTByczhJTHRHdTYxakx2dHhWTTJSVlRWMDNHWlJTWWw0dWluVWo4RElaWjBOCnR2MUZtRVFSd3VoaUZsOFEzcWl0Qm0wMUFSMkNJVXBGd2ZzSjZ4MXF3ckJzVkhZbGlBNVhwRVpZM3ExcGswSDQKM3Z3aGJlK1o2MVNrVHF5SVBYUUwrTWM5T1Nsbm0xb0R2N0NtSkZNMUlMRVI3QTVGZnZKOEdFRjJ6dHBoaUlFMwpub1dtdHNZb3JuT2wzc2lHQ2ZGZzR4Zmd4eW8ybmlneFNVekl1bXNnVm9PM2ttT0x1RVF6cXpkakJ3TFJXbWlECklmMXBMWnoyalVnald4UkhCM1gyWnVVV1d1T09PZnpXM01LaE8ybHEvZi9DdS8wYk83c0x0MCt3U2ZMSU91TFcKcW90blZtRmxMMytqTy82WDNDKzBERHk5aUtwbXJjVDBnWGZLemE1dHJRSURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBR05WdmVIOGR4ZzNvK21VeVRkbmFjVmQ1N24zSkExdnZEU1JWREkyQTZ1eXN3ZFp1L1BVCkkwZXpZWFV0RVNnSk1IRmQycVVNMjNuNVJsSXJ3R0xuUXFISUh5VStWWHhsdnZsRnpNOVpEWllSTmU3QlJvYXgKQVlEdUI5STZXT3FYbkFvczFqRmxNUG5NbFpqdU5kSGxpT1BjTU1oNndLaTZzZFhpVStHYTJ2RUVLY01jSVUyRgpvU2djUWdMYTk0aEpacGk3ZnNMdm1OQUxoT045UHdNMGM1dVJVejV4T0dGMUtCbWRSeEgvbUNOS2JKYjFRQm1HCkkwYitEUEdaTktXTU0xMzhIQXdoV0tkNjVoVHdYOWl4V3ZHMkh4TG1WQzg0L1BHT0tWQW9FNkpsYWFHdTlQVmkKdjlOSjVaZlZrcXdCd0hKbzZXdk9xVlA3SVFjZmg3d0drWm89Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
</span><span style="color:#b44">  signerName: kubernetes.io/kube-apiserver-client
</span><span style="color:#b44">  expirationSeconds: 86400  # one day
</span><span style="color:#b44">  usages:
</span><span style="color:#b44">  - client auth
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Some points to note:

- `usages` has to be '`client auth`'
- `expirationSeconds` could be made longer (i.e. `864000` for ten days) or shorter (i.e. `3600` for one hour)
- `request` is the base64 encoded value of the CSR file content.
  You can get the content using this command: ```cat myuser.csr | base64 | tr -d "\n"```
-->
<p>需要注意的几点:</p>
<ul>
<li><code>usage</code> 字段必须是 '<code>client auth</code>'</li>
<li><code>expirationSeconds</code> 可以设置为更长（例如 <code>864000</code> 是十天）或者更短（例如 <code>3600</code> 是一个小时）</li>
<li><code>request</code> 字段是 CSR 文件内容的 base64 编码值。
要得到该值，可以执行命令 <code>cat myuser.csr | base64 | tr -d &quot;\n&quot;</code>。</li>
</ul>
<!--
### Approve certificate signing request

Use kubectl to create a CSR and approve it.

Get the list of CSRs:
-->
<h3 id="approve-certificate-signing-request">批准证书签名请求</h3>
<p>使用 kubectl 创建 CSR 并批准。</p>
<p>获取 CSR 列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
Approve the CSR:
-->
<p>批准 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve myuser
</code></pre></div><!--
### Get the certificate

Retrieve the certificate from the CSR.
-->
<h3 id="get-the-certificate">取得证书</h3>
<p>从 CSR 取得证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr/myuser -o yaml
</code></pre></div><!--
The Certificate value is in Base64-encoded format under `status.certificate`.

Export the issued certificate from the CertificateSigningRequest.

-->
<p>证书的内容使用 base64 编码，存放在字段 <code>status.certificate</code>。</p>
<p>从 CertificateSigningRequest 导出颁发的证书。</p>
<pre><code>kubectl get csr myuser -o jsonpath='{.status.certificate}'| base64 -d &gt; myuser.crt
</code></pre><!--
### Create Role and RoleBinding

With the certificate created it is time to define the Role and RoleBinding for
this user to access Kubernetes cluster resources.

This is a sample command to create a Role for this new user:
-->
<h3 id="create-role-and-role-binding">创建角色和角色绑定</h3>
<p>创建了证书之后，为了让这个用户能访问 Kubernetes 集群资源，现在就要创建
Role 和 RoleBinding 了。</p>
<p>下面是为这个新用户创建 Role 的示例命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role developer --verb<span style="color:#666">=</span>create --verb<span style="color:#666">=</span>get --verb<span style="color:#666">=</span>list --verb<span style="color:#666">=</span>update --verb<span style="color:#666">=</span>delete --resource<span style="color:#666">=</span>pods
</code></pre></div><!--
This is a sample command to create a RoleBinding for this new user:
-->
<p>下面是为这个新用户创建 RoleBinding 的示例命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding developer-binding-myuser --role<span style="color:#666">=</span>developer --user<span style="color:#666">=</span>myuser
</code></pre></div><!--
### Add to kubeconfig

The last step is to add this user into the kubeconfig file.

First, we need to add new credentials:
-->
<h3 id="add-to-kubeconfig">添加到 kubeconfig  </h3>
<p>最后一步是将这个用户添加到 kubeconfig 文件。
我们假设私钥和证书文件存放在 “/home/vagrant/work/” 目录中。</p>
<p>首先，我们需要添加新的凭据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-credentials myuser --client-key<span style="color:#666">=</span>myuser.key --client-certificate<span style="color:#666">=</span>myuser.crt --embed-certs<span style="color:#666">=</span><span style="color:#a2f">true</span>

</code></pre></div><!--
Then, you need to add the context:
-->
<p>然后，你需要添加上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-context myuser --cluster<span style="color:#666">=</span>kubernetes --user<span style="color:#666">=</span>myuser
</code></pre></div><!--
To test it, change the context to `myuser`:
-->
<p>来测试一下，把上下文切换为 <code>myuser</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config use-context myuser
</code></pre></div><!--
## Approval or rejection   {#approval-rejection}

### Control plane automated approval {#approval-rejection-control-plane}

The kube-controller-manager ships with a built-in approver for certificates with
a signerName of `kubernetes.io/kube-apiserver-client-kubelet` that delegates various
permissions on CSRs for node credentials to authorization.
The kube-controller-manager POSTs SubjectAccessReview resources to the API server
in order to check authorization for certificate approval.
-->
<h2 id="approval-rejection">批准和驳回</h2>
<h3 id="approval-rejection-control-plane">控制平面的自动化批准</h3>
<p>kube-controller-manager 内建了一个证书批准者，其 signerName 为
<code>kubernetes.io/kube-apiserver-client-kubelet</code>，
该批准者将 CSR 上用于节点凭据的各种权限委托给权威认证机构。
kube-controller-manager 将 SubjectAccessReview 资源发送（POST）到 API 服务器，
以便检验批准证书的授权。</p>
<!--
### Approval or rejection using `kubectl` {#approval-rejection-kubectl}

A Kubernetes administrator (with appropriate permissions) can manually approve
(or deny) CertificateSigningRequests by using the `kubectl certificate
approve` and `kubectl certificate deny` commands.

To approve a CSR with kubectl:
-->
<h3 id="approval-rejection-kubectl">使用 <code>kubectl</code> 批准或驳回  </h3>
<p>Kubernetes 管理员（拥有足够的权限）可以手工批准（或驳回）CertificateSigningRequests，
此操作使用 <code>kubectl certificate approve</code> 和 <code>kubectl certificate deny</code> 命令实现。</p>
<p>使用 kubectl 批准一个 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve &lt;certificate-signing-request-name&gt;
</code></pre></div><!--
Likewise, to deny a CSR:
-->
<p>同样地，驳回一个 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate deny &lt;certificate-signing-request-name&gt;
</code></pre></div><!--
### Approval or rejection using the Kubernetes API {#approval-rejection-api-client}

Users of the REST API can approve CSRs by submitting an UPDATE request to the `approval`
subresource of the CSR to be approved. For example, you could write an
<a class='glossary-tooltip' title='一种用于管理自定义资源的专用控制器' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/extend-kubernetes/operator/' target='_blank' aria-label='operator'>operator</a> that watches for a particular
kind of CSR and then sends an UPDATE to approve them.

When you make an approval or rejection request, set either the `Approved` or `Denied`
status condition based on the state you determine:

For `Approved` CSRs:
-->
<h3 id="approval-rejection-api-client">使用 Kubernetes API 批准或驳回 </h3>
<p>REST API 的用户可以通过向待批准的 CSR 的 <code>approval</code> 子资源提交更新请求来批准 CSR。
例如，你可以编写一个
<a class='glossary-tooltip' title='一种用于管理自定义资源的专用控制器' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/extend-kubernetes/operator/' target='_blank' aria-label='operator'>operator</a>
来监视特定类型的 CSR，然后发送一个更新来批准它。</p>
<p>当你发出批准或驳回的指令时，根据你期望的状态来选择设置 <code>Approved</code> 或 <code>Denied</code>。</p>
<p>批准（<code>Approved</code>） 的 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">conditions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">lastUpdateTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">lastTransitionTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">message</span>:<span style="color:#bbb"> </span>Approved by my custom approver controller<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">reason</span>:<span style="color:#bbb"> </span>ApprovedByMyPolicy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># You can set this to any string</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Approved<span style="color:#bbb">
</span></code></pre></div><!--
For `Denied` CSRs:
-->
<p>驳回（<code>Denied</code>）的 CSR：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">conditions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">lastUpdateTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">lastTransitionTime</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2020-02-08T11:37:35Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">message</span>:<span style="color:#bbb"> </span>Denied by my custom approver controller<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">reason</span>:<span style="color:#bbb"> </span>DeniedByMyPolicy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># You can set this to any string</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Denied<span style="color:#bbb">
</span></code></pre></div><!--
It's usual to set `status.conditions.reason` to a machine-friendly reason
code using TitleCase; this is a convention but you can set it to anything
you like. If you want to add a note for human consumption, use the
`status.conditions.message` field.
-->
<p><code>status.conditions.reason</code> 字段通常设置为一个首字母大写的对机器友好的原因码;
这是一个命名约定，但你也可以随你的个人喜好设置。
如果你想添加一个供人类使用的注释，那就用 <code>status.conditions.message</code>  字段。</p>
<!--
## Signing

### Control plane signer {#signer-control-plane}

The Kubernetes control plane implements each of the
[Kubernetes signers](/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers),
as part of the kube-controller-manager.

Prior to Kubernetes v1.18, the kube-controller-manager would sign any CSRs that
were marked as approved.
-->
<h2 id="signing">签名  </h2>
<h3 id="signer-control-plane">控制平面签名者   </h3>
<p>Kubernetes 控制平面实现了每一个
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">Kubernetes 签名者</a>，
每个签名者的实现都是 kube-controller-manager 的一部分。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 在Kubernetes v1.18 之前，
kube-controller-manager 签名所有标记为 approved  的 CSR。
</div>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The `spec.expirationSeconds` field was added in Kubernetes v1.22.  Earlier versions of Kubernetes do not honor this field.
Kubernetes API servers prior to v1.22 will silently drop this field when the object is created.
-->
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<!--
### API-based signers {#signer-api}

Users of the REST API can sign CSRs by submitting an UPDATE request to the `status`
subresource of the CSR to be signed.

As part of this request, the `status.certificate` field should be set to contain the
signed certificate. This field contains one or more PEM-encoded certificates.

All PEM blocks must have the "CERTIFICATE" label, contain no headers,
and the encoded data must be a BER-encoded ASN.1 Certificate structure
as described in [section 4 of RFC5280](https://tools.ietf.org/html/rfc5280#section-4.1).

Example certificate content:
-->
<h3 id="signer-api">基于 API 的签名者  </h3>
<p>REST API 的用户可以通过向待签名的 CSR 的 <code>status</code> 子资源提交更新请求来对 CSR 进行签名。</p>
<p>作为这个请求的一部分， <code>status.certificate</code> 字段应设置为已签名的证书。
此字段可包含一个或多个 PEM 编码的证书。</p>
<p>所有的 PEM 块必须具备 &quot;CERTIFICATE&quot; 标签，且不包含文件头，且编码的数据必须是
<a href="https://tools.ietf.org/html/rfc5280#section-4.1">RFC5280 第 4 节</a>
中描述的 BER 编码的 ASN.1 证书结构。</p>
<pre><code>-----BEGIN CERTIFICATE-----
MIIDgjCCAmqgAwIBAgIUC1N1EJ4Qnsd322BhDPRwmg3b/oAwDQYJKoZIhvcNAQEL
BQAwXDELMAkGA1UEBhMCeHgxCjAIBgNVBAgMAXgxCjAIBgNVBAcMAXgxCjAIBgNV
BAoMAXgxCjAIBgNVBAsMAXgxCzAJBgNVBAMMAmNhMRAwDgYJKoZIhvcNAQkBFgF4
MB4XDTIwMDcwNjIyMDcwMFoXDTI1MDcwNTIyMDcwMFowNzEVMBMGA1UEChMMc3lz
dGVtOm5vZGVzMR4wHAYDVQQDExVzeXN0ZW06bm9kZToxMjcuMC4wLjEwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDne5X2eQ1JcLZkKvhzCR4Hxl9+ZmU3
+e1zfOywLdoQxrPi+o4hVsUH3q0y52BMa7u1yehHDRSaq9u62cmi5ekgXhXHzGmm
kmW5n0itRECv3SFsSm2DSghRKf0mm6iTYHWDHzUXKdm9lPPWoSOxoR5oqOsm3JEh
Q7Et13wrvTJqBMJo1GTwQuF+HYOku0NF/DLqbZIcpI08yQKyrBgYz2uO51/oNp8a
sTCsV4OUfyHhx2BBLUo4g4SptHFySTBwlpRWBnSjZPOhmN74JcpTLB4J5f4iEeA7
2QytZfADckG4wVkhH3C2EJUmRtFIBVirwDn39GXkSGlnvnMgF3uLZ6zNAgMBAAGj
YTBfMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMB
Af8EAjAAMB0GA1UdDgQWBBTREl2hW54lkQBDeVCcd2f2VSlB1DALBgNVHREEBDAC
ggAwDQYJKoZIhvcNAQELBQADggEBABpZjuIKTq8pCaX8dMEGPWtAykgLsTcD2jYr
L0/TCrqmuaaliUa42jQTt2OVsVP/L8ofFunj/KjpQU0bvKJPLMRKtmxbhXuQCQi1
qCRkp8o93mHvEz3mTUN+D1cfQ2fpsBENLnpS0F4G/JyY2Vrh19/X8+mImMEK5eOy
o0BMby7byUj98WmcUvNCiXbC6F45QTmkwEhMqWns0JZQY+/XeDhEcg+lJvz9Eyo2
aGgPsye1o3DpyXnyfJWAWMhOz7cikS5X2adesbgI86PhEHBXPIJ1v13ZdfCExmdd
M1fLPhLyR54fGaY+7/X8P9AZzPefAkwizeXwe9ii6/a08vWoiE4=
-----END CERTIFICATE-----
</code></pre><!--
Non-PEM content may appear before or after the CERTIFICATE PEM blocks and is unvalidated,
to allow for explanatory text as described in section 5.2 of RFC7468.

When encoded in JSON or YAML, this field is base-64 encoded.
A CertificateSigningRequest containing the example certificate above would look like this:
-->
<p>非 PEM 内容可能会出现在证书 PEM 块前后的位置，且未经验证，
以允许使用 RFC7468 第5.2节 中描述的解释性文本。</p>
<p>当使用 JSON 或 YAML 格式时，此字段是 base-64 编码。
包含上述示例证书的 CertificateSigningRequest 如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>certificates.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CertificateSigningRequest<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">certificate</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JS...&#34;</span><span style="color:#bbb">
</span></code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
* Read [Manage TLS Certificates in a Cluster](/docs/tasks/tls/managing-tls-in-a-cluster/)
* View the source code for the kube-controller-manager built in [signer](https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go)
* View the source code for the kube-controller-manager built in [approver](https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go)
* For details of X.509 itself, refer to [RFC 5280](https://tools.ietf.org/html/rfc5280#section-3.1) section 3.1
* For information on the syntax of PKCS#10 certificate signing requests, refer to [RFC 2986](https://tools.ietf.org/html/rfc2986)
-->
<ul>
<li>参阅 <a href="/zh/docs/tasks/tls/managing-tls-in-a-cluster/">管理集群中的 TLS 认证</a></li>
<li>查看 kube-controller-manager 中<a href="https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go">签名者</a>部分的源代码</li>
<li>查看 kube-controller-manager 中<a href="https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go">批准者</a>部分的源代码</li>
<li>有关 X.509 本身的详细信息，请参阅 <a href="https://tools.ietf.org/html/rfc5280#section-3.1">RFC 5280</a> 第3.1节</li>
<li>有关 PKCS#10 证书签名请求语法的信息，请参阅 <a href="https://tools.ietf.org/html/rfc2986">RFC 2986</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-518807b9b00bda46d7c7e6e0b17c18f8">4 - 使用准入控制器</h1>
    
	<!--
reviewers:
- lavalamp
- davidopp
- derekwaynecarr
- erictune
- janetkuo
- thockin
title: Using Admission Controllers
content_type: concept
weight: 30
-->
<!-- overview -->
<!--
This page provides an overview of Admission Controllers.
-->
<p>此页面概述了准入控制器。</p>
<!-- body -->
<!--
## What are they?
-->
<h2 id="什么是准入控制插件">什么是准入控制插件？</h2>
<!--
An admission controller is a piece of code that intercepts requests to the
Kubernetes API server prior to persistence of the object, but after the request
is authenticated and authorized.  The controllers consist of the
[list](#what-does-each-admission-controller-do) below, are compiled into the
`kube-apiserver` binary, and may only be configured by the cluster
administrator. In that list, there are two special controllers:
MutatingAdmissionWebhook and ValidatingAdmissionWebhook.  These execute the
mutating and validating (respectively) [admission control
webhooks](/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks)
which are configured in the API.
-->
<p>准入控制器是一段代码，它会在请求通过认证和授权之后、对象被持久化之前拦截到达 API
服务器的请求。控制器由下面的<a href="#what-does-each-admission-controller-do">列表</a>组成，
并编译进 <code>kube-apiserver</code> 二进制文件，并且只能由集群管理员配置。
在该列表中，有两个特殊的控制器：MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
它们根据 API 中的配置，分别执行变更和验证
<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks">准入控制 webhook</a>。</p>
<!--
Admission controllers may be "validating", "mutating", or both. Mutating
controllers may modify related objects to the requests they admit; validating controllers may not.

Admission controllers limit requests to create, delete, modify objects or connect to proxy. They do not limit requests to read objects.

The admission control process proceeds in two phases. In the first phase,
mutating admission controllers are run. In the second phase, validating
admission controllers are run. Note again that some of the controllers are
both.

If any of the controllers in either phase reject the request, the entire
request is rejected immediately and an error is returned to the end-user.
-->
<p>准入控制器可以执行 “验证（Validating）” 和/或 “变更（Mutating）” 操作。
变更（mutating）控制器可以根据被其接受的请求修改相关对象；验证（validating）控制器则不行。</p>
<p>准入控制器限制创建、删除、修改对象或连接到代理的请求，不限制读取对象的请求。</p>
<p>准入控制过程分为两个阶段。第一阶段，运行变更准入控制器。第二阶段，运行验证准入控制器。
再次提醒，某些控制器既是变更准入控制器又是验证准入控制器。</p>
<p>如果任何一个阶段的任何控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回一个错误。</p>
<!--
Finally, in addition to sometimes mutating the object in question, admission
controllers may sometimes have side effects, that is, mutate related
resources as part of request processing. Incrementing quota usage is the
canonical example of why this is necessary. Any such side-effect needs a
corresponding reclamation or reconciliation process, as a given admission
controller does not know for sure that a given request will pass all of the
other admission controllers.
-->
<p>最后，除了对对象进行变更外，准入控制器还可以有其它作用：将相关资源作为请求处理的一部分进行变更。
增加使用配额就是一个典型的示例，说明了这样做的必要性。
此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。</p>
<!--
## Why do I need them?
-->
<h2 id="为什么需要准入控制器">为什么需要准入控制器？</h2>
<!--
Many advanced features in Kubernetes require an admission controller to be enabled in order
to properly support the feature.  As a result, a Kubernetes API server that is not properly
configured with the right set of admission controllers is an incomplete server and will not
support all the features you expect.
-->
<p>Kubernetes 的许多高级功能都要求启用一个准入控制器，以便正确地支持该特性。
因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你期望的所有特性。</p>
<!--
## How do I turn on an admission controller?
-->
<h2 id="如何启用一个准入控制器">如何启用一个准入控制器？</h2>
<!--
The Kubernetes API server flag `enable-admission-plugins` takes a comma-delimited list of admission control plugins to invoke prior to modifying objects in the cluster.
For example, the following command line enables the `NamespaceLifecycle` and the `LimitRanger`
admission control plugins:
-->
<p>Kubernetes API 服务器的 <code>enable-admission-plugins</code> 标志接受一个用于在集群修改对象之前
调用的（以逗号分隔的）准入控制插件顺序列表。</p>
<p>例如，下面的命令就启用了 <code>NamespaceLifecycle</code> 和 <code>LimitRanger</code> 准入控制插件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --enable-admission-plugins<span style="color:#666">=</span>NamespaceLifecycle,LimitRanger ...
</code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Depending on the way your Kubernetes cluster is deployed and how the API server is
started, you may need to apply the settings in different ways. For example, you may
have to modify the systemd unit file if the API server is deployed as a systemd
service, you may modify the manifest file for the API server if Kubernetes is deployed
in a self-hosted way.
-->
<p>根据你 Kubernetes 集群的部署方式以及 API 服务器的启动方式的不同，你可能需要以不同的方式应用设置。
例如，如果将 API 服务器部署为 systemd 服务，你可能需要修改 systemd 单元文件；
如果以自托管方式部署 Kubernetes，你可能需要修改 API 服务器的清单文件。
</div>
<!--
## How do I turn off an admission controller?

The Kubernetes API server flag `disable-admission-plugins` takes a comma-delimited list of admission control plugins to be disabled, even if they are in the list of plugins enabled by default.
-->
<h2 id="怎么关闭准入控制器">怎么关闭准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>disable-admission-plugins</code> 标志，会将传入的（以逗号分隔的）
准入控制插件列表禁用，即使是默认启用的插件也会被禁用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --disable-admission-plugins<span style="color:#666">=</span>PodNodeSelector,AlwaysDeny ...
</code></pre></div><!--
## Which plugins are enabled by default?

To see which admission plugins are enabled:
-->
<h2 id="哪些插件是默认启用的">哪些插件是默认启用的？</h2>
<p>下面的命令可以查看哪些插件是默认启用的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver -h | grep enable-admission-plugins
</code></pre></div><!--
In the current version, the default ones are:
-->
<p>在目前版本中，它们是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle, PersistentVolumeClaimResize, Priority, ResourceQuota, RuntimeClass, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook
</code></pre></div><!--
## What does each admission controller do?

### AlwaysAdmit {#alwaysadmit} 




<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>



This admission controller allows all pods into the cluster. It is deprecated because its behavior is the same as if there were no admission controller at all.
-->
<h2 id="每个准入控制器的作用是什么">每个准入控制器的作用是什么？</h2>
<h3 id="alwaysadmit">AlwaysAdmit</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


<p>该准入控制器会允许所有的 pod 接入集群。已废弃，因为它的行为根本就和没有准入控制器一样。</p>
<h3 id="alwaysdeny">AlwaysDeny</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


<!--
Rejects all requests. AlwaysDeny is DEPRECATED as it has no real meaning.
-->
<p>拒绝所有的请求。由于它没有实际意义，已废弃。</p>
<h3 id="alwayspullimages">AlwaysPullImages</h3>
<!--
This admission controller modifies every new Pod to force the image pull policy to Always. This is useful in a
multitenant cluster so that users can be assured that their private images can only be used by those
who have the credentials to pull them. Without this admission controller, once an image has been pulled to a
node, any pod from any user can use it by knowing the image's name (assuming the Pod is
scheduled onto the right node), without any authorization check against the image. When this admission controller
is enabled, images are always pulled prior to starting containers, which means valid credentials are
required.
-->
<p>该准入控制器会修改每一个新创建的 Pod 的镜像拉取策略为 Always 。
这在多租户集群中是有用的，这样用户就可以放心，他们的私有镜像只能被那些有凭证的人使用。
如果没有这个准入控制器，一旦镜像被拉取到节点上，任何用户的 Pod 都可以通过已了解到的镜像
的名称（假设 Pod 被调度到正确的节点上）来使用它，而不需要对镜像进行任何授权检查。
当启用这个准入控制器时，总是在启动容器之前拉取镜像，这意味着需要有效的凭证。</p>
<h3 id="certificateapproval">CertificateApproval</h3>
<!--
This admission controller observes requests to 'approve' CertificateSigningRequest resources
and performs additional authorization checks to ensure the approving user has permission 
to approve certificate requests with the spec.signerName requested on the CertificateSigningRequest resource.
-->
<p>此准入控制器获取“审批” CertificateSigningRequest 资源的请求并执行额外的授权检查，
以确保审批请求的用户有权限审批 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求。</p>
<!--
See Certificate Signing Requests for more information on the permissions required 
to perform different actions on CertificateSigningRequest resources.
-->
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a></p>
<h3 id="certificatesigning">CertificateSigning</h3>
<!--
This admission controller observes updates to the status.certificate field of CertificateSigningRequest resources 
and performs an additional authorization checks to ensure the signing user has permission 
to sign certificate requests with the spec.signerName requested on the CertificateSigningRequest resource.
-->
<p>此准入控制器获取 CertificateSigningRequest 资源的 <code>status.certificate</code> 字段更新请求并执行额外的授权检查，
以确保签发证书的用户有权限为 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求<code>签发</code>证书。</p>
<!--
See Certificate Signing Requests for more information on the permissions required 
to perform different actions on CertificateSigningRequest resources.
-->
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a></p>
<h3 id="certificatesubjectrestrictions">CertificateSubjectRestrictions</h3>
<!--
This admission controller observes creation of CertificateSigningRequest resources 
that have a spec.signerName of kubernetes.io/kube-apiserver-client. It rejects any request 
that specifies a 'group' (or 'organization attribute') of system:masters.
-->
<p>此准入控制器获取具有 <code>kubernetes.io/kube-apiserver-client</code> 的 <code>spec.signerName</code> 的
CertificateSigningRequest 资源创建请求，
它拒绝任何包含了 <code>system:masters</code> 一个“组”（或者“组织”）的请求。</p>
<h3 id="defaultingressclass">DefaultIngressClass</h3>
<!--
This admission controller observes creation of `Ingress` objects that do not request any specific
ingress class and automatically adds a default ingress class to them.  This way, users that do not
request any special ingress class do not need to care about them at all and they will get the
default one.
-->
<p>该准入控制器监测没有请求任何特定 Ingress 类的 <code>Ingress</code> 对象的创建，并自动向其添加默认 Ingress 类。
这样，没有任何特殊 Ingress 类需求的用户根本不需要关心它们，它们将获得默认 Ingress 类。</p>
<!--
This admission controller does not do anything when no default ingress class is configured. When more than one ingress
class is marked as default, it rejects any creation of `Ingress` with an error and an administrator
must revisit their `IngressClass` objects and mark only one as default (with the annotation
"ingressclass.kubernetes.io/is-default-class").  This admission controller ignores any `Ingress`
updates; it acts only on creation.
-->
<p>当未配置默认 Ingress 类时，此准入控制器不执行任何操作。如果将多个 Ingress 类标记为默认 Ingress 类，
它将拒绝任何创建 <code>Ingress</code> 的操作，并显示错误。
要修复此错误，管理员必须重新检查其 <code>IngressClass</code> 对象，并仅将其中一个标记为默认（通过注解
&quot;ingressclass.kubernetes.io/is-default-class&quot;）。
此准入控制器会忽略所有 <code>Ingress</code> 更新操作，仅响应创建操作。</p>
<!--
See the [ingress](/docs/concepts/services-networking/ingress/) documentation for more about ingress
classes and how to mark one as default.
-->
<p>关于 Ingress 类以及如何将 Ingress 类标记为默认的更多信息，请参见
<a href="/zh/docs/concepts/services-networking/ingress/">ingress</a>。</p>
<h3 id="defaultstorageclass">DefaultStorageClass</h3>
<!--
This admission controller observes creation of `PersistentVolumeClaim` objects that do not request any specific storage class
and automatically adds a default storage class to them.
This way, users that do not request any special storage class do not need to care about them at all and they
will get the default one.
-->
<p>该准入控制器监测没有请求任何特定存储类的 <code>PersistentVolumeClaim</code> 对象的创建，
并自动向其添加默认存储类。
这样，没有任何特殊存储类需求的用户根本不需要关心它们，它们将获得默认存储类。</p>
<!--
This admission controller does not do anything when no default storage class is configured. When more than one storage
class is marked as default, it rejects any creation of `PersistentVolumeClaim` with an error and an administrator
must revisit their `StorageClass` objects and mark only one as default.
This admission controller ignores any `PersistentVolumeClaim` updates; it acts only on creation.
-->
<p>当未配置默认存储类时，此准入控制器不执行任何操作。如果将多个存储类标记为默认存储类，
它将拒绝任何创建 <code>PersistentVolumeClaim</code> 的操作，并显示错误。
要修复此错误，管理员必须重新访问其 <code>StorageClass</code> 对象，并仅将其中一个标记为默认。
此准入控制器会忽略所有 <code>PersistentVolumeClaim</code> 更新操作，仅响应创建操作。</p>
<!--
See [persistent volume](/docs/concepts/storage/persistent-volumes/) documentation about persistent volume claims and
storage classes and how to mark a storage class as default.
-->
<p>关于持久化卷和存储类，以及如何将存储类标记为默认，请参见
<a href="/zh/docs/concepts/storage/persistent-volumes/">持久化卷</a>。</p>
<h3 id="defaulttolerationseconds">DefaultTolerationSeconds</h3>
<!--
This admission controller sets the default forgiveness toleration for pods to tolerate
the taints `notready:NoExecute` and `unreachable:NoExecute` based on the k8s-apiserver input parameters
`default-not-ready-toleration-seconds` and `default-unreachable-toleration-seconds` if the pods don't already
have toleration for taints `node.kubernetes.io/not-ready:NoExecute` or
`node.kubernetes.io/unreachable:NoExecute`.
The default value for `default-not-ready-toleration-seconds` and `default-unreachable-toleration-seconds` is 5 minutes.
-->
<p>该准入控制器基于 k8s-apiserver 输入参数 <code>default-not-ready-toleration-seconds</code> 和
<code>default-unreachable-toleration-seconds</code> 为 Pod 设置默认的容忍度，以容忍 <code>notready:NoExecute</code> 和
<code>unreachable:NoExecute</code> 污点。
（如果 Pod 尚未容忍 <code>node.kubernetes.io/not-ready：NoExecute</code> 和
<code>node.kubernetes.io/unreachable：NoExecute</code> 污点的话）
<code>default-not-ready-toleration-seconds</code> 和 <code>default-unreachable-toleration-seconds</code> 的默认值是 5 分钟。</p>
<h3 id="denyescalatingexec">DenyEscalatingExec</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


<!--
This admission controller will deny exec and attach commands to pods that run with escalated privileges that
allow host access.  This includes pods that run as privileged, have access to the host IPC namespace, and
have access to the host PID namespace.
-->
<p>该准入控制器将拒绝在由于拥有升级特权，而具备访问宿主机能力的 Pod 中执行 exec 和
attach 命令。这包括在特权模式运行的 Pod，可以访问主机 IPC 名字空间的 Pod，
和访问主机 PID 名字空间的 Pod 。</p>
<!--
The DenyEscalatingExec admission plugin is deprecated.

Use of a policy-based admission plugin (like [PodSecurityPolicy](#podsecuritypolicy) or a custom admission plugin)
which can be targeted at specific users or Namespaces and also protects against creation of overly privileged Pods
is recommended instead.
-->
<p>DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href="#podsecuritypolicy">PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id="denyexeconprivileged">DenyExecOnPrivileged</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


<!--
This admission controller will intercept all requests to exec a command in a pod if that pod has a privileged container.
-->
<p>如果一个 pod 拥有一个特权容器，该准入控制器将拦截所有在该 pod 中执行 exec 命令的请求。</p>
<!--
This functionality has been merged into [DenyEscalatingExec](#denyescalatingexec).
The DenyExecOnPrivileged admission plugin is deprecated.
-->
<p>此功能已合并至 <a href="#denyescalatingexec">DenyEscalatingExec</a>。
而 DenyExecOnPrivileged 准入插件已被废弃。</p>
<!--
Use of a policy-based admission plugin (like [PodSecurityPolicy](#podsecuritypolicy) or a custom admission plugin)
which can be targeted at specific users or Namespaces and also protects against creation of overly privileged Pods
is recommended instead.
-->
<p>建议使用基于策略的准入插件（例如 <a href="#podsecuritypolicy">PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id="denyserviceexternalips">DenyServiceExternalIPs</h3>
<!--
This admission controller rejects all net-new usage of the `Service` field `externalIPs`.  This
feature is very powerful (allows network traffic interception) and not well
controlled by policy.  When enabled, users of the cluster may not create new
Services which use `externalIPs` and may not add new values to `externalIPs` on
existing `Service` objects.  Existing uses of `externalIPs` are not affected,
and users may remove values from `externalIPs` on existing `Service` objects.
-->
<p>该准入控制器拒绝 <code>Service</code> 字段 <code>externalIPs</code> 的所有新规使用。 此功能非常强大（允许网络流量拦截），
并且无法很好地受策略控制。 启用后，群集用户将无法创建使用 <code>externalIPs</code> 的新服务，也无法在现有
<code>Service</code> 对象上向 <code>externalIPs</code> 添加新值。 <code>externalIPs</code> 的现有使用不受影响，用户可以从现有
<code>Service</code> 对象上的 <code>externalIPs</code> 中删除值。</p>
<!--
Most users do not need this feature at all, and cluster admins should consider disabling it.
Clusters that do need to use this feature should consider using some custom policy to manage usage
of it.
-->
<p>大多数用户根本不需要此功能，集群管理员应考虑将其禁用。
确实需要使用此功能的集群应考虑使用一些自定义策略来管理其的使用。</p>
<h3 id="eventratelimit">EventRateLimit</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [alpha]</code>
</div>


<!--
This admission controller mitigates the problem where the API server gets flooded by
event requests. The cluster admin can specify event rate limits by:
-->
<p>该准入控制器缓解了事件请求淹没 API 服务器的问题。集群管理员可以通过以下方式指定事件速率限制：</p>
<!--
 * Enabling the `EventRateLimit` admission controller;
 * Referencing an `EventRateLimit` configuration file from the file provided to the API
   server's command line flag `--admission-control-config-file`:
-->
<ul>
<li>启用 <code>EventRateLimit</code> 准入控制器；</li>
<li>从文件中引用 <code>EventRateLimit</code> 配置文件，并提供给 API 服务器命令的
<code>--admission-control-config-file</code> 标志：</li>
</ul>
<ul class="nav nav-tabs" id="eventratelimit-example" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#eventratelimit-example-0" role="tab" aria-controls="eventratelimit-example-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#eventratelimit-example-1" role="tab" aria-controls="eventratelimit-example-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="eventratelimit-example"><div id="eventratelimit-example-0" class="tab-pane show active" role="tabpanel" aria-labelledby="eventratelimit-example-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>EventRateLimit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>eventconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="eventratelimit-example-1" class="tab-pane" role="tabpanel" aria-labelledby="eventratelimit-example-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>EventRateLimit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>eventconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
There are four types of limits that can be specified in the configuration:
-->
<p>可以在配置中指定四种类型的限制：</p>
<!--
 * `Server`: All event requests received by the API server share a single bucket.
 * `Namespace`: Each namespace has a dedicated bucket.
 * `User`: Each user is allocated a bucket.
 * `SourceAndObject`: A bucket is assigned by each combination of source and
   involved object of the event.
-->
<ul>
<li><code>Server</code>: API 服务器收到的所有事件请求共享一个桶。</li>
<li><code>Namespace</code>: 每个名字空间都有一个专用的桶。</li>
<li><code>User</code>: 给每个用户都分配一个桶。</li>
<li><code>SourceAndObject</code>: 根据事件的源和涉及对象的每种组合分配桶。</li>
</ul>
<!--
Below is a sample `eventconfig.yaml` for such a configuration:
-->
<p>下面是一个配置示例 <code>eventconfig.yaml</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>eventratelimit.admission.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Configuration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">qps</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">burst</span>:<span style="color:#bbb"> </span><span style="color:#666">100</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cacheSize</span>:<span style="color:#bbb"> </span><span style="color:#666">2000</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">qps</span>:<span style="color:#bbb"> </span><span style="color:#666">10</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">burst</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span></code></pre></div><!--
See the [EventRateLimit proposal](https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md)
for more details.
-->
<p>详情请参见
<a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md">事件速率限制提案</a>。</p>
<h3 id="extendedresourcetoleration">ExtendedResourceToleration</h3>
<!--
This plug-in facilitates creation of dedicated nodes with extended resources.
If operators want to create dedicated nodes with extended resources (like GPUs, FPGAs etc.), they are expected to
[taint the node](/docs/concepts/scheduling-eviction/taint-and-toleration/#example-use-cases) with the extended resource
name as the key. This admission controller, if enabled, automatically
adds tolerations for such taints to pods requesting extended resources, so users don't have to manually
add these tolerations.
-->
<p>该插件有助于创建可扩展资源的专用节点。
如果运营商想创建可扩展资源的专用节点（如 GPU、FPGA 等），
那他们应该以扩展资源名称作为键名，
<a href="/zh/docs/concepts/scheduling-eviction/taint-and-toleration/">为节点设置污点</a>。
如果启用了该准入控制器，会将此类污点的容忍自动添加到请求扩展资源的 Pod 中，
用户不必再手动添加这些容忍。</p>
<h3 id="imagepolicywebhook">ImagePolicyWebhook</h3>
<!--
The ImagePolicyWebhook admission controller allows a backend webhook to make admission decisions.
-->
<p>ImagePolicyWebhook 准入控制器允许使用一个后端的 webhook 做出准入决策。</p>
<!--
#### Configuration File Format
-->
<h4 id="配置文件格式">配置文件格式</h4>
<!--
ImagePolicyWebhook uses a configuration file to set options for the behavior of the backend.
This file may be json or yaml and has the following format:
-->
<p>ImagePolicyWebhook 使用配置文件来为后端行为设置配置选项。该文件可以是 JSON 或 YAML，
并具有以下格式:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>/path/to/kubeconfig/for/backend<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以秒计的时长，控制批准请求的缓存时间</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以秒计的时长，控制拒绝请求的缓存时间</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 以毫秒计的时长，控制重试间隔</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 确定 Webhook 后端失效时的行为</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><!--
Reference the ImagePolicyWebhook configuration file from the file provided to the API server's command line flag `--admission-control-config-file`:
-->
<p>从文件中引用 ImagePolicyWebhook 的配置文件，并将其提供给 API 服务器命令标志
<code>--admission-control-config-file</code>：</p>
<ul class="nav nav-tabs" id="imagepolicywebhook-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#imagepolicywebhook-example1-0" role="tab" aria-controls="imagepolicywebhook-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#imagepolicywebhook-example1-1" role="tab" aria-controls="imagepolicywebhook-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="imagepolicywebhook-example1"><div id="imagepolicywebhook-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="imagepolicywebhook-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>imagepolicyconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="imagepolicywebhook-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="imagepolicywebhook-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>imagepolicyconfig.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Alternatively, you can embed the configuration directly in the file:
-->
<p>或者，你也可以直接将配置嵌入到文件中：</p>
<ul class="nav nav-tabs" id="imagepolicywebhook-example2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#imagepolicywebhook-example2-0" role="tab" aria-controls="imagepolicywebhook-example2-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#imagepolicywebhook-example2-1" role="tab" aria-controls="imagepolicywebhook-example2-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="imagepolicywebhook-example2"><div id="imagepolicywebhook-example2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="imagepolicywebhook-example2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>&lt;kubeconfig 文件路径&gt;<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="imagepolicywebhook-example2-1" class="tab-pane" role="tabpanel" aria-labelledby="imagepolicywebhook-example2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ImagePolicyWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imagePolicy</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span>&lt;kubeconfig 文件路径&gt;<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">allowTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">denyTTL</span>:<span style="color:#bbb"> </span><span style="color:#666">50</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">retryBackoff</span>:<span style="color:#bbb"> </span><span style="color:#666">500</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">defaultAllow</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
The ImagePolicyWebhook config file must reference a
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
formatted file which sets up the connection to the backend.
It is required that the backend communicate over TLS.
-->
<p>ImagePolicyWebhook 的配置文件必须引用
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>
格式的文件；该文件设置了到后端的连接参数。
要求后端使用 TLS 进行通信。</p>
<!--
The kubeconfig file's cluster field must point to the remote service, and the user field must contain the returned authorizer.
-->
<p>kubeconfig 文件的 cluster 字段需要指向远端服务，user 字段需要包含已返回的授权者。</p>
<!--
```yaml
# clusters refers to the remote service.
clusters:
- name: name-of-remote-imagepolicy-service
  cluster:
    certificate-authority: /path/to/ca.pem    # CA for verifying the remote service.
    server: https://images.example.com/policy # URL of remote service to query. Must use 'https'.

# users refers to the API server's webhook configuration.
users:
- name: name-of-api-server
  user:
    client-certificate: /path/to/cert.pem # cert for the webhook admission controller to use
    client-key: /path/to/key.pem          # key matching the cert
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># clusters 指的是远程服务。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-imagepolicy-service<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem   <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># CA 用于验证远程服务</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://images.example.com/policy<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 要查询的远程服务的 URL。必须是 &#39;https&#39; 。</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 指的是 API 服务器的 Webhook 配置。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># webhook 准入控制器使用的证书</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 证书匹配的密钥</span><span style="color:#bbb">
</span></code></pre></div><!--
For additional HTTP configuration, refer to the
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) documentation.
-->
<p>关于 HTTP 配置的更多信息，请参阅
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>
文档。</p>
<!--
#### Request Payloads
-->
<h4 id="请求载荷">请求载荷</h4>
<!--
When faced with an admission decision, the API Server POSTs a JSON serialized `imagepolicy.k8s.io/v1alpha1` `ImageReview` object describing the action. This object contains fields describing the containers being admitted, as well as any pod annotations that match `*.image-policy.k8s.io/*`.
-->
<p>当面对一个准入决策时，API 服务器发送一个描述操作的 JSON 序列化的
<code>imagepolicy.k8s.io/v1alpha1</code> <code>ImageReview</code> 对象。
该对象包含描述被审核容器的字段，以及所有匹配 <code>*.image-policy.k8s.io/*</code> 的
Pod 注解。</p>
<!--
Note that webhook API objects are subject to the same versioning compatibility rules as other Kubernetes API objects. Implementers should be aware of looser compatibility promises for alpha objects and check the "apiVersion" field of the request to ensure correct deserialization. Additionally, the API Server must enable the imagepolicy.k8s.io/v1alpha1 API extensions group (`--runtime-config=imagepolicy.k8s.io/v1alpha1=true`).
-->
<p>注意，Webhook API 对象与其他 Kubernetes API 对象一样受制于相同的版本控制兼容性规则。
实现者应该知道对 alpha 对象的更宽松的兼容性，并检查请求的 &quot;apiVersion&quot; 字段，
以确保正确的反序列化。
此外，API 服务器必须启用 <code>imagepolicy.k8s.io/v1alpha1</code> API 扩展组
（<code>--runtime-config=imagepolicy.k8s.io/v1alpha1=true</code>）。</p>
<!--
An example request body:
-->
<p>请求载荷示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>:{
    <span style="color:#008000;font-weight:bold">&#34;containers&#34;</span>:[
      {
        <span style="color:#008000;font-weight:bold">&#34;image&#34;</span>:<span style="color:#b44">&#34;myrepo/myimage:v1&#34;</span>
      },
      {
        <span style="color:#008000;font-weight:bold">&#34;image&#34;</span>:<span style="color:#b44">&#34;myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed&#34;</span>
      }
    ],
    <span style="color:#008000;font-weight:bold">&#34;annotations&#34;</span>:{
      <span style="color:#008000;font-weight:bold">&#34;mycluster.image-policy.k8s.io/ticket-1234&#34;</span>: <span style="color:#b44">&#34;break-glass&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>:<span style="color:#b44">&#34;mynamespace&#34;</span>
  }
}
</code></pre></div><!--
The remote service is expected to fill the `ImageReviewStatus` field of the request and respond to either allow or disallow access. The response body's "spec" field is ignored and may be omitted. A permissive response would return:
-->
<p>远程服务将填充请求的 <code>ImageReviewStatus</code> 字段，并返回允许或不允许访问的响应。
响应体的 &quot;spec&quot; 字段会被忽略，并且可以省略。一个允许访问应答会返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div><!--
To disallow access, the service would return:
-->
<p>若不允许访问，服务将返回：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ImageReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;image currently blacklisted&#34;</span>
  }
}
</code></pre></div><!--
For further documentation refer to the `imagepolicy.v1alpha1` API objects and `plugin/pkg/admission/imagepolicy/admission.go`.
-->
<p>更多的文档，请参阅 <code>imagepolicy.v1alpha1</code> API 对象和
<code>plugin/pkg/admission/imagepolicy/admission.go</code>。</p>
<!--
#### Extending with Annotations
-->
<h4 id="使用注解进行扩展">使用注解进行扩展</h4>
<!--
All annotations on a Pod that match `*.image-policy.k8s.io/*` are sent to the webhook. Sending annotations allows users who are aware of the image policy backend to send extra information to it, and for different backends implementations to accept different information.
-->
<p>一个 Pod 中匹配 <code>*.image-policy.k8s.io/*</code> 的注解都会被发送给 Webhook。
这样做使得了解后端镜像策略的用户可以向它发送额外的信息，并为不同的后端实现
接收不同的信息。</p>
<!--
Examples of information you might put here are:
-->
<p>你可以在这里输入的信息有：</p>
<!--
 * request to "break glass" to override a policy, in case of emergency.
 * a ticket number from a ticket system that documents the break-glass request
 * provide a hint to the policy server as to the imageID of the image being provided, to save it a lookup
-->
<ul>
<li>在紧急情况下，请求 &quot;break glass&quot; 覆盖一个策略。</li>
<li>从一个记录了 break-glass 的请求的 ticket 系统得到的一个 ticket 号码。</li>
<li>向策略服务器提供一个提示，用于提供镜像的 imageID，以方便它进行查找。</li>
</ul>
<!--
In any case, the annotations are provided by the user and are not validated by Kubernetes in any way. In the future, if an annotation is determined to be widely useful, it may be promoted to a named field of `ImageReviewSpec`.
-->
<p>在任何情况下，注解都是由用户提供的，并不会被 Kubernetes 以任何方式进行验证。
在将来，如果一个注解确定将被广泛使用，它可能会被提升为 ImageReviewSpec 的一个命名字段。</p>
<h3 id="limitpodhardantiaffinitytopology">LimitPodHardAntiAffinityTopology</h3>
<!--
This admission controller denies any pod that defines `AntiAffinity` topology key other than
`kubernetes.io/hostname` in `requiredDuringSchedulingRequiredDuringExecution`.
-->
<p>该准入控制器拒绝（定义了 <code>AntiAffinity</code> 拓扑键的）任何 Pod
（<code>requiredDuringSchedulingRequiredDuringExecution</code> 中的
<code>kubernetes.io/hostname</code> 除外）。</p>
<h3 id="limitranger">LimitRanger</h3>
<!--
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints
enumerated in the `LimitRange` object in a `Namespace`.  If you are using `LimitRange` objects in
your Kubernetes deployment, you MUST use this admission controller to enforce those constraints. LimitRanger can also
be used to apply default resource requests to Pods that don't specify any; currently, the default LimitRanger
applies a 0.1 CPU requirement to all Pods in the `default` namespace.
-->
<p>该准入控制器会观察传入的请求，并确保它不会违反 <code>Namespace</code> 中 <code>LimitRange</code>
对象枚举的任何约束。
如果你在 Kubernetes 部署中使用了 <code>LimitRange</code> 对象，则必须使用此准入控制器来
执行这些约束。
LimitRanger 还可以用于将默认资源请求应用到没有指定任何内容的 Pod；
当前，默认的 LimitRanger 对 <code>default</code> 名字空间中的所有 Pod 都应用了
0.1 CPU 的需求。</p>
<!--
See the [limitRange design doc](https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md)
and the [example of Limit Range](/docs/tasks/configure-pod-container/limit-range/) for more details.
-->
<p>请查看
<a href="https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md">limitRange 设计文档</a>
和 <a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">LimitRange 例子</a>
以了解更多细节。</p>
<h3 id="mutatingadmissionwebhook">MutatingAdmissionWebhook</h3>
<!--
This admission controller calls any mutating webhooks which match the request. Matching
webhooks are called in serial; each one may modify the object if it desires.

This admission controller (as implied by the name) only runs in the mutating phase.
-->
<p>该准入控制器调用任何与请求匹配的变更 Webhook。匹配的 Webhook 将被串行调用。
每一个 Webhook 都可以根据需要修改对象。</p>
<p><code>MutatingAdmissionWebhook</code>，顾名思义，仅在变更阶段运行。</p>
<!--
If a webhook called by this has side effects (for example, decrementing quota) it
*must* have a reconciliation system, as it is not guaranteed that subsequent
webhooks or validating admission controllers will permit the request to finish.
-->
<p>如果由此准入控制器调用的 Webhook 有副作用（如降低配额），
则它 <em>必须</em> 具有协调系统，因为不能保证后续的 Webhook 和验证准入控制器都会允许完成请求。</p>
<!--
If you disable the MutatingAdmissionWebhook, you must also disable the
`MutatingWebhookConfiguration` object in the `admissionregistration.k8s.io/v1`
group/version via the `--runtime-config` flag (both are on by default in
versions >= 1.9).
-->
<p>如果你禁用了 MutatingAdmissionWebhook，那么还必须使用 <code>--runtime-config</code> 标志禁止
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>MutatingWebhookConfiguration</code>
对象（版本 &gt;=1.9 时，这两个对象都是默认启用的）。</p>
<!--
#### Use caution when authoring and installing mutating webhooks
-->
<h4 id="谨慎编写和安装变更-webhook">谨慎编写和安装变更 webhook</h4>
<!--
 * Users may be confused when the objects they try to create are different from
   what they get back.
 * Built in control loops may break when the objects they try to create are
   different when read back.
   * Setting originally unset fields is less likely to cause problems than
     overwriting fields set in the original request. Avoid doing the latter.
 * Future changes to control loops for built-in resources or third-party resources
   may break webhooks that work well today. Even when the webhook installation API
   is finalized, not all possible webhook behaviors will be guaranteed to be supported
   indefinitely.
-->
<ul>
<li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li>
<li>当它们回读的对象与尝试创建的对象不同，内建的控制环可能会出问题。
<ul>
<li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。
应尽量避免前面那种方式。</li>
</ul>
</li>
<li>内建资源和第三方资源的控制回路未来可能会受到破坏性的更改，使现在运行良好的 Webhook
无法再正常运行。即使完成了 Webhook API 安装，也不代表会为该 webhook 提供无限期的支持。</li>
</ul>
<h3 id="namespaceautoprovision">NamespaceAutoProvision</h3>
<!--
This admission controller examines all incoming requests on namespaced resources and checks
if the referenced namespace does exist.
It creates a namespace if it cannot be found.
This admission controller is useful in deployments that do not want to restrict creation of
a namespace prior to its usage.
-->
<p>该准入控制器会检查名字空间资源上的所有传入请求，并检查所引用的名字空间是否确实存在。
如果找不到，它将创建一个名字空间。
此准入控制器对于不想要求名字空间必须先创建后使用的集群部署中很有用。</p>
<h3 id="namespaceexists">NamespaceExists</h3>
<!--
This admission controller checks all requests on namespaced resources other than `Namespace` itself.
If the namespace referenced from a request doesn't exist, the request is rejected.
-->
<p>该准入控制器检查除 <code>Namespace</code> 以外的名字空间作用域资源上的所有请求。
如果请求引用的名字空间不存在，则拒绝该请求。</p>
<h3 id="namespacelifecycle">NamespaceLifecycle</h3>
<!--
This admission controller enforces that a `Namespace` that is undergoing termination cannot have new objects created in it,
and ensures that requests in a non-existent `Namespace` are rejected. This admission controller also prevents deletion of
three system reserved namespaces `default`, `kube-system`, `kube-public`.
-->
<p>该准入控制器禁止在一个正在被终止的 <code>Namespace</code> 中创建新对象，并确保
使用不存在的 <code>Namespace</code> 的请求被拒绝。
该准入控制器还会禁止删除三个系统保留的名字空间，即 <code>default</code>、
<code>kube-system</code> 和 <code>kube-public</code>。</p>
<!--
A `Namespace` deletion kicks off a sequence of operations that remove all objects (pods, services, etc.) in that
namespace.  In order to enforce integrity of that process, we strongly recommend running this admission controller.
-->
<p>删除 <code>Namespace</code> 会触发删除该名字空间中所有对象（Pod、Service 等）的一系列操作。
为了确保这个过程的完整性，我们强烈建议启用这个准入控制器。</p>
<h3 id="noderestriction">NodeRestriction</h3>
<!--
This admission controller limits the `Node` and `Pod` objects a kubelet can modify. In order to be limited by this admission controller,
kubelets must use credentials in the `system:nodes` group, with a username in the form `system:node:<nodeName>`.
Such kubelets will only be allowed to modify their own `Node` API object, and only modify `Pod` API objects that are bound to their node.
-->
<p>该准入控制器限制了 kubelet 可以修改的 <code>Node</code> 和 <code>Pod</code> 对象。
为了受到这个准入控制器的限制，kubelet 必须使用在 <code>system:nodes</code> 组中的凭证，
并使用 <code>system:node:&lt;nodeName&gt;</code> 形式的用户名。
这样，kubelet 只可修改自己的 <code>Node</code> API 对象，只能修改绑定到节点本身的 Pod 对象。</p>
<!--
In Kubernetes 1.11+, kubelets are not allowed to update or remove taints from their `Node` API object.

In Kubernetes 1.13+, the `NodeRestriction` admission plugin prevents kubelets from deleting their `Node` API object,
and enforces kubelet modification of labels under the `kubernetes.io/` or `k8s.io/` prefixes as follows:
-->
<p>在 Kubernetes 1.11+ 的版本中，不允许 kubelet 从 <code>Node</code> API 对象中更新或删除污点。</p>
<p>在 Kubernetes 1.13+ 的版本中，<code>NodeRestriction</code> 准入插件可防止 kubelet 删除
<code>Node</code> API 对象，并对 <code>kubernetes.io/</code> 或 <code>k8s.io/</code> 前缀标签的 kubelet
强制进行如下修改：</p>
<!--
* **Prevents** kubelets from adding/removing/updating labels with a `node-restriction.kubernetes.io/` prefix.
This label prefix is reserved for administrators to label their `Node` objects for workload isolation purposes,
and kubelets will not be allowed to modify labels with that prefix.
* **Allows** kubelets to add/remove/update these labels and label prefixes:
-->
<ul>
<li><strong>防止</strong> kubelet 添加/删除/更新带有 <code>node-restriction.kubernetes.io/</code> 前缀的标签。
保留此前缀的标签，供管理员用来标记 Node 对象以隔离工作负载，并且不允许 kubelet
修改带有该前缀的标签。</li>
<li><strong>允许</strong> kubelet 添加/删除/更新这些和这些前缀的标签：
<ul>
<li><code>kubernetes.io/hostname</code></li>
<li><code>kubernetes.io/arch</code></li>
<li><code>kubernetes.io/os</code></li>
<li><code>beta.kubernetes.io/instance-type</code></li>
<li><code>node.kubernetes.io/instance-type</code></li>
<li><code>failure-domain.beta.kubernetes.io/region</code> （已弃用）</li>
<li><code>failure-domain.beta.kubernetes.io/zone</code>  (已弃用）</li>
<li><code>topology.kubernetes.io/region</code></li>
<li><code>topology.kubernetes.io/zone</code></li>
<li><code>kubelet.kubernetes.io/</code>-prefixed labels</li>
<li><code>node.kubernetes.io/</code>-prefixed labels</li>
</ul>
</li>
</ul>
<!--
Use of any other labels under the `kubernetes.io` or `k8s.io` prefixes by kubelets is reserved, and may be disallowed or allowed by the `NodeRestriction` admission plugin in the future.

Future versions may add additional restrictions to ensure kubelets have the minimal set of permissions required to operate correctly.
-->
<p>kubelet 保留 <code>kubernetes.io</code> 或 <code>k8s.io</code> 前缀的所有标签，并且将来可能会被
<code>NodeRestriction</code> 准入插件允许或禁止。</p>
<p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p>
<h3 id="ownerreferencespermissionenforcement">OwnerReferencesPermissionEnforcement</h3>
<!--
This admission controller protects the access to the `metadata.ownerReferences` of an object
so that only users with "delete" permission to the object can change it.
This admission controller also protects the access to `metadata.ownerReferences[x].blockOwnerDeletion`
of an object, so that only users with "update" permission to the `finalizers`
subresource of the referenced *owner* can change it.
-->
<p>该准入控制器保护对 <code>metadata.ownerReferences</code> 对象的访问，以便只有对该对象具有
“删除” 权限的用户才能对其进行更改。
该准入控制器还保护对 <code>metadata.ownerReferences[x].blockOwnerDeletion</code> 对象的访问，
以便只有对所引用的 <strong>属主（owner）</strong> 的 <code>finalizers</code> 子资源具有 “更新”
权限的用户才能对其进行更改。</p>
<h3 id="persistentvolumeclaimresize">PersistentVolumeClaimResize</h3>
<!--
This admission controller implements additional validations for checking incoming `PersistentVolumeClaim` resize requests.
-->
<p>该准入控制器检查传入的 <code>PersistentVolumeClaim</code> 调整大小请求，对其执行额外的验证操作。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Support for volume resizing is available as a beta feature. As a cluster administrator,
you must ensure that the feature gate `ExpandPersistentVolumes` is set
to `true` to enable resizing.
-->
<p>对调整卷大小的支持是一种 Beta 特性。作为集群管理员，你必须确保特性门控 <code>ExpandPersistentVolumes</code>
设置为 <code>true</code> 才能启用调整大小。
</div>
<!--
After enabling the `ExpandPersistentVolumes` feature gate, enabling the `PersistentVolumeClaimResize` admission
controller is recommended, too. This admission controller prevents resizing of all claims by default unless a claim's `StorageClass`
 explicitly enables resizing by setting `allowVolumeExpansion` to `true`.

For example: all `PersistentVolumeClaim`s created from the following `StorageClass` support volume expansion:
-->
<p>启用 <code>ExpandPersistentVolumes</code> 特性门控之后，建议将 <code>PersistentVolumeClaimResize</code>
准入控制器也启用。除非 PVC 的 <code>StorageClass</code> 明确地将 <code>allowVolumeExpansion</code> 设置为
<code>true</code> 来显式启用调整大小。否则，默认情况下该准入控制器会阻止所有对 PVC 大小的调整。</p>
<p>例如：由以下 <code>StorageClass</code> 创建的所有 <code>PersistentVolumeClaim</code> 都支持卷容量扩充：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>storage.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>StorageClass<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>gluster-vol-default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">provisioner</span>:<span style="color:#bbb"> </span>kubernetes.io/glusterfs<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">parameters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resturl</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;http://192.168.10.100:8080&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">restuser</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">secretNamespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">secretName</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">allowVolumeExpansion</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><!--
For more information about persistent volume claims, see [PersistentVolumeClaims](/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims).
-->
<p>关于持久化卷申领的更多信息，请参见
<a href="/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">PersistentVolumeClaims</a>。</p>
<h3 id="persistentvolumelabel">PersistentVolumeLabel</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>


<!--
This admission controller automatically attaches region or zone labels to PersistentVolumes
as defined by the cloud provider (for example, GCE or AWS).
It helps ensure the Pods and the PersistentVolumes mounted are in the same
region and/or zone.
If the admission controller doesn't support automatic labelling your PersistentVolumes, you
may need to add the labels manually to prevent pods from mounting volumes from
a different zone. PersistentVolumeLabel is DEPRECATED and labeling persistent volumes has been taken over by
[cloud controller manager](/docs/tasks/administer-cluster/running-cloud-controller/).
Starting from 1.11, this admission controller is disabled by default.
-->
<p>该准入控制器会自动将区（region）或区域（zone）标签附加到由云提供商（如 GCE、AWS）
定义的 PersistentVolume。这有助于确保 Pod 和 PersistentVolume 位于相同的区或区域。
如果准入控制器不支持为 PersistentVolumes 自动添加标签，那你可能需要手动添加标签，
以防止 Pod 挂载其他区域的卷。
PersistentVolumeLabel 已被废弃，标记持久卷已由
<a href="/zh/docs/tasks/administer-cluster/running-cloud-controller/">云管理控制器</a>接管。
从 1.11 开始，默认情况下禁用此准入控制器。</p>
<h3 id="podnodeselector">PodNodeSelector</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.5 [alpha]</code>
</div>


<!--
This admission controller defaults and limits what node selectors may be used within a namespace by reading a namespace annotation and a global configuration.
-->
<p>该准入控制器通过读取名字空间注解和全局配置，来为名字空间中可以使用的节点选择器
设置默认值并实施限制。</p>
<!--
#### Configuration File Format

`PodNodeSelector` uses a configuration file to set options for the behavior of the backend.
Note that the configuration file format will move to a versioned file in a future release.
This file may be json or yaml and has the following format:
-->
<h4 id="配置文件格式-1">配置文件格式</h4>
<p><code>PodNodeSelector</code> 使用配置文件来设置后端行为的选项。
请注意，配置文件格式将在将来某个版本中改为版本化文件。
该文件可以是 JSON 或 YAML，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">podNodeSelectorPluginConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">clusterDefaultNodeSelector</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">namespace1</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#008000;font-weight:bold">namespace2</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span></code></pre></div><!--
Reference the `PodNodeSelector` configuration file from the file provided to the API server's command line flag `--admission-control-config-file`:
-->
<p>基于提供给 API 服务器命令行标志 <code>--admission-control-config-file</code> 的文件名，
从文件中引用 <code>PodNodeSelector</code> 配置文件：</p>
<ul class="nav nav-tabs" id="podnodeselector-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#podnodeselector-example1-0" role="tab" aria-controls="podnodeselector-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#podnodeselector-example1-1" role="tab" aria-controls="podnodeselector-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="podnodeselector-example1"><div id="podnodeselector-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="podnodeselector-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>PodNodeSelector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>podnodeselector.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="podnodeselector-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="podnodeselector-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 在 v1.17 中废弃，以鼓励使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>PodNodeSelector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>podnodeselector.yaml<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
#### Configuration Annotation Format

`PodNodeSelector` uses the annotation key `scheduler.alpha.kubernetes.io/node-selector` to assign node selectors to namespaces.
-->
<h4 id="配置注解格式">配置注解格式</h4>
<p><code>PodNodeSelector</code> 使用键为 <code>scheduler.alpha.kubernetes.io/node-selector</code> 的注解
为名字空间设置节点选择算符。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/node-selector</span>:<span style="color:#bbb"> </span>name-of-node-selector<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>namespace3<span style="color:#bbb">
</span></code></pre></div><!--
#### Internal Behavior
This admission controller has the following behavior:
-->
<h4 id="内部行为">内部行为</h4>
<p>该准入控制器行为如下：</p>
<!--
1. If the `Namespace` has an annotation with a key `scheduler.alpha.kubernetes.io/node-selector`, use its value as the
node selector.
2. If the namespace lacks such an annotation, use the `clusterDefaultNodeSelector` defined in the `PodNodeSelector`
plugin configuration file as the node selector.
3. Evaluate the pod's node selector against the namespace node selector for conflicts. Conflicts result in rejection.
4. Evaluate the pod's node selector against the namespace-specific allowed selector defined the plugin configuration file.
Conflicts result in rejection.
-->
<ol>
<li>如果 <code>Namespace</code> 的注解带有键 <code>scheduler.alpha.kubernetes.io/node-selector</code>，
则将其值用作节点选择算符。</li>
<li>如果名字空间缺少此类注解，则使用 <code>PodNodeSelector</code> 插件配置文件中定义的
<code>clusterDefaultNodeSelector</code> 作为节点选择算符。</li>
<li>评估 Pod 节点选择算符和名字空间节点选择算符是否存在冲突。存在冲突将导致拒绝。</li>
<li>评估 Pod 节点选择算符和特定于名字空间的被允许的选择算符所定义的插件配置文件是否存在冲突。
存在冲突将导致拒绝。</li>
</ol>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
PodNodeSelector allows forcing pods to run on specifically labeled nodes. Also see the PodTolerationRestriction
admission plugin, which allows preventing pods from running on specifically tainted nodes.
-->
<p>PodNodeSelector 允许 Pod 强制在特定标签的节点上运行。
另请参阅 PodTolerationRestriction 准入插件，该插件可防止 Pod 在特定污点的节点上运行。
</div>
<h3 id="podsecurity">PodSecurity</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>


<!--
This is the replacement for the deprecated [PodSecurityPolicy](#podsecuritypolicy) admission controller
defined in the next section. This admission controller acts on creation and modification of the pod and
determines if it should be admitted based on the requested security context and the 
[Pod Security Standards](/docs/concepts/security/pod-security-standards/).

See the [Pod Security Admission documentation](/docs/concepts/security/pod-security-admission/)
for more information.
-->
<p>这是下节已被废弃的 <a href="#podsecuritypolicy">PodSecurityPolicy</a> 准入控制器的替代品。
此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>
来确定是否可以执行请求。</p>
<p>更多信息请参阅 <a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全性准入控制器</a>。</p>
<h3 id="podsecuritypolicy">PodSecurityPolicy</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>


<!--
This admission controller acts on creation and modification of the pod and determines if it should be admitted
based on the requested security context and the available Pod Security Policies.
-->
<p>此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和可用的 Pod
安全策略确定是否可以执行请求。</p>
<!--
See also the [PodSecurityPolicy](/docs/concepts/security/pod-security-policy/) documentation
for more information.
-->
<p>查看 <a href="/zh/docs/concepts/security/pod-security-policy/">Pod 安全策略文档</a>
了解更多细节。</p>
<h3 id="podtolerationrestriction">PodTolerationRestriction</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.7 [alpha]</code>
</div>


<!--
The PodTolerationRestriction admission controller verifies any conflict between tolerations of a pod and the tolerations of its namespace.
It rejects the pod request if there is a conflict.
It then merges the tolerations annotated on the namespace into the tolerations of the pod.
The resulting tolerations are checked against a list of allowed tolerations annotated to the namespace.
If the check succeeds, the pod request is admitted otherwise it is rejected.
-->
<p>准入控制器 PodTolerationRestriction 检查 Pod 的容忍度与其名字空间的容忍度之间
是否存在冲突。如果存在冲突，则拒绝 Pod 请求。
然后，它将名字空间的容忍度合并到 Pod 的容忍度中，之后根据名字空间的容忍度
白名单检查所得到的容忍度结果。如果检查成功，则将接受 Pod 请求，否则拒绝该请求。</p>
<!--
If the namespace of the pod does not have any associated default tolerations or allowed
tolerations annotated, the cluster-level default tolerations or cluster-level list of allowed tolerations are used
instead if they are specified.
-->
<p>如果 Pod 的名字空间没有任何关联的默认容忍度或容忍度白名单，则使用集群级别的
默认容忍度或容忍度白名单（如果有的话）。</p>
<!--
Tolerations to a namespace are assigned via the `scheduler.alpha.kubernetes.io/defaultTolerations` annotation key.
The list of allowed tolerations can be added via the `scheduler.alpha.kubernetes.io/tolerationsWhitelist` annotation key.

Example for namespace annotations:
-->
<p>名字空间的容忍度通过注解健 <code>scheduler.alpha.kubernetes.io/defaultTolerations</code>
来设置。可接受的容忍度可以通过 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code>
注解键来添加。</p>
<p>名字空间注解的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>apps-that-need-nodes-exclusively<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/defaultTolerations</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scheduler.alpha.kubernetes.io/tolerationsWhitelist</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style="color:#bbb">
</span></code></pre></div><!--
### Priority {#priority}

The priority admission controller uses the `priorityClassName` field and populates the integer value of the priority. If the priority class is not found, the Pod is rejected.
-->
<h3 id="priority">优先级</h3>
<p>优先级准入控制器使用 <code>priorityClassName</code> 字段并用整型值填充优先级。
如果找不到优先级，则拒绝 Pod。</p>
<h3 id="resourcequota">ResourceQuota</h3>
<!--
This admission controller will observe the incoming request and ensure that it does not violate any of the constraints
enumerated in the `ResourceQuota` object in a `Namespace`.  If you are using `ResourceQuota`
objects in your Kubernetes deployment, you MUST use this admission controller to enforce quota constraints.
-->
<p>该准入控制器会监测传入的请求，并确保它不违反任何一个 <code>Namespace</code> 中的 <code>ResourceQuota</code>
对象中枚举出来的约束。
如果你在 Kubernetes 部署中使用了 <code>ResourceQuota</code>，你必须使用这个准入控制器来强制
执行配额限制。</p>
<!--
See the [resourceQuota design doc](https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md) and the [example of Resource Quota](/docs/concepts/policy/resource-quotas/) for more details.
-->
<p>请查看
<a href="https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md">resourceQuota 设计文档</a>和 <a href="/zh/docs/concepts/policy/resource-quotas/">Resource Quota 例子</a>
了解更多细节。</p>
<!--
### RuntimeClass {#runtimeclass}






<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>



If you enable the `PodOverhead` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/), and define a RuntimeClass with [Pod overhead](/docs/concepts/scheduling-eviction/pod-overhead/) configured, this admission controller checks incoming
Pods. When enabled, this admission controller rejects any Pod create requests that have the overhead already set.
For Pods that have a  RuntimeClass is configured and selected in their `.spec`, this admission controller sets `.spec.overhead` in the Pod based on the value defined in the corresponding RuntimeClass.

<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> The <code>.spec.overhead</code> field for Pod and the <code>.overhead</code> field for RuntimeClass are both in beta. If you do not enable the <code>PodOverhead</code> feature gate, all Pods are treated as if <code>.spec.overhead</code> is unset.
</div>

See also [Pod Overhead](/docs/concepts/scheduling-eviction/pod-overhead/)
for more information.
-->
<h3 id="runtimeclass">RuntimeClass</h3>
<p>+




<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>

</p>
<p>如果你开启 <code>PodOverhead</code>
<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>,
并且通过 <a href="/zh/docs/concepts/scheduling-eviction/pod-overhead/">Pod 开销</a>
配置来定义一个 RuntimeClass，这个准入控制器会检查新的 Pod。
当启用的时候，这个准入控制器会拒绝任何 overhead 字段已经设置的 Pod。
对于配置了 RuntimeClass 并在其 <code>.spec</code> 中选定 RuntimeClass 的 Pod，
此准入控制器会根据相应 RuntimeClass 中定义的值为 Pod 设置 <code>.spec.overhead</code>。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Pod 的 <code>.spec.overhead</code> 字段和 RuntimeClass 的 <code>.overhead</code> 字段均为处于 beta 版本。
如果你未启用 <code>PodOverhead</code> 特性门控，则所有 Pod 均被视为未设置 <code>.spec.overhead</code>。
</div>
<p>详情请参见 <a href="/zh/docs/concepts/scheduling-eviction/pod-overhead/">Pod 开销</a>。</p>
<h3 id="securitycontextdeny">SecurityContextDeny</h3>
<!--
This admission controller will deny any Pod that attempts to set certain escalating
[SecurityContext](/docs/reference/generated/kubernetes-api/v1.23/#securitycontext-v1-core)
fields, as shown in the
[Configure a Security Context for a Pod or Container](/docs/tasks/configure-pod-container/security-context/)
task.
If you don't use [Pod Security admission](/docs/concepts/security/pod-security-admission/),
[PodSecurityPolicies](/docs/concepts/security/pod-security-policy/), nor any external enforcement mechanism,
then you could use this admission controller to restrict the set of values a security context can take.

See [Pod Security Standards](/docs/concepts/security/pod-security-standards/) for more context on restricting
pod privileges.
-->
<p>该准入控制器将拒绝任何试图设置特定提升
<a href="/zh/docs/tasks/configure-pod-container/security-context/">SecurityContext</a>
字段的 Pod，正如任务
<a href="/zh/docs/tasks/configure-pod-container/security-context/">为 Pod 或 Container 配置安全上下文</a>
中所展示的那样。
如果集群没有使用 <a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全性准入</a>、
<a href="/zh/docs/concepts/security/pod-security-policy/">PodSecurityPolicies</a>，
也没有任何外部执行机制，那么你可以使用此准入控制器来限制安全上下文所能获取的值集。</p>
<p>有关限制 Pod 权限的更多内容，请参阅
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a>。</p>
<h3 id="serviceaccount">ServiceAccount</h3>
<!--
This admission controller implements automation for
[serviceAccounts](/docs/tasks/configure-pod-container/configure-service-account/).
We strongly recommend using this admission controller if you intend to make use of Kubernetes `ServiceAccount` objects.
-->
<p>此准入控制器实现了
<a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">ServiceAccount</a>
的自动化。
如果你打算使用 Kubernetes 的 ServiceAccount 对象，我们强烈建议你使用这个准入控制器。</p>
<h3 id="storageobjectinuseprotection">StorageObjectInUseProtection</h3>
<!--
The `StorageObjectInUseProtection` plugin adds the `kubernetes.io/pvc-protection` or `kubernetes.io/pv-protection`
finalizers to newly created Persistent Volume Claims (PVCs) or Persistent Volumes (PV).
In case a user deletes a PVC or PV the PVC or PV is not removed until the finalizer is removed
from the PVC or PV by PVC or PV Protection Controller.
Refer to the
[Storage Object in Use Protection](/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection)
for more detailed information.
-->
<p><code>StorageObjectInUseProtection</code> 插件将 <code>kubernetes.io/pvc-protection</code> 或
<code>kubernetes.io/pv-protection</code> finalizers 添加到新创建的持久化卷声明（PVC）
或持久化卷（PV）中。
如果用户尝试删除 PVC/PV，除非 PVC/PV 的保护控制器移除 finalizers，否则
PVC/PV 不会被删除。
有关更多详细信息，请参考
<a href="/zh/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection">保护使用中的存储对象</a>。</p>
<h3 id="taintnodesbycondition">TaintNodesByCondition</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>


<!--
This admission controller <a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='taints'>taints</a> newly created Nodes as `NotReady` and `NoSchedule`. That tainting avoids a race condition that could cause Pods to be scheduled on new Nodes before their taints were updated to accurately reflect their reported conditions.
-->
<p>该准入控制器为新创建的节点添加 <code>NotReady</code> 和 <code>NoSchedule</code>
<a class='glossary-tooltip' title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/scheduling-eviction/taint-and-toleration/' target='_blank' aria-label='污点'>污点</a>。
这些污点能够避免一些竞态条件的发生，这类静态条件可能导致 Pod 在更新节点污点以准确
反映其所报告状况之前，就被调度到新节点上。</p>
<h3 id="validatingadmissionwebhook">ValidatingAdmissionWebhook</h3>
<!--
This admission controller calls any validating webhooks which match the request. Matching
webhooks are called in parallel; if any of them rejects the request, the request
fails. This admission controller only runs in the validation phase; the webhooks it calls may not
mutate the object, as opposed to the webhooks called by the `MutatingAdmissionWebhook` admission controller.
-->
<p>该准入控制器调用与请求匹配的所有验证 Webhook。
匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。
该准入控制器仅在验证（Validating）阶段运行；与 <code>MutatingAdmissionWebhook</code> 准入控制器
所调用的 Webhook 相反，它调用的 Webhook 应该不会使对象出现变更。</p>
<!--
If a webhook called by this has side effects (for example, decrementing quota) it
*must* have a reconciliation system, as it is not guaranteed that subsequent
webhooks or other validating admission controllers will permit the request to finish.
-->
<p>如果以此方式调用的 Webhook 有其它作用（如，降低配额），则它必须具有协调机制。
这是因为无法保证后续的 Webhook 或其他有效的准入控制器都允许请求完成。</p>
<!--
If you disable the ValidatingAdmissionWebhook, you must also disable the
`ValidatingWebhookConfiguration` object in the `admissionregistration.k8s.io/v1`
group/version via the `--runtime-config` flag (both are on by default in
versions 1.9 and later).
-->
<p>如果你禁用了 ValidatingAdmissionWebhook，还必须通过 <code>--runtime-config</code> 标志来禁用
<code>admissionregistration.k8s.io/v1</code> 组/版本中的  <code>ValidatingWebhookConfiguration</code>
对象（默认情况下在 1.9 版和更高版本中均处于启用状态）。</p>
<!--
## Is there a recommended set of admission controllers to use?

Yes. The recommended admission controllers are enabled by default (shown [here](/docs/reference/command-line-tools-reference/kube-apiserver/#options)), so you do not need to explicitly specify them. You can enable additional admission controllers beyond the default set using the `--enable-admission-plugins` flag (**order doesn't matter**).
-->
<h2 id="有推荐的准入控制器吗">有推荐的准入控制器吗？</h2>
<p>有。推荐使用的准入控制器默认情况下都处于启用状态
（请查看<a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver/#options">这里</a>）。
因此，你无需显式指定它们。
你可以使用 <code>--enable-admission-plugins</code> 标志（ <strong>顺序不重要</strong> ）来启用默认设置以外的其他准入控制器。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
`--admission-control` was deprecated in 1.10 and replaced with `--enable-admission-plugins`.
-->
<p><code>--admission-control</code> 在 1.10 中已废弃，由 <code>--enable-admission-plugins</code> 取代。
</div>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d04751f776f1faa6a82bbb7f0a200950">5 - 动态准入控制</h1>
    
	<!--
title: Dynamic Admission Control
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
In addition to [compiled-in admission plugins](/docs/reference/access-authn-authz/admission-controllers/),
admission plugins can be developed as extensions and run as webhooks configured at runtime.
This page describes how to build, configure, use, and monitor admission webhooks.
-->
<p>除了<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">内置的 admission 插件</a>，
准入插件可以作为扩展独立开发，并以运行时所配置的 Webhook 的形式运行。
此页面描述了如何构建、配置、使用和监视准入 Webhook。</p>
<!-- body -->
<!--
## What are admission webhooks?
-->
<h2 id="什么是准入-webhook">什么是准入 Webhook？</h2>
<!--
Admission webhooks are HTTP callbacks that receive admission requests and do
something with them. You can define two types of admission webhooks,
[validating admission Webhook](/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook)
and
[mutating admission webhook](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook).
Mutating admission Webhooks are invoked first, and can modify objects sent to the API server to enforce custom defaults.
-->
<p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。
可以定义两种类型的准入 webhook，即
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">验证性质的准入 Webhook</a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">修改性质的准入 Webhook</a>。
修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API
服务器的对象以执行自定义的设置默认值操作。</p>
<!--
After all object modifications are complete, and after the incoming object is validated by the API server,
validating admission webhooks are invoked and can reject requests to enforce custom policies.
-->
<p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后，
验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p>
<!--
Admission webhooks that need to guarantee they see the final state of the object in order to enforce policy
should use a validating admission webhook, since objects can be modified after being seen by mutating webhooks.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。
则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。
</div>
<!--
### Experimenting with admission webhooks

Admission webhooks are essentially part of the cluster control-plane. You should
write and deploy them with great caution. Please read the [user
guides](/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server) for
instructions if you intend to write/deploy production-grade admission webhooks.
In the following, we describe how to quickly experiment with admission webhooks.
-->
<h3 id="尝试准入-webhook">尝试准入 Webhook</h3>
<p>准入 Webhook 本质上是集群控制平面的一部分。你应该非常谨慎地编写和部署它们。
如果你打算编写或者部署生产级准入 webhook，请阅读<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server">用户指南</a>以获取相关说明。
在下文中，我们将介绍如何快速试验准入 Webhook。</p>
<!--
### Prerequisites

* Ensure that the Kubernetes cluster is at least as new as v1.16 (to use `admissionregistration.k8s.io/v1`),
  or v1.9 (to use `admissionregistration.k8s.io/v1beta1`).

* Ensure that MutatingAdmissionWebhook and ValidatingAdmissionWebhook
  admission controllers are enabled.
  [Here](/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use)
  is a recommended set of admission controllers to enable in general.

* Ensure that the admissionregistration.k8s.io/v1beta1 API is enabled.
-->
<h3 id="prerequisites">先决条件</h3>
<ul>
<li>
<p>确保 Kubernetes 集群版本至少为 v1.16（以便使用 <code>admissionregistration.k8s.io/v1</code> API） 或者 v1.9 （以便使用 <code>admissionregistration.k8s.io/v1beta1</code> API）。</p>
</li>
<li>
<p>确保启用 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook 控制器。
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use">这里</a>
是一组推荐的 admission 控制器，通常可以启用。</p>
</li>
<li>
<p>确保启用了 <code>admissionregistration.k8s.io/v1beta1</code> API。</p>
</li>
</ul>
<!--
### Write an admission webhook server
-->
<h3 id="编写一个准入-webhook-服务器">编写一个准入 Webhook 服务器</h3>
<!--
Please refer to the implementation of the [admission webhook
server](https://github.com/kubernetes/kubernetes/blob/release-1.21/test/images/agnhost/webhook/main.go)
that is validated in a Kubernetes e2e test. The webhook handles the
`AdmissionReview` request sent by the apiservers, and sends back its decision
as an `AdmissionReview` object in the same version it received.
-->
<p>请参阅 Kubernetes e2e 测试中的
<a href="https://github.com/kubernetes/kubernetes/blob/release-1.21/test/images/agnhost/webhook/main.go">admission webhook 服务器</a>
的实现。webhook 处理由 apiserver 发送的 <code>AdmissionReview</code> 请求，并且将其决定
作为 <code>AdmissionReview</code> 对象以相同版本发送回去。</p>
<!--
See the [webhook request](#request) section for details on the data sent to webhooks.
-->
<p>有关发送到 webhook 的数据的详细信息，请参阅 <a href="#request">webhook 请求</a>。</p>
<!--
See the [webhook response](#response) section for the data expected from webhooks.
-->
<p>要获取来自 webhook 的预期数据，请参阅 <a href="#response">webhook 响应</a>。</p>
<!--
The example admission webhook server leaves the `ClientAuth` field
[empty](https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/images/agnhost/webhook/config.go#L38-L39),
which defaults to `NoClientCert`. This means that the webhook server does not
authenticate the identity of the clients, supposedly apiservers. If you need
mutual TLS or other ways to authenticate the clients, see
how to [authenticate apiservers](#authenticate-apiservers).
-->
<p>示例准入 Webhook 服务器置 <code>ClientAuth</code> 字段为
<a href="https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/images/agnhost/webhook/config.go#L38-L39">空</a>，
默认为 <code>NoClientCert</code> 。这意味着 webhook 服务器不会验证客户端的身份，认为其是 apiservers。
如果你需要双向 TLS 或其他方式来验证客户端，请参阅
如何<a href="#authenticate-apiservers">对 apiservers 进行身份认证</a>。</p>
<!--
### Deploy the admission webhook service
-->
<h3 id="部署准入-webhook-服务">部署准入 Webhook 服务</h3>
<!--
The webhook server in the e2e test is deployed in the Kubernetes cluster, via
the [deployment API](/docs/reference/generated/kubernetes-api/v1.23/#deployment-v1-apps).
The test also creates a [service](/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core)
as the front-end of the webhook server. See
[code](https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/e2e/apimachinery/webhook.go#L748).
-->
<p>e2e 测试中的 webhook 服务器通过
<a href="/docs/reference/generated/kubernetes-api/v1.23/#deployment-v1-apps">deployment API</a>
部署在 Kubernetes 集群中。该测试还将创建一个
<a href="/docs/reference/generated/kubernetes-api/v1.23/#service-v1-core">service</a>
作为 webhook 服务器的前端。参见
<a href="https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/e2e/apimachinery/webhook.go#L748">相关代码</a>。</p>
<!--
You may also deploy your webhooks outside of the cluster. You will need to update
your webhook configurations accordingly.
-->
<p>你也可以在集群外部署 webhook。这样做需要相应地更新你的 webhook 配置。</p>
<!--
### Configure准入 Webhooks on the fly
-->
<h3 id="即时配置准入-webhook">即时配置准入 Webhook</h3>
<!--
You can dynamically configure what resources are subject to what admission
webhooks via
[ValidatingWebhookConfiguration](/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io)
or
[MutatingWebhookConfiguration](/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io).
-->
<p>你可以通过
<a href="/docs/reference/generated/kubernetes-api/v1.23/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a>
或者
<a href="/docs/reference/generated/kubernetes-api/v1.23/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io">MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。</p>
<!--
The following is an example `ValidatingWebhookConfiguration`, a mutating webhook configuration is similar.
See the [webhook configuration](#webhook-configuration) section for details about each config field.
-->
<p>以下是一个 <code>ValidatingWebhookConfiguration</code> 示例，mutating webhook 配置与此类似。有关每个配置字段的详细信息，请参阅 <a href="#webhook-configuration">webhook 配置</a> 部分。</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-example-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-example-1-0" role="tab" aria-controls="validatingwebhookconfiguration-example-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-example-1-1" role="tab" aria-controls="validatingwebhookconfiguration-example-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-example-1"><div id="validatingwebhookconfiguration-example-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-example-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb">  </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb">       </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-namespace&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-service&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>None<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-example-1-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-example-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;pod-policy.example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb">  </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">   </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb">       </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-namespace&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;example-service&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
The scope field specifies if only cluster-scoped resources ("Cluster") or namespace-scoped
resources ("Namespaced") will match this rule. "&lowast;" means that there are no scope restrictions.
-->
<p>scope 字段指定是仅集群范围的资源（Cluster）还是名字空间范围的资源资源（Namespaced）将与此规则匹配。<code>*</code> 表示没有范围限制。</p>
<!--
When using `clientConfig.service`, the server cert must be valid for
`<svc_name>.<svc_namespace>.svc`.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 当使用 <code>clientConfig.service</code> 时，服务器证书必须对 <code>&lt;svc_name&gt;.&lt;svc_namespace&gt;.svc</code> 有效。
</div>
<!--
Default timeout for a webhook call is 10 seconds for webhooks registered created using `admissionregistration.k8s.io/v1`,
and 30 seconds for webhooks created using `admissionregistration.k8s.io/v1beta1`. Starting in kubernetes 1.14 you
can set the timeout and it is encouraged to use a small timeout for webhooks.
If the webhook call times out, the request is handled according to the webhook's
failure policy.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 对于使用 <code>admissionregistration.k8s.io/v1</code> 创建的 webhook 而言，其 webhook 调用的默认超时是 10 秒；
对于使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的 webhook 而言，其默认超时是 30 秒。
从 kubernetes 1.14 开始，可以设置超时。建议对 webhooks 设置较短的超时时间。
如果 webhook 调用超时，则根据 webhook 的失败策略处理请求。
</div>
<!--
When an apiserver receives a request that matches one of the `rules`, the
apiserver sends an `admissionReview` request to webhook as specified in the
`clientConfig`.

After you create the webhook configuration, the system will take a few seconds
to honor the new configuration.
-->
<p>当 apiserver 收到与 <code>rules</code> 相匹配的请求时，apiserver 按照 <code>clientConfig</code> 中指定的方式向 webhook 发送一个 <code>admissionReview</code> 请求。</p>
<p>创建 webhook 配置后，系统将花费几秒钟使新配置生效。</p>
<!--
### Authenticate apiservers
-->
<h3 id="authenticate-apiservers">对 apiservers 进行身份认证</h3>
<!--
If your admission webhooks require authentication, you can configure the
apiservers to use basic auth, bearer token, or a cert to authenticate itself to
the webhooks. There are three steps to complete the configuration.
-->
<p>如果你的 webhook 需要身份验证，则可以将 apiserver 配置为使用基本身份验证、持有者令牌或证书来向 webhook 提供身份证明。完成此配置需要三个步骤。</p>
<!--
* When starting the apiserver, specify the location of the admission control
  configuration file via the `--admission-control-config-file` flag.

* In the admission control configuration file, specify where the
  MutatingAdmissionWebhook controller and ValidatingAdmissionWebhook controller
  should read the credentials. The credentials are stored in kubeConfig files
  (yes, the same schema that's used by kubectl), so the field name is
  `kubeConfigFile`. Here is an example admission control configuration file:
-->
<ul>
<li>
<p>启动 apiserver 时，通过 <code>--admission-control-config-file</code> 参数指定准入控制配置文件的位置。</p>
</li>
<li>
<p>在准入控制配置文件中，指定 MutatingAdmissionWebhook 控制器和 ValidatingAdmissionWebhook 控制器应该读取凭据的位置。
凭证存储在 kubeConfig 文件中（是​​的，与 kubectl 使用的模式相同），因此字段名称为 <code>kubeConfigFile</code>。
以下是一个准入控制配置文件示例：</p>
</li>
</ul>
<!--
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1, kind=WebhookAdmissionConfiguration
# Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1, kind=WebhookAdmissionConfiguration
-->
<ul class="nav nav-tabs" id="admissionconfiguration-example1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionconfiguration-example1-0" role="tab" aria-controls="admissionconfiguration-example1-0" aria-selected="true">apiserver.config.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionconfiguration-example1-1" role="tab" aria-controls="admissionconfiguration-example1-1">apiserver.k8s.io/v1alpha1</a></li></ul>
<div class="tab-content" id="admissionconfiguration-example1"><div id="admissionconfiguration-example1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionconfiguration-example1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ValidatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MutatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></div>
  <div id="admissionconfiguration-example1-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionconfiguration-example1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>AdmissionConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">plugins</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>ValidatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmission<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>MutatingAdmissionWebhook<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">configuration</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apiserver.config.k8s.io/v1alpha1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>WebhookAdmission<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubeConfigFile</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
For more information about `AdmissionConfiguration`, see the
[AdmissionConfiguration (v1) reference](/docs/reference/config-api/apiserver-webhookadmission.v1/).
See the [webhook configuration](#webhook-configuration) section for details about each config field.

* In the kubeConfig file, provide the credentials:
-->
<p>有关 <code>AdmissionConfiguration</code> 的更多信息，请参见
<a href="/docs/reference/config-api/apiserver-webhookadmission.v1/">AdmissionConfiguration (v1) reference</a>。
有关每个配置字段的详细信息，请参见 <a href="#webhook-%E9%85%8D%E7%BD%AE">webhook 配置</a>部分。</p>
<ul>
<li>
<p>在 kubeConfig 文件中，提供证书凭据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 名称应设置为服务的 DNS 名称或配置了 Webhook 的 URL 的主机名（包括端口）。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 如果将非 443 端口用于服务，则在配置 1.16+ API 服务器时，该端口必须包含在名称中。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置在默认端口（443）上与服务对话的 Webhook，请指定服务的 DNS 名称：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置在非默认端口（例如 8443）上与服务对话的 Webhook，请在 1.16+ 中指定服务的 DNS 名称和端口：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc:8443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 并可以选择仅使用服务的 DNS 名称来创建第二节，以与 1.15 API 服务器版本兼容：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: webhook1.ns1.svc</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 对于配置为使用 URL 的 webhook，请匹配在 webhook 的 URL 中指定的主机（和端口）。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com:443` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com:443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 带有 `url: https://www.example.com:8443` 的 webhook：</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># - name: www.example.com:8443</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#   user: ...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic">#</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;webhook1.ns1.svc&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate-data</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;pem encoded certificate&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key-data</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;pem encoded key&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># `name` 支持使用 * 通配符匹配前缀段。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*.webhook-company.org&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">password</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;password&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">username</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;name&gt;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># &#39;*&#39; 是默认匹配项。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;*&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">token</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&lt;token&gt;&#34;</span><span style="color:#bbb">
</span></code></pre></div></li>
</ul>
<!--
Of course you need to set up the webhook server to handle these authentications.
-->
<p>当然，你需要设置 webhook 服务器来处理这些身份验证。</p>
<!--
### Request

Webhooks are sent as POST request, with `Content-Type: application/json`,
with an `AdmissionReview` API object in the `admission.k8s.io` API group
serialized to JSON as the body.

Webhooks can specify what versions of `AdmissionReview` objects they accept
with the `admissionReviewVersions` field in their configuration:
-->
<h3 id="request">请求</h3>
<p>Webhook 发送 POST 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code>  API 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 JSON 作为请求的主体。</p>
<p>Webhook 可以在配置中的 <code>admissionReviewVersions</code> 字段指定可接受的 <code>AdmissionReview</code> 对象版本：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-admissionreviewversions" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-admissionreviewversions-0" role="tab" aria-controls="validatingwebhookconfiguration-admissionreviewversions-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-admissionreviewversions-1" role="tab" aria-controls="validatingwebhookconfiguration-admissionreviewversions-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-admissionreviewversions"><div id="validatingwebhookconfiguration-admissionreviewversions-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-admissionreviewversions-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
`admissionReviewVersions` is a required field when creating
`admissionregistration.k8s.io/v1` webhook configurations.
Webhooks are required to support at least one `AdmissionReview`
version understood by the current and previous API server.
-->
<p>创建 <code>admissionregistration.k8s.io/v1</code> webhook 配置时，<code>admissionReviewVersions</code> 是必填字段。
Webhook 必须支持至少一个当前和以前的 apiserver 都可以解析的 <code>AdmissionReview</code> 版本。</p>
</div>
  <div id="validatingwebhookconfiguration-admissionreviewversions-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-admissionreviewversions-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">admissionReviewVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
If no `admissionReviewVersions` are specified, the default when creating
`admissionregistration.k8s.io/v1beta1` webhook configurations is `v1beta1`.
-->
<p>如果未指定 <code>admissionReviewVersions</code>，则创建 <code>admissionregistration.k8s.io/v1beta1</code> Webhook 配置时的默认值为 <code>v1beta1</code>。</p>
</div></div>

<!--
API servers send the first `AdmissionReview` version in the `admissionReviewVersions` list they support.
If none of the versions in the list are supported by the API server, the configuration will not be allowed to be created.
If an API server encounters a webhook configuration that was previously created and does not support any of the `AdmissionReview`
versions the API server knows how to send, attempts to call to the webhook will fail and be subject to the [failure policy](#failure-policy).

This example shows the data contained in an `AdmissionReview` object
for a request to update the `scale` subresource of an `apps/v1` `Deployment`:
-->
<p>API 服务器将发送的是 <code>admissionReviewVersions</code> 列表中所支持的第一个 <code>AdmissionReview</code> 版本。如果 API 服务器不支持列表中的任何版本，则不允许创建配置。</p>
<p>如果 API 服务器遇到以前创建的 Webhook 配置，并且不支持该 API 服务器知道如何发送的任何 <code>AdmissionReview</code> 版本，则调用 Webhook 的尝试将失败，并依据<a href="#failure-policy">失败策略</a>进行处理。</p>
<p>此示例显示了 <code>AdmissionReview</code> 对象中包含的数据，该数据用于请求更新 <code>apps/v1</code> <code>Deployment</code> 的 <code>scale</code> 子资源：</p>
<ul class="nav nav-tabs" id="admissionreview-request" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-request-0" role="tab" aria-controls="admissionreview-request-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-request-1" role="tab" aria-controls="admissionreview-request-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-request"><div id="admissionreview-request-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-request-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">{<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;AdmissionReview&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;request&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 唯一标识此准入回调的随机 uid</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 传入完全正确的 group/version/kind 对象</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 修改 resource 的完全正确的的 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;resource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;subResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定 `matchPolicy: Equivalent` 且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `kind` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestKind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestResource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestSubResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 被修改资源的名称</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;name&#34;: </span><span style="color:#b44">&#34;my-deployment&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;namespace&#34;: </span><span style="color:#b44">&#34;my-namespace&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;operation&#34;: </span><span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;userInfo&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;username&#34;: </span><span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;014fbff9a07c&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;groups&#34;: </span>[<span style="color:#b44">&#34;system:authenticated&#34;</span>,<span style="color:#b44">&#34;my-admin-group&#34;</span>],<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;extra&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#b44">&#34;some-key&#34;</span>:[<span style="color:#b44">&#34;some-value1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;some-value2&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># object 是被接纳的新对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 DELETE 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;object&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># oldObject 是现有对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CREATE 和 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;oldObject&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;options&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;meta.k8s.io/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;UpdateOptions&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;dryRun&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="admissionreview-request-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-request-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">{<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admission.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;AdmissionReview&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">&#34;request&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 唯一标识此准入回调的随机 uid</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 传入完全正确的 group/version/kind 对象</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 修改 resource 的完全正确的的 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;resource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;subResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 Webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 Webhook 注册的版本时，这与 `kind` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestKind&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;autoscaling&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestResource&#34;: </span>{<span style="color:#b44">&#34;group&#34;</span>:<span style="color:#b44">&#34;apps&#34;</span>,<span style="color:#b44">&#34;version&#34;</span>:<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#b44">&#34;resource&#34;</span>:<span style="color:#b44">&#34;deployments&#34;</span>},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># subResource（如果请求是针对 subResource 的）</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;requestSubResource&#34;: </span><span style="color:#b44">&#34;scale&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 被修改资源的名称</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;name&#34;: </span><span style="color:#b44">&#34;my-deployment&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;namespace&#34;: </span><span style="color:#b44">&#34;my-namespace&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;operation&#34;: </span><span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;userInfo&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;username&#34;: </span><span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;uid&#34;: </span><span style="color:#b44">&#34;014fbff9a07c&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;groups&#34;: </span>[<span style="color:#b44">&#34;system:authenticated&#34;</span>,<span style="color:#b44">&#34;my-admin-group&#34;</span>],<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">&#34;extra&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#b44">&#34;some-key&#34;</span>:[<span style="color:#b44">&#34;some-value1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;some-value2&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># object 是被接纳的新对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 DELETE 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;object&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># oldObject 是现有对象。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CREATE 和 CONNECT 操作（对于 v1.15.0 之前版本的 API 服务器中的 DELETE 操作），它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;oldObject&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;autoscaling/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Scale&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 对于 CONNECT 操作，它为 null。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 仅由 v1.15+ API 服务器发送。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;options&#34;: </span>{<span style="color:#b44">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;meta.k8s.io/v1&#34;</span>,<span style="color:#b44">&#34;kind&#34;</span>:<span style="color:#b44">&#34;UpdateOptions&#34;</span>,...},<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;dryRun&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>}<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Response
-->
<h3 id="response">响应</h3>
<!--
Webhooks respond with a 200 HTTP status code, `Content-Type: application/json`,
and a body containing an `AdmissionReview` object (in the same version they were sent),
with the `response` stanza populated, serialized to JSON.
-->
<p>Webhook 使用 HTTP 200 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 JSON 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。</p>
<!--
At a minimum, the `response` stanza must contain the following fields:

* `uid`, copied from the `request.uid` sent to the webhook
* `allowed`, either set to `true` or `false`

Example of a minimal response from a webhook to allow a request:
-->
<p><code>response</code> 至少必须包含以下字段：</p>
<ul>
<li><code>uid</code>，从发送到 webhook 的 <code>request.uid</code> 中复制而来</li>
<li><code>allowed</code>，设置为 <code>true</code> 或 <code>false</code></li>
</ul>
<!--
Example of a minimal response from a webhook to allow a request:
-->
<p>Webhook 允许请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id="admissionreview-response-allow" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-allow-0" role="tab" aria-controls="admissionreview-response-allow-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-allow-1" role="tab" aria-controls="admissionreview-response-allow-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-allow"><div id="admissionreview-response-allow-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-allow-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-allow-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-allow-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div></div></div>

<!--
Example of a minimal response from a webhook to forbid a request:
-->
<p>Webhook 禁止请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id="admissionreview-response-forbid-minimal" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-forbid-minimal-0" role="tab" aria-controls="admissionreview-response-forbid-minimal-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-forbid-minimal-1" role="tab" aria-controls="admissionreview-response-forbid-minimal-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-forbid-minimal"><div id="admissionreview-response-forbid-minimal-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-forbid-minimal-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-forbid-minimal-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-forbid-minimal-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
  }
}
</code></pre></div></div></div>

<!--
When rejecting a request, the webhook can customize the http code and message returned to the user using the `status` field.
The specified status object is returned to the user.
See the [API documentation](/docs/reference/generated/kubernetes-api/v1.14/#status-v1-meta) for details about the status type.
Example of a response to forbid a request, customizing the HTTP status code and message presented to the user:
-->
<p>当拒绝请求时，Webhook 可以使用 <code>status</code> 字段自定义 http 响应码和返回给用户的消息。
有关状态类型的详细信息，请参见
<a href="/docs/reference/generated/kubernetes-api/v1.23/#status-v1-meta">API 文档</a>。
禁止请求的响应示例，它定制了向用户显示的 HTTP 状态码和消息：</p>
<ul class="nav nav-tabs" id="admissionreview-response-forbid-details" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-forbid-details-0" role="tab" aria-controls="admissionreview-response-forbid-details-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-forbid-details-1" role="tab" aria-controls="admissionreview-response-forbid-details-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-forbid-details"><div id="admissionreview-response-forbid-details-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-forbid-details-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;code&#34;</span>: <span style="color:#666">403</span>,
      <span style="color:#008000;font-weight:bold">&#34;message&#34;</span>: <span style="color:#b44">&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-forbid-details-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-forbid-details-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;code&#34;</span>: <span style="color:#666">403</span>,
      <span style="color:#008000;font-weight:bold">&#34;message&#34;</span>: <span style="color:#b44">&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div></div>

<!--
When allowing a request, a mutating admission webhook may optionally modify the incoming object as well.
This is done using the `patch` and `patchType` fields in the response.
The only currently supported `patchType` is `JSONPatch`.
See [JSON patch](http://jsonpatch.com/) documentation for more details.
For `patchType: JSONPatch`, the `patch` field contains a base64-encoded array of JSON patch operations.
-->
<p>当允许请求时，mutating准入 Webhook 也可以选择修改传入的对象。
这是通过在响应中使用 <code>patch</code> 和 <code>patchType</code> 字段来完成的。
当前唯一支持的 <code>patchType</code> 是 <code>JSONPatch</code>。
有关更多详细信息，请参见 <a href="https://jsonpatch.com/">JSON patch</a>。
对于 <code>patchType: JSONPatch</code>，<code>patch</code> 字段包含一个以 base64 编码的 JSON patch 操作数组。</p>
<!--
As an example, a single patch operation that would set `spec.replicas` would be `[{"op": "add", "path": "/spec/replicas", "value": 3}]`

Base64-encoded, this would be `W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=`
-->
<p>例如，设置 <code>spec.replicas</code> 的单个补丁操作将是
<code>[{&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/spec/replicas&quot;, &quot;value&quot;: 3}]</code>。</p>
<p>如果以 Base64 形式编码，结果将是
<code>W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=</code></p>
<!--
So a webhook response to add that label would be:
-->
<p>因此，添加该标签的 webhook 响应为：
<ul class="nav nav-tabs" id="admissionreview-response-modify" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#admissionreview-response-modify-0" role="tab" aria-controls="admissionreview-response-modify-0" aria-selected="true">admission.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#admissionreview-response-modify-1" role="tab" aria-controls="admissionreview-response-modify-1">admission.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="admissionreview-response-modify"><div id="admissionreview-response-modify-0" class="tab-pane show active" role="tabpanel" aria-labelledby="admissionreview-response-modify-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;patchType&#34;</span>: <span style="color:#b44">&#34;JSONPatch&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;patch&#34;</span>: <span style="color:#b44">&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div>
  <div id="admissionreview-response-modify-1" class="tab-pane" role="tabpanel" aria-labelledby="admissionreview-response-modify-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;AdmissionReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;response&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;uid&#34;</span>: <span style="color:#b44">&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;patchType&#34;</span>: <span style="color:#b44">&#34;JSONPatch&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;patch&#34;</span>: <span style="color:#b44">&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div></div>
</p>
<!--
## Webhook configuration
-->
<h2 id="webhook-configuration">Webhook 配置</h2>
<!--
To register admission webhooks, create `MutatingWebhookConfiguration` or `ValidatingWebhookConfiguration` API objects.

Each configuration can contain one or more webhooks.
If multiple webhooks are specified in a single configuration, each should be given a unique name.
This is required in `admissionregistration.k8s.io/v1`, but strongly recommended when using `admissionregistration.k8s.io/v1beta1`,
in order to make resulting audit logs and metrics easier to match up to active configurations.

Each webhook defines the following things.
-->
<p>要注册准入 Webhook，请创建 <code>MutatingWebhookConfiguration</code> 或
<code>ValidatingWebhookConfiguration</code> API 对象。</p>
<p>每种配置可以包含一个或多个 Webhook。如果在单个配置中指定了多个
Webhook，则应为每个 webhook 赋予一个唯一的名称。
这在 <code>admissionregistration.k8s.io/v1</code> 中是必需的，但是在使用
<code>admissionregistration.k8s.io/v1beta1</code> 时强烈建议使用，
以使生成的审核日志和指标更易于与活动配置相匹配。</p>
<p>每个 Webhook 定义以下内容。</p>
<!--
### Matching requests: rules
-->
<h3 id="matching-requests-rules">匹配请求-规则</h3>
<!--
Each webhook must specify a list of rules used to determine if a request to the API server should be sent to the webhook.
Each rule specifies one or more operations, apiGroups, apiVersions, and resources, and a resource scope:
-->
<p>每个 webhook 必须指定用于确定是否应将对 apiserver 的请求发送到 webhook 的规则列表。
每个规则都指定一个或多个 operations、apiGroups、apiVersions 和 resources 以及资源的 scope：</p>
<!--
* `operations` lists one or more operations to match. Can be `"CREATE"`, `"UPDATE"`, `"DELETE"`, `"CONNECT"`, or `"*"` to match all.
* `apiGroups` lists one or more API groups to match. `""` is the core API group. `"*"` matches all API groups.
* `apiVersions` lists one or more API versions to match. `"*"` matches all API versions.
* `resources` lists one or more resources to match.
    * `"*"` matches all resources, but not subresources.
    * `"*/*"` matches all resources and subresources.
    * `"pods/*"` matches all subresources of pods.
    * `"*/status"` matches all status subresources.
* `scope` specifies a scope to match. Valid values are `"Cluster"`, `"Namespaced"`, and `"*"`. Subresources match the scope of their parent resource. Supported in v1.14+. Default is `"*"`, matching pre-1.14 behavior.
    * `"Cluster"` means that only cluster-scoped resources will match this rule (Namespace API objects are cluster-scoped).
    * `"Namespaced"` means that only namespaced resources will match this rule.
    * `"*"` means that there are no scope restrictions.
-->
<ul>
<li><code>operations</code> 列出一个或多个要匹配的操作。
可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CONNECT</code> 或 <code>*</code> 以匹配所有内容。</li>
<li><code>apiGroups</code> 列出了一个或多个要匹配的 API 组。<code>&quot;&quot;</code> 是核心 API 组。<code>&quot;*&quot;</code> 匹配所有 API 组。</li>
<li><code>apiVersions</code> 列出了一个或多个要匹配的 API 版本。<code>&quot;*&quot;</code> 匹配所有 API 版本。</li>
<li><code>resources</code> 列出了一个或多个要匹配的资源。
<ul>
<li><code>&quot;*&quot;</code> 匹配所有资源，但不包括子资源。</li>
<li><code>&quot;*/*&quot;</code> 匹配所有资源，包括子资源。</li>
<li><code>&quot;pods/*&quot;</code> 匹配 pod 的所有子资源。</li>
<li><code>&quot;*/status&quot;</code> 匹配所有 status 子资源。</li>
</ul>
</li>
<li><code>scope</code> 指定要匹配的范围。有效值为 <code>&quot;Cluster&quot;</code>、<code>&quot;Namespaced&quot;</code> 和 <code>&quot;*&quot;</code>。
子资源匹配其父资源的范围。在 Kubernetes v1.14+ 版本中才被支持。
默认值为 <code>&quot;*&quot;</code>，对应 1.14 版本之前的行为。
<ul>
<li><code>&quot;Cluster&quot;</code> 表示只有集群作用域的资源才能匹配此规则（API 对象 Namespace 是集群作用域的）。</li>
<li><code>&quot;Namespaced&quot;</code> 意味着仅具有名字空间的资源才符合此规则。</li>
<li><code>&quot;*&quot;</code> 表示没有范围限制。</li>
</ul>
</li>
</ul>
<!--
If an incoming request matches one of the specified operations, groups, versions, resources, and scope for any of a webhook's rules, the request is sent to the webhook.

Here are other examples of rules that could be used to specify which resources should be intercepted.

Match `CREATE` or `UPDATE` requests to `apps/v1` and `apps/v1beta1` `deployments` and `replicasets`:
-->
<p>如果传入请求与任何 Webhook 规则的指定操作、组、版本、资源和范围匹配，则该请求将发送到 Webhook。</p>
<p>以下是可用于指定应拦截哪些资源的规则的其他示例。</p>
<p>匹配针对 <code>apps/v1</code> 和 <code>apps/v1beta1</code> 组中 <code>deployments</code> 和 <code>replicasets</code>
资源的 <code>CREATE</code> 或 <code>UPDATE</code> 请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-1-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-1-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-1"><div id="validatingwebhookconfiguration-rules-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;replicasets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-1-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;v1beta1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;replicasets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Match create requests for all resources (but not subresources) in all API groups and versions:
-->
<p>匹配所有 API 组和版本中的所有资源（但不包括子资源）的创建请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-2-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-2-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-2"><div id="validatingwebhookconfiguration-rules-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Match update requests for all `status` subresources in all API groups and versions:
-->
<p>匹配所有 API 组和版本中所有 <code>status</code> 子资源的更新请求：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-rules-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-rules-2-0" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-rules-2-1" role="tab" aria-controls="validatingwebhookconfiguration-rules-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-rules-2"><div id="validatingwebhookconfiguration-rules-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*/status&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-rules-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-rules-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;UPDATE&#34;</span>]<span style="color:#bbb"> 
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*/status&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Matching requests: objectSelector
-->
<h3 id="matching-requests-objectselector">匹配请求：objectSelector</h3>
<!--
In v1.15+, webhooks may optionally limit which requests are intercepted based on the labels of the
objects they would be sent, by specifying an `objectSelector`. If specified, the objectSelector
is evaluated against both the object and oldObject that would be sent to the webhook,
and is considered to match if either object matches the selector.
-->
<p>在版本 v1.15+ 中, 通过指定 <code>objectSelector</code>，Webhook 能够根据
可能发送的对象的标签来限制哪些请求被拦截。
如果指定，则将对 <code>objectSelector</code> 和可能发送到 Webhook 的 object 和 oldObject
进行评估。如果两个对象之一与选择器匹配，则认为该请求已匹配。</p>
<!--
A null object (oldObject in the case of create, or newObject in the case of delete),
or an object that cannot have labels (like a `DeploymentRollback` or a `PodProxyOptions` object)
is not considered to match.
-->
<p>空对象（对于创建操作而言为 oldObject，对于删除操作而言为 newObject），
或不能带标签的对象（例如 <code>DeploymentRollback</code> 或 <code>PodProxyOptions</code> 对象）
被认为不匹配。</p>
<!--
Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels.
-->
<p>仅当选择使用 webhook 时才使用对象选择器，因为最终用户可以通过设置标签来
跳过准入 Webhook。</p>
<!--
This example shows a mutating webhook that would match a `CREATE` of any resource with the label `foo: bar`:
-->
<p>这个例子展示了一个 mutating webhook，它将匹配带有标签 <code>foo:bar</code> 的任何资源的
<code>CREATE</code> 的操作：</p>
<ul class="nav nav-tabs" id="objectselector-example" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#objectselector-example-0" role="tab" aria-controls="objectselector-example-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#objectselector-example-1" role="tab" aria-controls="objectselector-example-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="objectselector-example"><div id="objectselector-example-0" class="tab-pane show active" role="tabpanel" aria-labelledby="objectselector-example-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">objectSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">foo</span>:<span style="color:#bbb"> </span>bar<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="objectselector-example-1" class="tab-pane" role="tabpanel" aria-labelledby="objectselector-example-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">objectSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">foo</span>:<span style="color:#bbb"> </span>bar<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.
-->
<p>有关标签选择器的更多示例，请参见<a href="/zh/docs/concepts/overview/working-with-objects/labels">标签</a>。</p>
<!--
### Matching requests: namespaceSelector
-->
<h3 id="matching-requests-namespaceselector">匹配请求：namespaceSelector</h3>
<!--
Webhooks may optionally limit which requests for namespaced resources are intercepted,
based on the labels of the containing namespace, by specifying a `namespaceSelector`.
-->
<p>通过指定 <code>namespaceSelector</code>，Webhook 可以根据具有名字空间的资源所处的
名字空间的标签来选择拦截哪些资源的操作。</p>
<!--
The `namespaceSelector` decides whether to run the webhook on a request for a namespaced resource
(or a Namespace object), based on whether the namespace's labels match the selector.
If the object itself is a namespace, the matching is performed on object.metadata.labels.
If the object is a cluster scoped resource other than a Namespace, `namespaceSelector` has no effect.
-->
<p><code>namespaceSelector</code> 根据名字空间的标签是否匹配选择器，决定是否针对具名字空间的资源
（或 Namespace 对象）的请求运行 webhook。
如果对象是除 Namespace 以外的集群范围的资源，则 <code>namespaceSelector</code> 标签无效。</p>
<!--
This example shows a mutating webhook that matches a `CREATE` of any namespaced resource inside a namespace
that does not have a "runlevel" label of "0" or "1":
-->
<p>本例给出的修改性质的 Webhook 将匹配到对名字空间中具名字空间的资源的 <code>CREATE</code> 请求，
前提是这些资源不含值为 &quot;0&quot; 或 &quot;1&quot; 的 &quot;runlevel&quot; 标签：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-namespaceselector-1" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-namespaceselector-1-0" role="tab" aria-controls="mutatingwebhookconfiguration-namespaceselector-1-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-namespaceselector-1-1" role="tab" aria-controls="mutatingwebhookconfiguration-namespaceselector-1-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-namespaceselector-1"><div id="mutatingwebhookconfiguration-namespaceselector-1-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-namespaceselector-1-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>runlevel<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>NotIn<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;0&#34;</span>,<span style="color:#b44">&#34;1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-namespaceselector-1-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-namespaceselector-1-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>runlevel<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>NotIn<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;0&#34;</span>,<span style="color:#b44">&#34;1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
This example shows a validating webhook that matches a `CREATE` of any namespaced resource inside a namespace
that is associated with the "environment" of "prod" or "staging":
-->
<p>此示例显示了一个验证性质的 Webhook，它将匹配到对某名字空间中的任何具名字空间的资源的
<code>CREATE</code> 请求，前提是该名字空间具有值为 &quot;prod&quot; 或 &quot;staging&quot; 的 &quot;environment&quot; 标签：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-namespaceselector-2" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-namespaceselector-2-0" role="tab" aria-controls="validatingwebhookconfiguration-namespaceselector-2-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-namespaceselector-2-1" role="tab" aria-controls="validatingwebhookconfiguration-namespaceselector-2-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-namespaceselector-2"><div id="validatingwebhookconfiguration-namespaceselector-2-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-namespaceselector-2-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>environment<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;prod&#34;</span>,<span style="color:#b44">&#34;staging&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-namespaceselector-2-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-namespaceselector-2-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespaceSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>environment<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">operator</span>:<span style="color:#bbb"> </span>In<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">values</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;prod&#34;</span>,<span style="color:#b44">&#34;staging&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;*&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.
-->
<p>有关标签选择器的更多示例，请参见
<a href="/zh/docs/concepts/overview/working-with-objects/labels">标签</a>。</p>
<!--
### Matching requests: matchPolicy
-->
<h3 id="matching-requests-matchpolicy">匹配请求：matchPolicy</h3>
<!--
API servers can make objects available via multiple API groups or versions.
For example, the Kubernetes API server allows creating and modifying `Deployment` objects
via `extensions/v1beta1`, `apps/v1beta1`, `apps/v1beta2`, and `apps/v1` APIs.
-->
<p>API 服务器可以通过多个 API 组或版本来提供对象。
例如，Kubernetes API 服务器允许通过 <code>extensions/v1beta1</code>、<code>apps/v1beta1</code>、
<code>apps/v1beta2</code> 和 <code>apps/v1</code> API 创建和修改 <code>Deployment</code> 对象。</p>
<!--
For example, if a webhook only specified a rule for some API groups/versions (like `apiGroups:["apps"], apiVersions:["v1","v1beta1"]`),
and a request was made to modify the resource via another API group/version (like `extensions/v1beta1`),
the request would not be sent to the webhook.
-->
<p>例如，如果一个 webhook 仅为某些 API 组/版本指定了规则（例如
<code>apiGroups:[&quot;apps&quot;], apiVersions:[&quot;v1&quot;,&quot;v1beta1&quot;]</code>），而修改资源的请求
是通过另一个 API 组/版本（例如 <code>extensions/v1beta1</code>）发出的，
该请求将不会被发送到 Webhook。</p>
<!--
In v1.15+, `matchPolicy` lets a webhook define how its `rules` are used to match incoming requests.
Allowed values are `Exact` or `Equivalent`.
-->
<p>在 v1.15+ 中，<code>matchPolicy</code> 允许 webhook 定义如何使用其 <code>rules</code> 匹配传入的请求。
允许的值为 <code>Exact</code> 或 <code>Equivalent</code>。</p>
<!--
* `Exact` means a request should be intercepted only if it exactly matches a specified rule.
* `Equivalent` means a request should be intercepted if modifies a resource listed in `rules`, even via another API group or version.

In the example given above, the webhook that only registered for `apps/v1` could use `matchPolicy`:
* `matchPolicy: Exact` would mean the `extensions/v1beta1` request would not be sent to the webhook
* `matchPolicy: Equivalent` means the `extensions/v1beta1` request would be sent to the webhook (with the objects converted to a version the webhook had specified: `apps/v1`)
-->
<ul>
<li><code>Exact</code> 表示仅当请求与指定规则完全匹配时才应拦截该请求。</li>
<li><code>Equivalent</code> 表示如果某个请求意在修改 <code>rules</code> 中列出的资源，
即使该请求是通过其他 API 组或版本发起，也应拦截该请求。</li>
</ul>
<p>在上面给出的示例中，仅为 <code>apps/v1</code> 注册的 webhook 可以使用 <code>matchPolicy</code>：</p>
<ul>
<li><code>matchPolicy: Exact</code> 表示不会将 <code>extensions/v1beta1</code> 请求发送到 Webhook</li>
<li><code>matchPolicy:Equivalent</code> 表示将 <code>extensions/v1beta1</code> 请求发送到 webhook
（将对象转换为 webhook 指定的版本：<code>apps/v1</code>）</li>
</ul>
<!--
Specifying `Equivalent` is recommended, and ensures that webhooks continue to intercept the
resources they expect when upgrades enable new versions of the resource in the API server.
-->
<p>建议指定 <code>Equivalent</code>，确保升级后启用 API 服务器中资源的新版本时，
Webhook 继续拦截他们期望的资源。</p>
<!--
When a resource stops being served by the API server, it is no longer considered equivalent to other versions of that resource that are still served.
For example, deprecated `extensions/v1beta1` deployments are scheduled to stop being served by default in v1.16.
Once that occurs, a webhook with a `apiGroups:["extensions"], apiVersions:["v1beta1"], resources:["deployments"]` rule
would no longer intercept deployments created via `apps/v1` APIs. For that reason, webhooks should prefer registering
for stable versions of resources.
-->
<p>当 API 服务器停止提供某资源时，该资源不再被视为等同于该资源的其他仍在提供服务的版本。
例如，<code>extensions/v1beta1</code> 中的 Deployment 已被废弃，计划在 v1.16 中默认停止使用。
在这种情况下，带有 <code>apiGroups:[&quot;extensions&quot;], apiVersions:[&quot;v1beta1&quot;], resources: [&quot;deployments&quot;]</code>
规则的 Webhook 将不再拦截通过 <code>apps/v1</code> API 来创建 Deployment 的请求。
[&quot;deployments&quot;] 规则将不再拦截通过 <code>apps/v1</code> API 创建的部署。</p>
<!--
This example shows a validating webhook that intercepts modifications to deployments (no matter the API group or version),
and is always sent an `apps/v1` `Deployment` object:
-->
<p>此示例显示了一个验证性质的 Webhook，该 Webhook 拦截对 Deployment 的修改（无论 API 组或版本是什么），
始终会发送一个 <code>apps/v1</code> 版本的 Deployment 对象：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-matchpolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-matchpolicy-0" role="tab" aria-controls="validatingwebhookconfiguration-matchpolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-matchpolicy-1" role="tab" aria-controls="validatingwebhookconfiguration-matchpolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-matchpolicy"><div id="validatingwebhookconfiguration-matchpolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-matchpolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchPolicy</span>:<span style="color:#bbb"> </span>Equivalent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#b44">&#34;DELETE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default to `Equivalent`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的 admission webhhok 默认为 <code>Equivalent</code>。</p>
</div>
  <div id="validatingwebhookconfiguration-matchpolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-matchpolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchPolicy</span>:<span style="color:#bbb"> </span>Equivalent<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">operations</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;CREATE&#34;</span>,<span style="color:#b44">&#34;UPDATE&#34;</span>,<span style="color:#b44">&#34;DELETE&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersions</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;v1&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">scope</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Namespaced&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default to `Exact`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认为 <code>Exact</code>。</p>
</div></div>

<!--
### Contacting the webhook
-->
<h3 id="调用-webhook">调用 Webhook</h3>
<!--
Once the API server has determined a request should be sent to a webhook,
it needs to know how to contact the webhook. This is specified in the `clientConfig`
stanza of the webhook configuration.

Webhooks can either be called via a URL or a service reference,
and can optionally include a custom CA bundle to use to verify the TLS connection.
-->
<p>API 服务器确定请求应发送到 webhook 后，它需要知道如何调用 webhook。
此信息在 webhook 配置的 <code>clientConfig</code> 节中指定。</p>
<p>Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，以用于验证 TLS 连接。</p>
<!--
#### URL
-->
<h4 id="url">URL</h4>
<!--
`url` gives the location of the webhook, in standard URL form
(`scheme://host:port/path`).
-->
<p><code>url</code> 以标准 URL 形式给出 webhook 的位置（<code>scheme://host:port/path</code>）。</p>
<!--
The `host` should not refer to a service running in the cluster; use
a service reference by specifying the `service` field instead.
The host might be resolved via external DNS in some apiservers
(e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would
be a layering violation). `host` may also be an IP address.
-->
<p><code>host</code> 不应引用集群中运行的服务；通过指定 <code>service</code> 字段来使用服务引用。
主机可以通过某些 apiserver 中的外部 DNS 进行解析。
（例如，<code>kube-apiserver</code> 无法解析集群内 DNS，因为这将违反分层规则）。<code>host</code> 也可以是 IP 地址。</p>
<!--
Please note that using `localhost` or `127.0.0.1` as a `host` is
risky unless you take great care to run this webhook on all hosts
which run an apiserver which might need to make calls to this
webhook. Such installations are likely to be non-portable, i.e., not easy
to turn up in a new cluster.
-->
<p>请注意，将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code> 是有风险的，
除非你非常小心地在所有运行 apiserver 的、可能需要对此 webhook
进行调用的主机上运行。这样的安装方式可能不具有可移植性，即很难在新集群中启用。</p>
<!--
The scheme must be "https"; the URL must begin with "https://".
-->
<p>scheme 必须为 &quot;https&quot;；URL 必须以 &quot;https://&quot; 开头。</p>
<!--
Attempting to use a user or basic auth e.g. "user:password@" is not allowed.
Fragments ("#...") and query parameters ("?...") are also not allowed.
-->
<p>使用用户或基本身份验证（例如：&quot;user:password@&quot;）是不允许的。
使用片段（&quot;#...&quot;）和查询参数（&quot;?...&quot;）也是不允许的。</p>
<!--
Here is an example of a mutating webhook configured to call a URL
(and expects the TLS certificate to be verified using system trust roots, so does not specify a caBundle):
-->
<p>这是配置为调用 URL 的修改性质的 Webhook 的示例
（并且期望使用系统信任根证书来验证 TLS 证书，因此不指定 caBundle）：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-url" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-url-0" role="tab" aria-controls="mutatingwebhookconfiguration-url-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-url-1" role="tab" aria-controls="mutatingwebhookconfiguration-url-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-url"><div id="mutatingwebhookconfiguration-url-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-url-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">url</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-url-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-url-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">url</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
#### Service reference
-->
<h4 id="service-reference">服务引用 </h4>
<!--
The `service` stanza inside `clientConfig` is a reference to the service for this webhook.
If the webhook is running within the cluster, then you should use `service` instead of `url`.
The service namespace and name are required. The port is optional and defaults to 443.
The path is optional and defaults to "/".
-->
<p><code>clientConfig</code> 内部的 Service 是对该 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的 <code>namespace</code> 和 <code>name</code> 是必需的。
<code>port</code> 是可选的，默认值为 443。<code>path</code> 是可选的，默认为 &quot;/&quot;。</p>
<!--
Here is an example of a mutating webhook configured to call a service on port "1234"
at the subpath "/my-path", and to verify the TLS connection against the ServerName
`my-service-name.my-service-namespace.svc` using a custom CA bundle:
-->
<p>这是一个 mutating Webhook 的示例，该 mutating Webhook 配置为在子路径 &quot;/my-path&quot; 端口
&quot;1234&quot; 上调用服务，并使用自定义 CA 包针对 ServerName
<code>my-service-name.my-service-namespace.svc</code> 验证 TLS 连接：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-service" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-service-0" role="tab" aria-controls="mutatingwebhookconfiguration-service-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-service-1" role="tab" aria-controls="mutatingwebhookconfiguration-service-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-service"><div id="mutatingwebhookconfiguration-service-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-service-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>my-service-namespace<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service-name<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/my-path<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">1234</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-service-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-service-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clientConfig</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">caBundle</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>my-service-namespace<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-service-name<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/my-path<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">1234</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Side effects
-->
<h3 id="side-effects">副作用</h3>
<!--
Webhooks typically operate only on the content of the `AdmissionReview` sent to them.
Some webhooks, however, make out-of-band changes as part of processing admission requests.
-->
<p>Webhook 通常仅对发送给他们的 <code>AdmissionReview</code> 内容进行操作。
但是，某些 Webhook 在处理 admission 请求时会进行带外更改。</p>
<!--
Webhooks that make out-of-band changes ("side effects") must also have a reconcilation mechanism
(like a controller) that periodically determines the actual state of the world, and adjusts
the out-of-band data modified by the admission webhook to reflect reality.
This is because a call to an admission webhook does not guarantee the admitted object will be persisted as is, or at all.
Later webhooks can modify the content of the object, a conflict could be encountered while writing to storage,
or the server could power off before persisting the object.
-->
<p>进行带外更改的（产生“副作用”的） Webhook 必须具有协调机制（如控制器），
该机制定期确定事物的实际状态，并调整由准入 Webhook 修改的带外数据以反映现实情况。
这是因为对准入 Webhook 的调用不能保证所准入的对象将原样保留，或根本不保留。
以后，webhook 可以修改对象的内容，在写入存储时可能会发生冲突，或者
服务器可以在持久保存对象之前关闭电源。</p>
<!--
Additionally, webhooks with side effects must skip those side-effects when `dryRun: true` admission requests are handled.
A webhook must explicitly indicate that it will not have side-effects when run with `dryRun`,
or the dry-run request will not be sent to the webhook and the API request will fail instead.
-->
<p>此外，处理 <code>dryRun: true</code> admission 请求时，具有副作用的 Webhook 必须避免产生副作用。
一个 Webhook 必须明确指出在使用 <code>dryRun</code> 运行时不会有副作用，
否则 <code>dry-run</code> 请求将不会发送到该 Webhook，而 API 请求将会失败。</p>
<!--
Webhooks indicate whether they have side effects using the `sideEffects` field in the webhook configuration:
* `Unknown`: no information is known about the side effects of calling the webhook.
If a request with `dryRun: true` would trigger a call to this webhook, the request will instead fail, and the webhook will not be called.
* `None`: calling the webhook will have no side effects.
* `Some`: calling the webhook will possibly have side effects.
If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail, and the webhook will not be called.
* `NoneOnDryRun`: calling the webhook will possibly have side effects,
but if a request with `dryRun: true` is sent to the webhook, the webhook will suppress the side effects (the webhook is `dryRun`-aware).
-->
<p>Webhook 使用 webhook 配置中的 <code>sideEffects</code> 字段显示它们是否有副作用：</p>
<ul>
<li><code>Unknown</code>：有关调用 Webhook 的副作用的信息是不可知的。
如果带有 <code>dryRun：true</code> 的请求将触发对该 Webhook 的调用，则该请求将失败，并且不会调用该 Webhook。</li>
<li><code>None</code>：调用 webhook 没有副作用。</li>
<li><code>Some</code>：调用 webhook 可能会有副作用。
如果请求具有 <code>dry-run</code> 属性将触发对此 Webhook 的调用，
则该请求将会失败，并且不会调用该 Webhook。</li>
<li><code>NoneOnDryRun</code>：调用 webhook 可能会有副作用，但是如果将带有 <code>dryRun: true</code>
属性的请求发送到 webhook，则 webhook 将抑制副作用（该 webhook 可识别 <code>dryRun</code>）。</li>
</ul>
<!--
Allowed values:
* In `admissionregistration.k8s.io/v1beta1`, `sideEffects` may be set to `Unknown`, `None`, `Some`, or `NoneOnDryRun`, and defaults to `Unknown`.
* In `admissionregistration.k8s.io/v1`, `sideEffects` must be set to `None` or `NoneOnDryRun`.
-->
<p>允许值：</p>
<ul>
<li>在 <code>admissionregistration.k8s.io/v1beta1</code> 中，<code>sideEffects</code> 可以设置为
<code>Unknown</code>、<code>None</code>、<code>Some</code> 或者 <code>NoneOnDryRun</code>，并且默认值为 <code>Unknown</code>。</li>
<li>在 <code>admissionregistration.k8s.io/v1</code> 中, <code>sideEffects</code> 必须设置为
<code>None</code> 或者 <code>NoneOnDryRun</code>。</li>
</ul>
<!--
Here is an example of a validating webhook indicating it has no side effects on `dryRun: true` requests:
-->
<p>这是一个 validating webhook 的示例，表明它对 <code>dryRun: true</code> 请求没有副作用：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-sideeffects" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-sideeffects-0" role="tab" aria-controls="validatingwebhookconfiguration-sideeffects-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-sideeffects-1" role="tab" aria-controls="validatingwebhookconfiguration-sideeffects-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-sideeffects"><div id="validatingwebhookconfiguration-sideeffects-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-sideeffects-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>NoneOnDryRun<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="validatingwebhookconfiguration-sideeffects-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-sideeffects-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">sideEffects</span>:<span style="color:#bbb"> </span>NoneOnDryRun<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
### Timeouts
-->
<h3 id="timeouts">超时</h3>
<!--
Because webhooks add to API request latency, they should evaluate as quickly as possible.
`timeoutSeconds` allows configuring how long the API server should wait for a webhook to respond
before treating the call as a failure.
-->
<p>由于 Webhook 会增加 API 请求的延迟，因此应尽快完成自身的操作。
<code>timeoutSeconds</code> 用来配置在将调用视为失败之前，允许 API 服务器等待 Webhook 响应的时间长度。</p>
<!--
If the timeout expires before the webhook responds, the webhook call will be ignored or
the API call will be rejected based on the [failure policy](#failure-policy).

The timeout value must be between 1 and 30 seconds.

Here is an example of a validating webhook with a custom timeout of 2 seconds:
-->
<p>如果超时在 Webhook 响应之前被触发，则基于<a href="#failure-policy">失败策略</a>，将忽略
Webhook 调用或拒绝 API 调用。</p>
<p>超时值必须设置在 1 到 30 秒之间。</p>
<p>这是一个自定义超时设置为 2 秒的 validating Webhook 的示例：</p>
<ul class="nav nav-tabs" id="validatingwebhookconfiguration-timeoutseconds" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#validatingwebhookconfiguration-timeoutseconds-0" role="tab" aria-controls="validatingwebhookconfiguration-timeoutseconds-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#validatingwebhookconfiguration-timeoutseconds-1" role="tab" aria-controls="validatingwebhookconfiguration-timeoutseconds-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="validatingwebhookconfiguration-timeoutseconds"><div id="validatingwebhookconfiguration-timeoutseconds-0" class="tab-pane show active" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-timeoutseconds-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default timeouts to 10 seconds.
-->
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 默认超时为 10 秒。</p>
</div>
  <div id="validatingwebhookconfiguration-timeoutseconds-1" class="tab-pane" role="tabpanel" aria-labelledby="validatingwebhookconfiguration-timeoutseconds-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ValidatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">timeoutSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default timeouts to 30 seconds.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认超时为 30 秒。</p>
</div></div>

<!--
### Reinvocation policy
-->
<h3 id="reinvocation-policy">再调用策略 </h3>
<!--
A single ordering of mutating admissions plugins (including webhooks) does not work for all cases
(see https://issue.k8s.io/64333 as an example). A mutating webhook can add a new sub-structure
to the object (like adding a `container` to a `pod`), and other mutating plugins which have already
run may have opinions on those new structures (like setting an `imagePullPolicy` on all containers).
-->
<p>修改性质的准入插件（包括 Webhook）的任何一种排序方式都不会适用于所有情况。
(参见 <a href="https://issue.k8s.io/64333">https://issue.k8s.io/64333</a> 示例)。
修改性质的 Webhook 可以向对象中添加新的子结构（例如向 <code>pod</code> 中添加 <code>container</code>），
已经运行的其他修改插件可能会对这些新结构有影响
（就像在所有容器上设置 <code>imagePullPolicy</code> 一样）。</p>
<!--
In v1.15+, to allow mutating admission plugins to observe changes made by other plugins,
built-in mutating admission plugins are re-run if a mutating webhook modifies an object,
and mutating webhooks can specify a `reinvocationPolicy` to control whether they are reinvoked as well.
-->
<p>在 v1.15+ 中，允许修改性质的准入插件感应到其他插件所做的更改，
如果修改性质的 Webhook 修改了一个对象，则会重新运行内置的修改性质的准入插件，
并且修改性质的 Webhook 可以指定 <code>reinvocationPolicy</code> 来控制是否也重新调用它们。</p>
<!--
`reinvocationPolicy` may be set to `Never` or `IfNeeded`. It defaults to `Never`.
-->
<p>可以将 <code>reinvocationPolicy</code> 设置为 <code>Never</code> 或 <code>IfNeeded</code>。 默认为 <code>Never</code>。</p>
<!--
* `Never`: the webhook must not be called more than once in a single admission evaluation
* `IfNeeded`: the webhook may be called again as part of the admission evaluation if the object
being admitted is modified by other admission plugins after the initial webhook call.
-->
<ul>
<li><code>Never</code>: 在一次准入测试中，不得多次调用 Webhook。</li>
<li><code>IfNeeded</code>: 如果在最初的 Webhook 调用之后被其他对象的插件修改了被接纳的对象，
则可以作为准入测试的一部分再次调用该 webhook。</li>
</ul>
<!--
The important elements to note are:
-->
<p>要注意的重要因素有：</p>
<!--
* The number of additional invocations is not guaranteed to be exactly one.
* If additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
* Webhooks that use this option may be reordered to minimize the number of additional invocations.
* To validate an object after all mutations are guaranteed complete, use a validating admission webhook instead (recommended for webhooks with side-effects).
-->
<ul>
<li>不能保证附加调用的次数恰好是一。</li>
<li>如果其他调用导致对该对象的进一步修改，则不能保证再次调用 Webhook。</li>
<li>使用此选项的 Webhook 可能会重新排序，以最大程度地减少额外调用的次数。</li>
<li>要在确保所有修改都完成后验证对象，请改用验证性质的 Webhook
（推荐用于有副作用的 Webhook）。</li>
</ul>
<!--
Here is an example of a mutating webhook opting into being re-invoked if later admission plugins modify the object:
-->
<p>这是一个修改性质的 Webhook 的示例，该 Webhook 在以后的准入插件修改对象时被重新调用：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-reinvocationpolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-reinvocationpolicy-0" role="tab" aria-controls="mutatingwebhookconfiguration-reinvocationpolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-reinvocationpolicy-1" role="tab" aria-controls="mutatingwebhookconfiguration-reinvocationpolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-reinvocationpolicy"><div id="mutatingwebhookconfiguration-reinvocationpolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-reinvocationpolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">reinvocationPolicy</span>:<span style="color:#bbb"> </span>IfNeeded<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div>
  <div id="mutatingwebhookconfiguration-reinvocationpolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-reinvocationpolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">reinvocationPolicy</span>:<span style="color:#bbb"> </span>IfNeeded<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div></div></div>

<!--
Mutating webhooks must be [idempotent](#idempotence), able to successfully process an object they have already admitted
and potentially modified. This is true for all mutating admission webhooks, since any change they can make
in an object could already exist in the user-provided object, but it is essential for webhooks that opt into reinvocation.
-->
<p>修改性质的 Webhook 必须具有<a href="#idempotence">幂等</a>性，并且能够成功处理
已被接纳并可能被修改的对象的修改性质的 Webhook。
对于所有修改性质的准入 Webhook 都是如此，因为它们可以在对象中进行的
任何更改可能已经存在于用户提供的对象中，但是对于选择重新调用的 webhook
来说是必不可少的。</p>
<!--
### Failure policy
-->
<h3 id="failure-policy">失败策略</h3>
<!--
`failurePolicy` defines how unrecognized errors and timeout errors from the admission webhook
are handled. Allowed values are `Ignore` or `Fail`.

* `Ignore` means that an error calling the webhook is ignored and the API request is allowed to continue.
* `Fail` means that an error calling the webhook causes the admission to fail and the API request to be rejected.

Here is a mutating webhook configured to reject an API request if errors are encountered calling the admission webhook:
-->
<p><code>failurePolicy</code> 定义了如何处理准入 webhook 中无法识别的错误和超时错误。允许的值为 <code>Ignore</code> 或 <code>Fail</code>。</p>
<ul>
<li><code>Ignore</code> 表示调用 webhook 的错误将被忽略并且允许 API 请求继续。</li>
<li><code>Fail</code> 表示调用 webhook 的错误导致准入失败并且 API 请求被拒绝。</li>
</ul>
<p>这是一个修改性质的 webhook，配置为在调用准入 Webhook 遇到错误时拒绝 API 请求：</p>
<ul class="nav nav-tabs" id="mutatingwebhookconfiguration-failurepolicy" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#mutatingwebhookconfiguration-failurepolicy-0" role="tab" aria-controls="mutatingwebhookconfiguration-failurepolicy-0" aria-selected="true">admissionregistration.k8s.io/v1</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#mutatingwebhookconfiguration-failurepolicy-1" role="tab" aria-controls="mutatingwebhookconfiguration-failurepolicy-1">admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class="tab-content" id="mutatingwebhookconfiguration-failurepolicy"><div id="mutatingwebhookconfiguration-failurepolicy-0" class="tab-pane show active" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-failurepolicy-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">failurePolicy</span>:<span style="color:#bbb"> </span>Fail<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1` default `failurePolicy` to `Fail`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Fail</code>。</p>
</div>
  <div id="mutatingwebhookconfiguration-failurepolicy-1" class="tab-pane" role="tabpanel" aria-labelledby="mutatingwebhookconfiguration-failurepolicy-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>admissionregistration.k8s.io/v1beta1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>MutatingWebhookConfiguration<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">webhooks</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>my-webhook.example.com<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">failurePolicy</span>:<span style="color:#bbb"> </span>Fail<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span></code></pre></div><!--
Admission webhooks created using `admissionregistration.k8s.io/v1beta1` default `failurePolicy` to `Ignore`.
-->
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div></div>

<!--
## Monitoring admission webhooks
-->
<h2 id="monitoring-admission-webhooks">监控 Admission Webhook   </h2>
<!--
The API server provides ways to monitor admission webhook behaviors. These
monitoring mechanisms help cluster admins to answer questions like:

1. Which mutating webhook mutated the object in a API request?

2. What change did the mutating webhook applied to the object?

3. Which webhooks are frequently rejecting API requests? What's the reason for a
   rejection?
-->
<p>API 服务器提供了监视准入 Webhook 行为的方法。这些监视机制可帮助集群管理员
回答以下问题：</p>
<ol>
<li>哪个修改性质的 webhook 改变了 API 请求中的对象？</li>
<li>修改性质的 Webhook 对对象做了哪些更改？</li>
<li>哪些 webhook 经常拒绝 API 请求？是什么原因拒绝？</li>
</ol>
<!--
### Mutating webhook auditing annotations
-->
<h3 id="mutating-webhook-审计注解">Mutating Webhook 审计注解</h3>
<!--
Sometimes it's useful to know which mutating webhook mutated the object in a API request, and what change did the
webhook apply.
-->
<p>有时，了解 API 请求中的哪个修改性质的 Webhook 使对象改变以及该
Webhook 应用了哪些更改很有用。</p>
<!--
In v1.16+, kube-apiserver performs [auditing](/docs/tasks/debug-application-cluster/audit/) on each mutating webhook
invocation. Each invocation generates an auditing annotation
capturing if a request object is mutated by the invocation, and optionally generates an annotation capturing the applied
patch from the webhook admission response. The annotations are set in the audit event for given request on given stage of
its execution, which is then pre-processed according to a certain policy and written to a backend.
-->
<p>在 v1.16+ 中，kube-apiserver 针对每个修改性质的 Webhook 调用执行
<a href="/zh/docs/tasks/debug-application-cluster/audit/">审计</a>操作。
每个调用都会生成一个审计注解，记述请求对象是否发生改变，
可选地还可以根据 webhook 的准入响应生成一个注解，记述所应用的修补。
针对给定请求的给定执行阶段，注解被添加到审计事件中，
然后根据特定策略进行预处理并写入后端。</p>
<!--
The audit level of a event determines which annotations get recorded:
-->
<p>事件的审计级别决定了要记录哪些注解：</p>
<!--
- At `Metadata` audit level or higher, an annotation with key
`mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}` gets logged with JSON payload indicating
a webhook gets invoked for given request and whether it mutated the object or not.
-->
<p>在 <code>Metadata</code> 或更高审计级别上，将使用 JSON 负载记录带有键名
<code>mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表示针对给定请求调用了 Webhook，以及该 Webhook 是否更改了对象。</p>
<!--
For example, the following annotation gets recorded for a webhook being reinvoked. The webhook is ordered the third in the
mutating webhook chain, and didn't mutated the request object during the invocation.
-->
<p>例如，对于正在被重新调用的某 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第三个位置，并且在调用期间未改变请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;mutation.webhook.admission.k8s.io/round_1_index_2&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook.example.com\&#34;,\&#34;mutated\&#34;: </span><span style="color:#a2f;font-weight:bold">false</span>}&#34;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;mutated&#34;: </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
The following annotation gets recorded for a webhook being invoked in the first round. The webhook is ordered the first in\
the mutating webhook chain, and mutated the request object during the invocation.
-->
<p>对于在第一轮中调用的 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第一位，并在调用期间改变了请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;mutation.webhook.admission.k8s.io/round_0_index_0&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;mutated\&#34;: </span><span style="color:#a2f;font-weight:bold">true</span>}&#34;<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;mutated&#34;: </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
- At `Request` audit level or higher, an annotation with key
`patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}` gets logged with JSON payload indicating
a webhook gets invoked for given request and what patch gets applied to the request object.
-->
<p>在 <code>Request</code> 或更高审计级别上，将使用 JSON 负载记录带有键名为
<code>patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表明针对给定请求调用了 Webhook 以及应用于请求对象之上的修改。</p>
<!--
For example, the following annotation gets recorded for a webhook being reinvoked. The webhook is ordered the fourth in the
mutating webhook chain, and responded with a JSON patch which got applied to the request object.
-->
<p>例如，以下是针对正在被重新调用的某 Webhook 所记录的注解。
Webhook 在修改性质的 Webhook 链中排在第四，并在其响应中包含一个 JSON 补丁，
该补丁已被应用于请求对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 审计事件相关记录</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;kind&#34;: </span><span style="color:#b44">&#34;Event&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;: </span><span style="color:#b44">&#34;audit.k8s.io/v1&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;annotations&#34;: </span>{<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">&#34;patch.webhook.admission.k8s.io/round_1_index_3&#34;: </span><span style="color:#b44">&#34;{\&#34;configuration\&#34;:\&#34;my-other-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;patch\&#34;:[{\&#34;op\&#34;:\&#34;add\&#34;,\&#34;path\&#34;:\&#34;/data/mutation-stage\&#34;,\&#34;value\&#34;:\&#34;yes\&#34;}],\&#34;patchType\&#34;:\&#34;JSONPatch\&#34;}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#080;font-style:italic"># 其他注解</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 其他字段</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 反序列化的注解值</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;configuration&#34;: </span><span style="color:#b44">&#34;my-other-mutating-webhook-configuration.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;webhook&#34;: </span><span style="color:#b44">&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;patchType&#34;: </span><span style="color:#b44">&#34;JSONPatch&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">&#34;patch&#34;: </span>[<span style="color:#bbb">
</span><span style="color:#bbb">        </span>{<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;op&#34;: </span><span style="color:#b44">&#34;add&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;path&#34;: </span><span style="color:#b44">&#34;/data/mutation-stage&#34;</span>,<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">&#34;value&#34;: </span><span style="color:#b44">&#34;yes&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></code></pre></div><!--
### Admission webhook metrics
-->
<h3 id="准入-webhook-度量值">准入 Webhook 度量值</h3>
<!--
Kube-apiserver exposes Prometheus metrics from the `/metrics` endpoint, which can be used for monitoring and
diagnosing API server status. The following metrics record status related to admission webhooks.
-->
<p>Kube-apiserver 从 <code>/metrics</code> 端点公开 Prometheus 指标，这些指标可用于监控和诊断
apiserver 状态。以下指标记录了与准入 Webhook 相关的状态。</p>
<!--
#### API server admission webhook rejection count
-->
<h4 id="apiserver-准入-webhook-拒绝次数">apiserver 准入 Webhook 拒绝次数</h4>
<!--
Sometimes it's useful to know which admission webhooks are frequently rejecting API requests, and the
reason for a rejection.

In v1.16+, kube-apiserver exposes a Prometheus counter metric recording admission webhook rejections. The
metrics are labelled to identify the causes of webhook rejection(s):
-->
<p>有时，了解哪些准入 Webhook 经常拒绝 API 请求以及拒绝的原因是很有用的。</p>
<p>在 v1.16+ 中，kube-apiserver 提供了 Prometheus 计数器度量值，记录
准入 Webhook 的拒绝次数。
度量值的标签给出了 Webhook 拒绝该请求的原因：</p>
<!--
- `name`: the name of the webhook that rejected a request.
- `operation`: the operation type of the request, can be one of `CREATE`,
  `UPDATE`, `DELETE` and `CONNECT`.
- `type`: the admission webhook type, can be one of `admit` and `validating`.
- `error_type`: identifies if an error occurred during the webhook invocation
  that caused the rejection. Its value can be one of:
   - `calling_webhook_error`: unrecognized errors or timeout errors from the admission webhook happened and the
   webhook's [Failure policy](#failure-policy) is set to `Fail`.
   - `no_error`: no error occurred. The webhook rejected the request with `allowed: false` in the admission
   response. The metrics label `rejection_code` records the `.status.code` set in the admission response.
   - `apiserver_internal_error`: an API server internal error happened.
- `rejection_code`: the HTTP status code set in the admission response when a
  webhook rejected a request.
-->
<ul>
<li><code>name</code>：拒绝请求 Webhook 的名称。</li>
<li><code>operation</code>：请求的操作类型可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>CONNECT</code> 其中之一。</li>
<li><code>type</code>：Admission webhook 类型，可以是 <code>admit</code> 和 <code>validating</code> 其中之一。</li>
<li><code>error_type</code>：标识在 webhook 调用期间是否发生了错误并且导致了拒绝。其值可以是以下之一：
<ul>
<li><code>calling_webhook_error</code>：发生了来自准入 Webhook 的无法识别的错误或超时错误，
并且 webhook 的 <a href="#failure-policy">失败策略</a> 设置为 <code>Fail</code>。</li>
<li><code>no_error</code>：未发生错误。Webhook 在准入响应中以 <code>allowed: false</code> 值拒绝了请求。
度量标签 <code>rejection_code</code> 记录了在准入响应中设置的 <code>.status.code</code>。</li>
<li><code>apiserver_internal_error</code>：apiserver 发生内部错误。</li>
</ul>
</li>
<li><code>rejection_code</code>：当 Webhook 拒绝请求时，在准入响应中设置的 HTTP 状态码。</li>
</ul>
<!--
Example of the rejection count metrics:
-->
<p>拒绝计数指标示例：</p>
<pre><code># HELP apiserver_admission_webhook_rejection_count [ALPHA] Admission webhook rejection count, identified by name and broken out for each admission type (validating or admit) and operation. Additional labels specify an error type (calling_webhook_error or apiserver_internal_error if an error occurred; no_error otherwise) and optionally a non-zero rejection code if the webhook rejects the request with an HTTP status code (honored by the apiserver when the code is greater or equal to 400). Codes greater than 600 are truncated to 600, to keep the metrics cardinality bounded.
# TYPE apiserver_admission_webhook_rejection_count counter
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;always-timeout-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;invalid-admission-response-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;no_error&quot;,name=&quot;deny-unwanted-configmap-data.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;400&quot;,type=&quot;validating&quot;} 13
</code></pre><!--
## Best practices and warnings

### Idempotence
-->
<h2 id="最佳实践和警告">最佳实践和警告</h2>
<h3 id="idempotence">幂等性 </h3>
<!--
An idempotent mutating admission webhook is able to successfully process an object it has already admitted
and potentially modified. The admission can be applied multiple times without changing the result beyond
the initial application.
-->
<p>幂等的修改性质的准入 Webhook 能够成功处理已经被它接纳甚或修改的对象。
即使多次执行该准入测试，也不会产生与初次执行结果相异的结果。</p>
<!--
#### Example of idempotent mutating admission webhooks:

1. For a `CREATE` pod request, set the field `.spec.securityContext.runAsNonRoot` of the
   pod to true, to enforce security best practices.

2. For a `CREATE` pod request, if the field `.spec.containers[].resources.limits`
   of a container is not set, set default resource limits.

3. For a `CREATE` pod request, inject a sidecar container with name `foo-sidecar` if no container with the name `foo-sidecar` already exists.

In the cases above, the webhook can be safely reinvoked, or admit an object that already has the fields set.
-->
<h4 id="幂等-mutating-admission-webhook-的示例">幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> Pod 请求，将 Pod 的字段 <code>.spec.securityContext.runAsNonRoot</code>
设置为 true，以实施安全最佳实践。</li>
<li>对于 <code>CREATE</code> Pod 请求，如果未设置容器的字段
<code>.spec.containers[].resources.limits</code>，设置默认资源限制值。</li>
<li>对于 <code>CREATE</code> pod 请求，如果 Pod 中不存在名为 <code>foo-sidecar</code> 的边车容器，
向 Pod 注入一个 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述情况下，可以安全地重新调用 Webhook，或接受已经设置了字段的对象。</p>
<!--
#### Example of non-idempotent mutating admission webhooks:
-->
<h4 id="非幂等-mutating-admission-webhook-的示例">非幂等 mutating admission Webhook 的示例：</h4>
<!--
1. For a `CREATE` pod request, inject a sidecar container with name `foo-sidecar`
   suffixed with the current timestamp (e.g. `foo-sidecar-19700101-000000`).

2. For a `CREATE`/`UPDATE` pod request, reject if the pod has label `"env"` set,
   otherwise add an `"env": "prod"` label to the pod.

3. For a `CREATE` pod request, blindly append a sidecar container named
   `foo-sidecar` without looking to see if there is already a `foo-sidecar`
   container in the pod.
-->
<ol>
<li>对于 <code>CREATE</code> pod 请求，注入名称为 <code>foo-sidecar</code> 并带有当前时间戳的
边车容器（例如 <code>foo-sidecar-19700101-000000</code>）。</li>
<li>对于 <code>CREATE/UPDATE</code> pod 请求，如果容器已设置标签 <code>&quot;env&quot;</code> 则拒绝，
否则将 <code>&quot;env&quot;: &quot;prod&quot;</code> 标签添加到容器。</li>
<li>对于 <code>CREATE</code> pod 请求，盲目地添加一个名为 <code>foo-sidecar</code> 的边车容器，
而未查看 Pod 中是否已经有 <code>foo-sidecar</code> 容器。</li>
</ol>
<!--
In the first case above, reinvoking the webhook can result in the same sidecar being injected multiple times to a pod, each time
with a different container name. Similarly the webhook can inject duplicated containers if the sidecar already exists in
a user-provided pod.

In the second case above, reinvoking the webhook will result in the webhook failing on its own output.

In the third case above, reinvoking the webhook will result in duplicated containers in the pod spec, which makes
the request invalid and rejected by the API server.
-->
<p>在上述第一种情况下，重新调用该 Webhook 可能导致同一个 Sidecar 容器
多次注入到 Pod 中，而且每次使用不同的容器名称。
类似地，如果 Sidecar 已存在于用户提供的 Pod 中，则 Webhook 可能注入重复的容器。</p>
<p>在上述第二种情况下，重新调用 Webhook 将导致 Webhook 自身输出失败。</p>
<p>在上述第三种情况下，重新调用 Webhook 将导致 Pod 规范中的容器重复，
从而使请求无效并被 API 服务器拒绝。</p>
<!--
### Intercepting all versions of an object

It is recommended that admission webhooks should always intercept all versions of an object by setting `.webhooks[].matchPolicy`
to `Equivalent`. It is also recommended that admission webhooks should prefer registering for stable versions of resources.
Failure to intercept all versions of an object can result in admission policies not being enforced for requests in certain
versions. See [Matching requests: matchPolicy](#matching-requests-matchpolicy) for examples.
-->
<h3 id="拦截对象的所有版本">拦截对象的所有版本</h3>
<p>建议通过将 <code>.webhooks[].matchPolicy</code> 设置为 <code>Equivalent</code>，
以确保准入 Webhooks 始终拦截对象的所有版本。
建议准入 Webhooks 应该更偏向注册资源的稳定版本。
如果无法拦截对象的所有版本，可能会导致准入策略未再某些版本的请求上执行。
有关示例，请参见<a href="#matching-requests-matchpolicy">匹配请求：matchPolicy</a>。</p>
<!--
### Availability

It is recommended that admission Webhooks should evaluate as quickly as possible (typically in milliseconds), since they add to API request latency.
It is encouraged to use a small timeout for webhooks. See [Timeouts](#timeouts) for more detail.

It is recommended that admission webhooks should leverage some format of load-balancing, to provide high availability and
performance benefits. If a webhook is running within the cluster, you can run multiple webhook backends behind a service
to leverage the load-balancing that service supports.
-->
<h3 id="availability">可用性  </h3>
<p>建议准入 webhook 尽快完成执行（时长通常是毫秒级），因为它们会增加 API 请求的延迟。
建议对 Webhook 使用较小的超时值。有关更多详细信息，请参见<a href="#timeouts">超时</a>。</p>
<p>建议 Admission Webhook 应该采用某种形式的负载均衡机制，以提供高可用性和高性能。
如果集群中正在运行 Webhook，则可以在服务后面运行多个 Webhook 后端，以利用该服务支持的负载均衡。</p>
<!--
### Guaranteeing the final state of the object is seen

Admission webhooks that need to guarantee they see the final state of the object in order to enforce policy
should use a validating admission webhook, since objects can be modified after being seen by mutating webhooks.

For example, a mutating admission webhook is configured to inject a sidecar container with name "foo-sidecar" on every
`CREATE` pod request. If the sidecar *must* be present, a validating admisson webhook should also be configured to intercept `CREATE` pod requests, and validate
that a container with name "foo-sidecar" with the expected configuration exists in the to-be-created object.
-->
<h3 id="确保看到对象的最终状态">确保看到对象的最终状态</h3>
<p>如果某准入 Webhook 需要保证自己能够看到对象的最终状态以实施策略，
则应该使用一个验证性质的 webhook，
因为可以通过 mutating Webhook 看到对象后对其进行修改。</p>
<p>例如，一个修改性质的准入Webhook 被配置为在每个 <code>CREATE</code> Pod 请求中
注入一个名称为 &quot;foo-sidecar&quot; 的 sidecar 容器。</p>
<p>如果<em>必须</em>存在边车容器，则还应配置一个验证性质的准入 Webhook 以拦截
<code>CREATE</code> Pod 请求，并验证要创建的对象中是否存在具有预期配置的名称为
&quot;foo-sidecar&quot; 的容器。</p>
<!--
### Avoiding deadlocks in self-hosted webhooks

A webhook running inside the cluster might cause deadlocks for its own deployment if it is configured
to intercept resources required to start its own pods.

For example, a mutating admission webhook is configured to admit `CREATE` pod requests only if a certain label is set in the
pod (e.g. `"env": "prod"`). The webhook server runs in a deployment which doesn't set the `"env"` label.
When a node that runs the webhook server pods
becomes unhealthy, the webhook deployment will try to reschedule the pods to another node. However the requests will
get rejected by the existing webhook server since the `"env"` label is unset, and the migration cannot happen.

It is recommended to exclude the namespace where your webhook is running with a [namespaceSelector](#matching-requests-namespaceselector).
-->
<h3 id="避免自托管的-webhooks-中出现死锁">避免自托管的 Webhooks 中出现死锁</h3>
<p>如果集群内的 Webhook 配置能够拦截启动其自己的 Pod 所需的资源，
则该 Webhook 可能导致其自身部署时发生死锁。</p>
<p>例如，某修改性质的准入 Webhook 配置为仅当 Pod 中设置了某个标签
（例如 <code>&quot;env&quot;: &quot;prod&quot;</code>）时，才接受 <code>CREATE</code> Pod 请求。
Webhook 服务器在未设置 <code>&quot;env&quot;</code> 标签的 Deployment 中运行。当运行 Webhook 服务器的
容器的节点运行不正常时，Webhook 部署尝试将容器重新调度到另一个节点。
但是，由于未设置 <code>&quot;env&quot;</code> 标签，因此请求将被现有的 Webhook 服务器拒绝，并且调度迁移不会发生。</p>
<p>建议使用 <a href="#matching-requests-namespaceselector">namespaceSelector</a> 排除
Webhook 所在的名字空间。</p>
<!--
### Side effects

It is recommended that admission webhooks should avoid side effects if possible, which means the webhooks operate only on the
content of the `AdmissionReview` sent to them, and do not make out-of-band changes. The `.webhooks[].sideEffects` field should
be set to `None` if a webhook doesn't have any side effect.

If side effects are required during the admission evaluation, they must be suppressed when processing an
`AdmissionReview` object with `dryRun` set to `true`, and the `.webhooks[].sideEffects` field should be
set to `NoneOnDryRun`. See [Side effects](#side-effects) for more detail.
-->
<h3 id="side-effects">副作用 </h3>
<p>建议准入 Webhook 应尽可能避免副作用，这意味着该准入 webhook 仅对发送给他们的
<code>AdmissionReview</code> 的内容起作用，并且不要进行额外更改。
如果 Webhook 没有任何副作用，则 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>None</code>。</p>
<p>如果在准入执行期间存在副作用，则应在处理 <code>dryRun</code> 为 <code>true</code> 的 <code>AdmissionReview</code>
对象时避免产生副作用，并且其 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>NoneOnDryRun</code>。更多详细信息，请参见<a href="#side-effects">副作用</a>。</p>
<!--
### Avoiding operating on the kube-system namespace
-->
<h3 id="避免对-kube-system-名字空间进行操作">避免对 kube-system 名字空间进行操作</h3>
<!--
The `kube-system` namespace contains objects created by the Kubernetes system,
e.g. service accounts for the control plane components, pods like `kube-dns`.
Accidentally mutating or rejecting requests in the `kube-system` namespace may
cause the control plane components to stop functioning or introduce unknown behavior.
If your admission webhooks don't intend to modify the behavior of the Kubernetes control
plane, exclude the `kube-system` namespace from being intercepted using a
[`namespaceSelector`](#matching-requests-namespaceselector).
-->
<p><code>kube-system</code> 名字空间包含由 Kubernetes 系统创建的对象，
例如用于控制平面组件的服务账号，诸如 <code>kube-dns</code> 之类的 Pod 等。
意外更改或拒绝 <code>kube-system</code> 名字空间中的请求可能会导致控制平面组件
停止运行或者导致未知行为发生。
如果你的准入 Webhook 不想修改 Kubernetes 控制平面的行为，请使用
<a href="#matching-requests-namespaceselector"><code>namespaceSelector</code></a> 避免
拦截 <code>kube-system</code> 名字空间。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bea207258f3576b8ec7444a20d498e1d">6 - 管理服务账号</h1>
    
	<!--
reviewers:
- bprashanth
- davidopp
- lavalamp
- liggitt
title: Managing Service Accounts
content_type: concept
weight: 50
-->
<!-- overview -->
<!--
This is a Cluster Administrator guide to service accounts. You should be familiar with 
[configuring Kubernetes service accounts](/docs/tasks/configure-pod-container/configure-service-account/).

Support for authorization and user accounts is planned but incomplete. Sometimes
incomplete features are referred to in order to better describe service accounts.
-->
<p>这是一篇针对服务账号的集群管理员指南。你应该熟悉
<a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">配置 Kubernetes 服务账号</a>。</p>
<p>对鉴权和用户账号的支持已在规划中，当前并不完备。
为了更好地描述服务账号，有时这些不完善的特性也会被提及。</p>
<!-- body -->
<!--
## User accounts versus service accounts

Kubernetes distinguishes between the concept of a user account and a service account
for a number of reasons:
-->
<h2 id="user-accounts-versus-service-accounts">用户账号与服务账号 </h2>
<p>Kubernetes 区分用户账号和服务账号的概念，主要基于以下原因：</p>
<!--
- User accounts are for humans. Service accounts are for processes, which run
  in pods.
- User accounts are intended to be global. Names must be unique across all
  namespaces of a cluster. Service accounts are namespaced.
- Typically, a cluster's user accounts might be synced from a corporate
  database, where new user account creation requires special privileges and is
  tied to complex business processes. Service account creation is intended to be
  more lightweight, allowing cluster users to create service accounts for
  specific tasks by following the principle of least privilege.
- Auditing considerations for humans and service accounts may differ.
- A config bundle for a complex system may include definition of various service
  accounts for components of that system. Because service accounts can be created
  without many constraints and have namespaced names, such config is portable.
-->
<ul>
<li>用户账号是针对人而言的。 服务账号是针对运行在 Pod 中的进程而言的。</li>
<li>用户账号是全局性的。其名称跨集群中名字空间唯一的。服务账号是名字空间作用域的。</li>
<li>通常情况下，集群的用户账号可能会从企业数据库进行同步，其创建需要特殊权限，
并且涉及到复杂的业务流程。
服务账号创建有意做得更轻量，允许集群用户为了具体的任务创建服务账号
以遵从权限最小化原则。</li>
<li>对人员和服务账号审计所考虑的因素可能不同。</li>
<li>针对复杂系统的配置包可能包含系统组件相关的各种服务账号的定义。因为服务账号
的创建约束不多并且有名字空间域的名称，这种配置是很轻量的。</li>
</ul>
<!--
## Service account automation

Three separate components cooperate to implement the automation around service accounts:

- A `ServiceAccount` admission controller
- A Token controller
- A `ServiceAccount` controller
-->
<h2 id="service-account-automation">服务账号的自动化  </h2>
<p>三个独立组件协作完成服务账号相关的自动化：</p>
<ul>
<li><code>ServiceAccount</code> 准入控制器</li>
<li>Token 控制器</li>
<li><code>ServiceAccount</code> 控制器</li>
</ul>
<!--
### ServiceAccount Admission Controller

The modification of pods is implemented via a plugin
called an [Admission Controller](/docs/reference/access-authn-authz/admission-controllers/).
It is part of the API server.
It acts synchronously to modify pods as they are created or updated. When this plugin is active
(and it is by default on most distributions), then it does the following when a pod is created or modified:
-->
<h3 id="serviceaccount-admission-controller">ServiceAccount 准入控制器  </h3>
<p>对 Pod 的改动通过一个被称为
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
的插件来实现。它是 API 服务器的一部分。
当 Pod 被创建或更新时，它会同步地修改 Pod。
如果该插件处于激活状态（在大多数发行版中都是默认激活的），当 Pod 被创建
或更新时它会进行以下操作：</p>
<!--
1. If the pod does not have a `ServiceAccount` set, it sets the `ServiceAccount` to `default`.
1. It ensures that the `ServiceAccount` referenced by the pod exists, and otherwise rejects it.
1. It adds a `volume` to the pod which contains a token for API access
   if neither the ServiceAccount `automountServiceAccountToken` nor the Pod's
   `automountServiceAccountToken` is set to `false`.
1. It adds a `volumeSource` to each container of the pod mounted at
   `/var/run/secrets/kubernetes.io/serviceaccount`, if the previous step has
   created a volume for ServiceAccount token.
1. If the pod does not contain any `ImagePullSecrets`, then `ImagePullSecrets` of the `ServiceAccount` are added to the pod.
-->
<ol>
<li>如果该 Pod 没有设置 <code>ServiceAccount</code>，将其 <code>ServiceAccount</code> 设为 <code>default</code>。</li>
<li>保证 Pod 所引用的 <code>ServiceAccount</code> 确实存在，否则拒绝该 Pod。</li>
<li>如果服务账号的 <code>automountServiceAccountToken</code> 或 Pod 的
<code>automountServiceAccountToken</code> 都未显式设置为 <code>false</code>，则为 Pod 创建一个
<code>volume</code>，在其中包含用来访问 API 的令牌。</li>
<li>如果前一步中为服务账号令牌创建了卷，则为 Pod 中的每个容器添加一个
<code>volumeSource</code>，挂载在其 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>
目录下。</li>
<li>如果 Pod 不包含 <code>imagePullSecrets</code> 设置，将 <code>ServiceAccount</code> 所引用
的服务账号中的 <code>imagePullSecrets</code> 信息添加到 Pod 中。</li>
</ol>
<!--
#### Bound Service Account Token Volume
-->
<h4 id="bound-service-account-token-volume">绑定的服务账号令牌卷 </h4>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>


<!--
The ServiceAccount admission controller will add the following projected volume instead of a Secret-based volume for the non-expiring service account token created by Token Controller.
-->
<p>ServiceAccount 准入控制器将添加如下投射卷，而不是为令牌控制器
所生成的不过期的服务账号令牌而创建的基于 Secret 的卷。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kube-api-access-&lt;随机后缀&gt;<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">projected</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">defaultMode</span>:<span style="color:#bbb"> </span><span style="color:#666">420</span><span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 0644</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">sources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">serviceAccountToken</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">expirationSeconds</span>:<span style="color:#bbb"> </span><span style="color:#666">3607</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>token<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">configMap</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">items</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>kube-root-ca.crt<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">downwardAPI</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">items</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">fieldRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">fieldPath</span>:<span style="color:#bbb"> </span>metadata.namespace<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>namespace<span style="color:#bbb">
</span></code></pre></div><!--
This projected volume consists of three sources:

1. A ServiceAccountToken acquired from kube-apiserver via TokenRequest API. It will expire after 1 hour by default or when the pod is deleted. It is bound to the pod and has kube-apiserver as the audience.
1. A ConfigMap containing a CA bundle used for verifying connections to the kube-apiserver. This feature depends on the `RootCAConfigMap` feature gate, which publishes a "kube-root-ca.crt" ConfigMap to every namespace. `RootCAConfigMap` feature gate is graduated to GA in 1.21 and default to true. (This feature will be removed from --feature-gate arg in 1.22).
1. A DownwardAPI that references the namespace of the pod.
-->
<p>此投射卷有三个数据源：</p>
<ol>
<li>通过 TokenRequest API 从 kube-apiserver 处获得的 ServiceAccountToken。
这一令牌默认会在一个小时之后或者 Pod 被删除时过期。
该令牌绑定到 Pod 实例上，并将 kube-apiserver 作为其受众（audience）。</li>
<li>包含用来验证与 kube-apiserver 连接的 CA 证书包的 ConfigMap 对象。
这一特性依赖于 <code>RootCAConfigMap</code> 特性门控。该特性被启用时，
控制面会公开一个名为 <code>kube-root-ca.crt</code> 的 ConfigMap 给所有名字空间。
<code>RootCAConfigMap</code> 在 1.21 版本中进入 GA 状态，默认被启用，
该特性门控会在 1.22 版本中从 <code>--feature-gate</code> 参数中删除。</li>
<li>引用 Pod 名字空间的一个 DownwardAPI。</li>
</ol>
<!--
See more details about [projected volumes](/docs/tasks/configure-pod-container/configure-projected-volume-storage/).
-->
<p>参阅<a href="/zh/docs/tasks/configure-pod-container/configure-projected-volume-storage/">投射卷</a>
了解进一步的细节。</p>
<!--
### Token Controller

TokenController runs as part of `kube-controller-manager`. It acts asynchronously. It:

- watches ServiceAccount creation and creates a corresponding
  ServiceAccount token Secret to allow API access.
- watches ServiceAccount deletion and deletes all corresponding ServiceAccount
  token Secrets.
- watches ServiceAccount token Secret addition, and ensures the referenced
  ServiceAccount exists, and adds a token to the Secret if needed.
- watches Secret deletion and removes a reference from the corresponding
  ServiceAccount if needed.
-->
<h3 id="token-controller">Token 控制器   </h3>
<p>TokenController 作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p>
<ul>
<li>监测 ServiceAccount 的创建并创建相应的服务账号令牌 Secret 以允许访问 API。</li>
<li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li>
<li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li>
<li>监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li>
</ul>
<!--
You must pass a service account private key file to the token controller in
the `kube-controller-manager` using the `--service-account-private-key-file`
flag. The private key is used to sign generated service account tokens.
Similarly, you must pass the corresponding public key to the `kube-apiserver`
using the `--service-account-key-file` flag. The public key will be used to
verify the tokens during authentication.
-->
<p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p>
<!--
#### To create additional API tokens

A controller loop ensures a Secret with an API token exists for each
ServiceAccount. To create additional API tokens for a ServiceAccount, create a
Secret of type `kubernetes.io/service-account-token` with an annotation
referencing the ServiceAccount, and the controller will update it with a
generated token:

Below is a sample configuration for such a Secret:
-->
<h4 id="to-create-additional-api-tokens">创建额外的 API 令牌  </h4>
<p>控制器中有专门的循环来保证每个 ServiceAccount 都存在对应的包含 API 令牌的 Secret。
当需要为 ServiceAccount 创建额外的 API 令牌时，可以创建一个类型为
<code>kubernetes.io/service-account-token</code> 的 Secret，并在其注解中引用对应的
ServiceAccount。控制器会生成令牌并更新该 Secret：</p>
<p>下面是这种 Secret 的一个示例配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Secret<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>mysecretname<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubernetes.io/service-account.name</span>:<span style="color:#bbb"> </span>myserviceaccount<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>kubernetes.io/service-account-token<span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./secret.json
kubectl describe secret mysecretname
</code></pre></div><!--
#### To delete/invalidate a ServiceAccount token Secret
-->
<h4 id="删除-废止服务账号令牌-secret">删除/废止服务账号令牌 Secret</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete secret mysecretname
</code></pre></div><!--
### ServiceAccount controller

A ServiceAccount controller manages the ServiceAccounts inside namespaces, and
ensures a ServiceAccount named "default" exists in every active namespace.
-->
<h3 id="serviceaccount-controller">服务账号控制器  </h3>
<p>服务账号控制器管理各名字空间下的 ServiceAccount 对象，并且保证每个活跃的
名字空间下存在一个名为 &quot;default&quot; 的 ServiceAccount。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-342be69d36f174f762c36f4fe11fcb20">7 - 鉴权概述</h1>
    
	<!--
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Authorization Overview
content_type: concept
weight: 60
-->
<!-- overview -->
<!--
Learn more about Kubernetes authorization, including details about creating
policies using the supported authorization modules.
-->
<p>了解有关 Kubernetes 鉴权的更多信息，包括使用支持的鉴权模块创建策略的详细信息。</p>
<!-- body -->
<!--
In Kubernetes, you must be authenticated (logged in) before your request can be
authorized (granted permission to access). For information about authentication,
see [Accessing Control Overview](/docs/concepts/security/controlling-access/).

Kubernetes expects attributes that are common to REST API requests. This means
that Kubernetes authorization works with existing organization-wide or
cloud-provider-wide access control systems which may handle other APIs besides
the Kubernetes API.
-->
<p>在 Kubernetes 中，你必须在鉴权（授予访问权限）之前进行身份验证（登录），有关身份验证的信息，
请参阅<a href="/zh/docs/concepts/security/controlling-access/">访问控制概述</a>.</p>
<p>Kubernetes 期望请求中存在 REST API 常见的属性。
这意味着 Kubernetes 鉴权适用于现有的组织范围或云提供商范围的访问控制系统，
除了 Kubernetes API 之外，它还可以处理其他 API。</p>
<!--
## Determine Whether a Request is Allowed or Denied

Kubernetes authorizes API requests using the API server. It evaluates all of the
request attributes against all policies and allows or denies the request. All
parts of an API request must be allowed by some policy in order to proceed. This
means that permissions are denied by default.

(Although Kubernetes uses the API server, access controls and policies that
depend on specific fields of specific kinds of objects are handled by Admission
Controllers.)

When multiple authorization modules are configured, each is checked in sequence.
If any authorizer approves or denies a request, that decision is immediately
returned and no other authorizer is consulted. If all modules have no opinion on
the request, then the request is denied. A deny returns an HTTP status code 403.
-->
<h2 id="确定是允许还是拒绝请求">确定是允许还是拒绝请求</h2>
<p>Kubernetes 使用 API 服务器对 API 请求进行鉴权。
它根据所有策略评估所有请求属性来决定允许或拒绝请求。
一个 API 请求的所有部分都必须被某些策略允许才能继续。
这意味着默认情况下拒绝权限。</p>
<p>（尽管 Kubernetes 使用 API 服务器，但是依赖于特定对象种类的特定字段的访问控制
和策略由准入控制器处理。）</p>
<p>当系统配置了多个鉴权模块时，Kubernetes 将按顺序使用每个模块。
如果任何鉴权模块批准或拒绝请求，则立即返回该决定，并且不会与其他鉴权模块协商。
如果所有模块对请求没有意见，则拒绝该请求。
被拒绝响应返回 HTTP 状态代码 403。</p>
<!--
## Review Your Request Attributes

Kubernetes reviews only the following API request attributes:

 * **user** - The `user` string provided during authentication.
 * **group** - The list of group names to which the authenticated user belongs.
 * **extra** - A map of arbitrary string keys to string values, provided by the authentication layer.
 * **API** - Indicates whether the request is for an API resource.
 * **Request path** - Path to miscellaneous non-resource endpoints like `/api` or `/healthz`.
 * **API request verb** - API verbs `get`, `list`, `create`, `update`, `patch`, `watch`, `proxy`, `redirect`, `delete`, and `deletecollection` are used for resource requests. To determine the request verb for a resource API endpoint, see [Determine the request verb](/docs/reference/access-authn-authz/authorization/#determine-whether-a-request-is-allowed-or-denied) below.
 * **HTTP request verb** - HTTP verbs `get`, `post`, `put`, and `delete` are used for non-resource requests.
 * **Resource** - The ID or name of the resource that is being accessed (for resource requests only) -- For resource requests using `get`, `update`, `patch`, and `delete` verbs, you must provide the resource name.
 * **Subresource** - The subresource that is being accessed (for resource requests only).
 * **Namespace** - The namespace of the object that is being accessed (for namespaced resource requests only).
 * **API group** - The <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a> being accessed (for resource requests only). An empty string designates the _core_ [API group](/docs/reference/using-api/#api-groups).
-->
<h2 id="审查你的请求属性">审查你的请求属性</h2>
<p>Kubernetes 仅审查以下 API 请求属性：</p>
<ul>
<li><strong>用户</strong> - 身份验证期间提供的 <code>user</code> 字符串。</li>
<li><strong>组</strong> - 经过身份验证的用户所属的组名列表。</li>
<li><strong>额外信息</strong> - 由身份验证层提供的任意字符串键到字符串值的映射。</li>
<li><strong>API</strong> - 指示请求是否针对 API 资源。</li>
<li><strong>请求路径</strong> - 各种非资源端点的路径，如 <code>/api</code> 或 <code>/healthz</code>。</li>
<li><strong>API 请求动词</strong> - API 动词 <code>get</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>patch</code>、<code>watch</code>、
<code>proxy</code>、<code>redirect</code>、<code>delete</code> 和 <code>deletecollection</code> 用于资源请求。
要确定资源 API 端点的请求动词，请参阅
<a href="#determine-the-request-verb">确定请求动词</a>。</li>
<li><strong>HTTP 请求动词</strong> - HTTP 动词 <code>get</code>、<code>post</code>、<code>put</code> 和 <code>delete</code> 用于非资源请求。</li>
<li><strong>Resource</strong> - 正在访问的资源的 ID 或名称（仅限资源请求）-
对于使用 <code>get</code>、<code>update</code>、<code>patch</code> 和 <code>delete</code> 动词的资源请求，你必须提供资源名称。</li>
<li><strong>子资源</strong> - 正在访问的子资源（仅限资源请求）。</li>
<li><strong>名字空间</strong> - 正在访问的对象的名称空间（仅适用于名字空间资源请求）。</li>
<li><strong>API 组</strong> - 正在访问的 <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>
（仅限资源请求）。空字符串表示<a href="/zh/docs/reference/using-api/#api-groups">核心 API 组</a>。</li>
</ul>
<!--
## Determine the Request Verb

**Non-resource requests**
Requests to endpoints other than `/api/v1/...` or `/apis/<group>/<version>/...`
are considered "non-resource requests", and use the lower-cased HTTP method of the request as the verb.
For example, a `GET` request to endpoints like `/api` or `/healthz` would use `get` as the verb.
-->
<h2 id="determine-the-request-verb">确定请求动词 </h2>
<p><strong>非资源请求</strong></p>
<p>对于 <code>/api/v1/...</code> 或 <code>/apis/&lt;group&gt;/&lt;version&gt;/...</code> 之外的端点的请求被
视为“非资源请求（Non-Resource Requests）”，并使用该请求的 HTTP 方法的
小写形式作为其请求动词。
例如，对 <code>/api</code> 或 <code>/healthz</code> 这类端点的 <code>GET</code> 请求将使用 <code>get</code> 作为其动词。</p>
<!--
**Resource requests**

To determine the request verb for a resource API endpoint, review the HTTP verb
used and whether or not the request acts on an individual resource or a
collection of resources:
-->
<p><strong>资源请求</strong></p>
<p>要确定对资源 API 端点的请求动词，需要查看所使用的 HTTP 动词以及该请求是针对
单个资源还是一组资源：</p>
<!--
HTTP verb | request verb
----------|---------------
POST      | create
GET, HEAD | get (for individual resources), list (for collections)
PUT       | update
PATCH     | patch
DELETE    | delete (for individual resources), deletecollection (for collections)
-->
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get （针对单个资源）、list（针对集合）</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（针对单个资源）、deletecollection（针对集合）</td>
</tr>
</tbody>
</table>
<!--
Kubernetes sometimes checks authorization for additional permissions using specialized verbs. For example:

* [PodSecurityPolicy](/docs/concepts/security/pod-security-policy/)
  * `use` verb on `podsecuritypolicies` resources in the `policy` API group.
* [RBAC](/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping)
  * `bind` and `escalate` verbs on `roles` and `clusterroles` resources in the `rbac.authorization.k8s.io` API group.
* [Authentication](/docs/reference/access-authn-authz/authentication/)
  * `impersonate` verb on `users`, `groups`, and `serviceaccounts` in the core API group, and the `userextras` in the `authentication.k8s.io` API group.
-->
<p>Kubernetes 有时使用专门的动词以对额外的权限进行鉴权。例如：</p>
<ul>
<li><a href="/zh/docs/concepts/security/pod-security-policy/">PodSecurityPolicy</a>
<ul>
<li><code>policy</code> API 组中 <code>podsecuritypolicies</code> 资源使用 <code>use</code> 动词</li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping">RBAC</a>
<ul>
<li>对 <code>rbac.authorization.k8s.io</code> API 组中 <code>roles</code> 和 <code>clusterroles</code> 资源的 <code>bind</code>
和 <code>escalate</code> 动词</li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证</a>
<ul>
<li>对核心 API 组中 <code>users</code>、<code>groups</code> 和 <code>serviceaccounts</code> 以及 <code>authentication.k8s.io</code>
API 组中的 <code>userextras</code> 所使用的 <code>impersonate</code> 动词。</li>
</ul>
</li>
</ul>
<!--
## Authorization Modules  {#authorization-modules}

 * **Node** - A special-purpose authorizer that grants permissions to kubelets based on the pods they are scheduled to run. To learn more about using the Node authorization mode, see [Node Authorization](/docs/reference/access-authn-authz/node/).
 * **ABAC** - Attribute-based access control (ABAC) defines an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes, etc). To learn more about using the ABAC mode, see [ABAC Mode](/docs/reference/access-authn-authz/abac/).
 * **RBAC** - Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within an enterprise. In this context, access is the ability of an individual user to perform a specific task, such as view, create, or modify a file. To learn more about using the RBAC mode, see [RBAC Mode](/docs/reference/access-authn-authz/rbac/)
   * When specified RBAC (Role-Based Access Control) uses the `rbac.authorization.k8s.io` API group to drive authorization decisions, allowing admins to dynamically configure permission policies through the Kubernetes API.
   * To enable RBAC, start the apiserver with `--authorization-mode=RBAC`.
 * **Webhook** - A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen. To learn more about using the Webhook mode, see [Webhook Mode](/docs/reference/access-authn-authz/webhook/).
-->
<h2 id="authorization-modules">鉴权模块 </h2>
<ul>
<li><strong>Node</strong> - 一个专用鉴权组件，根据调度到 kubelet 上运行的 Pod 为 kubelet 授予权限。
了解有关使用节点鉴权模式的更多信息，请参阅<a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a>。</li>
<li><strong>ABAC</strong> - 基于属性的访问控制（ABAC）定义了一种访问控制范型，通过使用将属性组合
在一起的策略，将访问权限授予用户。策略可以使用任何类型的属性（用户属性、资源属性、
对象，环境属性等）。要了解有关使用 ABAC 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/abac/">ABAC 模式</a>。</li>
<li><strong>RBAC</strong> - 基于角色的访问控制（RBAC）是一种基于企业内个人用户的角色来管理对
计算机或网络资源的访问的方法。在此上下文中，权限是单个用户执行特定任务的能力，
例如查看、创建或修改文件。要了解有关使用 RBAC 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC 模式</a>。
<ul>
<li>被启用之后，RBAC（基于角色的访问控制）使用 <code>rbac.authorization.k8s.io</code> API 组来
驱动鉴权决策，从而允许管理员通过 Kubernetes API 动态配置权限策略。</li>
<li>要启用 RBAC，请使用 <code>--authorization-mode = RBAC</code> 启动 API 服务器。</li>
</ul>
</li>
<li><strong>Webhook</strong> - WebHook 是一个 HTTP 回调：发生某些事情时调用的 HTTP POST；
通过 HTTP POST 进行简单的事件通知。实现 WebHook 的 Web 应用程序会在发生某些事情时
将消息发布到 URL。要了解有关使用 Webhook 模式的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/webhook/">Webhook 模式</a>。</li>
</ul>
<!--
#### Checking API Access

`kubectl` provides the `auth can-i` subcommand for quickly querying the API authorization layer.
The command uses the `SelfSubjectAccessReview` API to determine if the current user can perform
a given action, and works regardless of the authorization mode used.
-->
<h4 id="checking-api-access">检查 API 访问  </h4>
<p><code>kubectl</code> 提供 <code>auth can-i</code> 子命令，用于快速查询 API 鉴权。
该命令使用 <code>SelfSubjectAccessReview</code> API 来确定当前用户是否可以执行给定操作，
无论使用何种鉴权模式该命令都可以工作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth can-i create deployments --namespace dev
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>yes
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth can-i create deployments --namespace prod
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>no
</code></pre><!--
Administrators can combine this with [user impersonation](/docs/reference/access-authn-authz/authentication/#user-impersonation)
to determine what action other users can perform.
-->
<p>管理员可以将此与
<a href="/zh/docs/reference/access-authn-authz/authentication/#user-impersonation">用户扮演</a>
结合使用，以确定其他用户可以执行的操作。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl auth can-i list secrets --namespace dev --as dave
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>no
</code></pre><!--
Similarly, to check whether a ServiceAccount named `dev-sa` in Namespace `dev`
can list Pods in the Namespace `target`:
-->
<p>类似地，检查名字空间 <code>dev</code> 里的 <code>dev-sa</code> 服务账号是否可以列举名字空间 <code>target</code> 里的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl auth can-i list pods <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>	--namespace target <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>	--as system:serviceaccount:dev:dev-sa
</code></pre></div><!-- The output is similar to this: -->
<p>输出类似于：</p>
<pre><code>yes
</code></pre><!--
`SelfSubjectAccessReview` is part of the `authorization.k8s.io` API group, which
exposes the API server authorization to external services. Other resources in
this group include:

* `SubjectAccessReview` - Access review for any user, not only the current one. Useful for delegating authorization decisions to the API server. For example, the kubelet and extension API servers use this to determine user access to their own APIs.
* `LocalSubjectAccessReview` - Like `SubjectAccessReview` but restricted to a specific namespace.
* `SelfSubjectRulesReview` - A review which returns the set of actions a user can perform within a namespace. Useful for users to quickly summarize their own access, or for UIs to hide/show actions.

These APIs can be queried by creating normal Kubernetes resources, where the response "status"
field of the returned object is the result of the query.
-->
<p><code>SelfSubjectAccessReview</code> 是 <code>authorization.k8s.io</code> API 组的一部分，它将 API
服务器鉴权公开给外部服务。该组中的其他资源包括：</p>
<ul>
<li><code>SubjectAccessReview</code> - 对任意用户的访问进行评估，而不仅仅是当前用户。
当鉴权决策被委派给 API 服务器时很有用。例如，kubelet 和扩展 API 服务器使用
它来确定用户对自己的 API 的访问权限。</li>
<li><code>LocalSubjectAccessReview</code> - 与 <code>SubjectAccessReview</code> 类似，但仅限于特定的
名字空间。</li>
<li><code>SelfSubjectRulesReview</code> - 返回用户可在名字空间内执行的操作集的审阅。
用户可以快速汇总自己的访问权限，或者用于 UI 中的隐藏/显示动作。</li>
</ul>
<p>可以通过创建普通的 Kubernetes 资源来查询这些 API，其中返回对象的响应 &quot;status&quot;
字段是查询的结果。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl create -f - -o yaml <span style="color:#b44">&lt;&lt; EOF
</span><span style="color:#b44">apiVersion: authorization.k8s.io/v1
</span><span style="color:#b44">kind: SelfSubjectAccessReview
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  resourceAttributes:
</span><span style="color:#b44">    group: apps
</span><span style="color:#b44">    name: deployments
</span><span style="color:#b44">    verb: create
</span><span style="color:#b44">    namespace: dev
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
The generated `SelfSubjectAccessReview` is:
-->
<p>生成的 <code>SelfSubjectAccessReview</code> 为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>SelfSubjectAccessReview<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">creationTimestamp</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">null</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceAttributes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">group</span>:<span style="color:#bbb"> </span>apps<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>deployments<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>dev<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verb</span>:<span style="color:#bbb"> </span>create<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">status</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">allowed</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">denied</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">false</span><span style="color:#bbb">
</span></code></pre></div><!--
## Using Flags for Your Authorization Module

You must include a flag in your policy to indicate which authorization module
your policies include:

The following flags can be used:
-->
<h2 id="为你的鉴权模块设置参数">为你的鉴权模块设置参数</h2>
<p>你必须在策略中包含一个参数标志，以指明你的策略包含哪个鉴权模块：</p>
<p>可以使用的参数有：</p>
<!--
  * `--authorization-mode=ABAC` Attribute-Based Access Control (ABAC) mode allows you to configure policies using local files.
  * `--authorization-mode=RBAC` Role-based access control (RBAC) mode allows you to create and store policies using the Kubernetes API.
  * `--authorization-mode=Webhook` WebHook is an HTTP callback mode that allows you to manage authorization using a remote REST endpoint.
  * `--authorization-mode=Node` Node authorization is a special-purpose authorization mode that specifically authorizes API requests made by kubelets.
  * `--authorization-mode=AlwaysDeny` This flag blocks all requests. Use this flag only for testing.
  * `--authorization-mode=AlwaysAllow` This flag allows all requests. Use this flag only if you do not require authorization for your API requests.
-->
<ul>
<li><code>--authorization-mode=ABAC</code> 基于属性的访问控制（ABAC）模式允许你
使用本地文件配置策略。</li>
<li><code>--authorization-mode=RBAC</code> 基于角色的访问控制（RBAC）模式允许你使用
Kubernetes API 创建和存储策略。</li>
<li><code>--authorization-mode=Webhook</code> WebHook 是一种 HTTP 回调模式，允许你使用远程
REST 端点管理鉴权。</li>
<li><code>--authorization-mode=Node</code> 节点鉴权是一种特殊用途的鉴权模式，专门对
kubelet 发出的 API 请求执行鉴权。</li>
<li><code>--authorization-mode=AlwaysDeny</code> 该标志阻止所有请求。仅将此标志用于测试。</li>
<li><code>--authorization-mode=AlwaysAllow</code> 此标志允许所有请求。仅在你不需要 API 请求
的鉴权时才使用此标志。</li>
</ul>
<!--
You can choose more than one authorization module. Modules are checked in order
so an earlier module has higher priority to allow or deny a request.
-->
<p>你可以选择多个鉴权模块。模块按顺序检查，以便较靠前的模块具有更高的优先级来允许
或拒绝请求。</p>
<!--
## Privilege escalation via workload creation or edits {#privilege-escalation-via-pod-creation}

Users who can create/edit pods in a namespace, either directly or through a [controller](/docs/concepts/architecture/controller/)
such as an operator, could escalate their privileges in that namespace.
-->
<h2 id="privilege-escalation-via-pod-creation">通过创建或编辑工作负载提升权限</h2>
<p>能够在名字空间中创建或者编辑 Pod 的用户，
无论是直接操作还是通过<a href="/zh/docs/concepts/architecture/controller/">控制器</a>（例如，一个 Operator）来操作，
都可以提升他们在该名字空间内的权限。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
System administrators, use care when granting access to create or edit workloads.
Details of how these can be misused are documented in [escalation paths](/docs/reference/access-authn-authz/authorization/#escalation-paths)
-->
<p>系统管理员在授予对工作负载的创建或编辑的权限时要小心。
关于这些权限如何被误用的详细信息请参阅
<a href="#escalation-paths">提升途径</a>
</div>

<!--
### Escalation paths {#escalation-paths}
- Mounting arbitrary secrets in that namespace
  - Can be used to access secrets meant for other workloads
  - Can be used to obtain a more privileged service account's service account token
- Using arbitrary Service Accounts in that namespace
  - Can perform Kubernetes API actions as another workload (impersonation)
  - Can perform any privileged actions that Service Account has
- Mounting configmaps meant for other workloads in that namespace
  - Can be used to obtain information meant for other workloads, such as DB host names.
- Mounting volumes meant for other workloads in that namespace
  - Can be used to obtain information meant for other workloads, and change it.
-->
<h3 id="escalation-paths">提升途径</h3>
<ul>
<li>挂载该名字空间内的任意 Secret
<ul>
<li>可以用来访问其他工作负载专用的 Secret</li>
<li>可以用来获取权限更高的服务账号的令牌</li>
</ul>
</li>
<li>使用该名字空间内的任意服务账号
<ul>
<li>可以用另一个工作负载的身份来访问 Kubernetes API（伪装）</li>
<li>可以执行该服务账号的任意特权操作</li>
</ul>
</li>
<li>挂载该名字空间里其他工作负载专用的 ConfigMap
<ul>
<li>可以用来获取其他工作负载专用的信息，例如数据库主机名。</li>
</ul>
</li>
<li>挂载该名字空间里其他工作负载的卷
<ul>
<li>可以用来获取其他工作负载专用的信息，并且更改它。</li>
</ul>
</li>
</ul>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
System administrators should be cautious when deploying CRDs that
change the above areas. These may open privilege escalations paths.
This should be considered when deciding on your RBAC controls.
-->
<p>系统管理员在部署改变以上部分的 CRD 的时候要小心。
它们可能会打开权限提升的途径。
在决定你的 RBAC 控制时应该考虑这方面的问题。
</div>

<h2 id="what-s-next">What's next</h2>
<!--
* To learn more about Authentication, see **Authentication** in [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/).
* To learn more about Admission Control, see [Using Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/).
-->
<ul>
<li>要了解有关身份验证的更多信息，请参阅
<a href="/zh/docs/concepts/security/controlling-access/">控制对 Kubernetes API 的访问</a>
中的 <strong>身份验证</strong>  部分。</li>
<li>要了解有关准入控制的更多信息，请参阅
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">使用准入控制器</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-954776b47f2d90515f375623a0ce98e1">8 - 使用 RBAC 鉴权</h1>
    
	<!--
reviewers:
- erictune
- deads2k
- liggitt
title: Using RBAC Authorization
content_type: concept
weight: 70
-->
<!-- overview -->
<!--
Role-based access control (RBAC) is a method of regulating access to computer or
network resources based on the roles of individual users within your organization.
-->
<p>基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对
计算机或网络资源的访问的方法。</p>
<!-- body -->
<!--
RBAC authorization uses the `rbac.authorization.k8s.io`
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a> to drive authorization
decisions, allowing you to dynamically configure policies through the Kubernetes API.
-->
<p>RBAC 鉴权机制使用 <code>rbac.authorization.k8s.io</code>
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>
来驱动鉴权决定，允许你通过 Kubernetes API 动态配置策略。</p>
<!--
To enable RBAC, start the <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API server'>API server</a>
with the `-authorization-mode` flag set to a comma-separated list that includes `RBAC`;
for example:
-->
<p>要启用 RBAC，在启动 <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API 服务器'>API 服务器</a>
时将 <code>--authorization-mode</code> 参数设置为一个逗号分隔的列表并确保其中包含 <code>RBAC</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kube-apiserver --authorization-mode<span style="color:#666">=</span>Example,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;
</code></pre></div><!--
## API objects {#api-overview}

The RBAC API declares four kinds of Kubernetes object: _Role_, _ClusterRole_,
_RoleBinding_ and _ClusterRoleBinding_. You can
[describe objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects),
or amend them, using tools such as `kubectl`, just like any other Kubernetes object.

-->
<h2 id="api-overview">API 对象 </h2>
<p>RBAC API 声明了四种 Kubernetes 对象：<em>Role</em>、<em>ClusterRole</em>、<em>RoleBinding</em> 和
<em>ClusterRoleBinding</em>。你可以像使用其他 Kubernetes 对象一样，
通过类似 <code>kubectl</code> 这类工具
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects">描述对象</a>,
或修补对象。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
These objects, by design, impose access restrictions. If you are making changes
to a cluster as you learn, see
[privilege escalation prevention and bootstrapping](#privilege-escalation-prevention-and-bootstrapping)
to understand how those restrictions can prevent you making some changes.
-->
<p>这些对象在设计时即实施了一些访问限制。如果你在学习过程中对集群做了更改，请参考
<a href="#privilege-escalation-prevention-and-bootstrapping">避免特权提升和引导</a>
一节，以了解这些限制会以怎样的方式阻止你做出修改。
</div>

<!--
### Role and ClusterRole

An RBAC _Role_ or _ClusterRole_ contains rules that represent a set of permissions.
Permissions are purely additive (there are no "deny" rules).

A Role always sets permissions within a particular <a class='glossary-tooltip' title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespace'>namespace</a>;
when you create a Role, you have to specify the namespace it belongs in.

ClusterRole, by contrast, is a non-namespaced resource. The resources have different names (Role
and ClusterRole) because a Kubernetes object always has to be either namespaced or not namespaced;
it can't be both.
-->
<h3 id="role-and-clusterole">Role 和 ClusterRole  </h3>
<p>RBAC 的 <em>Role</em> 或 <em>ClusterRole</em> 中包含一组代表相关权限的规则。
这些权限是纯粹累加的（不存在拒绝某操作的规则）。</p>
<p>Role 总是用来在某个<a class='glossary-tooltip' title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a>
内设置访问权限；在你创建 Role 时，你必须指定该 Role 所属的名字空间。</p>
<p>与之相对，ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和
ClusterRole）是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，
不可两者兼具。</p>
<!--
ClusterRoles have several uses. You can use a ClusterRole to:

1. define permissions on namespaced resources and be granted within individual namespace(s)
1. define permissions on namespaced resources and be granted across all namespaces
1. define permissions on cluster-scoped resources

If you want to define a role within a namespace, use a Role; if you want to define
a role cluster-wide, use a ClusterRole.
-->
<p>ClusterRole 有若干用法。你可以用它来：</p>
<ol>
<li>定义对某名字空间域对象的访问权限，并将在各个名字空间内完成授权；</li>
<li>为名字空间作用域的对象设置访问权限，并跨所有名字空间执行授权；</li>
<li>为集群作用域的资源定义访问权限。</li>
</ol>
<p>如果你希望在名字空间内定义角色，应该使用 Role；
如果你希望定义集群范围的角色，应该使用 ClusterRole。</p>
<!--
#### Role example

Here's an example Role in the "default" namespace that can be used to grant read access to
<a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='pods'>pods</a>:
-->
<h4 id="role-示例">Role 示例</h4>
<p>下面是一个位于 &quot;default&quot; 名字空间的 Role 的示例，可用来授予对
<a class='glossary-tooltip' title='Pod 表示您的集群上一组正在运行的容器。' data-toggle='tooltip' data-placement='top' href='/docs/concepts/workloads/pods/pod-overview/' target='_blank' aria-label='pods'>pods</a> 的读访问权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#34;&#34; 标明 core API 组</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
#### ClusterRole example

A ClusterRole can be used to grant the same permissions as a Role.
Because they are cluster-scoped, you can also use them to grant access to:

* cluster-scoped resources (like <a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='nodes'>nodes</a>)
* non-resource endpoints (like `/healthz`)
* namespaced resources (like Pods), across all namespaces

  For example: you can use a ClusterRole to allow a particular user to run
  `kubectl get pods -all-namespaces`
-->
<h3 id="clusterrole-示例">ClusterRole 示例</h3>
<p>ClusterRole 可以和 Role 相同完成授权。
因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p>
<ul>
<li>
<p>集群范围资源（比如 <a class='glossary-tooltip' title='Kubernetes 中的工作机器称作节点。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/nodes/' target='_blank' aria-label='节点（Node）'>节点（Node）</a>）</p>
</li>
<li>
<p>非资源端点（比如 <code>/healthz</code>）</p>
</li>
<li>
<p>跨名字空间访问的名字空间作用域的资源（如 Pods）</p>
<p>比如，你可以使用 ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></p>
</li>
</ul>
<!--
Here is an example of a ClusterRole that can be used to grant read access to
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='secrets'>secrets</a> in any particular namespace,
or across all namespaces (depending on how it is [bound](#rolebinding-and-clusterrolebinding)):
-->
<p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='Secret'>Secret</a> 授予读访问权限，
或者跨名字空间的访问权限（取决于该角色是如何<a href="#rolebinding-and-clusterrolebinding">绑定</a>的）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># &#34;namespace&#34; 被忽略，因为 ClusterRoles 不受名字空间限制</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &#34;secrets&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;secrets&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The name of a Role or a ClusterRole object must be a valid
[path segment name](/docs/concepts/overview/working-with-objects/names#path-segment-names).
-->
<p>Role 或 ClusterRole 对象的名称必须是合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#path-segment-names">路径区段名称</a>。</p>
<!--
### RoleBinding and ClusterRoleBinding

A role binding grants the permissions defined in a role to a user or set of users.
It holds a list of *subjects* (users, groups, or service accounts), and a reference to the
role being granted.
A RoleBinding grants permissions within a specific namespace whereas a ClusterRoleBinding
grants that access cluster-wide.

A RoleBinding may reference any Role in the same namespace. Alternatively, a RoleBinding
can reference a ClusterRole and bind that ClusterRole to the namespace of the RoleBinding.
If you want to bind a ClusterRole to all the namespaces in your cluster, you use a
ClusterRoleBinding.

The name of a RoleBinding or ClusterRoleBinding object must be a valid
[path segment name](/docs/concepts/overview/working-with-objects/names#path-segment-names).
-->
<h3 id="rolebinding-and-clusterrolebinding">RoleBinding 和 ClusterRoleBinding  </h3>
<p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。
它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。
RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。</p>
<p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。
或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到
RoleBinding 所在的名字空间。
如果你希望将某  ClusterRole 绑定到集群中所有名字空间，你要使用 ClusterRoleBinding。</p>
<p>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names#path-segment-names">路径区段名称</a>。</p>
<!--
#### RoleBinding examples {#rolebinding-example}

Here is an example of a RoleBinding that grants the "pod-reader" Role to the user "jane"
within the "default" namespace.
This allows "jane" to read pods in the "default" namespace.
-->
<h4 id="rolebinding-example">RoleBinding 示例  </h4>
<p>下面的例子中的 RoleBinding 将 &quot;pod-reader&quot; Role 授予在 &quot;default&quot; 名字空间中的用户 &quot;jane&quot;。
这样，用户 &quot;jane&quot; 就具有了读取 &quot;default&quot; 名字空间中 pods 的权限。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此角色绑定允许 &#34;jane&#34; 读取 &#34;default&#34; 名字空间中的 Pods</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-pods<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 你可以指定不止一个“subject（主体）”</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>jane<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#34;name&#34; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># &#34;roleRef&#34; 指定与某 Role 或 ClusterRole 的绑定关系</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 此字段必须是 Role 或 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-reader    <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
A RoleBinding can also reference a ClusterRole to grant the permissions defined in that
ClusterRole to resources inside the RoleBinding's namespace. This kind of reference
lets you define a set of common roles across your cluster, then reuse them within
multiple namespaces.

For instance, even though the following RoleBinding refers to a ClusterRole,
"dave" (the subject, case sensitive) will only be able to read Secrets in the "development"
namespace, because the RoleBinding's namespace (in its metadata) is "development".
-->
<p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予
RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色，
之后在多个名字空间中复用。</p>
<p>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，&quot;dave&quot;（这里的主体，
区分大小写）只能访问 &quot;development&quot; 名字空间中的 Secrets 对象，因为 RoleBinding
所在的名字空间（由其 metadata 决定）是 &quot;development&quot;。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此角色绑定使得用户 &#34;dave&#34; 能够读取 &#34;development&#34; 名字空间中的 Secrets</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 你需要一个名为 &#34;secret-reader&#34; 的 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-secrets<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># RoleBinding 的名字空间决定了访问权限的授予范围。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 这里隐含授权仅在 &#34;development&#34; 名字空间内的访问权限。</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dave<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#39;name&#39; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
#### ClusterRoleBinding example

To grant permissions across a whole cluster, you can use a ClusterRoleBinding.
The following ClusterRoleBinding allows any user in the group "manager" to read
secrets in any namespace.
-->
<h4 id="clusterrolebinding-example">ClusterRoleBinding 示例  </h4>
<p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。
下面的 ClusterRoleBinding 允许 &quot;manager&quot; 组内的所有用户访问任何名字空间中的
Secrets。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>read-secrets-global<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>manager<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># &#39;name&#39; 是区分大小写的</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>secret-reader<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
After you create a binding, you cannot change the Role or ClusterRole that it refers to.
If you try to change a binding's `roleRef`, you get a validation error. If you do want
to change the `roleRef` for a binding, you need to remove the binding object and create
a replacement.

There are two reasons for this restriction:
-->
<p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。
试图改变绑定对象的 <code>roleRef</code> 将导致合法性检查错误。
如果你想要改变现有绑定对象中 <code>roleRef</code> 字段的内容，必须删除重新创建绑定对象。</p>
<p>这种限制有两个主要原因：</p>
<!--
1. A binding to a different role is a fundamentally different binding.
Requiring a binding to be deleted/recreated in order to change the `roleRef`
ensures the full list of subjects in the binding is intended to be granted
the new role (as opposed to enabling or accidentally modifying only the roleRef
without verifying all of the existing subjects should be given the new role's permissions).
2. Making `roleRef` immutable allows giving `update` permission on an existing binding object
to a user, which lets them manage the list of subjects, without being able to change the
role that is granted to those subjects.
-->
<ol>
<li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改 <code>roleRef</code>,
这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改
了 <code>roleRef</code> 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li>
<li>将 <code>roleRef</code> 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 <code>update</code> 权限，
这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li>
</ol>
<!--
The `kubectl auth reconcile` command-line utility creates or updates a manifest file containing RBAC objects,
and handles deleting and recreating binding objects if required to change the role they refer to.
See [command usage and examples](#kubectl-auth-reconcile) for more information.
-->
<p>命令 <code>kubectl auth reconcile</code> 可以创建或者更新包含 RBAC 对象的清单文件，
并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。
更多相关信息请参照<a href="#kubectl-auth-reconcile">命令用法和示例</a></p>
<!--
### Referring to Resources

In the Kubernetes API, most resources are represented and accessed using a string representation of
their object name, such as `pods` for a Pod. RBAC refers to resources using exactly the same
name that appears in the URL for the relevant API endpoint.
Some Kubernetes APIs involve a
_subresource_, such as the logs for a Pod. A request for a Pod's logs looks like:
-->
<h3 id="referring-to-resources">对资源的引用   </h3>
<p>在 Kubernetes API 中，大多数资源都是使用对象名称的字符串表示来呈现与访问的。
例如，对于 Pod 应使用 &quot;pods&quot;。
RBAC 使用对应 API 端点的 URL 中呈现的名字来引用资源。
有一些 Kubernetes API 涉及 <strong>子资源（subresource）</strong>，例如 Pod 的日志。
对 Pod 日志的请求看起来像这样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="">GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div><!--
In this case, `pods` is the namespaced resource for Pod resources, and `log` is a
subresource of `pods`. To represent this in an RBAC role, use a slash (`/`) to
delimit the resource and subresource. To allow a subject to read `pods` and
also access the `log` subresource for each of those Pods, you write:
-->
<p>在这里，<code>pods</code> 对应名字空间作用域的 Pod 资源，而 <code>log</code> 是 <code>pods</code> 的子资源。
在 RBAC 角色表达子资源时，使用斜线（<code>/</code>）来分隔资源和子资源。
要允许某主体读取 <code>pods</code> 同时访问这些 Pod 的 <code>log</code> 子资源，你可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>pod-and-pod-logs-reader<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;pods/log&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
You can also refer to resources by name for certain requests through the `resourceNames` list.
When specified, requests can be restricted to individual instances of a resource.
Here is an example that restricts its subject to only `get` or `update` a
<a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a> named `my-configmap`:
-->
<p>对于某些请求，也可以通过 <code>resourceNames</code> 列表按名称引用资源。
在指定时，可以将请求限定为资源的单个实例。
下面的例子中限制可以 &quot;get&quot; 和 &quot;update&quot; 一个名为 <code>my-configmap</code> 的
<a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Role<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>configmap-updater<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 ConfigMap 的资源的名称为 &#34;configmaps&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;configmaps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;my-configmap&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;get&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
You cannot restrict `create` or `deletecollection` requests by their resource name.
For `create`, this limitation is because the name of the new object may not be known at authorization time.
If you restrict `list` or `watch` by resourceName, clients must include a `metadata.name` field selector in their `list` or `watch` request that matches the specified resourceName in order to be authorized.
For example, `kubectl get configmaps --field-selector=metadata.name=my-configmap`
-->
<p>你不能使用资源名字来限制 <code>create</code> 或者 <code>deletecollection</code> 请求。
对于 <code>create</code> 请求而言，这是因为在鉴权时可能还不知道新对象的名字。
如果你使用 resourceName 来限制 <code>list</code> 或者 <code>watch</code> 请求，
客户端必须在它们的 <code>list</code> 或者 <code>watch</code> 请求里包含一个与指定的 resourceName 匹配的 <code>metadata.name</code> 字段选择器。
例如，<code>kubectl get configmaps --field-selector=metadata.name=my-configmap</code>
</div>
<!--
### Aggregated ClusterRoles

You can _aggregate_ several ClusterRoles into one combined ClusterRole.
A controller, running as part of the cluster control plane, watches for ClusterRole
objects with an `aggregationRule` set. The `aggregationRule` defines a label
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='selector'>selector</a> that the controller
uses to match other ClusterRole objects that should be combined into the `rules`
field of this one.

Here is an example aggregated ClusterRole:
-->
<h3 id="aggregated-clusterroles">聚合的 ClusterRole   </h3>
<p>你可以将若干 ClusterRole <strong>聚合（Aggregate）</strong> 起来，形成一个复合的 ClusterRole。
某个控制器作为集群控制面的一部分会监视带有 <code>aggregationRule</code> 的 ClusterRole
对象集合。<code>aggregationRule</code> 为控制器定义一个标签
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择算符'>选择算符</a>供后者匹配
应该组合到当前 ClusterRole 的 <code>roles</code> 字段中的 ClusterRole 对象。</p>
<p>下面是一个聚合 ClusterRole 的示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>monitoring<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">aggregationRule</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">clusterRoleSelectors</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">rbac.example.com/aggregate-to-monitoring</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb"> </span>[]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># 控制面自动填充这里的规则</span><span style="color:#bbb">
</span></code></pre></div><!--
If you create a new ClusterRole that matches the label selector of an existing aggregated ClusterRole,
that change triggers adding the new rules into the aggregated ClusterRole.
Here is an example that adds rules to the "monitoring" ClusterRole, by creating another
ClusterRole labeled `rbac.example.com/aggregate-to-monitoring: true`.
-->
<p>如果你创建一个与某个已存在的聚合 ClusterRole 的标签选择算符匹配的 ClusterRole，
这一变化会触发新的规则被添加到聚合 ClusterRole 的操作。
下面的例子中，通过创建一个标签同样为 <code>rbac.example.com/aggregate-to-monitoring: true</code>
的 ClusterRole，新的规则可被添加到 &quot;monitoring&quot; ClusterRole 中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>monitoring-endpoints<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.example.com/aggregate-to-monitoring</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 当你创建 &#34;monitoring-endpoints&#34; ClusterRole 时，</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># 下面的规则会被添加到 &#34;monitoring&#34; ClusterRole 中</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;services&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;endpoints&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
The [default user-facing roles](#default-roles-and-role-bindings) use ClusterRole aggregation. This lets you,
as a cluster administrator, include rules for custom resources, such as those served by
<a class='glossary-tooltip' title='通过定制化的代码给您的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/' target='_blank' aria-label='CustomResourceDefinitions'>CustomResourceDefinitions</a>
or aggregated API servers, to extend the default roles.

For example: the following ClusterRoles let the "admin" and "edit" default roles manage the custom resource
named CronTab, whereas the "view" role can perform only read actions on CronTab resources.
You can assume that CronTab objects are named `"crontabs"` in URLs as seen by the API server.
-->
<p>默认的<a href="#default-roles-and-role-bindings">面向用户的角色</a> 使用 ClusterRole 聚合。
这使得作为集群管理员的你可以为扩展默认规则，包括为定制资源设置规则，
比如通过 CustomResourceDefinitions 或聚合 API 服务器提供的定制资源。</p>
<p>例如，下面的 ClusterRoles 让默认角色 &quot;admin&quot; 和 &quot;edit&quot; 拥有管理自定义资源 &quot;CronTabs&quot; 的权限，
&quot;view&quot; 角色对 CronTab 资源拥有读操作权限。
你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为 <code>&quot;crontabs&quot;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>aggregate-cron-tabs-edit<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 添加以下权限到默认角色 &#34;admin&#34; 和 &#34;edit&#34; 中</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;stable.example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;crontabs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>aggregate-cron-tabs-view<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-style:italic"># 添加以下权限到 &#34;view&#34; 默认角色中</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-view</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;stable.example.com&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;crontabs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
#### Role Examples

The following examples are excerpts from Role or ClusterRole objects, showing only
the `rules` section.

Allow reading `"pods"` resources in the core
<a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API Group'>API Group</a>:
-->
<h4 id="role-examples">Role 示例  </h4>
<p>以下示例均为从 Role 或 ClusterRole 对象中截取出来，我们仅展示其 <code>rules</code> 部分。</p>
<p>允许读取在核心 <a class='glossary-tooltip' title='Kubernetes API 中的一组相关路径' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning' target='_blank' aria-label='API 组'>API 组</a>下的
<code>&quot;Pods&quot;</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 在 HTTP 层面，用来访问 Pod 的资源的名称为 &#34;pods&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading/writing Deployments (at the HTTP level: objects with `"deployments"`
in the resource part of their URL) in the `"apps"` API groups:
-->
<p>允许读/写在 <code>&quot;apps&quot;</code> API 组中的 Deployment（在 HTTP 层面，对应
URL 中资源部分为 &quot;deployments&quot;）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading Pods in the core API group, as well as reading or writing Job
resources in the `"batch"` API group:
-->
<p>允许读取核心 API 组中的 &quot;pods&quot; 和读/写 <code>&quot;batch&quot;</code> API 组中的
&quot;jobs&quot;：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;pods&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;batch&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;jobs&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading a ConfigMap named "my-config" (must be bound with a
RoleBinding to limit to a single ConfigMap in a single namespace):
-->
<p>允许读取名称为 &quot;my-config&quot; 的 ConfigMap（需要通过 RoleBinding 绑定以
限制为某名字空间中特定的 ConfigMap）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;configmaps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;my-config&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow reading the resource `"nodes"` in the core group (because a
Node is cluster-scoped, this must be in a ClusterRole bound with a
ClusterRoleBinding to be effective):
-->
<p>允许读取在核心组中的 &quot;nodes&quot; 资源（因为 <code>Node</code> 是集群作用域的，所以需要
ClusterRole 绑定到 ClusterRoleBinding 才生效）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;nodes&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;list&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;watch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
Allow GET and POST requests to the non-resource endpoint `/healthz` and
all subpaths (must be in a ClusterRole bound with a ClusterRoleBinding
to be effective):
-->
<p>允许针对非资源端点 <code>/healthz</code> 和其子路径上发起 GET 和 POST 请求
（必须在 ClusterRole 绑定 ClusterRoleBinding 才生效）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">nonResourceURLs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;/healthz&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;/healthz/*&#34;</span>]<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># nonResourceURL 中的 &#39;*&#39; 是一个全局通配符</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;get&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;post&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
### Referring to Subjects

A RoleBinding or ClusterRoleBinding binds a role to subjects.
Subjects can be groups, users or
<a class='glossary-tooltip' title='为在 Pod 中运行的进程提供标识。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-service-account/' target='_blank' aria-label='ServiceAccounts'>ServiceAccounts</a>.

Kubernetes represents usernames as strings.
These can be: plain names, such as "alice"; email-style names, like "bob@example.com";
or numeric user IDs represented as a string.  It is up to you as a cluster administrator
to configure the [authentication modules](/docs/reference/access-authn-authz/authentication/)
so that authentication produces usernames in the format you want.
-->
<h3 id="referring-to-subjects">对主体的引用  </h3>
<p>RoleBinding 或者 ClusterRoleBinding 可绑定角色到某 *主体（Subject）*上。
主体可以是组，用户或者
<a class='glossary-tooltip' title='为在 Pod 中运行的进程提供标识。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-service-account/' target='_blank' aria-label='服务账户'>服务账户</a>。</p>
<p>Kubernetes 用字符串来表示用户名。
用户名可以是普通的用户名，像 &quot;alice&quot;；或者是邮件风格的名称，如 &quot;bob@example.com&quot;，
或者是以字符串形式表达的数字 ID。
你作为 Kubernetes 管理员负责配置
<a href="/zh/docs/reference/access-authn-authz/authentication/">身份认证模块</a>
以便后者能够生成你所期望的格式的用户名。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
The prefix `system:` is reserved for Kubernetes system use, so you should ensure
that you don't have users or groups with names that start with `system:` by
accident.
Other than this special prefix, the RBAC authorization system does not require any format
for usernames.
-->
<p>前缀 <code>system:</code> 是 Kubernetes 系统保留的，所以你要确保
所配置的用户名或者组名不能出现上述 <code>system:</code> 前缀。
除了对前缀的限制之外，RBAC 鉴权系统不对用户名格式作任何要求。
</div>

<!--
In Kubernetes, Authenticator modules provide group information.
Groups, like users, are represented as strings, and that string has no format requirements,
other than that the prefix `system:` is reserved.

[Service Accounts](/docs/tasks/configure-pod-container/configure-service-account/) have usernames with the `system:serviceaccount:` prefix and belong
to groups with the `system:serviceaccounts:` prefix.
-->
<p>在 Kubernetes 中，鉴权模块提供用户组信息。
与用户名一样，用户组名也用字符串来表示，而且对该字符串没有格式要求，
只是不能使用保留的前缀 <code>system:</code>。</p>
<p><a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">服务账户</a>
的用户名前缀为 <code>system:serviceaccount:</code>，属于前缀为 <code>system:serviceaccounts:</code>
的用户组。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
- `system:serviceaccount:` (singular) is the prefix for service account usernames.
- `system:serviceaccounts:` (plural) is the prefix for service account groups.
-->
<ul>
<li><code>system:serviceaccount:</code> （单数）是用于服务账户用户名的前缀；</li>
<li><code>system:serviceaccounts:</code> （复数）是用于服务账户组名的前缀。</li>
</ul>

</div>
<!--
#### Role Binding Examples

The following examples are `RoleBinding` excerpts that only
show the `subjects` section.

For a user named `alice@example.com`:
-->
<h4 id="role-binding-examples">RoleBinding 示例  </h4>
<p>下面示例是 <code>RoleBinding</code> 中的片段，仅展示其 <code>subjects</code> 的部分。</p>
<p>对于名称为 <code>alice@example.com</code> 的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;alice@example.com&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For a group named `frontend-admins`:
-->
<p>对于名称为 <code>frontend-admins</code> 的用户组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;frontend-admins&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For the default service account in the "kube-system" namespace:
-->
<p>对于 <code>kube-system</code> 名字空间中的默认服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ServiceAccount<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>kube-system<span style="color:#bbb">
</span></code></pre></div><!--
For all service accounts in the "qa" namespace:
-->
<p>对于 &quot;qa&quot; 名称空间中的所有服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:serviceaccounts:qa<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all service accounts in any namespace:
-->
<p>对于在任何名字空间中的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:serviceaccounts<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all authenticated users:
-->
<p>对于所有已经过认证的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:authenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all unauthenticated users:
-->
<p>对于所有未通过认证的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:unauthenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
For all users:
-->
<p>对于所有用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:authenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Group<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>system:unauthenticated<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span></code></pre></div><!--
## Default roles and role bindings

API servers create a set of default ClusterRole and ClusterRoleBinding objects.
Many of these are `system:` prefixed, which indicates that the resource is directly
managed by the cluster control plane.
All of the default ClusterRoles and ClusterRoleBindings are labeled with `kubernetes.io/bootstrapping=rbac-defaults`.
-->
<h2 id="默认-roles-和-role-bindings">默认 Roles 和 Role Bindings</h2>
<p>API 服务器创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。
这其中许多是以 <code>system:</code> 为前缀的，用以标识对应资源是直接由集群控制面管理的。
所有的默认 ClusterRole 和 ClusterRoleBinding 都有
<code>kubernetes.io/bootstrapping=rbac-defaults</code>
标签。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
Take care when modifying ClusterRoles and ClusterRoleBindings with names
that have a `system:` prefix.
Modifications to these resources can result in non-functional clusters.
-->
<p>在修改名称包含 <code>system:</code> 前缀的 ClusterRole 和 ClusterRoleBinding
时要格外小心。
对这些资源的更改可能导致集群无法继续工作。
</div>

<!--
### Auto-reconciliation

At each start-up, the API server updates default cluster roles with any missing permissions,
and updates default cluster role bindings with any missing subjects.
This allows the cluster to repair accidental modifications, and helps to keep roles and role bindings
up-to-date as permissions and subjects change in new releases.

To opt out of this reconciliation, set the `rbac.authorization.kubernetes.io/autoupdate`
annotation on a default cluster role or rolebinding to `false`.
Be aware that missing default permissions and subjects can result in non-functional clusters.

Auto-reconciliation is enabled by default if the RBAC authorizer is active.
-->
<h3 id="auto-reconciliation">自动协商  </h3>
<p>在每次启动时，API 服务器都会更新默认 ClusterRole 以添加缺失的各种权限，并更新
默认的 ClusterRoleBinding 以增加缺失的各类主体。
这种自动协商机制允许集群去修复一些不小心发生的修改，并且有助于保证角色和角色绑定
在新的发行版本中有权限或主体变更时仍然保持最新。</p>
<p>如果要禁止此功能，请将默认 ClusterRole 以及 ClusterRoleBinding 的
<code>rbac.authorization.kubernetes.io/autoupdate</code> 注解设置成 <code>false</code>。
注意，缺少默认权限和角色绑定主体可能会导致集群无法正常工作。</p>
<p>如果基于 RBAC 的鉴权机制被启用，则自动协商功能默认是被启用的。</p>
<!--
### API discovery roles {#discovery-roles}

Default role bindings authorize unauthenticated and authenticated users to read API information that is deemed safe to be publicly accessible (including CustomResourceDefinitions). To disable anonymous unauthenticated access add `--anonymous-auth=false` to the API server configuration.

To view the configuration of these roles via `kubectl` run:
-->
<h3 id="discovery-roles">API 发现角色 </h3>
<p>无论是经过身份验证的还是未经过身份验证的用户，默认的角色绑定都授权他们读取被认为
是可安全地公开访问的 API（ 包括 CustomResourceDefinitions）。
如果要禁用匿名的未经过身份验证的用户访问，请在 API 服务器配置中中添加
<code>--anonymous-auth=false</code> 的配置选项。</p>
<p>通过运行命令 <code>kubectl</code> 可以查看这些角色的配置信息:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get clusterroles system:discovery -o yaml
</code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
If you edit that ClusterRole, your changes will be overwritten on API server restart
via [auto-reconciliation](#auto-reconciliation). To avoid that overwriting,
either do not manually edit the role, or disable auto-reconciliation.
-->
<p>如果你编辑该 ClusterRole，你所作的变更会被 API 服务器在重启时自动覆盖，这是通过
<a href="#auto-reconciliation">自动协商</a>机制完成的。要避免这类覆盖操作，
要么不要手动编辑这些角色，要么禁止自动协商机制。
</div>
<table>
<caption>
<!--
Kubernetes RBAC API discovery roles
-->
Kubernetes RBAC API 发现角色
</caption>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:basic-user</b></td>
<!-- 
<td><b>system:authenticated</b> group</td>
-->
<td><b>system:authenticated</b> 组</td>
<td>
<!-- 
Allows a user read-only access to basic information about themselves. 
Prior to 1.14, this role was also bound to <tt>system:unauthenticated</tt> by default.
-->
允许用户以只读的方式去访问他们自己的基本信息。在 1.14 版本之前，这个角色在默认情况下也绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<!-- 
<td><b>system:authenticated</b> group</td>
-->
<td><b>system:authenticated</b> 组</td>
<td>
<!-- 
Allows read-only access to API discovery endpoints needed to discover and negotiate an API level. 
Prior to 1.14, this role was also bound to <tt>system:unauthenticated</tt> by default.
-->
允许以只读方式访问 API 发现端点，这些端点用来发现和协商 API 级别。
在 1.14 版本之前，这个角色在默认情况下绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<!-- 
<td><b>system:authenticated</b> and <b>system:unauthenticated</b> groups</td>
-->
<td><b>system:authenticated</b> 和 <b>system:unauthenticated</b> 组</td>
<td>
<!-- 
Allows read-only access to non-sensitive information about the cluster. Introduced in Kubernetes v1.14.
-->
允许对集群的非敏感信息进行只读访问，它是在 1.14 版本中引入的。
</td>
</tr>
</tbody>
</table>
<!--
### User-facing roles

Some of the default ClusterRoles are not `system:` prefixed. These are intended to be user-facing roles.
They include super-user roles (`cluster-admin`), roles intended to be granted cluster-wide
using ClusterRoleBindings, and roles intended to be granted within particular
namespaces using RoleBindings (`admin`, `edit`, `view`).

User-facing ClusterRoles use [ClusterRole aggregation](#aggregated-clusterroles) to allow admins to include
rules for custom resources on these ClusterRoles. To add rules to the `admin`, `edit`, or `view` roles, create
a ClusterRole with one or more of the following labels:
-->
<h3 id="user-facing-roles">面向用户的角色  </h3>
<p>一些默认的 ClusterRole 不是以前缀 <code>system:</code> 开头的。这些是面向用户的角色。
它们包括超级用户（Super-User）角色（<code>cluster-admin</code>）、
使用 ClusterRoleBinding 在集群范围内完成授权的角色（<code>cluster-status</code>）、
以及使用 RoleBinding 在特定名字空间中授予的角色（<code>admin</code>、<code>edit</code>、<code>view</code>）。</p>
<p>面向用户的 ClusterRole 使用 <a href="#aggregated-clusterroles">ClusterRole 聚合</a>以允许管理员在
这些 ClusterRole 上添加用于定制资源的规则。如果想要添加规则到 <code>admin</code>、<code>edit</code> 或者 <code>view</code>，
可以创建带有以下一个或多个标签的 ClusterRole：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-view</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span></code></pre></div><table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>cluster-admin</b></td>
<!--
<td><b>system:masters</b> group</td>
-->
<td><b>system:masters</b> 组</td>
<td>
<!-- 
Allows super-user access to perform any action on any resource.
When used in a <b>ClusterRoleBinding</b>, it gives full control over every resource in the cluster and in all namespaces.
When used in a <b>RoleBinding</b>, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.
-->
允许超级用户在平台上的任何资源上执行所有操作。
当在 <b>ClusterRoleBinding</b> 中使用时，可以授权对集群中以及所有名字空间中的全部资源进行完全控制。
当在 <b>RoleBinding</b> 中使用时，可以授权控制 RoleBinding 所在名字空间中的所有资源，包括名字空间本身。
</td>
</tr>
<tr>
<td><b>admin</b></td>
<!-- 
<td>None</td>
--->
<td>无</td>
<td>
<!-- 
Allows admin access, intended to be granted within a namespace using a <b>RoleBinding</b>.
If used in a <b>RoleBinding</b>, allows read/write access to most resources in a namespace,
including the ability to create roles and rolebindings within the namespace.
This role does not allow write access to resource quota or to the namespace itself.
This role also does not allow write access to Endpoints in clusters created
using Kubernetes v1.22+. More information is available in the
["Write Access for Endpoints" section](#write-access-for-endpoints).
-->
允许管理员访问权限，旨在使用 <b>RoleBinding</b> 在名字空间内执行授权。
<p>如果在 <b>RoleBinding</b> 中使用，则可授予对名字空间中的大多数资源的读/写权限，
包括创建角色和角色绑定的能力。
此角色不允许对资源配额或者名字空间本身进行写操作。
此角色也不允许对 Kubernetes v1.22+ 创建的 Endpoints 进行写操作。
更多信息参阅<a href="#write-access-for-endpoints">“Endpoints 写权限”小节</a>。</p>
</td>
</tr>
<tr>
<td><b>edit</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!-- 
Allows read/write access to most objects in a namespace.
This role does not allow viewing or modifying roles or role bindings.
However, this role allows accessing Secrets and running Pods as any ServiceAccount in
the namespace, so it can be used to gain the API access levels of any ServiceAccount in
the namespace. This role also does not allow write access to Endpoints in
clusters created using Kubernetes v1.22+. More information is available in the
["Write Access for Endpoints" section](#write-access-for-endpoints).
-->
允许对名字空间的大多数对象进行读/写操作。
<p>它不允许查看或者修改角色或者角色绑定。
不过，此角色可以访问 Secret，以名字空间中任何 ServiceAccount 的身份运行 Pods，
所以可以用来了解名字空间内所有服务账户的 API 访问级别。
此角色也不允许对 Kubernetes v1.22+ 创建的 Endpoints 进行写操作。
更多信息参阅<a href="#write-access-for-endpoints">“Endpoints 写操作”小节</a>。</p>
</td>
</tr>
<tr>
<td><b>view</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!-- 
Allows read-only access to see most objects in a namespace.
It does not allow viewing roles or rolebindings.
-->
允许对名字空间的大多数对象有只读权限。
它不允许查看角色或角色绑定。
<!--
This role does not allow viewing Secrets, since reading
the contents of Secrets enables access to ServiceAccount credentials
in the namespace, which would allow API access as any ServiceAccount
in the namespace (a form of privilege escalation). 
-->
<p>此角色不允许查看 Secrets，因为读取 Secret 的内容意味着可以访问名字空间中
ServiceAccount 的凭据信息，进而允许利用名字空间中任何 ServiceAccount 的
身份访问 API（这是一种特权提升）。</p>
</td>
</tr>
</tbody>
</table>
<!--
### Core component roles
-->
<h3 id="core-component-roles">核心组件角色  </h3>
<table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!--
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th>
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:kube-scheduler</b></td>
<!-- 
<td><b>system:kube-scheduler</b> user</td> 
-->
<td><b>system:kube-scheduler</b> 用户</td>
<td>
<!-- 
Allows access to the resources required by the <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-scheduler/' target='_blank' aria-label='scheduler'>scheduler</a> component.
-->
允许访问 <a class='glossary-tooltip' title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-scheduler/' target='_blank' aria-label='scheduler'>scheduler</a>
组件所需要的资源。
</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<!-- 
<td><b>system:kube-scheduler</b> user</td> 
-->
<td><b>system:kube-scheduler</b> 用户</td>
<td>
<!--
Allows access to the volume resources required by the kube-scheduler component.
-->
允许访问 kube-scheduler 组件所需要的卷资源。
</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<!-- 
<td><b>system:kube-controller-manager</b> user</td> 
-->
<td><b>system:kube-controller-manager</b> 用户</td>
<td>
<!-- 
Allows access to the resources required by the <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='controller manager'>controller manager</a> component.
The permissions required by individual controllers are detailed in the <a href="#controller-roles">controller roles</a>.
-->
允许访问<a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='控制器管理器'>控制器管理器</a>
组件所需要的资源。
各个控制回路所需要的权限在<a href="#controller-roles">控制器角色</a> 详述。
</td>
</tr>
<tr>
<td><b>system:node</b></td>
<!-- 
<td>None</td>
-->
<td>无</td>
<td>
<!--
Allows access to resources required by the kubelet, <b>including read access to all secrets, and write access to all pod status objects</b>.
-->
允许访问 kubelet 所需要的资源，<b>包括对所有 Secret 的读操作和对所有 Pod 状态对象的写操作。</b>
<!--  
You should use the <a href="/docs/reference/access-authn-authz/node/">Node authorizer</a> and 
<a href="/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a> 
instead of the <tt>system:node</tt> role, and allow granting API access to kubelets based on the Pods scheduled to run on them.
-->
<p>你应该使用 <a href="/zh/docs/reference/access-authn-authz/node/">Node 鉴权组件</a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction 准入插件</a>
而不是 <tt>system:node</tt> 角色。同时基于 kubelet 上调度执行的 Pod 来授权
kubelet 对 API 的访问。</p>
<!--  
The <tt>system:node</tt> role only exists for compatibility with Kubernetes clusters upgraded from versions prior to v1.8.
-->
<p><tt>system:node</tt> 角色的意义仅是为了与从 v1.8 之前版本升级而来的集群兼容。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<!-- <td><b>system:kube-proxy</b> user</td> -->
<td><b>system:kube-proxy</b> 用户</td>
<!-- td>Allows access to the resources required by the <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a> component.</td-->
<td>允许访问 <a class='glossary-tooltip' title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-proxy/' target='_blank' aria-label='kube-proxy'>kube-proxy</a>
组件所需要的资源。</td>
</tr>
</tbody>
</table>
<!--
### Other component roles
-->
<h3 id="other-component-roles">其他组件角色   </h3>
<table>
<colgroup><col width="25%"><col width="25%"><col></colgroup>
<thead>
<tr>
<!-- 
<th>Default ClusterRole</th>
<th>Default ClusterRoleBinding</th>
<th>Description</th> 
-->
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:auth-delegator</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows delegated authentication and authorization checks.
This is commonly used by add-on API servers for unified authentication and authorization.
-->
允许将身份认证和鉴权检查操作外包出去。
这种角色通常用在插件式 API 服务器上，以实现统一的身份认证和鉴权。
</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!--
Role for the <a href="https://github.com/kubernetes/heapster">Heapster</a> component (deprecated).
-->
为 <a href="https://github.com/kubernetes/heapster">Heapster</a> 组件（已弃用）定义的角色。
</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<!-- td>Role for the <a href="https://github.com/kubernetes/kube-aggregator">kube-aggregator</a> component.</td -->
<td>为 <a href="https://github.com/kubernetes/kube-aggregator">kube-aggregator</a> 组件定义的角色。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td>
<!--
<b>kube-dns</b> service account in the <b>kube-system</b> namespace</td 
-->
在 <b>kube-system</b> 名字空间中的 <b>kube-dns</b> 服务账户</td>
<!-- td>Role for the <a href="/docs/concepts/services-networking/dns-pod-service/">kube-dns</a> component.</td -->
<td>为 <a href="/docs/concepts/services-networking/dns-pod-service/">kube-dns</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows full access to the kubelet API.
-->
允许 kubelet API 的完全访问权限。
</td>
</tr>  
<tr>
<td><b>system:node-bootstrapper</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows access to the resources required to perform
<a href="/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">Kubelet TLS bootstrapping</a>.
-->
允许访问执行
<a href="/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet TLS 启动引导</a>
所需要的资源。
</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Role for the <a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a> component.
-->
为 <a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<!-- 
<td>None</td> 
-->
<td>无</td>
<td>
<!-- 
Allows access to the resources required by most <a href="/docs/concepts/storage/persistent-volumes/#dynamic">dynamic volume provisioners</a>.
-->
允许访问大部分
<a href="/zh/docs/concepts/storage/persistent-volumes/#dynamic">动态卷驱动
</a>
所需要的资源。</td>
</tr>
<tr>
<td><b>system:monitoring</b></td>
<!-- 
<td><b>system:monitoring</b> group</td>
-->
<td><b>system:monitoring</b> 组</td>
<td>
<!--
Allows read access to control-plane monitoring endpoints 
(i.e. <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='kube-apiserver'>kube-apiserver</a> liveness and readiness endpoints 
(<tt>/healthz</tt>, <tt>/livez</tt>, <tt>/readyz</tt>), the individual health-check endpoints 
(<tt>/healthz/*</tt>, <tt>/livez/*</tt>, <tt>/readyz/*</tt>),  and <tt>/metrics</tt>).
 Note that individual health check endpoints and the metric endpoint may expose sensitive information.
-->
允许对控制平面监控端点的读取访问（例如：<a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='kube-apiserver'>kube-apiserver</a>
存活和就绪端点（<tt>/healthz</tt>、<tt>/livez</tt>、<tt>/readyz</tt>），
各个健康检查端点（<tt>/healthz/*</tt>、<tt>/livez/*</tt>、<tt>/readyz/*</tt>）和 <tt>/metrics</tt>）。
请注意，各个运行状况检查端点和度量标准端点可能会公开敏感信息。
</td>
</tr>
</tbody>
</table>
<!--
### Roles for built-in controllers {#controller-roles}

The Kubernetes <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='controller manager'>controller manager</a> runs
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controllers'>controllers</a> that are built in to the Kubernetes
control plane.
When invoked with `-use-service-account-credentials`, kube-controller-manager starts each controller
using a separate service account.
Corresponding roles exist for each built-in controller, prefixed with `system:controller:`.
If the controller manager is not started with `-use-service-account-credentials`, it runs all control loops
using its own credential, which must be granted all the relevant roles.
These roles include:
-->
<h3 id="controller-roles">内置控制器的角色  </h3>
<p>Kubernetes <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='控制器管理器'>控制器管理器</a>
运行内建于 Kubernetes 控制面的<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>。
当使用 <code>--use-service-account-credentials</code> 参数启动时, kube-controller-manager
使用单独的服务账户来启动每个控制器。
每个内置控制器都有相应的、前缀为 <code>system:controller:</code> 的角色。
如果控制管理器启动时未设置 <code>--use-service-account-credentials</code>，
它使用自己的身份凭据来运行所有的控制器，该身份必须被授予所有相关的角色。
这些角色包括:</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<!--
## Privilege Escalation Prevention and Bootstrapping

The RBAC API prevents users from escalating privileges by editing roles or role bindings.
Because this is enforced at the API level, it applies even when the RBAC authorizer is not in use.
-->
<h2 id="初始化与预防权限提升">初始化与预防权限提升</h2>
<p>RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。
由于这一点是在 API 级别实现的，所以在 RBAC 鉴权组件未启用的状态下依然可以正常工作。</p>
<!--
### Restrictions on role creation or update

You can only create/update a role if at least one of the following things is true:

1. You already have all the permissions contained in the role, at the same scope as the object being modified
(cluster-wide for a ClusterRole, within the same namespace or cluster-wide for a Role).
2. You are granted explicit permission to perform the `escalate` verb on the `roles` or `clusterroles` resource in the `rbac.authorization.k8s.io` API group.
-->
<h3 id="对角色创建或更新的限制">对角色创建或更新的限制</h3>
<p>只有在符合下列条件之一的情况下，你才能创建/更新角色:</p>
<ol>
<li>你已经拥有角色中包含的所有权限，且其作用域与正被修改的对象作用域相同。
（对 ClusterRole 而言意味着集群范围，对 Role 而言意味着相同名字空间或者集群范围）。</li>
<li>你被显式授权在 <code>rbac.authorization.k8s.io</code> API 组中的 <code>roles</code> 或 <code>clusterroles</code> 资源
使用 <code>escalate</code> 动词。</li>
</ol>
<!--
For example, if `user-1` does not have the ability to list Secrets cluster-wide, they cannot create a ClusterRole
containing that permission. To allow a user to create/update roles:

1. Grant them a role that allows them to create/update Role or ClusterRole objects, as desired.
2. Grant them permission to include specific permissions in the roles they create/update:
    * implicitly, by giving them those permissions (if they attempt to create or modify a Role or ClusterRole with permissions they themselves have not been granted, the API request will be forbidden)
    * or explicitly allow specifying any permission in a `Role` or `ClusterRole` by giving them permission to perform the `escalate` verb on `roles` or `clusterroles` resources in the `rbac.authorization.k8s.io` API group
-->
<p>例如，如果 <code>user-1</code> 没有列举集群范围所有 Secret 的权限，他将不能创建包含该权限的 ClusterRole。
若要允许用户创建/更新角色：</p>
<ol>
<li>根据需要赋予他们一个角色，允许他们根据需要创建/更新 Role 或者 ClusterRole 对象。</li>
<li>授予他们在所创建/更新角色中包含特殊权限的权限:
<ul>
<li>隐式地为他们授权（如果它们试图创建或者更改 Role 或 ClusterRole 的权限，
但自身没有被授予相应权限，API 请求将被禁止）。</li>
<li>通过允许他们在 Role 或 ClusterRole 资源上执行 <code>escalate</code> 动作显式完成授权。
这里的 <code>roles</code> 和 <code>clusterroles</code> 资源包含在 <code>rbac.authorization.k8s.io</code> API 组中。</li>
</ul>
</li>
</ol>
<!--
### Restrictions on role binding creation or update

You can only create/update a role binding if you already have all the permissions contained in the referenced role
(at the same scope as the role binding) *or* if you have been authorized to perform the `bind` verb on the referenced role.
For example, if `user-1` does not have the ability to list Secrets cluster-wide, they cannot create a ClusterRoleBinding
to a role that grants that permission. To allow a user to create/update role bindings:
-->
<h3 id="对角色绑定创建或更新的限制">对角色绑定创建或更新的限制</h3>
<p>只有你已经具有了所引用的角色中包含的全部权限时，或者你被授权在所引用的角色上执行 <code>bind</code>
动词时，你才可以创建或更新角色绑定。这里的权限与角色绑定的作用域相同。
例如，如果用户 <code>user-1</code> 没有列举集群范围所有 Secret 的能力，则他不可以创建
ClusterRoleBinding 引用授予该许可权限的角色。
如要允许用户创建或更新角色绑定：</p>
<!--
1. Grant them a role that allows them to create/update RoleBinding or ClusterRoleBinding objects, as desired.
2. Grant them permissions needed to bind a particular role:
    * implicitly, by giving them the permissions contained in the role.
    * explicitly, by giving them permission to perform the `bind` verb on the particular Role (or ClusterRole).

For example, this ClusterRole and RoleBinding would allow `user-1` to grant other users the `admin`, `edit`, and `view` roles in the namespace `user-1-namespace`:
-->
<ol>
<li>赋予他们一个角色，使得他们能够根据需要创建或更新 RoleBinding 或 ClusterRoleBinding
对象。</li>
<li>授予他们绑定某特定角色所需要的许可权限：
<ul>
<li>隐式授权下，可以将角色中包含的许可权限授予他们；</li>
<li>显式授权下，可以授权他们在特定 Role （或 ClusterRole）上执行 <code>bind</code> 动词的权限。</li>
</ul>
</li>
</ol>
<p>例如，下面的 ClusterRole 和 RoleBinding 将允许用户 <code>user-1</code> 把名字空间 <code>user-1-namespace</code>
中的 <code>admin</code>、<code>edit</code> 和 <code>view</code> 角色赋予其他用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rbac.authorization.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rolebindings&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;create&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;rbac.authorization.k8s.io&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;clusterroles&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;bind&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-style:italic"># 忽略 resourceNames 意味着允许绑定任何 ClusterRole</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resourceNames</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;admin&#34;</span>,<span style="color:#b44">&#34;edit&#34;</span>,<span style="color:#b44">&#34;view&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>RoleBinding<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor-binding<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>user-1-namespace<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">roleRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>role-grantor<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">subjects</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroup</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>User<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>user-1<span style="color:#bbb">
</span></code></pre></div><!--
When bootstrapping the first roles and role bindings, it is necessary for the initial user to grant permissions they do not yet have.
To bootstrap initial roles and role bindings:

* Use a credential with the `system:masters` group, which is bound to the `cluster-admin` super-user role by the default bindings.
* If your API server runs with the insecure port enabled (`-insecure-port`), you can also make API calls via that port, which does not enforce authentication or authorization.
-->
<p>当启动引导第一个角色和角色绑定时，需要为初始用户授予他们尚未拥有的权限。
对初始角色和角色绑定进行初始化时需要：</p>
<ul>
<li>使用用户组为 <code>system:masters</code> 的凭据，该用户组由默认绑定关联到 <code>cluster-admin</code>
这个超级用户角色。</li>
<li>如果你的 API 服务器启动时启用了不安全端口（使用 <code>--insecure-port</code>）, 你也可以通过
该端口调用 API ，这样的操作会绕过身份验证或鉴权。</li>
</ul>
<!--
## Command-line Utilities

### `kubectl create role`

Creates a `Role` object defining permissions within a single namespace. Examples:

* Create a Role named "pod-reader" that allows users to perform `get`, `watch` and `list` on pods:
-->
<h2 id="一些命令行工具">一些命令行工具</h2>
<h3 id="kubectl-create-role"><code>kubectl create role</code></h3>
<p>创建 Role 对象，定义在某一名字空间中的权限。例如:</p>
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 Role 对象，允许用户对 Pods 执行 <code>get</code>、<code>watch</code> 和 <code>list</code> 操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role pod-reader --verb<span style="color:#666">=</span>get --verb<span style="color:#666">=</span>list --verb<span style="color:#666">=</span>watch --resource<span style="color:#666">=</span>pods
</code></pre></div></li>
</ul>
<!--
* Create a Role named "pod-reader" with resourceNames specified:
-->
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 Role 对象并指定 <code>resourceNames</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role pod-reader --verb<span style="color:#666">=</span>get --resource<span style="color:#666">=</span>pods --resource-name<span style="color:#666">=</span>readablepod --resource-name<span style="color:#666">=</span>anotherpod
</code></pre></div></li>
</ul>
<!--
* Create a `Role` named "foo" with apiGroups specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 Role 对象并指定 <code>apiGroups</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>replicasets.apps
</code></pre></div></li>
</ul>
<!--
* Create a Role named "foo" with subresource permissions:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 Role 对象并指定子资源权限:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods,pods/status
</code></pre></div></li>
</ul>
<!--
* Create a Role named "my-component-lease-holder" with permissions to get/update a resource with a specific name:
-->
<ul>
<li>
<p>创建名为 &quot;my-component-lease-holder&quot; 的 Role 对象，使其具有对特定名称的
资源执行 get/update 的权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create role my-component-lease-holder --verb<span style="color:#666">=</span>get,list,watch,update --resource<span style="color:#666">=</span>lease --resource-name<span style="color:#666">=</span>my-component
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-clusterrole"><code>kubectl create clusterrole</code></h3>
<!--
Creates a ClusterRole. Examples:

* Create a ClusterRole named "pod-reader" that allows user to perform `get`, `watch` and `list` on pods:
-->
<p>创建 ClusterRole 对象。例如：</p>
<ul>
<li>
<p>创建名称为 &quot;pod-reader&quot; 的 ClusterRole<code>对象，允许用户对 Pods 对象执行 </code>get<code>、</code>watch<code>和</code>list` 操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole pod-reader --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "pod-reader" with resourceNames specified:
-->
<ul>
<li>
<p>创建名为 &quot;pod-reader&quot; 的 ClusterRole 对象并指定 <code>resourceNames</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole pod-reader --verb<span style="color:#666">=</span>get --resource<span style="color:#666">=</span>pods --resource-name<span style="color:#666">=</span>readablepod --resource-name<span style="color:#666">=</span>anotherpod
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with apiGroups specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定 <code>apiGroups</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>replicasets.apps
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with subresource permissions:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定子资源:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole foo --verb<span style="color:#666">=</span>get,list,watch --resource<span style="color:#666">=</span>pods,pods/status
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "foo" with nonResourceURL specified:
-->
<ul>
<li>
<p>创建名为 &quot;foo&quot; 的 ClusterRole 对象并指定 <code>nonResourceURL</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole <span style="color:#b44">&#34;foo&#34;</span> --verb<span style="color:#666">=</span>get --non-resource-url<span style="color:#666">=</span>/logs/*
</code></pre></div></li>
</ul>
<!--
* Create a ClusterRole named "monitoring" with an aggregationRule specified:
-->
<ul>
<li>
<p>创建名为 &quot;monitoring&quot; 的 ClusterRole 对象并指定 <code>aggregationRule</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrole monitoring --aggregation-rule<span style="color:#666">=</span><span style="color:#b44">&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-rolebinding"><code>kubectl create rolebinding</code></h3>
<!--
Grants a Role or ClusterRole within a specific namespace. Examples:

* Within the namespace "acme", grant the permissions in the "admin" ClusterRole to a user named "bob":
-->
<p>在特定的名字空间中对 <code>Role</code> 或 <code>ClusterRole</code> 授权。例如：</p>
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>admin</code> 的 ClusterRole 中的权限授予名称 &quot;bob&quot; 的用户:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding bob-admin-binding --clusterrole<span style="color:#666">=</span>admin --user<span style="color:#666">=</span>bob --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<!--
* Within the namespace "acme", grant the permissions in the "view" ClusterRole to the service account in the namespace "acme" named "myapp":
-->
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>view</code> 的 ClusterRole 中的权限授予名字空间 &quot;acme&quot;
中名为 <code>myapp</code> 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>acme:myapp --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<!--
* Within the namespace "acme", grant the permissions in the "view" ClusterRole to a service account in the namespace "myappnamespace" named "myapp":
-->
<ul>
<li>
<p>在名字空间 &quot;acme&quot; 中，将名为 <code>view</code> 的 ClusterRole 对象中的权限授予名字空间
&quot;myappnamespace&quot; 中名称为 <code>myapp</code> 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>myappnamespace:myapp --namespace<span style="color:#666">=</span>acme
</code></pre></div></li>
</ul>
<h3 id="kubectl-create-clusterrolebinding"><code>kubectl create clusterrolebinding</code></h3>
<!--
Grants a ClusterRole across the entire cluster (all namespaces). Examples:

* Across the entire cluster, grant the permissions in the "cluster-admin" ClusterRole to a user named "root":
-->
<p>在整个集群（所有名字空间）中用 ClusterRole 授权。例如：</p>
<ul>
<li>
<p>在整个集群范围，将名为 <code>cluster-admin</code> 的 ClusterRole 中定义的权限授予名为
&quot;root&quot; 用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style="color:#666">=</span>cluster-admin --user<span style="color:#666">=</span>root
</code></pre></div></li>
</ul>
<!--
* Across the entire cluster, grant the permissions in the "system:node-proxier" ClusterRole to a user named "system:kube-proxy":
-->
<ul>
<li>
<p>在整个集群范围内，将名为 <code>system:node-proxier</code> 的 ClusterRole 的权限授予名为
&quot;system:kube-proxy&quot; 的用户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style="color:#666">=</span>system:node-proxier --user<span style="color:#666">=</span>system:kube-proxy
</code></pre></div></li>
</ul>
<!--
* Across the entire cluster, grant the permissions in the "view" ClusterRole to a service account named "myapp" in the namespace "acme":
-->
<ul>
<li>
<p>在整个集群范围内，将名为 <code>view</code> 的 ClusterRole 中定义的权限授予 &quot;acme&quot; 名字空间中
名为 &quot;myapp&quot; 的服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style="color:#666">=</span>view --serviceaccount<span style="color:#666">=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id="kubectl-auth-reconcile"><code>kubectl auth reconcile</code></h3>
<!--
Creates or updates `rbac.authorization.k8s.io/v1` API objects from a manifest file.

Missing objects are created, and the containing namespace is created for namespaced objects, if required.

Existing roles are updated to include the permissions in the input objects,
and remove extra permissions if `--remove-extra-permissions` is specified.

Existing bindings are updated to include the subjects in the input objects,
and remove extra subjects if `--remove-extra-subjects` is specified.

Examples:
-->
<p>使用清单文件来创建或者更新 <code>rbac.authorization.k8s.io/v1</code> API 对象。</p>
<p>尚不存在的对象会被创建，如果对应的名字空间也不存在，必要的话也会被创建。
已经存在的角色会被更新，使之包含输入对象中所给的权限。如果指定了
<code>--remove-extra-permissions</code>，可以删除额外的权限。</p>
<p>已经存在的绑定也会被更新，使之包含输入对象中所给的主体。如果指定了
<code>--remove-extra-permissions</code>，则可以删除多余的主体。</p>
<p>例如:</p>
<!--
* Test applying a manifest file of RBAC objects, displaying changes that would be made:
-->
<ul>
<li>
<p>测试应用 RBAC 对象的清单文件，显示将要进行的更改：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml --dry-run
</code></pre></div></li>
</ul>
<!--
* Apply a manifest file of RBAC objects, preserving any extra permissions (in roles) and any extra subjects (in bindings):
-->
<ul>
<li>
<p>应用 RBAC 对象的清单文件，保留角色中的额外权限和绑定中的其他主体：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
</ul>
<!--
* Apply a manifest file of RBAC objects, removing any extra permissions (in roles) and any extra subjects (in bindings):
-->
<ul>
<li>
<p>应用 RBAC 对象的清单文件, 删除角色中的额外权限和绑定中的其他主体：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</code></pre></div></li>
</ul>
<!--
See the CLI help for detailed usage.
-->
<p>查看 CLI 帮助获取详细的用法。</p>
<!--
## ServiceAccount Permissions

Default RBAC policies grant scoped permissions to control-plane components, nodes,
and controllers, but grant *no permissions* to service accounts outside the `kube-system` namespace
(beyond discovery permissions given to all authenticated users).

This allows you to grant particular roles to particular service accounts as needed.
Fine-grained role bindings provide greater security, but require more effort to administrate.
Broader grants can give unnecessary (and potentially escalating) API access to service accounts, but are easier to administrate.
-->
<h2 id="service-account-permissions">服务账户权限  </h2>
<p>默认的 RBAC 策略为控制面组件、节点和控制器授予权限。
但是不会对 <code>kube-system</code> 名字空间之外的服务账户授予权限。
（除了授予所有已认证用户的发现权限）</p>
<p>这使得你可以根据需要向特定服务账户授予特定权限。
细粒度的角色绑定可带来更好的安全性，但需要更多精力管理。
粗粒度的授权可能导致服务账户被授予不必要的 API 访问权限（甚至导致潜在的权限提升），
但更易于管理。</p>
<!--
In order from most secure to least secure, the approaches are:

1. Grant a role to an application-specific service account (best practice)
-->
<p>按从最安全到最不安全的顺序，存在以下方法：</p>
<ol>
<li>
<p>为特定应用的服务账户授予角色（最佳实践）</p>
<!--
This requires the application to specify a `serviceAccountName` in its pod spec,
and for the service account to be created (via the API, application manifest, `kubectl create serviceaccount`, etc.).

For example, grant read-only permission within "my-namespace" to the "my-sa" service account:
-->
<p>这要求应用在其 Pod 规约中指定 <code>serviceAccountName</code>，
并额外创建服务账户（包括通过 API、应用程序清单、<code>kubectl create serviceaccount</code> 等）。</p>
<p>例如，在名字空间 &quot;my-namespace&quot; 中授予服务账户 &quot;my-sa&quot; 只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding my-sa-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>my-namespace:my-sa <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div></li>
</ol>
<!--
2. Grant a role to the "default" service account in a namespace
-->
<ol start="2">
<li>
<p>将角色授予某名字空间中的 &quot;default&quot; 服务账户</p>
<!--
If an application does not specify a `serviceAccountName`, it uses the "default" service account.

<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Permissions given to the &quot;default&quot; service account are available to any pod
in the namespace that does not specify a <code>serviceAccountName</code>.
</div>

For example, grant read-only permission within "my-namespace" to the "default" service account:
-->
<p>如果某应用没有指定 <code>serviceAccountName</code>，那么它将使用 &quot;default&quot; 服务账户。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> &quot;default&quot; 服务账户所具有的权限会被授予给名字空间中所有未指定
<code>serviceAccountName</code> 的 Pod。
</div>
<p>例如，在名字空间 &quot;my-namespace&quot; 中授予服务账户 &quot;default&quot; 只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding default-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>my-namespace:default <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div><!--
Many [add-ons](/docs/concepts/cluster-administration/addons/) run as the
"default" service account in the `kube-system` namespace.
To allow those add-ons to run with super-user access, grant cluster-admin
permissions to the "default" service account in the `kube-system` namespace.

<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Enabling this means the <code>kube-system</code> namespace contains Secrets
that grant super-user access to the API.
</div>
-->
<p>许多<a href="/zh/docs/concepts/cluster-administration/addons/">插件组件</a> 在 <code>kube-system</code>
名字空间以 &quot;default&quot; 服务账户运行。
要允许这些插件组件以超级用户权限运行，需要将集群的 <code>cluster-admin</code> 权限授予
<code>kube-system</code> 名字空间中的 &quot;default&quot; 服务账户。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 启用这一配置意味着在 <code>kube-system</code> 名字空间中包含以超级用户账号来访问 API
的 Secrets。
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding add-on-cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --serviceaccount<span style="color:#666">=</span>kube-system:default
</code></pre></div></li>
</ol>
<!--
3. Grant a role to all service accounts in a namespace

   If you want all applications in a namespace to have a role, no matter what service account they use,
   you can grant a role to the service account group for that namespace.

   For example, grant read-only permission within "my-namespace" to all service accounts in that namespace:
-->
<ol start="3">
<li>
<p>将角色授予名字空间中所有服务账户</p>
<p>如果你想要名字空间中所有应用都具有某角色，无论它们使用的什么服务账户，
可以将角色授予该名字空间的服务账户组。</p>
<p>例如，在名字空间 &quot;my-namespace&quot; 中的只读权限授予该名字空间中的所有服务账户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create rolebinding serviceaccounts-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts:my-namespace <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --namespace<span style="color:#666">=</span>my-namespace
</code></pre></div></li>
</ol>
<!--
4. Grant a limited role to all service accounts cluster-wide (discouraged)

   If you don't want to manage permissions per-namespace, you can grant a cluster-wide role to all service accounts.

   For example, grant read-only permission across all namespaces to all service accounts in the cluster:
-->
<ol start="4">
<li>
<p>在集群范围内为所有服务账户授予一个受限角色（不鼓励）</p>
<p>如果你不想管理每一个名字空间的权限，你可以向所有的服务账户授予集群范围的角色。</p>
<p>例如，为集群范围的所有服务账户授予跨所有名字空间的只读权限：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding serviceaccounts-view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>view <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<!--
5. Grant super-user access to all service accounts cluster-wide (strongly discouraged)

   If you don't care about partitioning permissions at all, you can grant super-user access to all service accounts.

   <div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> This allows any application full access to your cluster, and also grants
any user with read access to Secrets (or the ability to create any pod)
full access to your cluster.
</div>


-->
<ol start="5">
<li>
<p>授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</p>
<p>如果你不关心如何区分权限，你可以将超级用户访问权限授予所有服务账户。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> 这样做会允许所有应用都对你的集群拥有完全的访问权限，并将允许所有能够读取
Secret（或创建 Pod）的用户对你的集群有完全的访问权限。
</div>


<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<!--
## Write access for Endpoints

Kubernetes clusters created before Kubernetes v1.22 include write access to
Endpoints in the aggregated "edit" and "admin" roles. As a mitigation for
[CVE-2021-25740](https://github.com/kubernetes/kubernetes/issues/103675), this
access is not part of the aggregated roles in clusters that you create using
Kubernetes v1.22 or later.

Existing clusters that have been upgraded to Kubernetes v1.22 will not be
subject to this change. The [CVE
announcement](https://github.com/kubernetes/kubernetes/issues/103675) includes
guidance for restricting this access in existing clusters.

If you want new clusters to retain this level of access in the aggregated roles,
you can create the following ClusterRole:



 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/endpoints-aggregated.yaml" download="access/endpoints-aggregated.yaml"><code>access/endpoints-aggregated.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-endpoints-aggregated-yaml')" title="Copy access/endpoints-aggregated.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-endpoints-aggregated-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubernetes.io/description</span>:<span style="color:#bbb"> </span>|-<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">      Add endpoints write permissions to the edit and admin roles. This was
</span><span style="color:#b44;font-style:italic">      removed by default in 1.22 because of CVE-2021-25740. See
</span><span style="color:#b44;font-style:italic">      https://issue.k8s.io/103675. This can allow writers to direct LoadBalancer
</span><span style="color:#b44;font-style:italic">      or Ingress implementations to expose backend IPs that would not otherwise
</span><span style="color:#b44;font-style:italic">      be accessible, and can circumvent network policies or security controls
</span><span style="color:#b44;font-style:italic">      intended to prevent/isolate access to those backends.</span><span style="color:#bbb">      
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>custom:aggregate-to-edit:endpoints<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># you can change this if you wish</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;endpoints&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;deletecollection&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>]<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


-->
<h2 id="write-access-for-endpoints">Endpoints 写权限</h2>
<p>在 Kubernetes v1.22 之前版本创建的集群里，
&quot;edit&quot; 和 &quot;admin&quot; 聚合角色包含对 Endpoints 的写权限。
作为 <a href="https://github.com/kubernetes/kubernetes/issues/103675">CVE-2021-25740</a> 的缓解措施，
此访问权限不包含在 Kubernetes 1.22 以及更高版本集群的聚合角色里。</p>
<p>升级到 Kubernetes v1.22 版本的现有集群不会包括此变化。
<a href="https://github.com/kubernetes/kubernetes/issues/103675">CVE 公告</a>
包含了在现有集群里限制此访问权限的指引。</p>
<p>如果你希望在新集群的聚合角色里保留此访问权限，你可以创建下面的 ClusterRole：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/endpoints-aggregated.yaml" download="access/endpoints-aggregated.yaml"><code>access/endpoints-aggregated.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('access-endpoints-aggregated-yaml')" title="Copy access/endpoints-aggregated.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="access-endpoints-aggregated-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>rbac.authorization.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ClusterRole<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">kubernetes.io/description</span>:<span style="color:#bbb"> </span>|-<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">      Add endpoints write permissions to the edit and admin roles. This was
</span><span style="color:#b44;font-style:italic">      removed by default in 1.22 because of CVE-2021-25740. See
</span><span style="color:#b44;font-style:italic">      https://issue.k8s.io/103675. This can allow writers to direct LoadBalancer
</span><span style="color:#b44;font-style:italic">      or Ingress implementations to expose backend IPs that would not otherwise
</span><span style="color:#b44;font-style:italic">      be accessible, and can circumvent network policies or security controls
</span><span style="color:#b44;font-style:italic">      intended to prevent/isolate access to those backends.</span><span style="color:#bbb">      
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;true&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>custom:aggregate-to-edit:endpoints<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># you can change this if you wish</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;endpoints&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;create&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;delete&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;deletecollection&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;patch&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;update&#34;</span>]<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
## Upgrading from ABAC

Clusters that originally ran older Kubernetes versions often used
permissive ABAC policies, including granting full API access to all
service accounts.

Default RBAC policies grant scoped permissions to control-plane components, nodes,
and controllers, but grant *no permissions* to service accounts outside the `kube-system` namespace
(beyond discovery permissions given to all authenticated users).

While far more secure, this can be disruptive to existing workloads expecting to automatically receive API permissions.
Here are two approaches for managing this transition:
-->
<h2 id="从-abac-升级">从 ABAC 升级</h2>
<p>原来运行较老版本 Kubernetes 的集群通常会使用限制宽松的 ABAC 策略，
包括授予所有服务帐户全权访问 API 的能力。</p>
<p>默认的 RBAC 策略为控制面组件、节点和控制器等授予有限的权限，但不会为
<code>kube-system</code> 名字空间外的服务账户授权
（除了授予所有认证用户的发现权限之外）。</p>
<p>这样做虽然安全得多，但可能会干扰期望自动获得 API 权限的现有工作负载。
这里有两种方法来完成这种转换:</p>
<!--
### Parallel Authorizers

Run both the RBAC and ABAC authorizers, and specify a policy file that contains
[the legacy ABAC policy](/docs/reference/access-authn-authz/abac/#policy-file-format):
-->
<h3 id="parallel-authorizers">并行鉴权   </h3>
<p>同时运行 RBAC 和 ABAC 鉴权模式, 并指定包含
<a href="/zh/docs/reference/access-authn-authz/abac/#policy-file-format">现有的 ABAC 策略</a>
的策略文件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--authorization-mode<span style="color:#666">=</span>RBAC,ABAC --authorization-policy-file<span style="color:#666">=</span>mypolicy.json
</code></pre></div><!--
To explain that first command line option in detail: if earlier authorizers, such as Node,
deny a request, then the RBAC authorizer attempts to authorize the API request. If RBAC
also denies that API request, the ABAC authorizer is then run. This means that any request
allowed by *either* the RBAC or ABAC policies is allowed.
-->
<p>关于命令行中的第一个选项：如果早期的鉴权组件，例如 Node，拒绝了某个请求，则
RBAC 鉴权组件尝试对该 API 请求鉴权。如果 RBAC 也拒绝了该 API 请求，则运行 ABAC
鉴权组件。这意味着被 RBAC 或 ABAC 策略所允许的任何请求都是被允许的请求。</p>
<!--
When the apiserver is run with a log level of 5 or higher for the RBAC component
(`--vmodule=rbac*=5` or `--v=5`), you can see RBAC details in the apiserver log
(prefixed with `RBAC:`).
You can use that information to determine which roles need to be granted to which users, groups, or service accounts.
-->
<p>如果 API 服务器启动时，RBAC 组件的日志级别为 5 或更高（<code>--vmodule=rbac*=5</code> 或 <code>--v=5</code>），
你可以在 API 服务器的日志中看到 RBAC 的细节 （前缀 <code>RBAC:</code>）
你可以使用这些信息来确定需要将哪些角色授予哪些用户、组或服务帐户。</p>
<!--
Once you have [granted roles to service accounts](#service-account-permissions) and workloads
are running with no RBAC denial messages in the server logs, you can remove the ABAC authorizer.
-->
<p>一旦你<a href="#service-account-permissions">将角色授予服务账户</a> ，工作负载运行时
在服务器日志中没有出现 RBAC 拒绝消息，就可以删除 ABAC 鉴权器。</p>
<!--
### Permissive RBAC Permissions

You can replicate a permissive policy using RBAC role bindings.
-->
<h3 id="permissive-rbac-permissions">宽松的 RBAC 权限  </h3>
<p>你可以使用 RBAC 角色绑定在多个场合使用宽松的策略。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <!--
The following policy allows **ALL** service accounts to act as cluster administrators.
Any application running in a container receives service account credentials automatically,
and could perform any action against the API, including viewing secrets and modifying permissions.
This is not a recommended policy.
-->
<p>下面的策略允许 <strong>所有</strong> 服务帐户充当集群管理员。
容器中运行的所有应用程序都会自动收到服务帐户的凭据，可以对 API 执行任何操作，
包括查看 Secrets 和修改权限。这一策略是不被推荐的。
</div>


<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create clusterrolebinding permissive-binding <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --clusterrole<span style="color:#666">=</span>cluster-admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>admin <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --user<span style="color:#666">=</span>kubelet <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --group<span style="color:#666">=</span>system:serviceaccounts
</code></pre></div><!--
After you have transitioned to use RBAC, you should adjust the access controls
for your cluster to ensure that these meet your information security needs.
-->
<p>在你完成到 RBAC 的迁移后，应该调整集群的访问控制，确保相关的策略满足你的信息安全需求。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9cbb97d4d9f08d67931a1baae4e6519c">9 - 使用 Node 鉴权</h1>
    
	<!--
---
reviewers:
- timstclair
- deads2k
- liggitt
- ericchiang
title: Using Node Authorization
content_type: concept
weight: 90
---
-->
<!-- overview -->
<p>节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求进行鉴权。</p>
<!--
Node authorization is a special-purpose authorization mode that specifically authorizes API requests made by kubelets.
-->
<!-- body -->
<h2 id="概述">概述</h2>
<!--
## Overview
-->
<p>节点鉴权器允许 kubelet 执行 API 操作。包括：</p>
<!--
The Node authorizer allows a kubelet to perform API operations. This includes:
-->
<p>读取操作：</p>
<!--
Read operations:
-->
<ul>
<li>services</li>
<li>endpoints</li>
<li>nodes</li>
<li>pods</li>
<li>secrets、configmaps、pvcs 以及绑定到 kubelet 节点的与 pod 相关的持久卷</li>
</ul>
<!--
* services
* endpoints
* nodes
* pods
* secrets, configmaps, persistent volume claims and persistent volumes related to pods bound to the kubelet's node
-->
<p>写入操作：</p>
<!--
Write operations:
-->
<ul>
<li>节点和节点状态（启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改自己的节点）</li>
<li>Pod 和 Pod 状态 (启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改绑定到自身的 Pod)</li>
<li>事件</li>
</ul>
<!--
* nodes and node status (enable the `NodeRestriction` admission plugin to limit a kubelet to modify its own node)
* pods and pod status (enable the `NodeRestriction` admission plugin to limit a kubelet to modify pods bound to itself)
* events
-->
<p>鉴权相关操作：</p>
<!--
Auth-related operations:
-->
<ul>
<li>对于基于 TLS 的启动引导过程时使用的
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">certificationsigningrequests API</a>
的读/写权限</li>
<li>为委派的身份验证/授权检查创建 TokenReview 和 SubjectAccessReview 的能力</li>
</ul>
<!--
* read/write access to the [CertificateSigningRequests API](/docs/reference/access-authn-authz/certificate-signing-requests/) for TLS bootstrapping
* the ability to create TokenReviews and SubjectAccessReviews for delegated authentication/authorization checks
-->
<p>在将来的版本中，节点鉴权器可能会添加或删除权限，以确保 kubelet 具有正确操作所需的最小权限集。</p>
<!--
In future releases, the node authorizer may add or remove permissions to ensure kubelets
have the minimal set of permissions required to operate correctly.
-->
<p>为了获得节点鉴权器的授权，kubelet 必须使用一个凭证以表示它在 <code>system:nodes</code> 组中，用户名为 <code>system:node:&lt;nodeName&gt;</code>。
上述的组名和用户名格式要与 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet TLS 启动引导</a>过程中为每个 kubelet 创建的标识相匹配。</p>
<!--
In order to be authorized by the Node authorizer, kubelets must use a credential that identifies them as
being in the `system:nodes` group, with a username of `system:node:<nodeName>`.
This group and user name format match the identity created for each kubelet as part of
[kubelet TLS bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/).
-->
<p>要启用节点授权器，请使用 <code>--authorization-mode = Node</code> 启动 apiserver。</p>
<!--
To enable the Node authorizer, start the apiserver with `--authorization-mode=Node`.
-->
<p>要限制 kubelet 具有写入权限的 API 对象，请使用 <code>--enable-admission-plugins=...,NodeRestriction,...</code> 启动 apiserver，从而启用 <a href="/zh/docs/reference/access-authn-authz/admission-controllers#NodeRestriction">NodeRestriction</a> 准入插件。</p>
<!--
To limit the API objects kubelets are able to write, enable the [NodeRestriction](/docs/reference/access-authn-authz/admission-controllers#NodeRestriction) admission plugin by starting the apiserver with `--enable-admission-plugins=...,NodeRestriction,...`
 -->
<h2 id="迁移考虑因素">迁移考虑因素</h2>
<!--
## Migration considerations
-->
<h3 id="在-system-nodes-组之外的-kubelet">在 <code>system:nodes</code> 组之外的 Kubelet</h3>
<!--
### Kubelets outside the `system:nodes` group
-->
<p><code>system:nodes</code> 组之外的 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的机制来授权。
节点准入插件不会限制来自这些 kubelet 的请求。</p>
<!--
Kubelets outside the `system:nodes` group would not be authorized by the `Node` authorization mode,
and would need to continue to be authorized via whatever mechanism currently authorizes them.
The node admission plugin would not restrict requests from these kubelets.
-->
<h3 id="具有无差别用户名的-kubelet">具有无差别用户名的 Kubelet</h3>
<!--
### Kubelets with undifferentiated usernames
-->
<p>在一些部署中，kubelet 具有 <code>system:nodes</code> 组的凭证，但是无法给出它们所关联的节点的标识，因为它们没有 <code>system:node:...</code> 格式的用户名。
这些 kubelet 不会被 <code>Node</code> 授权模式授权，并且需要继续通过当前授权它们的任何机制来授权。</p>
<!--
In some deployments, kubelets have credentials that place them in the `system:nodes` group,
but do not identify the particular node they are associated with,
because they do not have a username in the `system:node:...` format.
These kubelets would not be authorized by the `Node` authorization mode,
and would need to continue to be authorized via whatever mechanism currently authorizes them.
-->
<p>因为默认的节点标识符实现不会把它当作节点身份标识，<code>NodeRestriction</code> 准入插件会忽略来自这些 kubelet 的请求。</p>
<!--
The `NodeRestriction` admission plugin would ignore requests from these kubelets,
since the default node identifier implementation would not consider that a node identity.
-->
<h3 id="相对于以前使用-rbac-的版本的更新">相对于以前使用 RBAC 的版本的更新</h3>
<!--
### Upgrades from previous versions using RBAC
-->
<p>升级的 1.7 之前的使用 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC</a> 的集群将继续按原样运行，因为 <code>system:nodes</code> 组绑定已经存在。</p>
<!--
Upgraded pre-1.7 clusters using [RBAC](/docs/reference/access-authn-authz/rbac/) will continue functioning as-is because the `system:nodes` group binding will already exist.
-->
<p>如果集群管理员希望开始使用 <code>Node</code> 鉴权器和 <code>NodeRestriction</code> 准入插件来限制节点对 API 的访问，这一需求可以通过下列操作来完成且不会影响已部署的应用：</p>
<!--
If a cluster admin wishes to start using the `Node` authorizer and `NodeRestriction` admission plugin
to limit node access to the API, that can be done non-disruptively:
 -->
<ol>
<li>启用 <code>Node</code> 鉴权模式 (<code>--authorization-mode=Node,RBAC</code>) 和 <code>NodeRestriction</code> 准入插件</li>
<li>确保所有 kubelet 的凭据符合组/用户名要求</li>
<li>审核 apiserver 日志以确保 <code>Node</code> 鉴权器不会拒绝来自 kubelet 的请求（日志中没有持续的 <code>NODE DENY</code> 消息）</li>
<li>删除 <code>system:node</code> 集群角色绑定</li>
</ol>
<!--
1. Enable the `Node` authorization mode (`--authorization-mode=Node,RBAC`) and the `NodeRestriction` admission plugin
2. Ensure all kubelets' credentials conform to the group/username requirements
3. Audit apiserver logs to ensure the `Node` authorizer is not rejecting requests from kubelets (no persistent `NODE DENY` messages logged)
4. Delete the `system:node` cluster role binding
-->
<h3 id="rbac-节点权限">RBAC 节点权限</h3>
<!--
### RBAC Node Permissions
-->
<p>在 1.6 版本中，当使用 <a href="/zh/docs/reference/access-authn-authz/rbac/">RBAC 鉴权模式</a> 时，<code>system:nodes</code> 集群角色会被自动绑定到 <code>system:node</code> 组。</p>
<!--
In 1.6, the `system:node` cluster role was automatically bound to the `system:nodes` group when using the [RBAC Authorization mode](/docs/reference/access-authn-authz/rbac/).
-->
<p>在 1.7 版本中，不再推荐将 <code>system:nodes</code> 组自动绑定到 <code>system:node</code> 角色，因为节点鉴权器通过对 secret 和 configmap 访问的额外限制完成了相同的任务。
如果同时启用了 <code>Node</code> 和 <code>RBAC</code> 授权模式，1.7 版本则不会创建 <code>system:nodes</code> 组到 <code>system:node</code> 角色的自动绑定。</p>
<!--
In 1.7, the automatic binding of the `system:nodes` group to the `system:node` role is deprecated
because the node authorizer accomplishes the same purpose with the benefit of additional restrictions
on secret and configmap access. If the `Node` and `RBAC` authorization modes are both enabled,
the automatic binding of the `system:nodes` group to the `system:node` role is not created in 1.7.
-->
<p>在 1.8 版本中，绑定将根本不会被创建。</p>
<!--
In 1.8, the binding will not be created at all.
-->
<p>使用 RBAC 时，将继续创建 <code>system:node</code> 集群角色，以便与将其他用户或组绑定到该角色的部署方法兼容。</p>
<!--
When using RBAC, the `system:node` cluster role will continue to be created,
for compatibility with deployment methods that bind other users or groups to that role.
-->

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-215c25173044b8f97e9b0494b0c7e53f">10 - Webhook 模式</h1>
    
	<!--
---
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Webhook Mode
content_type: concept
weight: 95
---
-->
<!-- overview -->
<!--
A WebHook is an HTTP callback: an HTTP POST that occurs when something happens; a simple event-notification via HTTP POST. A web application implementing WebHooks will POST a message to a URL when certain things happen.
-->
<p>WebHook 是一种 HTTP 回调：某些条件下触发的 HTTP POST 请求；通过 HTTP POST 发送的简单事件通知。一个基于 web 应用实现的 WebHook 会在特定事件发生时把消息发送给特定的 URL。</p>
<!-- body -->
<!--
When specified, mode `Webhook` causes Kubernetes to query an outside REST
service when determining user privileges.
-->
<p>具体来说，当在判断用户权限时，<code>Webhook</code> 模式会使 Kubernetes 查询外部的 REST 服务。</p>
<!--
## Configuration File Format
-->
<h2 id="配置文件格式">配置文件格式</h2>
<!--
Mode `Webhook` requires a file for HTTP configuration, specify by the
`--authorization-webhook-config-file=SOME_FILENAME` flag.
-->
<p><code>Webhook</code> 模式需要一个 HTTP 配置文件，通过 <code>--authorization-webhook-config-file=SOME_FILENAME</code> 的参数声明。</p>
<!--
The configuration file uses the [kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
file format. Within the file "users" refers to the API Server webhook and
"clusters" refers to the remote service.
-->
<p>配置文件的格式使用 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a>。在文件中，&quot;users&quot; 代表着 API 服务器的 webhook，而 &quot;cluster&quot; 代表着远程服务。</p>
<!--
A configuration example which uses HTTPS client auth:
-->
<p>使用 HTTPS 客户端认证的配置例子：</p>
<!--
```yaml
# Kubernetes API version
apiVersion: v1
# kind of the API object
kind: Config
# clusters refers to the remote service.
clusters:
  - name: name-of-remote-authz-service
    cluster:
      # CA for verifying the remote service.
      certificate-authority: /path/to/ca.pem
      # URL of remote service to query. Must use 'https'. May not include parameters.
      server: https://authz.example.com/authorize

# users refers to the API Server's webhook configuration.
users:
  - name: name-of-api-server
    user:
      client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
      client-key: /path/to/key.pem          # key matching the cert

# kubeconfig files require a context. Provide one for the API Server.
current-context: webhook
contexts:
- context:
    cluster: name-of-remote-authz-service
    user: name-of-api-server
  name: webhook
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># Kubernetes API 版本</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># API 对象种类</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># clusters 代表远程服务。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-remote-authz-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 对远程服务进行身份认证的 CA。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>/path/to/ca.pem<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#080;font-style:italic"># 远程服务的查询 URL。必须使用 &#39;https&#39;。</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://authz.example.com/authorize<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># users 代表 API 服务器的 webhook 配置</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>/path/to/cert.pem<span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># webhook plugin 使用 cert</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>/path/to/key.pem         <span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># cert 所对应的 key</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-style:italic"># kubeconfig 文件必须有 context。需要提供一个给 API 服务器。</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>name-of-remote-authz-service<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>name-of-api-server<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>webhook<span style="color:#bbb">
</span></code></pre></div><!--
## Request Payloads
-->
<h2 id="请求载荷">请求载荷</h2>
<!--
When faced with an authorization decision, the API Server POSTs a JSON-
serialized `authorization.k8s.io/v1beta1` `SubjectAccessReview` object describing the
action. This object contains fields describing the user attempting to make the
request, and either details about the resource being accessed or requests
attributes.
-->
<p>在做认证决策时，API 服务器会 POST 一个 JSON 序列化的 <code>authorization.k8s.io/v1beta1</code> <code>SubjectAccessReview</code> 对象来描述这个动作。这个对象包含了描述用户请求的字段，同时也包含了需要被访问资源或请求特征的具体信息。</p>
<!--
Note that webhook API objects are subject to the same [versioning compatibility rules](/docs/concepts/overview/kubernetes-api/)
as other Kubernetes API objects. Implementers should be aware of looser
compatibility promises for beta objects and check the "apiVersion" field of the
request to ensure correct deserialization. Additionally, the API Server must
enable the `authorization.k8s.io/v1beta1` API extensions group (`--runtime-config=authorization.k8s.io/v1beta1=true`).
-->
<p>需要注意的是 webhook API 对象与其他 Kubernetes API 对象一样都同样都服从<a href="/zh/docs/concepts/overview/kubernetes-api/">版本兼容规则</a>。实施人员应该了解 beta 对象的更宽松的兼容性承诺，同时确认请求的 &quot;apiVersion&quot; 字段能被正确地反序列化。此外，API 服务器还必须启用 <code>authorization.k8s.io/v1beta1</code> API 扩展组 (<code>--runtime-config=authorization.k8s.io/v1beta1=true</code>)。</p>
<!--
An example request body:
-->
<p>一个请求内容的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;resourceAttributes&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;kittensandponies&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;verb&#34;</span>: <span style="color:#b44">&#34;get&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;unicorn.example.org&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;jane&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: [
      <span style="color:#b44">&#34;group1&#34;</span>,
      <span style="color:#b44">&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div><!--
The remote service is expected to fill the `status` field of
the request and respond to either allow or disallow access. The response body's
`spec` field is ignored and may be omitted. A permissive response would return:
-->
<p>期待远程服务填充请求的 <code>status</code> 字段并响应允许或禁止访问。响应主体的 <code>spec</code> 字段被忽略，可以省略。允许的响应将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
  }
}
</code></pre></div><!--
For disallowing access there are two methods.
-->
<p>为了禁止访问，有两种方法。</p>
<!--
The first method is preferred in most cases, and indicates the authorization
webhook does not allow, or has "no opinion" about the request, but if other
authorizers are configured, they are given a chance to allow the request.
If there are no other authorizers, or none of them allow the request, the
request is forbidden. The webhook would return:
-->
<p>在大多数情况下，第一种方法是首选方法，它指示授权 webhook 不允许或对请求&quot;无意见&quot;，但是，如果配置了其他授权者，则可以给他们机会允许请求。如果没有其他授权者，或者没有一个授权者，则该请求被禁止。webhook 将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div><!--
The second method denies immediately, short-circuiting evaluation by other
configured authorizers. This should only be used by webhooks that have
detailed knowledge of the full authorizer configuration of the cluster.
The webhook would return:
-->
<p>第二种方法立即拒绝其他配置的授权者进行短路评估。仅应由对集群的完整授权者配置有详细了解的 webhook 使用。webhook 将返回:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;allowed&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>,
    <span style="color:#008000;font-weight:bold">&#34;denied&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>,
    <span style="color:#008000;font-weight:bold">&#34;reason&#34;</span>: <span style="color:#b44">&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div><!--
Access to non-resource paths are sent as:
-->
<p>对于非资源的路径访问是这么发送的:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;nonResourceAttributes&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;path&#34;</span>: <span style="color:#b44">&#34;/debug&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;verb&#34;</span>: <span style="color:#b44">&#34;get&#34;</span>
    },
    <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;jane&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: [
      <span style="color:#b44">&#34;group1&#34;</span>,
      <span style="color:#b44">&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div><!--
Non-resource paths include: `/api`, `/apis`, `/metrics`, `/resetMetrics`,
`/logs`, `/debug`, `/healthz`, `/swagger-ui/`, `/swaggerapi/`, `/ui`, and
`/version.` Clients require access to `/api`, `/api/*`, `/apis`, `/apis/*`,
and `/version` to discover what resources and versions are present on the server.
Access to other non-resource paths can be disallowed without restricting access
to the REST api.
-->
<p>非资源类的路径包括：<code>/api</code>, <code>/apis</code>, <code>/metrics</code>, <code>/resetMetrics</code>,
<code>/logs</code>, <code>/debug</code>, <code>/healthz</code>, <code>/swagger-ui/</code>, <code>/swaggerapi/</code>, <code>/ui</code>, 和
<code>/version</code>。客户端需要访问 <code>/api</code>, <code>/api/*</code>, <code>/apis</code>, <code>/apis/*</code>, 和 <code>/version</code> 以便
能发现服务器上有什么资源和版本。对于其他非资源类的路径访问在没有 REST API 访问限制的情况下拒绝。</p>
<!--
For further documentation refer to the authorization.v1beta1 API objects and
[webhook.go](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go).
-->
<p>更多信息可以参考 authorization.v1beta1 API 对象和 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go">webhook.go</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-643e4cec52a8577e9454649bdaac84d0">11 - 从 PodSecurityPolicy 映射到 Pod 安全性标准</h1>
    
	<!--
reviewers:
- tallclair
- liggitt
title: Mapping PodSecurityPolicies to Pod Security Standards
content_type: concept
weight: 95
-->
<!-- overview -->
<!--
The tables below enumerate the configuration parameters on
[PodSecurityPolicy](/docs/concepts/policy/pod-security-policy/) objects, whether the field mutates
and/or validates pods, and how the configuration values map to the
[Pod Security Standards](/docs/concepts/security/pod-security-standards/).
-->
<p>下面的表格列举了<a href="/zh/docs/concepts/policy/pod-security-policy/">PodSecurityPolicy</a>
对象上的配置参数，这些字段是否会变更或检查 Pod 配置，以及这些配置值如何映射到
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全性标准（Pod Security Standards）</a>
之上。</p>
<!--
For each applicable parameter, the allowed values for the
[Baseline](/docs/concepts/security/pod-security-standards/#baseline) and
[Restricted](/docs/concepts/security/pod-security-standards/#restricted) profiles are listed.
Anything outside the allowed values for those profiles would fall under the
[Privileged](/docs/concepts/security/pod-security-standards/#priveleged) profile. "No opinion"
means all values are allowed under all Pod Security Standards.
-->
<p>对于每个可应用的参数，表格中给出了
<a href="/zh/docs/concepts/security/pod-security-standards/#baseline">Baseline</a> 和
<a href="/zh/docs/concepts/security/pod-security-standards/#restricted">Restricted</a>
配置下可接受的取值。
对这两种配置而言不可接受的取值均归入
<a href="/zh/docs/concepts/security/pod-security-standards/#priveleged">Privileged</a>
配置下。“无意见”意味着对所有 Pod 安全性标准而言所有取值都可接受。</p>
<!--
For a step-by-step migration guide, see
[Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller](/docs/tasks/configure-pod-container/migrate-from-psp/).
-->
<p>如果想要了解如何一步步完成迁移，可参阅
<a href="/zh/docs/tasks/configure-pod-container/migrate-from-psp/">从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a>。</p>
<!-- body -->
<!--
## PodSecurityPolicy Spec
-->
<h2 id="podsecuritypolicy-spec">PodSecurityPolicy 规约  </h2>
<!--
The fields enumerated in this table are part of the `PodSecurityPolicySpec`, which is specified
under the `.spec` field path.
-->
<p>下面表格中所列举的字段是 <code>PodSecurityPolicySpec</code> 的一部分，是通过 <code>.spec</code>
字段路径来设置的。</p>
<table class="no-word-break">
  <caption style="display:none"><!--Mapping PodSecurityPolicySpec fields to Pod Security Standards-->从 PodSecurityPolicySpec 字段映射到 Pod Security 标准</caption>
    <tbody>
      <tr>
      <th><code>PodSecurityPolicySpec</code></th>
      <th><!-- Type -->类型</th>
      <th><!--Pod Security Standards Equivalent-->Pod 安全性标准中对应设置</th>
    </tr>
    <tr>
      <td><code>privileged</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>: <code>false</code> / 未定义 / nil</td>
    </tr>
    <tr>
      <td><code>defaultAddCapabilities</code></td>
      <td><!-- Mutating & Validating -->更改性质 & 检查性质</td>
      <td><!--Requirements match <code>allowedCapabilities</code> below.-->需求满足下面的 <code>allallowedCapabilities</code></td>
    </tr>
    <tr>
      <td><code>allowedCapabilities</code></td>
      <td><!-- Validating -->检查性质</td>
      <td>
        <!-- p><b>Baseline</b>: subset of</p -->
        <p><b>Baseline</b>：下面各项的子集</p>
        <ul>
          <li><code>AUDIT_WRITE</code></li>
          <li><code>CHOWN</code></li>
          <li><code>DAC_OVERRIDE</code></li>
          <li><code>FOWNER</code></li>
          <li><code>FSETID</code></li>
          <li><code>KILL</code></li>
          <li><code>MKNOD</code></li>
          <li><code>NET_BIND_SERVICE</code></li>
          <li><code>SETFCAP</code></li>
          <li><code>SETGID</code></li>
          <li><code>SETPCAP</code></li>
          <li><code>SETUID</code></li>
          <li><code>SYS_CHROOT</code></li>
        </ul>
        <!-- p><b>Restricted</b>: empty / undefined / nil OR a list containing <i>only</i> <code>NET_BIND_SERVICE</code -->
        <p><b>Restricted</b>：空 / 未定义 / nil 或<i>仅</i>包含 <code>NET_BIND_SERVICE</code> 的列表</p>
      </td>
    </tr>
    <tr>
      <td><code>requiredDropCapabilities</code></td>
      <td><!--Mutating & Validating-->更改性质 & 检查性质</td>
      <td>
        <p><b>Baseline</b><!-- : no opinion-->：无意见</p>
        <p><b>Restricted</b><!-- : must include-->：必须包含 <code>ALL</code></p>
      </td>
    </tr>
    <tr>
      <td><code>volumes</code></td>
      <td><!-- Validating -->检查性质</td>
      <td>
        <p><b>Baseline</b><!--: anything except -->除下列取值之外的任何值</p>
        <ul>
          <li><code>hostPath</code></li>
          <li><code>*</code></li>
        </ul>
        <p><b>Restricted</b><!-- : subset of-->：下列取值的子集</p>
        <ul>
          <li><code>configMap</code></li>
          <li><code>csi</code></li>
          <li><code>downwardAPI</code></li>
          <li><code>emptyDir</code></li>
          <li><code>ephemeral</code></li>
          <li><code>persistentVolumeClaim</code></li>
          <li><code>projected</code></li>
          <li><code>secret</code></li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>hostNetwork</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
    </tr>
    <tr>
      <td><code>hostPorts</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>：未定义 / nil / 空</td>
    </tr>
    <tr>
      <td><code>hostPID</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
    </tr>
    <tr>
      <td><code>hostIPC</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td>
    </tr>
    <tr>
      <td><code>seLinux</code></td>
      <td><!-- Mutating & Validating -->更改性质 & 检查性质</td>
      <td>
        <p><b>Baseline & Restricted</b>：
        <!-- code>seLinux.rule</code> is <code>MustRunAs</code>, with the following <code>options</code-->
        <code>seLinux.rule</code> 为 <code>MustRunAs</code>，且 <code>options</code> 如下：
        </p>
        <ul>
          <!--
          <li><code>user</code> is unset (<code>""</code> / undefined / nil)</li>
          <li><code>role</code> is unset (<code>""</code> / undefined / nil)</li>
          <li><code>type</code> is unset or one of: <code>container_t, container_init_t, container_kvm_t</code></li>
          <li><code>level</code> is anything</li>
          -->
          <li><code>user</code> 未设置（<code>""</code> / 未定义 / nil）</li>
          <li><code>role</code> 未设置（<code>""</code> / 未定义 / nil）</li>
          <li><code>type</code> 未设置或者取值为 <code>container_t</code>、<code>container_init_t</code> 或 <code>container_kvm_t</code> 之一</li>
          <li><code>level</code> 是任何取值</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><code>runAsUser</code></td>
      <td><!-- Mutating & Validating -->变更性质 & 检查性质</td>
      <td>
        <p><b>Baseline</b><!-- : Anything -->：任何取值</p>
        <p><b>Restricted</b><!-- : <code>rule</code> is <code>MustRunAsNonRoot</code -->：<code>rule</code> 是 <code>MustRunAsNonRoot</code></p>
      </td>
    </tr>
    <tr>
      <td><code>runAsGroup</code></td>
      <td><!-- Mutating (MustRunAs) & Validating-->变更性质（MustRunAs）& 检查性质</td>
      <td>
        <i><!-- No opinion -->无意见</i>
      </td>
    </tr>
    <tr>
      <td><code>supplementalGroups</code></td>
      <td><!-- Mutating & Validating -->变更性质 & 检查性质</td>
      <td>
        <i><!-- No opinion -->无意见</i>
      </td>
    </tr>
    <tr>
      <td><code>fsGroup</code></td>
      <td><!-- Mutating & Validating -->变更性质 & 验证性质</td>
      <td>
        <i><!-- No opinion -->无意见</i>
      </td>
    </tr>
    <tr>
      <td><code>readOnlyRootFilesystem</code></td>
      <td><!-- Mutating & Validating -->变更性质 & 检查性质</td>
      <td>
        <i><!-- No opinion -->无意见</i>
      </td>
    </tr>
    <tr>
      <td><code>defaultAllowPrivilegeEscalation</code></td>
      <td><!-- Mutating -->变更性质</td>
      <td>
        <i><!-- No opinion (non-validating) -->无意见（非变更性质）</i>
      </td>
    </tr>
    <tr>
      <td><code>allowPrivilegeEscalation</code></td>
      <td><!-- Mutating & Validating -->变更性质 & 检查性质</td>
      <td>
        <!--
        <p><i>Only mutating if set to <code>false</code></i></p>
        <p><b>Baseline</b>: No opinion</p>
        <p><b>Restricted</b>: <code>false</code></p>
        -->
        <p><i>只有设置为 <code>false</code> 时才执行变更动作</i></p>
        <p><b>Baseline</b>：无意见</p>
        <p><b>Restricted</b>：<code>false</code></p>
      </td>
    </tr>
    <tr>
      <td><code>allowedHostPaths</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><i><!-- No opinion (volumes takes precedence)-->无意见（volumes 优先）</i></td>
    </tr>
    <tr>
      <td><code>allowedFlexVolumes</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><i><!-- No opinion (volumes takes precedence)-->无意见（volumes 优先）</i></td>
    </tr>
    <tr>
      <td><code>allowedCSIDrivers</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><i><!-- No opinion (volumes takes precedence) -->无意见（volumes 优先）</i></td>
    </tr>
    <tr>
      <td><code>allowedUnsafeSysctls</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><b>Baseline & Restricted</b>：未定义 / nil / 空</td>
    </tr>
    <tr>
      <td><code>forbiddenSysctls</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><i><!-- No opinion -->无意见</i></td>
    </tr>
    <tr>
      <td><code>allowedProcMountTypes</code><br><i>(alpha feature)</i></td>
      <td><!-- Validating -->检查性质</td>
      <!-- td><b>Baseline & Restricted</b>: <code>["Default"]</code> OR undefined / nil / empty</td -->
      <td><b>Baseline & Restricted</b>：<code>["Default"]</code> 或者未定义 / nil / 空</td>
    </tr>
    <tr>
      <td><code>runtimeClass</code><br><code>&nbsp;.defaultRuntimeClassName</code></td>
      <td><!-- Mutating -->变更性质</td>
      <td><i><!-- No opinion -->无意见</i></td>
    </tr>
    <tr>
      <td><code>runtimeClass</code><br><code>&nbsp;.allowedRuntimeClassNames</code></td>
      <td><!-- Validating -->检查性质</td>
      <td><i><!-- No opinion -->无意见</i></td>
    </tr>
  </tbody>
</table>
<!--
## PodSecurityPolicy annotations
-->
<h2 id="podsecuritypolicy-annotations">PodSecurityPolicy 注解   </h2>
<!--
The [annotations](/docs/concepts/overview/working-with-objects/annotations/) enumerated in this
table can be specified under `.metadata.annotations` on the PodSecurityPolicy object.
-->
<p>下面表格中所列举的<a href="/zh/docs/concepts/overview/working-with-objects/annotations/">注解</a>
可以通过 <code>.metadata.annotations</code> 设置到 PodSecurityPolicy 对象之上。</p>
<table class="no-word-break">
    <caption style="display:none"><!-- Mapping PodSecurityPolicy annotations to Pod Security Standards-->将 PodSecurityPolicy 注解映射到 Pod 安全性标准</caption>
    <tbody>
        <tr>
      <th><code><!--PSP Annotation-->PSP 注解</code></th>
      <th><!-- Type -->类型</th>
      <th><!-- Pod Security Standards Equivalent-->Pod 安全性标准中对应设置</th>
    </tr>
    <tr>
      <td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/defaultProfileName</code></td>
      <td><!-- Mutating -->变更性质</td>
      <td><i><!-- No opinion -->无意见</i></td>
    </tr>
    <tr>
      <td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/allowedProfileNames</code></td>
      <td><!-- Validating -->检查性质</td>
      <td>
        <!--
        <p><b>Baseline</b>: <code>"runtime/default,"</code> <i>(Trailing comma to allow unset)</i></p>
        <p><b>Restricted</b>: <code>"runtime/default"</code> <i>(No trailing comma)</i></p>
        <p><i><code>localhost/*</code> values are also permitted for both Baseline & Restricted.</i></p>
        -->
        <p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p>
        <p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p>
        <p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p>
      </td>
    </tr>
    <tr>
      <td><code>apparmor.security.beta.kubernetes.io</code><br><code>/defaultProfileName</code></td>
      <td><!-- Mutating -->变更性质</td>
      <td><i><!-- No opinion -->无意见</i></td>
    </tr>
    <tr>
      <td><code>apparmor.security.beta.kubernetes.io</code><br><code>/allowedProfileNames</code></td>
      <td><!-- Validating -->检查性质</td>
      <td>
        <!--
        <p><b>Baseline</b>: <code>"runtime/default,"</code> <i>(Trailing comma to allow unset)</i></p>
        <p><b>Restricted</b>: <code>"runtime/default"</code> <i>(No trailing comma)</i></p>
        <p><i><code>localhost/*</code> values are also permitted for both Baseline & Restricted.</i></p>
        -->
        <p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p>
        <p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p>
        <p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p>
      </td>
    </tr>
  </tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a5bdc757c01991e5e6ab1a82b90639ea">12 - 使用 ABAC 鉴权</h1>
    
	<!--
---
reviewers:
- erictune
- lavalamp
- deads2k
- liggitt
title: Using ABAC Authorization
content_type: concept
weight: 80
---
-->
<!-- overview -->
<!--
Attribute-based access control (ABAC) defines an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together.
-->
<p>基于属性的访问控制（Attribute-based access control - ABAC）定义了访问控制范例，其中通过使用将属性组合在一起的策略来向用户授予访问权限。</p>
<!-- body -->
<!--
## Policy File Format

To enable `ABAC` mode, specify `--authorization-policy-file=SOME_FILENAME` and `--authorization-mode=ABAC` on startup.

The file format is [one JSON object per line](http://jsonlines.org/).  There
should be no enclosing list or map, only one map per line.

Each line is a "policy object", where each such object is a map with the following
properties:

  - Versioning properties:
    - `apiVersion`, type string; valid values are "abac.authorization.kubernetes.io/v1beta1". Allows versioning and conversion of the policy format.
    - `kind`, type string: valid values are "Policy". Allows versioning and conversion of the policy format.
  - `spec` property set to a map with the following properties:
    - Subject-matching properties:
      - `user`, type string; the user-string from `--token-auth-file`. If you specify `user`, it must match the username of the authenticated user.
      - `group`, type string; if you specify `group`, it must match one of the groups of the authenticated user. `system:authenticated` matches all authenticated requests. `system:unauthenticated` matches all unauthenticated requests.
    - Resource-matching properties:
      - `apiGroup`, type string; an API group.
        - Ex: `apps`, `networking.k8s.io`
        - Wildcard: `*` matches all API groups.
      - `namespace`, type string; a namespace.
        - Ex: `kube-system`
        - Wildcard: `*` matches all resource requests.
      - `resource`, type string; a resource type
        - Ex: `pods`, `deployments`
        - Wildcard: `*` matches all resource requests.
    - Non-resource-matching properties:
      - `nonResourcePath`, type string; non-resource request paths.
        - Ex: `/version` or `/apis`
        - Wildcard:
          - `*` matches all non-resource requests.
          - `/foo/*` matches all subpaths of `/foo/`.
    - `readonly`, type boolean, when true, means that the Resource-matching policy only applies to get, list, and watch operations, Non-resource-matching policy only applies to get operation.
-->
<h2 id="策略文件格式">策略文件格式</h2>
<p>基于 <code>ABAC</code> 模式，可以这样指定策略文件 <code>--authorization-policy-file=SOME_FILENAME</code>。</p>
<p>此文件格式是 <a href="https://jsonlines.org/">JSON Lines</a>，不应存在外层的列表或映射，每行应只有一个映射。</p>
<p>每一行都是一个策略对象，策略对象是具有以下属性的映射：</p>
<ul>
<li>版本控制属性：
<ul>
<li><code>apiVersion</code>，字符串类型：有效值为<code>abac.authorization.kubernetes.io/v1beta1</code>，允许对策略格式进行版本控制和转换。</li>
<li><code>kind</code>，字符串类型：有效值为 <code>Policy</code>，允许对策略格式进行版本控制和转换。</li>
</ul>
</li>
<li><code>spec</code> 配置为具有以下映射的属性：
<ul>
<li>主体匹配属性：
<ul>
<li><code>user</code>，字符串类型；来自 <code>--token-auth-file</code> 的用户字符串，如果你指定 <code>user</code>，它必须与验证用户的用户名匹配。</li>
<li><code>group</code>，字符串类型；如果指定 <code>group</code>，它必须与经过身份验证的用户的一个组匹配，<code>system:authenticated</code>匹配所有经过身份验证的请求。<code>system:unauthenticated</code>匹配所有未经过身份验证的请求。</li>
</ul>
</li>
</ul>
</li>
<li>资源匹配属性：
<ul>
<li><code>apiGroup</code>，字符串类型；一个 API 组。
<ul>
<li>例： <code>apps</code>, <code>networking.k8s.io</code></li>
<li>通配符：<code>*</code>匹配所有 API 组。</li>
</ul>
</li>
<li><code>namespace</code>，字符串类型；一个命名空间。
<ul>
<li>例如：<code>kube-system</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
<li><code>resource</code>，字符串类型；资源类型。
<ul>
<li>例：<code>pods</code>, <code>deployments</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
</ul>
</li>
<li>非资源匹配属性：
<ul>
<li><code>nonResourcePath</code>，字符串类型；非资源请求路径。
<ul>
<li>例如：<code>/version</code>或 <code>/apis</code></li>
<li>通配符：
<ul>
<li><code>*</code> 匹配所有非资源请求。</li>
<li><code>/foo/*</code> 匹配 <code>/foo/</code> 的所有子路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>readonly</code>，键入布尔值，如果为 true，则表示该策略仅适用于 get、list 和 watch 操作。</li>
</ul>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
An unset property is the same as a property set to the zero value for its type
(e.g. empty string, 0, false). However, unset should be preferred for
readability.

In the future, policies may be expressed in a JSON format, and managed via a
REST interface.
-->
<p>属性未设置等效于属性被设置为对应类型的零值( 例如空字符串、0、false)，然而，出于可读性考虑，应尽量选择不设置这类属性。</p>
<p>在将来，策略可能以 JSON 格式表示，并通过 REST 界面进行管理。</p>

</div>
<!--
## Authorization Algorithm

A request has attributes which correspond to the properties of a policy object.

When a request is received, the attributes are determined.  Unknown attributes
are set to the zero value of its type (e.g. empty string, 0, false).

A property set to `"*"` will match any value of the corresponding attribute.

The tuple of attributes is checked for a match against every policy in the
policy file. If at least one line matches the request attributes, then the
request is authorized (but may fail later validation).

To permit any authenticated user to do something, write a policy with the
group property set to `"system:authenticated"`.

To permit any unauthenticated user to do something, write a policy with the
group property set to `"system:unauthenticated"`.

To permit a user to do anything, write a policy with the apiGroup, namespace,
resource, and nonResourcePath properties set to `"*"`.
-->
<h2 id="鉴权算法">鉴权算法</h2>
<p>请求具有与策略对象的属性对应的属性。</p>
<p>当接收到请求时，确定属性。未知属性设置为其类型的零值（例如：空字符串，0，false）。</p>
<p>设置为 <code>&quot;*&quot;</code> 的属性将匹配相应属性的任何值。</p>
<p>检查属性的元组，以匹配策略文件中的每个策略。如果至少有一行匹配请求属性，则请求被鉴权（但仍可能无法通过稍后的合法性检查）。</p>
<p>要允许任何经过身份验证的用户执行某些操作，请将策略组属性设置为 <code>&quot;system:authenticated&quot;</code>。</p>
<p>要允许任何未经身份验证的用户执行某些操作，请将策略组属性设置为 <code>&quot;system:authentication&quot;</code>。</p>
<p>要允许用户执行任何操作，请使用 apiGroup，命名空间，
资源和 nonResourcePath 属性设置为 <code>&quot;*&quot;</code> 的策略。</p>
<p>要允许用户执行任何操作，请使用设置为 <code>&quot;*&quot;</code> 的 apiGroup，namespace，resource 和 nonResourcePath 属性编写策略。</p>
<!--
## Kubectl

Kubectl uses the `/api` and `/apis` endpoints of api-server to discover
served resource types, and validates objects sent to the API by create/update
operations using schema information located at `/openapi/v2`.

When using ABAC authorization, those special resources have to be explicitly
exposed via the `nonResourcePath` property in a policy (see [examples](#examples) below):

* `/api`, `/api/*`, `/apis`, and `/apis/*` for API version negotiation.
* `/version` for retrieving the server version via `kubectl version`.
* `/swaggerapi/*` for create/update operations.

To inspect the HTTP calls involved in a specific kubectl operation you can turn
up the verbosity:

    kubectl --v=8 version
-->
<h2 id="kubectl">Kubectl</h2>
<p>Kubectl 使用 api-server 的 <code>/api</code> 和 <code>/apis</code> 端点来发现服务资源类型，并使用位于 <code>/openapi/v2</code> 的模式信息来验证通过创建/更新操作发送到 API 的对象。</p>
<p>当使用 ABAC 鉴权时，这些特殊资源必须显式地通过策略中的 <code>nonResourcePath</code> 属性暴露出来（参见下面的 <a href="#examples">示例</a>）：</p>
<ul>
<li><code>/api</code>，<code>/api/*</code>，<code>/apis</code>和 <code>/apis/*</code> 用于 API 版本协商。</li>
<li><code>/version</code> 通过 <code>kubectl version</code> 检索服务器版本。</li>
<li><code>/swaggerapi/*</code> 用于创建 / 更新操作。</li>
</ul>
<p>要检查涉及到特定 kubectl 操作的 HTTP 调用，您可以调整详细程度：
kubectl --v=8 version</p>
<!--
## Examples

 1. Alice can do anything to all resources:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "alice", "namespace": "*", "resource": "*", "apiGroup": "*"}}
    ```
 2. The Kubelet can read any pods:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "kubelet", "namespace": "*", "resource": "pods", "readonly": true}}
    ```
 3. The Kubelet can read and write events:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "kubelet", "namespace": "*", "resource": "events"}}
    ```
 -->
<h2 id="examples">例子</h2>
<ol>
<li>
<p>Alice 可以对所有资源做任何事情：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;alice&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;apiGroup&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读取任何 pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读写事件：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;kubelet&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;events&#34;</span>}}
</code></pre></div></li>
</ol>
 <!--
 4. Bob can just read pods in namespace "projectCaribou":

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user": "bob", "namespace": "projectCaribou", "resource": "pods", "readonly": true}}
    ```
 5. Anyone can make read-only requests to all non-resource paths:

    ```json
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group": "system:authenticated", "readonly": true, "nonResourcePath": "*"}}
    {"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group": "system:unauthenticated", "readonly": true, "nonResourcePath": "*"}}
    ```
-->
<ol start="4">
<li>
<p>Bob 可以在命名空间 <code>projectCaribou</code> 中读取 pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;bob&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;projectCaribou&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>}}
</code></pre></div></li>
<li>
<p>任何人都可以对所有非资源路径进行只读请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;system:authenticated&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>, <span style="color:#008000;font-weight:bold">&#34;nonResourcePath&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;system:unauthenticated&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>, <span style="color:#008000;font-weight:bold">&#34;nonResourcePath&#34;</span>: <span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div></li>
</ol>
<!--
[Complete file example](http://releases.k8s.io/v1.23.0/pkg/auth/authorizer/abac/example_policy_file.jsonl)

## A quick note on service accounts

Every service account has a corresponding ABAC username, and that service account's user name is generated according to the naming convention:

```shell
system:serviceaccount:<namespace>:<serviceaccountname>
```

-->
<p><a href="https://releases.k8s.io/v1.23.0/pkg/auth/authorizer/abac/example_policy_file.jsonl">完整文件示例</a></p>
<h2 id="服务帐户的快速说明">服务帐户的快速说明</h2>
<p>服务帐户自动生成用户。用户名是根据命名约定生成的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;
</code></pre></div><!--
Creating a new namespace leads to the creation of a new service account in the following format:

```shell
system:serviceaccount:<namespace>:default
```

For example, if you wanted to grant the default service account (in the `kube-system` namespace) full
privilege to the API using ABAC, you would add this line to your policy file:

```json
{"apiVersion":"abac.authorization.kubernetes.io/v1beta1","kind":"Policy","spec":{"user":"system:serviceaccount:kube-system:default","namespace":"*","resource":"*","apiGroup":"*"}}
```

The apiserver will need to be restarted to pickup the new policy lines.
-->
<p>创建新的命名空间也会导致创建一个新的服务帐户：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">system:serviceaccount:&lt;namespace&gt;:default
</code></pre></div><p>例如，如果要将 API 的 kube-system 完整权限中的默认服务帐户授予，则可以将此行添加到策略文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>:<span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>:<span style="color:#b44">&#34;Policy&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>:{<span style="color:#008000;font-weight:bold">&#34;user&#34;</span>:<span style="color:#b44">&#34;system:serviceaccount:kube-system:default&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;apiGroup&#34;</span>:<span style="color:#b44">&#34;*&#34;</span>}}
</code></pre></div><p>需要重新启动 apiserver 以获取新的策略行。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
