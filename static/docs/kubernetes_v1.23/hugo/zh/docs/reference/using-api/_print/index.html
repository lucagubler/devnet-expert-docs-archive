<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/reference/using-api/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/reference/using-api/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/reference/using-api/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/reference/using-api/">
<link rel="alternate" hreflang="de" href="http://localhost:1313/de/docs/reference/using-api/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/reference/using-api/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/reference/using-api/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>API 概述 | Kubernetes</title><meta property="og:title" content="API 概述" />
<meta property="og:description" content="生产级别的容器编排系统" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/using-api/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="API 概述">
<meta itemprop="description" content="生产级别的容器编排系统"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="API 概述"/>
<meta name="twitter:description" content="生产级别的容器编排系统"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta property="og:description" content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta name="twitter:description" content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考列 出了 Kubernetes v1.23 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何 向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案 描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
 Alpha:  版本名称包含 alpha（例如，v1alpha1）。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 某些特性可能默认禁用。 对某个特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。      Beta:">
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/using-api/">
<meta property="og:title" content="API 概述">
<meta name="twitter:title" content="API 概述">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/reference/using-api/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/reference/using-api/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/reference/using-api/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/reference/using-api/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/reference/using-api/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/reference/using-api/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/reference/using-api/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/reference/using-api/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/reference/using-api/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/reference/using-api/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/reference/using-api/">Español</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/reference/using-api/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">API 概述</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-2b5428a2ff6f4831fd972ef50e12b3eb">Kubernetes API 概念</a></li>


    
  
    
    
	
<li>2: <a href="#pg-040d9484db673074f1b8ba3465be9d91">服务器端应用（Server-Side Apply）</a></li>


    
  
    
    
	
<li>3: <a href="#pg-79880efc25dc8cb3b6962ad78a964319">客户端库</a></li>


    
  
    
    
	
<li>4: <a href="#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b">Kubernetes 弃用策略</a></li>


    
  
    
    
	
<li>5: <a href="#pg-2479c39af50fd55b898a3bcfb5988077">已弃用 API 的迁移指南</a></li>


    
  
    
    
	
<li>6: <a href="#pg-e4dbb59f8f23854d7b7d574e169923c4">Kubernetes API 健康端点</a></li>


    
  

    </ul>


<div class="content">
      <!-- overview -->
<!--
This section provides reference information for the Kubernetes API.
-->
<p>本文提供了 Kubernetes API 的参考信息。</p>
<!--
The REST API is the fundamental fabric of Kubernetes. All operations and
communications between components, and external user commands are REST API
calls that the API Server handles. Consequently, everything in the Kubernetes
platform is treated as an API object and has a corresponding entry in the
[API](/docs/reference/generated/kubernetes-api/v1.23/).
-->
<p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href="/docs/reference/generated/kubernetes-api/v1.23/">API</a> 中有相应的定义。</p>
<!--
The [Kubernetes API reference](/docs/reference/generated/kubernetes-api/v1.23/)
lists the API for Kubernetes version v1.23.
-->
<p><a href="/docs/reference/generated/kubernetes-api/v1.23/">Kubernetes API 参考</a>列
出了 Kubernetes v1.23 版本的 API。</p>
<!--
For general background information, read
[The Kubernetes API](/docs/concepts/overview/kubernetes-api/).
[Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access/)
describes how clients can authenticate to the Kubernetes API server, and how their
requests are authorized.
-->
<p>如需了解一般背景信息，请查阅 <a href="/zh/docs/concepts/overview/kubernetes-api/">Kubernetes API</a>。
<a href="/zh/docs/concepts/security/controlling-access/">Kubernetes API 控制访问</a>描述了客户端如何
向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p>
<!--
## API versioning
-->
<h2 id="api-版本控制">API 版本控制</h2>
<!--
The JSON and Protobuf serialization schemas follow the same guidelines for
schema changes. The following descriptions cover both formats.
-->
<p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p>
<!--
The API versioning and software versioning are indirectly related.
The [API and release versioning proposal](https://git.k8s.io/community/contributors/design-proposals/release/versioning.md)
describes the relationship between API versioning and software versioning.
-->
<p>API 版本控制和软件版本控制是间接相关的。
<a href="https://git.k8s.io/community/contributors/design-proposals/release/versioning.md">API 和发布版本控制提案</a>
描述了 API 版本控制和软件版本控制间的关系。</p>
<!--
Different API versions indicate different levels of stability and support. You
can find more information about the criteria for each level in the
[API Changes documentation](https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions).
-->
<p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions">API 变更文档</a>
中查看到更多的不同级别的判定标准。</p>
<!--
Here's a summary of each level:
-->
<p>下面是每个级别的摘要：</p>
<!--
- Alpha:
  - The version names contain `alpha` (for example, `v1alpha1`).
  - The software may contain bugs. Enabling a feature may expose bugs. A
    feature may be disabled by default.
  - The support for a feature may be dropped at any time without notice.
  - The API may change in incompatible ways in a later software release without notice.
  - The software is recommended for use only in short-lived testing clusters,
    due to increased risk of bugs and lack of long-term support.
-->
<ul>
<li>Alpha:
<ul>
<li>版本名称包含 <code>alpha</code>（例如，<code>v1alpha1</code>）。</li>
<li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。
某些特性可能默认禁用。</li>
<li>对某个特性的支持可能会随时被删除，恕不另行通知。</li>
<li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li>
</ul>
</li>
</ul>
<!--
- Beta:
  - The version names contain `beta` (for example, `v2beta3`).
  - The software is well tested. Enabling a feature is considered safe.
    Features are enabled by default.
  - The support for a feature will not be dropped, though the details may change.
-->
<ul>
<li>
<p>Beta:</p>
<ul>
<li>版本名称包含 <code>beta</code> （例如， <code>v2beta3</code>）。</li>
<li>软件被很好的测试过。启用某个特性被认为是安全的。
特性默认开启。</li>
<li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li>
</ul>
<!--
- The schema and/or semantics of objects may change in incompatible ways in
  a subsequent beta or stable release. When this happens, migration
  instructions are provided. Schema changes may require deleting, editing, and
  re-creating API objects. The editing process may not be straightforward.
  The migration may require downtime for applications that rely on the feature.
- The software is not recommended for production uses. Subsequent releases
  may introduce incompatible changes. If you have multiple clusters which
  can be upgraded independently, you may be able to relax this restriction.
-->
<ul>
<li>在随后的 Beta 版或稳定版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
模式更改可能需要删除、编辑和重建 API 对象。
编辑过程可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li>
<li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
如果你有多个集群可以独立升级，可以放宽这一限制。</li>
</ul>
<!--
Please try beta features and provide feedback. After the features exit beta, it
may not be practical to make more changes.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 请试用测试版特性时并提供反馈。特性完成 Beta 阶段测试后，
就可能不会有太多的变更了。
</div>
</li>
</ul>
<!--
- Stable:
  - The version name is `vX` where `X` is an integer.
  - The stable versions of features appear in released software for many subsequent versions.
-->
<ul>
<li>Stable:
<ul>
<li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li>
<li>特性的稳定版本会出现在后续很多版本的发布软件中。</li>
</ul>
</li>
</ul>
<!--## API groups-->
<h2 id="api-组">API 组</h2>
<!--
[API groups](https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md)
make it easier to extend the Kubernetes API.
The API group is specified in a REST path and in the `apiVersion` field of a
serialized object.
-->
<p><a href="https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md">API 组</a>
能够简化对 Kubernetes API 的扩展。
API 组信息出现在REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p>
<!--
There are several API groups in Kubernetes:

*  The *core* (also called *legacy*) group is found at REST path `/api/v1`.
   The core group is not specified as part of the `apiVersion` field, for
   example, `apiVersion: v1`.
*  The named groups are at REST path `/apis/$GROUP_NAME/$VERSION` and use
   `apiVersion: $GROUP_NAME/$VERSION` (for example, `apiVersion: batch/v1`).
   You can find the full list of supported API groups in
   [Kubernetes API reference](/docs/reference/generated/kubernetes-api/v1.23/#-strong-api-groups-strong-).
-->
<p>以下是 Kubernetes 中的几个组：</p>
<ul>
<li><em>核心</em>（也叫 <em>legacy</em>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li>
<li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如， <code>apiVersion: batch/v1</code>）。
你可以在 <a href="/docs/reference/generated/kubernetes-api/v1.23/#-strong-api-groups-strong-">Kubernetes API 参考文档</a>
中查看全部的 API 组。</li>
</ul>
<!--
## Enabling or disabling API groups   {#enabling-or-disabling}

Certain resources and API groups are enabled by default. You can enable or
disable them by setting `--runtime-config` on the API server.  The
`--runtime-config` flag accepts comma separated `<key>[=<value>]` pairs
describing the runtime configuration of the API server. If the `=<value>`
part is omitted, it is treated as if `=true` is specified. For example:

 - to disable `batch/v1`, set `--runtime-config=batch/v1=false`
 - to enable `batch/v2alpha1`, set `--runtime-config=batch/v2alpha1`
-->
<h2 id="enabling-or-disabling">启用或禁用 API 组  </h2>
<p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key&gt;[=&lt;value&gt;]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value&gt;</code> 部分，那么视其指定为 <code>=true</code>。
例如：</p>
<ul>
<li>禁用 <code>batch/v1</code>， 对应参数设置 <code>--runtime-config=batch/v1=false</code></li>
<li>启用 <code>batch/v2alpha1</code>， 对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li>
</ul>
<!--
When you enable or disable groups or resources, you need to restart the API
server and controller manager to pick up the `--runtime-config` changes.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。
</div>
<!--
## Persistence
-->
<h2 id="持久化">持久化</h2>
<!--
Kubernetes stores its serialized state in terms of the API resources by writing them into
-->
<p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class='glossary-tooltip' title='etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/' target='_blank' aria-label='etcd'>etcd</a> 中存储。</p>
<h2 id="what-s-next">What's next</h2>
<!--
- Learn more about [API conventions](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions)
- Read the design documentation for
  [aggregator](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md)
-->
<ul>
<li>进一步了解 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions">API 惯例</a></li>
<li>阅读 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md">聚合器</a></li>
</ul>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2b5428a2ff6f4831fd972ef50e12b3eb">1 - Kubernetes API 概念</h1>
    
	<!--
title: Kubernetes API Concepts
reviewers:
- smarterclayton
- lavalamp
- liggitt
content_type: concept
weight: 20
-->
<!-- overview -->
<!--
This page describes common concepts in the Kubernetes API.
-->
<p>本页描述 Kubernetes API 的通用概念。</p>
<!-- body -->
<!--
The Kubernetes API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating,
updating, and deleting primary resources via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET), includes additional subresources for many objects that allow fine grained authorization (such as binding a pod to a node), and can accept and serve those resources in different representations for convenience or efficiency. It also supports efficient change notifications on resources via "watches" and consistent lists to allow other components to effectively cache and synchronize the state of resources.
-->
<p>Kubernetes API 是基于资源的（RESTful）、通过 HTTP 提供的编程接口。
API 支持通过标准的 HTTP 动词（POST、PUT、PATCH、DELETE 和  GET）
检视、创建、更新和删除主要资源，为很多允许细粒度权限控制的对象提供子资源
（如将 Pod 绑定到节点上），并且出于便利性或效率考虑，支持并提供这些资源的
不同表示形式。
Kubernetes  API 还通过 &quot;watch&quot; 和一致性的列表支持高效的资源变更通知，
从而允许其他组件对资源的状态进行高效的缓存和同步。</p>
<!--
## Standard API terminology

Most Kubernetes API resource types are [objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects): they represent a concrete instance of a concept on the cluster, like a pod or namespace. A smaller number of API resource types are "virtual" - they often represent operations rather than objects, such as a permission check (use a POST with a JSON-encoded body of `SubjectAccessReview` to the `subjectaccessreviews` resource). All objects will have a unique name to allow idempotent creation and retrieval, but virtual resource types may not have unique names if they are not retrievable or do not rely on idempotency.
-->
<h2 id="standard-api-terminology">标准 API 术语 </h2>
<p>大多数 Kubernetes API 资源类型都是
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects">对象</a>：
它们代表的是集群中某一概念的具体实例，例如一个 Pod 或名字空间。
为数不多的几个 API 资源类型是“虚拟的” - 它们通常代表的是操作而非对象本身，
例如访问权限检查（使用 POST 请求发送一个 JSON 编码的 <code>SubjectAccessReview</code>
负载到 <code>subjectaccessreviews</code> 资源）。
所有对象都有一个唯一的名字，以便支持幂等的创建和检视操作，不过如果虚拟资源类型
不可检视或者不要求幂等，可以不具有唯一的名字。</p>
<!--
Kubernetes generally leverages standard RESTful terminology to describe the API concepts:

* A **resource type** is the name used in the URL (`pods`, `namespaces`, `services`)
* All resource types have a concrete representation in JSON (their object schema) which is called a **kind**
* A list of instances of a resource type is known as a **collection**
* A single instance of the resource type is called a **resource**
-->
<p>Kubernetes 一般会利用标准的 RESTful 术语来描述 API 概念：</p>
<ul>
<li><strong>资源类型（Resource Type）</strong> 是在 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li>
<li>所有资源类型都有具有一个 JSON 形式（其对象的模式定义）的具体表示，称作<strong>类别（Kind）</strong></li>
<li>某资源类型的实例的列表称作 <strong>集合（Collection）</strong></li>
<li>资源类型的单个实例被称作 <strong>资源（Resource）</strong></li>
</ul>
<!--
All resource types are either scoped by the cluster (`/apis/GROUP/VERSION/*`) or to a namespace (`/apis/GROUP/VERSION/namespaces/NAMESPACE/*`). A namespace-scoped resource type will be deleted when its namespace is deleted and access to that resource type is controlled by authorization checks on the namespace scope. The following paths are used to retrieve collections and resources:

* Cluster-scoped resources:
  * `GET /apis/GROUP/VERSION/RESOURCETYPE` - return the collection of resources of the resource type
  * `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME` - return the resource with NAME under the resource type
* Namespace-scoped resources:
  * `GET /apis/GROUP/VERSION/RESOURCETYPE` - return the collection of all instances of the resource type across all namespaces
  * `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE` - return collection of all instances of the resource type in NAMESPACE
  * `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME` - return the instance of the resource type with NAME in NAMESPACE
-->
<p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），要么是名字空间
作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，并且对该资源类型的
访问是由定义在名字空间域中的授权检查来控制的。
下列路径用来检视集合和资源：</p>
<ul>
<li>集群作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li>
</ul>
</li>
<li>名字空间作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li>
</ul>
</li>
</ul>
<!--
Since a namespace is a cluster-scoped resource type, you can retrieve the list of all namespaces with `GET /api/v1/namespaces` and details about a particular namespace with `GET /api/v1/namespaces/NAME`.

Almost all object resource types support the standard HTTP verbs - GET, POST, PUT, PATCH, and DELETE. Kubernetes uses the term **list** to describe returning a collection of resources to distinguish from retrieving a single resource which is usually called a **get**.
-->
<p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表，使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的
详细信息。</p>
<p>几乎所有对象资源类型都支持标准的 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 使用术语 <strong>list</strong> 来描述返回资源集合的操作，以便与返回单个资源的、
通常称作 <strong>get</strong> 的操作相区分。</p>
<!--
Some resource types will have one or more sub-resources, represented as sub paths below the resource:

* Cluster-scoped subresource: `GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE`
* Namespace-scoped subresource: `GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE`

The verbs supported for each subresource will differ depending on the object - see the API documentation more information. It is not possible to access sub-resources across multiple resources - generally a new virtual resource type would be used if that becomes necessary.
-->
<p>某些资源类型有一个或多个子资源（Sub-resource），表现为对应资源下面的子路径：</p>
<ul>
<li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
<li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
</ul>
<p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 API 文档以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种
新的虚拟资源类型了。</p>
<!--
## Efficient detection of changes

To enable clients to build a model of the current state of a cluster, all Kubernetes object resource types are required to support consistent lists and an incremental change notification feed called a **watch**.  Every Kubernetes object has a `resourceVersion` field representing the version of that resource as stored in the underlying database. When retrieving a collection of resources (either namespace or cluster scoped), the response from the server will contain a `resourceVersion` value that can be used to initiate a watch against the server. The server will return all changes (creates, deletes, and updates) that occur after the supplied `resourceVersion`. This allows a client to fetch the current state and then watch for changes without missing any updates. If the client watch is disconnected they can restart a new watch from the last returned `resourceVersion`, or perform a new collection request and begin again. See [Resource Version Semantics](#resource-versions) for more detail.

For example:
-->
<h2 id="efficient-detection-of-changes">高效检测变更 </h2>
<p>为了使客户端能够构造一个模型来表达集群的当前状态，所有 Kubernetes 对象资源类型
都需要支持一致的列表和一个称作 <strong>watch</strong> 的增量变更通知信源（feed）。
每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，代表该资源在下层数据库中
存储的版本。检视资源集合（名字空间作用域或集群作用域）时，服务器返回的响应
中会包含 <code>resourceVersion</code> 值，可用来向服务器发起 watch 请求。
服务器会返回所提供的 <code>resourceVersion</code> 之后发生的所有变更（创建、删除和更新）。
这使得客户端能够取回当前的状态并监视其变更，且不会错过任何变更事件。
客户端的监视连接被断开时，可以从最后返回的 <code>resourceVersion</code> 重启新的监视连接，
或者执行一个新的集合请求之后从头开始监视操作。
参阅<a href="#resource-versions">资源版本语义</a>以了解更多细节。</p>
<p>例如：</p>
<!--
1. List all of the pods in a given namespace.
-->
<ol>
<li>
<p>列举给定名字空间中的所有 Pods：</p>
<pre><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}
</code></pre></li>
</ol>
<!--
2. Starting from resource version 10245, receive notifications of any creates, deletes, or updates as individual JSON objects.
-->
<ol start="2">
<li>
<p>从资源版本 10245 开始，以 JSON 对象的形式接收所有创建、删除或更新操作的通知：</p>
<pre><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
{
  &quot;type&quot;: &quot;MODIFIED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;11020&quot;, ...}, ...}
}
...
</code></pre></li>
</ol>
<!--
A given Kubernetes server will only preserve a historical list of changes for a limited time. Clusters using etcd3 preserve changes in the last 5 minutes by default.  When the requested watch operations fail because the historical version of that resource is not available, clients must handle the case by recognizing the status code `410 Gone`, clearing their local cache, performing a list operation, and starting the watch from the `resourceVersion` returned by that new list operation. Most client libraries offer some form of standard tool for this logic. (In Go this is called a `Reflector` and is located in the `k8s.io/client-go/cache` package.)
-->
<p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 watch 操作因为资源的历史版本不存在而失败，客户端必须能够处理
因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，重新执行 list 操作，
并基于新的 list 操作所返回的 <code>resourceVersion</code> 来开始新的 watch 操作。
大多数客户端库都能够提供某种形式的、包含此逻辑的工具。
（在 Go 语言客户端库中，这一设施称作 <code>Reflector</code>，位于
<code>k8s.io/client-go/cache</code> 包中。)</p>
<!--
### Watch bookmarks

To mitigate the impact of short history window, we introduced a concept of `bookmark` watch event. It is a special kind of event to mark that all changes up to a given `resourceVersion` the client is requesting have already been sent. Object returned in that event is of the type requested by the request, but only `resourceVersion` field is set, e.g.:
-->
<h3 id="Watch-bookmark">监视书签 </h3>
<p>为了处理历史窗口过短的问题，我们引入了 <code>bookmark（书签）</code> 监视事件的概念。
该事件是一种特殊事件，用来标示客户端所请求的、指定的 <code>resourceVersion</code> 之前
的所有变更都以被发送。该事件中返回的对象是所请求的资源类型，但其中仅包含
<code>resourceVersion</code> 字段，例如：</p>
<pre><code class="language-console" data-lang="console">GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
...
{
  &quot;type&quot;: &quot;BOOKMARK&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;12746&quot;} }
}
</code></pre><!--
`Bookmark` events can be requested by `allowWatchBookmarks=true` option in watch requests, but clients shouldn't assume bookmarks are returned at any specific interval, nor may they assume the server will send any `bookmark` event.
-->
<p>通过在 watch 请求中设置 <code>allowWatchBookmarks=true</code> 选项，可以请求 <code>bookmark</code>
事件，但是客户端不能假定服务器端会按某特定时间间隔返回书签事件，甚至也不能
假定服务器一定会发送 <code>bookmark</code> 事件。</p>
<!--
## Retrieving large results sets in chunks
-->
<h2 id="retrieving-large-results-sets-in-chunks">分块检视大体量结果 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code>
</div>


<!--
On large clusters, retrieving the collection of some resource types may result in very large responses that can impact the server and client. For instance, a cluster may have tens of thousands of pods, each of which is 1-2kb of encoded JSON. Retrieving all pods across all namespaces may result in a very large response (10-20MB) and consume a large amount of server resources. Starting in Kubernetes 1.9 the server supports the ability to break a single large collection request into many smaller chunks while preserving the consistency of the total request. Each chunk can be returned sequentially which reduces both the total size of the request and allows user-oriented clients to display results incrementally to improve responsiveness.
-->
<p>在较大规模的集群中，检视某些资源类型的集合时可能会返回较大体量的响应数据，对
服务器和客户端都会造成影响。例如，某集群可能包含数万个 Pod，每个 Pod 的 JSON
编码都有 1-2 KB 的大小。返回所有名字空间的全部 Pod 时，其结果可能体量很大
（10-20 MB）且耗用大量的服务器资源。
从 Kubernetes 1.9 开始，服务器支持将单一的大体量集合请求分解成多个小数据块
同时还保证整个请求的一致性的能力。
各个数据块可以按顺序返回，进而降低请求的尺寸，允许面向用户的客户端以增量形式
呈现返回结果，改进系统响应效果。</p>
<!--
To retrieve a single list in chunks, two new parameters `limit` and `continue`
are supported on collection requests and a new field `continue` is returned
from all list operations in the list `metadata` field. A client should specify
the maximum results they wish to receive in each chunk with `limit` and the
server will return up to `limit` resources in the result and include a
`continue` value if there are more resources in the collection. The client can
then pass this `continue` value to the server on the next request to instruct
the server to return the next chunk of results. By continuing until the server
returns an empty `continue` value the client can consume the full set of
results.
-->
<p>为了用分块的形式返回一个列表，集合请求上可以设置两个新的参数 <code>limit</code> 和
<code>continue</code>，并且所有 list 操作的返回结果列表的 <code>metadata</code> 字段中会包含一个
新的 <code>continue</code> 字段。
客户端应该将 <code>limit</code> 设置为希望在每个数据块中收到的结果个数上限，而服务器则
会在结果中至多返回 <code>limit</code> 个资源并在集合中还有更多资源的时候包含一个
<code>continue</code> 值。客户端在下次请求时则可以将此 <code>continue</code> 值传递给服务器，
告知后者要从何处开始返回结果的下一个数据块。
通过重复这一操作直到服务器端返回空的 <code>continue</code> 值，客户端可以受到结果的
全集。</p>
<!--
Like a watch operation, a `continue` token will expire after a short amount of time (by default 5 minutes) and return a `410 Gone` if more results cannot be returned. In this case, the client will need to start from the beginning or omit the `limit` parameter.

For example, if there are 1,253 pods on the cluster and the client wants to receive chunks of 500 pods at a time, they would request those chunks as follows:
-->
<p>与 watch 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p>
<p>例如，如果集群上有 1253 个 Pods，客户端希望每次收到包含至多 500 个 Pod 的
数据块，它应按下面的步骤来请求数据块：</p>
<!--
1. List all of the pods on a cluster, retrieving up to 500 pods each time.
-->
<ol>
<li>列举集群中所有 Pod，每次接收至多 500 个 Pods：</li>
</ol>
<pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 1-500
}
</code></pre><!--
2. Continue the previous call, retrieving the next set of 500 pods.
-->
<ol start="2">
<li>继续前面的调用，返回下一组 500 个 Pods：</li>
</ol>
<pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN_2&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 501-1000
}
</code></pre><!--
3. Continue the previous call, retrieving the last 253 pods.
-->
<ol start="3">
<li>继续前面的调用，返回最后 253 个 Pods：</li>
</ol>
<pre><code class="language-console" data-lang="console">GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;&quot;, // continue token is empty because we have reached the end of the list
    ...
  },
  &quot;items&quot;: [...] // returns pods 1001-1253
}
</code></pre><!--
Note that the `resourceVersion` of the list remains constant across each request, indicating the server is showing us a consistent snapshot of the pods. Pods that are created, updated, or deleted after version `10245` would not be shown unless the user makes a list request without the `continue` token.  This allows clients to break large requests into smaller chunks and then perform a watch operation on the full set without missing any updates.
-->
<p>注意 list 操作的 <code>resourceVersion</code> 在每个请求中都设置的是同一个数值，
这表明服务器要向我们展示一个一致的 Pods 快照视图。
在版本 <code>10245</code> 之后创建、更新或删除的 Pods 都不会显示出来，除非用户发出
list 请求时不指定 <code>continue</code> 令牌。
这一设计使得客户端能够将较大的响应切分为较小的数据块，且能够对较大的集合
执行监视动作而不会错失任何更新事件。</p>
<!--
## Receiving resources as Tables

The output from the `kubectl get` command is a simple tabular representation of one or more instances of a particular resource type. In the past, clients were required to reproduce the tabular and describe output implemented in `kubectl` to perform simple lists of objects.
A few limitations of that approach include non-trivial logic when dealing with certain objects. Additionally, types provided by API aggregation or third party resources are not known at compile time. This means that generic implementations had to be in place for types unrecognized by a client.
-->
<h2 id="receiving-resources-as-tables">以表格形式接收资源 </h2>
<p><code>kubectl get</code> 命令的输出是一个包含一个或多个资源的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行
简单的对象列表操作。
这一方法在处理某些对象时，需要引入不容忽视的逻辑。
此外，<a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API 聚合</a>
和<a href="/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/">定制资源</a>
所提供的资源类型都是编译时不可预知的。这意味着，客户端必须针对无法
识别的类型提供通用的实现逻辑。</p>
<!--
In order to avoid potential limitations as described above, clients may request the Table representation of objects, delegating specific details of printing to the server. The Kubernetes API implements standard HTTP content type negotiation: passing an `Accept` header containing a value of `application/json;as=Table;g=meta.k8s.io;v=v1beta1` with a `GET` call will request that the server return objects in the Table content type.

For example:
-->
<p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code> 调用
传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1beta1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p>
<p>例如，以 Table 格式列举集群中所有 Pods：</p>
<pre><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
---
200 OK
Content-Type: application/json

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        ...
    ]
}
</code></pre><!--
For API resource types that do not have a custom Table definition on the
server, a default Table response is returned by the server, consisting of the
resource's `name` and `creationTimestamp` fields.
-->
<p>对于在服务器上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回
一个默认的 Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p>
<pre><code class="language-console" data-lang="console">GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;Name&quot;,
            &quot;type&quot;: &quot;string&quot;,
            ...
        },
        {
            &quot;name&quot;: &quot;Created At&quot;,
            &quot;type&quot;: &quot;date&quot;,
            ...
        }
    ]
}
</code></pre><!--
Table responses are available beginning in version 1.10 of the kube-apiserver.
As such, not all API resource types will support a Table response,
specifically when using a client against older clusters. Clients that must
work against all resource types, or can potentially deal with older clusters,
should specify multiple content types in their `Accept` header to support
fallback to non-Tabular JSON:
-->
<p><code>kube-apiserver</code> 从 1.10 版本开始提供 Table 响应。
因此，并非所有 API 资源类型都支持 Table 响应，尤其是使用客户端访问较老的集群时。
如果客户端需要能够处理所有资源类型，或者有可能需要与较老的集群交互，
则需要在其 <code>Accept</code> 头部设定多个内容类型值，以便可以回退到非表格形式的 JSON
表示。</p>
<pre><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json
</code></pre><!--
## Alternate representations of resources

By default, Kubernetes returns objects serialized to JSON with content type `application/json`. This is the default serialization format for the API. However, clients may request the more efficient Protobuf representation of these objects for better performance at scale. The Kubernetes API implements standard HTTP content type negotiation: passing an `Accept` header with a `GET` call will request that the server return objects in the provided content type, while sending an object in Protobuf to the server for a `PUT` or `POST` call takes the `Content-Type` header. The server will return a `Content-Type` header if the requested format is supported, or the `406 Not acceptable` error if an invalid content type is provided.

See the API documentation for a list of supported content types for each API.

For example:
-->
<h2 id="alternate-representations-of-resources">资源的其他表示形式 </h2>
<p>默认情况下，Kubernetes 返回 JSON 序列化的的对象并设定内容类型为
<code>application/json</code>。这是 API 的默认序列化格式。
不过，客户端也可出于大规模环境中更佳性能的需求而请求对象的更为高效的 Protobuf
表现形式。
Kubernetes API 实现了标准的 HTTP 内容类型协商：为 <code>GET</code> 调用传递一个 <code>Accept</code>
头部来请求服务器以所指定的内容类型返回对象，同时在通过 <code>PUT</code> 或 <code>POST</code> 调用
向服务器发送 Protobuf 格式的对象时提供 <code>Content-Type</code> 头部。
服务器会能够支持所请求的格式时返回 <code>Content-Type</code> 头部，并在所提供的内容类型
不合法时返回 <code>406 Not acceptable（无法接受）</code> 错误。</p>
<p>请参阅 API 文档了解每个 API 所支持的内容类型。</p>
<p>例如：</p>
<!--
1. List all of the pods on a cluster in Protobuf format.
-->
<ol>
<li>以 Protobuf 格式列举集群上的所有 Pods：</li>
</ol>
<pre><code class="language-console" data-lang="console">GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre><!--
2. Create a pod by sending Protobuf encoded data to the server, but request a response in JSON.
-->
<ol start="2">
<li>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</li>
</ol>
<pre><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;Pod&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  ...
}
</code></pre><!--
Not all API resource types will support Protobuf, specifically those defined
via Custom Resource Definitions or those that are API extensions. Clients that
must work against all resource types should specify multiple content types in
their `Accept` header to support fallback to JSON:
-->
<p>并非所有 API 资源类型都支持 Protobuf，尤其是那些通过定制资源定义（CRD）或通过
API 扩展而加入的资源。如果客户端必须能够处理所有资源类型，则应在其 <code>Accept</code>
头部指定多种内容类型以便可以回退到 JSON 格式：</p>
<pre><code class="language-console" data-lang="console">Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre><!--
### Protobuf encoding

Kubernetes uses an envelope wrapper to encode Protobuf responses. That wrapper starts with a 4 byte magic number to help identify content in disk or in etcd as Protobuf (as opposed to JSON), and then is followed by a Protobuf encoded wrapper message, which describes the encoding and type of the underlying object and then contains the object.

The wrapper format is:
-->
<h3 id="protobuf-encoding">Protobuf encoding</h3>
<p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p>
<p>封套格式如下：</p>
<!--
```console
A four byte magic number prefix:
  Bytes 0-3: "k8s\x00" [0x6b, 0x38, 0x73, 0x00]

An encoded Protobuf message with the following IDL:
  message Unknown {
    // typeMeta should have the string values for "kind" and "apiVersion" as set on the JSON object
    optional TypeMeta typeMeta = 1;

    // raw will hold the complete serialized object in protobuf. See the protobuf definitions in the client libraries for a given kind.
    optional bytes raw = 2;

    // contentEncoding is encoding used for the raw data. Unspecified means no encoding.
    optional string contentEncoding = 3;

    // contentType is the serialization method used to serialize 'raw'. Unspecified means application/vnd.kubernetes.protobuf and is usually
    // omitted.
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion is the group/version for this type
    optional string apiVersion = 1;
    // kind is the name of the object schema. A protobuf definition should exist for this object.
    optional string kind = 2;
  }
```
-->
<pre><code class="language-console" data-lang="console">四个字节的特殊数字前缀：
  字节 0-3: &quot;k8s\x00&quot; [0x6b, 0x38, 0x73, 0x00]

使用下面 IDL 来编码的 Protobuf 消息：
  message Unknown {
    // typeMeta 应该包含 &quot;kind&quot; 和 &quot;apiVersion&quot; 的字符串值，就像
    // 对应的 JSON 对象中所设置的那样
    optional TypeMeta typeMeta = 1;

    // raw 中将保存用 protobuf 序列化的完整对象。
    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
    optional bytes raw = 2;

    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
    optional string contentEncoding = 3;

    // contentType 包含 raw 数据所采用的序列化方法。
    // 未设置此值意味着  application/vnd.kubernetes.protobuf，且通常被忽略
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion 是 type 对应的组名/版本
    optional string apiVersion = 1;
    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
    optional string kind = 2;
  }
</code></pre><!--
Clients that receive a response in `application/vnd.kubernetes.protobuf` that does not match the expected prefix should reject the response, as future versions may need to alter the serialization format in an incompatible way and will do so by changing the prefix.
-->
<p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀
不匹配时应该拒绝响应，因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</p>
<!--
## Resource deletion

Resources are deleted in two phases: 1) finalization, and 2) removal.
-->
<h2 id="resource-deletion">资源删除 </h2>
<p>资源删除要经过两个阶段：1) 终止（finalization），和 2）去除。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;ConfigMap&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;v1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;metadata&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;finalizers&#34;</span>: {<span style="color:#008000;font-weight:bold">&#34;url.io/neat-finalization&#34;</span>, <span style="color:#008000;font-weight:bold">&#34;other-url.io/my-finalizer&#34;</span>},
    <span style="color:#008000;font-weight:bold">&#34;deletionTimestamp&#34;</span>: <span style="">nil</span>,
  }
}
</code></pre></div><!--
When a client first deletes a resource, the `.metadata.deletionTimestamp` is
set to the current time.  Once the `.metadata.deletionTimestamp` is set,
external controllers that act on finalizers may start performing their cleanup
work at any time, in any order.  Order is NOT enforced because it introduces
significant risk of stuck `.metadata.finalizers`.  `.metadata.finalizers` is a
shared field, any actor with permission can reorder it.  If the finalizer list
is processed in order, then this can lead to a situation in which the
component responsible for the first finalizer in the list is waiting for a
signal (field value, external system, or other) produced by a component
responsible for a finalizer later in the list, resulting in a deadlock.
Without enforced ordering finalizers are free to order amongst themselves and
are not vulnerable to ordering changes in the list.

Once the last finalizer is removed, the resource is actually removed from
etcd.
-->
<p>当客户端首先删除某资源时，其 <code>.metadata.deletionTimestamp</code> 会被设置为当前时间。
一旦 <code>.metadata.deletionTimestamp</code> 被设置，则对终结器（finalizers）执行动作
的外部控制器就可以在任何时候、以任何顺序执行其清理工作。
这里不强调顺序是因为很可能带来 <code>.metadata.finalizers</code> 被锁定的风险。
<code>.metadata.finalizers</code> 是一个共享的字段，任何具有相关权限的主体都可以对其
执行重排序的操作。如果终结器列表要按顺序处理，则很可能导致负责列表中第一个
终结器的组件要等待负责列表中排序靠后的终结器的组件的信号（可能是字段值变更、
外部系统或者其他形式），从而导致死锁行为。
在不对终结器顺序作强制要求的情况下，终结器可以自行排序，且不会因为其在列表
中的顺序而引入任何不稳定因素。</p>
<p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p>
<!--
## Single resource API

API verbs GET, CREATE, UPDATE, PATCH, DELETE and PROXY support single resources only.
These verbs with single resource support have no support for submitting
multiple resources together in an ordered or unordered list or transaction.
Clients including kubectl will parse a list of resources and make
single-resource API requests.

API verbs LIST and WATCH support getting multiple resources, and
DELETECOLLECTION supports deleting multiple resources.
-->
<h2 id="single-resource-api">单个资源 API </h2>
<p>API 动词 GET、CREATE、UPDATE、PATCH、DELETE 和 PROXY 仅支持单个资源。
这些支持单一资源的动词不支持以有序或无序列表甚或事务的形式同时提交给
多个资源。
包括 kubectl 在内的客户端将解析资源的列表，并执行单一资源的 API 请求。</p>
<p>API 动词 LIST 和 WATCH 支持获取多个资源，而 DELETECOLLECTION 支持删除多个
资源。</p>
<!--
## Dry-run
-->
<h2 id="dry-run">试运行 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>


<!--
The modifying verbs (`POST`, `PUT`, `PATCH`, and `DELETE`) can accept requests in a _dry run_ mode. Dry run mode helps to evaluate a request through the typical request stages (admission chain, validation, merge conflicts) up until persisting objects to storage. The response body for the request is as close as possible to a non-dry-run response. The system guarantees that dry-run requests will not be persisted in storage or have any other side effects.
-->
<p>修改性质的动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）可以支持 <em>试运行（dry
run）</em> 模式的请求。试运行模式可帮助通过典型的请求阶段（准入控制链、合法性
检查、合并冲突）来评估请求，只是最终的对象不会写入存储。请求的响应主体与
非试运行模式下的响应尽可能接近。系统会保证试运行模式的请求不会被写入到存储
中，也不会产生其他副作用。</p>
<!--
### Make a dry-run request

Dry-run is triggered by setting the `dryRun` query parameter. This parameter is a string, working as an enum, and the only accepted values are:

* `All`: Every stage runs as normal, except for the final storage stage. Admission controllers are run to check that the request is valid, mutating controllers mutate the request, merge is performed on `PATCH`, fields are defaulted, and schema validation occurs. The changes are not persisted to the underlying storage, but the final object which would have been persisted is still returned to the user, along with the normal status code. If the request would trigger an admission controller which would have side effects, the request will be failed rather than risk an unwanted side effect. All built in admission control plugins support dry-run. Additionally, admission webhooks can declare in their [configuration object](/docs/reference/generated/kubernetes-api/v1.23/#webhook-v1beta1-admissionregistration-k8s-io) that they do not have side effects by setting the sideEffects field to "None". If a webhook actually does have side effects, then the sideEffects field should be set to "NoneOnDryRun", and the webhook should also be modified to understand the `DryRun` field in AdmissionReview, and prevent side effects on dry-run requests.
* Leave the value empty, which is also the default: Keep the default modifying behavior.

For example:
-->
<h3 id="make-a-dry-run-request">发起试运行请求 </h3>
<p>通过设置 <code>dryRun</code> 查询参数可以触发试运行模式。此参数是一个字符串，以枚举值
的形式工作且可接受的值只有：</p>
<ul>
<li>
<p><code>All</code>：每个阶段被会正常运行，除了最后的存储阶段。准入控制器会被运行来检查请求
是否合法，变更性（Mutating）控制器会变更请求，<code>PATCH</code> 请求也会触发合并操作，
对象字段的默认值也会被设置，且基于模式定义的合法性检查也会被执行。
所生成的变更不会被写入到下层的持久性存储中，但本来会写入到数据库中的最终对象
会和正常的状态代码一起被返回给用户。如果请求会触发准入控制器而该准入控制器
带有一定的副作用，则请求会失败而不是冒险产生不希望的副作用。
所有的内置准入控制器插件都支持试运行模式。此外，准入控制 Webhook 也可在其
<a href="/docs/reference/generated/kubernetes-api/v1.23/#webhook-v1beta1-admissionregistration-k8s-io">配置对象</a>
中通过将 <code>sideEffects</code> 字段设置为 &quot;None&quot; 来声明自身不会产生副作用。
如果某 Webhook 确实会产生副作用，那么 <code>sideEffects</code> 字段应该设置为 &quot;NoneOnDryRun&quot;，
并且 Webhook 应该被更改以支持 AdmissionReview 中的 <code>dryRun</code> 字段，从而避免
在试运行时产生副作用。</p>
</li>
<li>
<p>空字符串（也即默认值）：保留默认的修改行为。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-console" data-lang="console">POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre><!--
The response would look the same as for non-dry-run request, but the values of some generated fields may differ.
-->
<p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p>
<!--
### Dry-run authorization

Authorization for dry-run and non-dry-run requests is identical. Thus, to make
a dry-run request, the user must be authorized to make the non-dry-run request.

For example, to run a dry-run `PATCH` for Deployments, you must have the
`PATCH` permission for Deployments, as in the example of the RBAC rule below.
-->
<h3 id="dry-run-authorization">试运行的授权   </h3>
<p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，用户必须
被授权执行非试运行请求。</p>
<p>例如，要在 Deployment 对象上试运行 <code>PATCH</code> 操作，你必须具有对 Deployment 执行
<code>PATCH</code> 操作的访问权限，如下面的 RBAC 规则所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">apiGroups</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;extensions&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;apps&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;deployments&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">verbs</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;patch&#34;</span>]<span style="color:#bbb">
</span></code></pre></div><!--
See [Authorization Overview](/docs/reference/access-authn-authz/authorization/).
-->
<p>参阅<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权概述</a>以了解鉴权细节。</p>
<!--
### Generated values

Some values of an object are typically generated before the object is persisted. It is important not to rely upon the values of these fields set by a dry-run request, since these values will likely be different in dry-run mode from when the real request is made. Some of these fields are:

* `name`: if `generateName` is set, `name` will have a unique random name
* `creationTimestamp`/`deletionTimestamp`: records the time of creation/deletion
* `UID`: uniquely identifies the object and is randomly generated (non-deterministic)
* `resourceVersion`: tracks the persisted version of the object
* Any field set by a mutating admission controller
* For the `Service` resource: Ports or IPs that kube-apiserver assigns to v1.Service objects
-->
<h3 id="generated-values">生成的值 </h3>
<p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行
请求为这些字段所设置的值，因为试运行模式下所得到的这些值与真实请求所获得的
值很可能不同。这类字段有：</p>
<ul>
<li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li>
<li><code>creationTimestamp</code>/<code>deletionTimestamp</code>：记录对象的创建/删除时间</li>
<li><code>UID</code>：唯一性标识对象，取值随机生成（非确定性）</li>
<li><code>resourceVersion</code>： 跟踪对象的持久化（存储）版本</li>
<li>变更性准入控制器所设置的字段</li>
<li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>v1.Service</code> 对象分配的端口和 IP</li>
</ul>
<!--
## Server Side Apply
-->
<h2 id="server-side-apply">服务器端应用 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>


<!--
Starting from Kubernetes v1.18, you can enable the
[Server Side Apply](/docs/reference/using-api/server-side-apply/)
feature so that the control plane tracks managed fields for all newly created objects.
Server Side Apply provides a clear pattern for managing field conflicts,
offers server-side `Apply` and `Update` operations, and replaces the
client-side functionality of `kubectl apply`. For more details about this
feature, see the section on
[Server Side Apply](/docs/reference/using-api/server-side-apply/).
-->
<p>从 Kubernetes v1.18 开始，可以启用<a href="/zh/docs/reference/using-api/server-side-apply/">服务器端应用</a>功能
特性，启用该特性后，控制面会跟踪所有新创建的对象的托管字段。服务器端应用提供了一种简洁的模式来管理字段冲突，提供服务器端的 <code>Apply</code> 和 <code>Update</code> 操作，并取代了
<code>kubectl apply</code> 的客户端功能。有关该特性的详细描述，请参见<a href="/zh/docs/reference/using-api/server-side-apply/">服务器端应用</a>章节</p>
<!--
## Resource Versions

Resource versions are strings that identify the server's internal version of an object. Resource versions can be used by clients to determine when objects have changed, or to express data consistency requirements when getting, listing and watching resources. Resource versions must be treated as opaque by clients and passed unmodified back to the server. For example, clients must not assume resource versions are numeric, and may only compare two resource version for equality (i.e. must not compare resource versions for greater-than or less-than relationships).
-->
<h2 id="resource-versions">资源版本  </h2>
<p>资源版本采用字符串来表达，用来标示对象的服务器端内部版本。
客户端可以使用资源版本来判定对象是否被更改，或者在读取、列举或监视资源时
用来表达数据一致性需求。
客户端必需将资源版本视为不透明的对象，将其原封不动地传递回服务器端。
例如，客户端一定不能假定资源版本是某种数值标识，也不可以对两个资源版本值
进行比较看其是否相同（也就是不可以比较两个版本值以判断其中一个比另一个
大或小）。</p>
<!--
### ResourceVersion in metadata

Clients find resource versions in resources, including the resources in watch events, and list responses returned from the server:

[v1.meta/ObjectMeta](/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta) - The `metadata.resourceVersion` of a resource instance identifies the resource version the instance was last modified at.

[v1.meta/ListMeta](/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta) - The `metadata.resourceVersion` of a resource collection (i.e. a list response) identifies the resource version at which the list response was constructed.
-->
<h3 id="resourceVersion-in-metadata"><code>metadata</code> 中的 <code>resourceVersion</code> </h3>
<p>客户端可以在资源中看到资源版本信息，这里的资源包括从服务器返回的 Watch 事件
以及 list 操作响应：</p>
<p><a href="/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta">v1.meta/ObjectMeta</a> - 资源
的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p>
<p><a href="/docs/reference/generated/kubernetes-api/v1.23/#listmeta-v1-meta">v1.meta/ListMeta</a> - 资源集合
（即 list 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造
时的资源版本。</p>
<!--
### The ResourceVersion Parameter

The get, list and watch operations support the `resourceVersion` parameter.

The exact meaning of this parameter differs depending on the operation and the value of `resourceVersion`.

For get and list, the semantics of resource version are:

**Get:**
-->
<h3 id="the-resourceversion-parameter"><code>resourceVersion</code> 参数  </h3>
<p>GET、LIST 和 WATCH 操作都支持 <code>resourceVersion</code> 参数。</p>
<p>参数的具体含义取决于所执行的操作和所给的 <code>resourceVersion</code> 值：</p>
<p>对于 GET 和 LIST 而言，资源版本的语义为：</p>
<p><strong>GET：</strong></p>
<!--
| resourceVersion unset | resourceVersion="0" | resourceVersion="{value other than 0}" |
|------------------------|---------------------|----------------------------------------|
| Most Recent           | Any                 | Not older than                         |
-->
<table>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新版本</td>
<td>任何版本</td>
<td>不老于给定版本</td>
</tr>
</tbody>
</table>
<p><strong>LIST：</strong></p>
<!--
v1.19+ API servers and newer support the `resourceVersionMatch` parameter, which
determines how resourceVersion is applied to list calls.  It is highly
recommended that `resourceVersionMatch` be set for list calls where
`resourceVersion` is set. If `resourceVersion` is unset, `resourceVersionMatch`
is not allowed.  For backward compatibility, clients must tolerate the server
ignoring `resourceVersionMatch`:
-->
<p>v1.19 及以上版本的 API 服务器支持 <code>resourceVersionMatch</code> 参数，用以确定如何对
LIST 调用应用 resourceVersion 值。
强烈建议在为 LIST 调用设置了 <code>resourceVersion</code> 时也设置 <code>resourceVersionMatch</code>。
如果 <code>resourceVersion</code> 未设置，则 <code>resourceVersionMatch</code> 是不允许设置的。
为了向后兼容，客户端必须能够容忍服务器在某些场景下忽略 <code>resourceVersionMatch</code> 的行为：</p>
<!--
- When using `resourceVersionMatch=NotOlderThan` and limit is set, clients must
  handle HTTP 410 "Gone" responses. For example, the client might retry with a
  newer `resourceVersion` or fall back to `resourceVersion=""`.

- When using `resourceVersionMatch=Exact` and `limit` is unset, clients must
  verify that the `resourceVersion` in the `ListMeta` of the response matches
  the requested `resourceVersion`, and handle the case where it does not. For
  example, the client might fall back to a request with `limit` set.
-->
<ul>
<li>
<p>当设置 <code>resourceVersionMatch=NotOlderThan</code> 且指定了 <code>limit</code> 时，客户端必须能够
处理 HTTP 410 &quot;Gone&quot; 响应。例如，客户端可以使用更新一点的 <code>resourceVersion</code>
来重试，或者回退到 <code>resourceVersion=&quot;&quot;</code> （即允许返回任何版本）。</p>
</li>
<li>
<p>当设置了 <code>resourceVersionMatch=Exact</code> 且未指定 <code>limit</code> 时，客户端必须验证
响应数据中 <code>ListMeta</code> 的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code> 匹配，
并处理二者可能不匹配的情况。例如，客户端可以重试设置了 <code>limit</code> 的请求。</p>
</li>
</ul>
<!--
Unless you have strong consistency requirements, using `resourceVersionMatch=NotOlderThan` and
a known `resourceVersion` is preferable since it can achieve better performance and scalability
of your cluster than leaving `resourceVersion` and `resourceVersionMatch` unset, which requires
quorum read to be served.
-->
<p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的
集群性能和可扩缩性。后者需要提供带票选能力的读操作。</p>
<!--
{{< table caption="resourceVersionMatch and paging parameters for list" >}}

| resourceVersionMatch param            | paging params                 | resourceVersion unset | resourceVersion="0"                       | resourceVersion="{value other than 0}" |
|---------------------------------------|-------------------------------|-----------------------|-------------------------------------------|----------------------------------------|
| resourceVersionMatch unset            | limit unset                   | Most Recent           | Any                                       | Not older than                         |
| resourceVersionMatch unset            | limit=\<n\>, continue unset     | Most Recent           | Any                                       | Exact                                  |
| resourceVersionMatch unset            | limit=\<n\>, continue=\<token\> | Continue Token, Exact | Invalid, treated as Continue Token, Exact | Invalid, HTTP `400 Bad Request`        |
| resourceVersionMatch=Exact [1]        | limit unset                   | Invalid               | Invalid                                   | Exact                                  |
| resourceVersionMatch=Exact [1]        | limit=\<n\>, continue unset     | Invalid               | Invalid                                   | Exact                                  |
| resourceVersionMatch=NotOlderThan [1] | limit unset                   | Invalid               | Any                                       | Not older than                         |
| resourceVersionMatch=NotOlderThan [1] | limit=\<n\>, continue unset     | Invalid               | Any                                       | Not older than                         |

{{< /table >}}

**Footnotes:**

[1] If the server does not honor the `resourceVersionMatch` parameter, it is treated as if it is unset.
-->





<table><caption style="display: none;">list 操作的 resourceVersionMatch 与分页参数</caption>
<thead>
<tr>
<th>resourceVersionMatch 参数</th>
<th>分页参数</th>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n&gt;, continue=&lt;token&gt;</td>
<td>从 token 开始、精确匹配</td>
<td>非法请求，视为从 token 开始、精确匹配</td>
<td>非法请求，返回 HTTP <code>400 Bad Request</code></td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit=&lt;n&gt;, continue 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
</tbody>
</table>

<p><strong>脚注：</strong></p>
<p>[1] 如果服务器无法正确处理 <code>resourceVersionMatch</code> 参数，其行为与未设置该参数相同。
</small></p>
<!--
The meaning of the get and list semantics are:

- **Most Recent:** Return data at the most recent resource version. The returned data must be
  consistent (i.e. served from etcd via a quorum read).
- **Any:** Return data at any resource version. The newest available resource version is preferred,
  but strong consistency is not required; data at any resource version may be served. It is possible
  for the request to return data at a much older resource version that the client has previously
  observed, particularly in high availability configurations, due to partitions or stale
  caches. Clients that cannot tolerate this should not use this semantic.
-->
<p>GET 和 LIST 操作的语义含义如下：</p>
<ul>
<li><strong>最新版本：</strong> 返回资源版本为最新的数据。所返回的数据必须一致
（通过票选读操作从 etcd 中取出）。</li>
<li><strong>任意版本：</strong> 返回任意资源版本的数据。优选最新可用的资源版本，不过不能保证
强一致性；返回的数据可能是任何资源版本的。请求返回的数据有可能是客户端以前
看到过的很老的资源版本。尤其在某些高可用配置环境中，网络分区或者高速缓存
未被更新等状态都可能导致这种状况。不能容忍这种不一致性的客户端不应采用此
语义。</li>
</ul>
<!--
- **Not older than:** Return data at least as new as the provided resourceVersion. The newest
  available data is preferred, but any data not older than the provided resourceVersion may be
  served.  For list requests to servers that honor the resourceVersionMatch parameter, this
  guarantees that resourceVersion in the ListMeta is not older than the requested resourceVersion,
  but does not make any guarantee about the resourceVersion in the ObjectMeta of the list items
  since ObjectMeta.resourceVersion tracks when an object was last updated, not how up-to-date the
  object is when served.
- **Exact:** Return data at the exact resource version provided. If the provided resourceVersion is
  unavailable, the server responds with HTTP 410 "Gone".  For list requests to servers that honor the
  resourceVersionMatch parameter, this guarantees that resourceVersion in the ListMeta is the same as
  the requested resourceVersion, but does not make any guarantee about the resourceVersion in the
  ObjectMeta of the list items since ObjectMeta.resourceVersion tracks when an object was last
  updated, not how up-to-date the object is when served.
- **Continue Token, Exact:** Return data at the resource version of the initial paginated list
  call. The returned Continue Tokens are responsible for keeping track of the initially provided
  resource version for all paginated list calls after the initial paginated list call.
-->
<ul>
<li>
<p><strong>不老于指定版本：</strong> 返回至少比所提供的 <code>resourceVersion</code> 还要新的数据。
优选最新的可用数据，不过最终提供的可能是不老于所给 <code>resourceVersion</code> 的任何版本。
对于发给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求，此语义
保证 <code>ListMeta</code> 中的 <code>resourceVersion</code> 不老于请求的 <code>resourceVersion</code>，不过
不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>确定版本：</strong> 返回精确匹配所给资源版本的数据。如果所指定的 resourceVersion
的数据不可用，服务器会响应 HTTP 410 &quot;Gone&quot;。
对于发送给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求而言，
此语义会保证 ListMeta 中的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code>
匹配， 不过不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>Continue 令牌、精确匹配：</strong> 返回原先带分页参数的 LIST 调用中指定的资源版本的数据。
在最初的带分页参数的 LIST 调用之后，所有分页式的 LIST 调用都使用所返回的 Continue
令牌来跟踪最初提供的资源版本，</p>
</li>
</ul>
<!--
For watch, the semantics of resource version are:
-->
<p>对于 WATCH 操作而言，资源版本的语义如下：</p>
<p><strong>WATCH：</strong></p>
<!--





<table><caption style="display: none;">resourceVersion for watch</caption>
<thead>
<tr>
<th>resourceVersion unset</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;{value other than 0}&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get State and Start at Most Recent</td>
<td>Get State and Start at Any</td>
<td>Start at Exact</td>
</tr>
</tbody>
</table>

-->





<table><caption style="display: none;">watch 操作的 resourceVersion 设置</caption>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion=&quot;0&quot;</th>
<th>resourceVersion=&quot;&lt;非零值&gt;&quot;</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取状态并从最新版本开始</td>
<td>读取状态并从任意版本开始</td>
<td>从指定版本开始</td>
</tr>
</tbody>
</table>

<!--
The meaning of the watch semantics are:

- **Get State and Start at Most Recent:** Start a watch at the most recent
  resource version, which must be consistent (i.e. served from etcd via a
  quorum read). To establish initial state, the watch begins with synthetic
  "Added" events of all resources instances that exist at the starting resource
  version. All following watch events are for all changes that occurred after
  the resource version the watch started at.
-->
<p>WATCH 操作语义的含义如下：</p>
<ul>
<li><strong>读取状态并从最新版本开始：</strong> 从最新的资源版本开始 WATCH 操作。这里的
最新版本必须是一致的（即通过票选读操作从 etcd 中取出）。为了建立初始状态，
WATCH 首先会处理一组合成的 &quot;Added&quot; 事件，这些事件涵盖在初始资源版本中存在
的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<!--
- **Get State and Start at Any:** Warning: Watches initialize this way may
  return arbitrarily stale data! Please review this semantic before using it,
  and favor the other semantics where possible. Start a watch at any resource
  version, the most recent resource version available is preferred, but not
  required; any starting resource version is allowed. It is possible for the
  watch to start at a much older resource version that the client has previously
  observed, particularly in high availability configurations, due to partitions
  or stale caches. Clients that cannot tolerate this should not start a watch
  with this semantic. To establish initial state, the watch begins with
  synthetic "Added" events for all resources instances that exist at the
  starting resource version. All following watch events are for all changes that
  occurred after the resource version the watch started at.
-->
<ul>
<li><strong>读取状态并从任意版本开始：</strong> 警告：通过这种方式初始化的 WATCH 操作可能会
返回任何状态的停滞数据。请在使用此语义之前执行复核，并在可能的情况下采用其他
语义。此语义会从任意资源版本开始执行 WATCH 操作，优选最新的可用的资源版本，
不过不是必须的；采用任何资源版本作为起始版本都是被允许的。
WATCH 操作有可能起始于客户端已经观测到的很老的版本。在高可用配置环境中，因为
网络分裂或者高速缓存未及时更新的原因都会造成此现象。
如果客户端不能容忍这种不一致性，就不要使用此语义来启动 WATCH 操作。
为了建立初始状态，WATCH 首先会处理一组合成的 &quot;Added&quot; 事件，这些事件涵盖在
初始资源版本中存在的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<!--
- **Start at Exact:** Start a watch at an exact resource version. The watch
  events are for all changes after the provided resource version. Unlike "Get
  State and Start at Most Recent" and "Get State and Start at Any", the watch is
  not started with synthetic "Added" events for the provided resource version.
  The client is assumed to already have the initial state at the starting
  resource version since the client provided the resource version.
-->
<ul>
<li><strong>从指定版本开始：</strong> 从某确切资源版本开始执行 WATCH 操作。WATCH 事件都是
关于 WATCH 开始时所处资源版本之后发生的变更。与前面两种语义不同，WATCH 操作
开始的时候不会生成或处理为所提供资源版本合成的 &quot;Added&quot; 事件。
我们假定客户端既然能够提供确切资源版本，就应该已经拥有了起始资源版本对应的初始状态。</li>
</ul>
<!--
### "410 Gone" responses

Servers are not required to serve all older resource versions and may return a
HTTP `410 (Gone)` status code if a client requests a resourceVersion older
than the server has retained. Clients must be able to tolerate `410 (Gone)`
responses. See [Efficient detection of
changes](#efficient-detection-of-changes) for details on how to handle `410
(Gone)` responses when watching resources.

If you request a a resourceVersion outside the applicable limit then,
depending on whether a request is served from cache or not, the API server may
reply with a `410 Gone` HTTP response.
-->
<h3 id="410-gone-responses">&quot;410 Gone&quot; 响应    </h3>
<p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href="#efficient-detection-of-changes">高效检测变更</a>以了解如何在监测资源时
处理 <code>410 (Gone)</code> 响应。</p>
<p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，那么取决于请求是否
是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p>
<!--
### Unavailable resource versions

Servers are not required to serve unrecognized resource versions. List and Get requests for unrecognized resource versions may wait briefly for the resource version to become available, should timeout with a `504 (Gateway Timeout)` if the provided resource versions does not become available in a reasonable amount of time, and may respond with a `Retry-After` response header indicating how many seconds a client should wait before retrying the request. Currently the kube-apiserver also identifies these responses with a "Too large resource version" message. Watch requests for a unrecognized resource version may wait indefinitely (until the request timeout) for the resource version to become available.
-->
<h3 id="unavailable-resource-versions">不可用的资源版本 </h3>
<p>服务器不必未无法识别的资源版本提供服务。针对无法识别的资源版本的 LIST 和 GET 请求
可能会短暂等待，以期资源版本可用。如果所给的资源版本在一定的时间段内仍未变得
可用，服务器应该超时并返回 <code>504 (Gateway Timeout)</code>，且可在响应中添加
<code>Retry-After</code> 响应头部字段，标明客户端在再次尝试之前应该等待多少秒钟。
目前，<code>kube-apiserver</code> 也能使用 <code>Too large resource version（资源版本过高）</code>
消息来标识这类响应。针对某无法识别的资源版本的 WATCH 操作可能会无限期
（直到请求超时）地等待下去，直到资源版本可用。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-040d9484db673074f1b8ba3465be9d91">2 - 服务器端应用（Server-Side Apply）</h1>
    
	<!--
title: Server-Side Apply
reviewers:
- smarterclayton
- apelisse
- lavalamp
- liggitt
content_type: concept
weight: 25
min-kubernetes-server-version: 1.16
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>


<!--
## Introduction

Server Side Apply helps users and controllers manage their resources through
declarative configurations. Clients can create and/or modify their
[objects](/docs/concepts/overview/working-with-objects/kubernetes-objects/)
declaratively by sending their fully specified intent.
-->
<h2 id="introduction">简介</h2>
<p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和/或修改
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/">对象</a>。</p>
<!--
A fully specified intent is a partial object that only includes the fields and
values for which the user has an opinion. That intent either creates a new
object or is [combined](#merge-strategy), by the server, with the existing object.

The system supports multiple appliers collaborating on a single object.
-->
<p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href="#merge-strategy">合并</a>。</p>
<p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p>
<!--
Changes to an object's fields are tracked through a "[field management](#field-management)"
mechanism. When a field's value changes, ownership moves from its current
manager to the manager making the change. When trying to apply an object,
fields that have a different value and are owned by another manager will
result in a [conflict](#conflicts). This is done in order to signal that the
operation might undo another collaborator's changes. Conflicts can be forced,
in which case the value will be overridden, and the ownership will be
transferred.
-->
<p>“<a href="#field-management">字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href="#conflicts">冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p>
<!--
If you remove a field from a configuration and apply the configuration, server
side apply checks if there are any other field managers that also own the
field.  If the field is not owned by any other field managers, it is either
deleted from the live object or reset to its default value, if it has one. The
same rule applies to associative list or map items.
-->
<p>当你从配置文件中删除一个字段，然后应用这个配置文件，
这将触发服务端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p>
<!--
Server side apply is meant both as a replacement for the original `kubectl
apply` and as a simpler mechanism for controllers to enact their changes.

If you have Server Side Apply enabled, the control plane tracks managed fields
for all newly created objects.
-->
<p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p>
<p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p>
<!--
## Field Management

Compared to the `last-applied` annotation managed by `kubectl`, Server Side
Apply uses a more declarative approach, which tracks a user's field management,
rather than a user's last applied state. This means that as a side effect of
using Server Side Apply, information about which field manager manages each
field in an object also becomes available.
-->
<h2 id="field-management">字段管理</h2>
<p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p>
<!--
For a user to manage a field, in the Server Side Apply sense, means that the
user relies on and expects the value of the field not to change. The user who
last made an assertion about the value of a field will be recorded as the
current field manager. This can be done either by changing the value with
`POST`, `PUT`, or non-apply `PATCH`, or by including the field in a config sent
to the Server Side Apply endpoint. When using Server-Side Apply, trying to
change a field which is managed by someone else will result in a rejected
request (if not forced, see [Conflicts](#conflicts)).
-->
<p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href="#conflicts">冲突</a>）。</p>
<!--
When two or more appliers set a field to the same value, they share ownership of
that field. Any subsequent attempt to change the value of the shared field, by any of
the appliers, results in a conflict. Shared field owners may give up ownership
of a field by removing it from their configuration.

Field management is stored in a`managedFields` field that is part of an object's
[`metadata`](/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta).

A simple example of an object created by Server Side Apply could look like this:
-->
<p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p>
<p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href="/docs/reference/generated/kubernetes-api/v1.23/#objectmeta-v1-meta"><code>metadata</code></a>
中的一部分。</p>
<p>服务器端应用创建对象的简单示例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;2010-10-10T0:00:00Z&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fieldsType</span>:<span style="color:#bbb"> </span>FieldsV1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fieldsV1</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>some value<span style="color:#bbb">
</span></code></pre></div><!--
The above object contains a single manager in `metadata.managedFields`. The
manager consists of basic information about the managing entity itself, like
operation type, API version, and the fields managed by it.

This field is managed by the  API server and should not be changed by
the user.
-->
<p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 该字段由 API 服务器管理，用户不应该改动它。
</div>
<!--
Nevertheless it is possible to change `metadata.managedFields` through an
`Update` operation. Doing so is highly discouraged, but might be a reasonable
option to try if, for example, the `managedFields` get into an inconsistent
state (which clearly should not happen).

The format of the `managedFields` is described in the
[API](/docs/reference/generated/kubernetes-api/v1.23/#fieldsv1-v1-meta).
-->
<p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p>
<p><code>managedFields</code> 的格式在
<a href="/docs/reference/generated/kubernetes-api/v1.23/#fieldsv1-v1-meta">API</a>
文档中描述。</p>
<!--
## Conflicts

A conflict is a special status error that occurs when an `Apply` operation tries
to change a field, which another user also claims to manage. This prevents an
applier from unintentionally overwriting the value set by another user. When
this occurs, the applier has 3 options to resolve the conflicts:
-->
<h2 id="conflicts">冲突</h2>
<p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p>
<!--
* **Overwrite value, become sole manager:** If overwriting the value was
  intentional (or if the applier is an automated process like a controller) the
  applier should set the `force` query parameter to true and make the request
  again. This forces the operation to succeed, changes the value of the field,
  and removes the field from all other managers' entries in managedFields.

* **Don't overwrite value, give up management claim:** If the applier doesn't
  care about the value of the field anymore, they can remove it from their
  config and make the request again. This leaves the value unchanged, and causes
  the field to be removed from the applier's entry in managedFields.

* **Don't overwrite value, become shared manager:** If the applier still cares
  about the value of the field, but doesn't want to overwrite it, they can
  change the value of the field in their config to match the value of the object
  on the server, and make the request again. This leaves the value unchanged,
  and causes the field's management to be shared by the applier and all other
  field managers that already claimed to manage it.
-->
<ul>
<li>
<p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true，然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p>
</li>
<li>
<p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p>
</li>
<li>
<p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p>
</li>
</ul>
<!--
## Managers

Managers identify distinct workflows that are modifying the object (especially
useful on conflicts!), and can be specified through the `fieldManager` query
parameter as part of a modifying request. It is required for the apply endpoint,
though kubectl will default it to `kubectl`. For other updates, its default is
computed from the user-agent.
-->
<h2 id="managers">管理器</h2>
<p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p>
<!--
## Apply and Update

The two operation types considered by this feature are `Apply` (`PATCH` with
content type `application/apply-patch+yaml`) and `Update` (all other operations
which modify the object). Both operations update the `managedFields`, but behave
a little differently.

Whether you are submitting JSON data or YAML data, use
`application/apply-patch+yaml` as the `Content-Type` header value.

All JSON documents are valid YAML.
-->
<h2 id="apply-and-update">应用和更新</h2>
<p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p>
<p>所有的 JSON 文档 都是合法的 YAML。</p>

</div>
<!--
For instance, only the apply operation fails on conflicts while update does
not. Also, apply operations are required to identify themselves by providing a
`fieldManager` query parameter, while the query parameter is optional for update
operations. Finally, when using the apply operation you cannot have
`managedFields` in the object that is being applied.

An example object with multiple managers could look like this:
-->
<p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p>
<p>一个包含多个管理器的对象，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>ConfigMap<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>test-cm<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">test-label</span>:<span style="color:#bbb"> </span>test<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kubectl<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">f:test-label</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>kube-controller-manager<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Update<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">time</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;2019-03-30T16:00:00.000Z&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:key</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">key</span>:<span style="color:#bbb"> </span>new value<span style="color:#bbb">
</span></code></pre></div><!--
In this example, a second operation was run as an `Update` by the manager called
`kube-controller-manager`. The update changed a value in the data field which
caused the field's management to change to the `kube-controller-manager`.

If this update would have been an `Apply` operation, the operation
would have failed due to conflicting ownership.
-->
<p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p>
<p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p>
<!--
## Merge strategy

The merging strategy, implemented with Server Side Apply, provides a generally
more stable object lifecycle. Server Side Apply tries to merge fields based on
the actor who manages them instead of overruling based on values. This way
multiple actors can update the same object without causing unexpected interference.
-->
<h2 id="merge-strategy">合并策略</h2>
<p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p>
<!--
When a user sends a "fully-specified intent" object to the Server Side Apply
endpoint, the server merges it with the live object favoring the value in the
applied config if it is specified in both places. If the set of items present in
the applied config is not a superset of the items applied by the same user last
time, each missing item not managed by any other appliers is removed. For
more information about how an object's schema is used to make decisions when
merging, see
[sigs.k8s.io/structured-merge-diff](https://sigs.k8s.io/structured-merge-diff).
-->
<p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href="https://sigs.k8s.io/structured-merge-diff">sigs.k8s.io/structured-merge-diff</a>.</p>
<!--
A number of markers were added in Kubernetes 1.16 and 1.17, to allow API
developers to describe the merge strategy supported by lists, maps, and
structs. These markers can be applied to objects of the respective type,
in Go files or in the OpenAPI schema definition of the
[CRD](/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io):
-->
<p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href="/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io">CRD</a>
的 OpenAPI 的模式中定义：</p>
<!--
| Golang marker | OpenAPI extension | Accepted values | Description | Introduced in |
|---|---|---|---|---|
| `//+listType` | `x-kubernetes-list-type` | `atomic`/`set`/`map` | Applicable to lists. `set` applies to lists that include only scalar elements. These elements must be unique. `map` applies to lists of nested types only. The key values (see `listMapKey`) must be unique in the list. `atomic` can apply to any list. If configured as `atomic`, the entire list is replaced during merge. At any point in time, a single manager owns the list. If `set` or `map`, different managers can manage entries separately. | 1.16          |
| `//+listMapKey` | `x-kubernetes-list-map-keys` | List of field names, e.g. `["port", "protocol"]` | Only applicable when `+listType=map`. A list of field names whose values uniquely identify entries in the list. While there can be multiple keys, `listMapKey` is singular because keys need to be specified individually in the Go type. The key fields must be scalars. | 1.16 |
| `//+mapType` | `x-kubernetes-map-type` | `atomic`/`granular` | Applicable to maps. `atomic` means that the map can only be entirely replaced by a single manager. `granular` means that the map supports separate managers updating individual fields. | 1.17 |
| `//+structType` | `x-kubernetes-map-type` | `atomic`/`granular` | Applicable to structs; otherwise same usage and OpenAPI annotation as `//+mapType`.| 1.17 |
-->
<table>
<thead>
<tr>
<th>Golang 标记</th>
<th>OpenAPI extension</th>
<th>可接受的值</th>
<th>描述</th>
<th>引入版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//+listType</code></td>
<td><code>x-kubernetes-list-type</code></td>
<td><code>atomic</code>/<code>set</code>/<code>map</code></td>
<td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+listMapKey</code></td>
<td><code>x-kubernetes-list-map-keys</code></td>
<td>字段名称的列表，例如，<code>[&quot;port&quot;, &quot;protocol&quot;]</code></td>
<td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+mapType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td>
<td>1.17</td>
</tr>
<tr>
<td><code>//+structType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td>
<td>1.17</td>
</tr>
</tbody>
</table>
<!--
If `listType` is missing, the API server interprets a
`patchMergeStrategy=merge` marker as a `listType=map` and the
corresponding `patchMergeKey` marker as a `listMapKey`.

The `atomic` list type is recursive.

These markers are specified as comments and don't have to be repeated as
field tags.
-->
<p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p>
<p><code>atomic</code> 列表类型是递归的。</p>
<p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p>
<!--
### Compatibility across topology changes
-->
<h3 id="compatibility-across-toplogy-changes">拓扑变化时的兼容性 </h3>
<!--
On rare occurences, a CRD or built-in type author may want to change the
specific topology of a field in their resource without incrementing its
version. Changing the topology of types, by upgrading the cluster or
updating the CRD, has different consequences when updating existing
objects. There are two categories of changes: when a field goes from
`map`/`set`/`granular` to `atomic` and the other way around.
-->
<p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p>
<!--
When the `listType`, `mapType`, or `structType` changes from
`map`/`set`/`granular` to `atomic`, the whole list, map or struct of
existing objects will end-up being owned by actors who owned an element
of these types. This means that any further change to these objects
would cause a conflict.
-->
<p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p>
<!--
When a list, map, or struct changes from `atomic` to
`map`/`set`/`granular`, the API server won't be able to infer the new
ownership of these fields. Because of that, no conflict will be produced
when objects have these fields updated. For that reason, it is not
recommended to change a type from `atomic` to `map`/`set`/`granular`.

Take for example, the custom resource:
-->
<p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p>
<p>以下面的自定义资源为例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Foo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>foo-sample<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">managedFields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">manager</span>:<span style="color:#bbb"> </span>manager-one<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">operation</span>:<span style="color:#bbb"> </span>Apply<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>example.com/v1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">fields</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">f:spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">f:data</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">data</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">key1</span>:<span style="color:#bbb"> </span>val1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">key2</span>:<span style="color:#bbb"> </span>val2<span style="color:#bbb">
</span></code></pre></div><!--
Before `spec.data` gets changed from `atomic` to `granular`,
`manager-one` owns the field `spec.data`, and all the fields within it
(`key1` and `key2`). When the CRD gets changed to make `spec.data`
`granular`, `manager-one` continues to own the top-level field
`spec.data` (meaning no other managers can delete the map called `data`
without a conflict), but it no longer owns `key1` and `key2`, so another
manager can then modify or delete those fields without conflict.
-->
<p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想
删除名为 <code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p>
<!--
### Custom Resources

By default, Server Side Apply treats custom resources as unstructured data. All
keys are treated the same as struct fields, and all lists are considered atomic.

If the Custom Resource Definition defines a
[schema](/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io)
that contains annotations as defined in the previous "Merge Strategy"
section, these annotations will be used when merging objects of this
type.
-->
<h3 id="custom-resources">自定义资源</h3>
<p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p>
<p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href="/docs/reference/generated/kubernetes-api/v1.23#jsonschemaprops-v1-apiextensions-k8s-io">模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p>
<!--
## Using Server-Side Apply in a controller

As a developer of a controller, you can use server-side apply as a way to
simplify the update logic of your controller. The main differences with a
read-modify-write and/or patch are the following:

* the applied object must contain all the fields that the controller cares about.
* there are no way to remove fields that haven't been applied by the controller
  before (controller can still send a PATCH/UPDATE for these use-cases).
* the object doesn't have to be read beforehand, `resourceVersion` doesn't have
  to be specified.

It is strongly recommended for controllers to always "force" conflicts, since they
might not be able to resolve or act on these conflicts.
-->
<h2 id="using-server-side-apply-in-controller">在控制器中使用服务器端应用</h2>
<p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p>
<ul>
<li>应用的对象必须包含控制器关注的所有字段。</li>
<li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li>
<li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li>
</ul>
<p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p>
<!--
## Transferring Ownership

In addition to the concurrency controls provided by [conflict resolution](#conflicts),
Server Side Apply provides ways to perform coordinated
field ownership transfers from users to controllers.

This is best explained by example. Let's look at how to safely transfer
ownership of the `replicas` field from a user to a controller while enabling
automatic horizontal scaling for a Deployment, using the HorizontalPodAutoscaler
resource and its accompanying controller.

Say a user has defined deployment with `replicas` set to the desired value:
-->
<h2 id="transferring-ownership">转移所有权</h2>
<p>除了通过<a href="#conflicts">冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p>
<p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p>
<p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment.yaml" download="application/ssa/nginx-deployment.yaml"><code>application/ssa/nginx-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-yaml')" title="Copy application/ssa/nginx-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
And the user has created the deployment using server side apply like so:
-->
<p>并且，用户使用服务器端应用，像这样创建 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</code></pre></div><!--
Then later, HPA is enabled for the deployment, e.g.:
-->
<p>然后，为 Deployment 启用 HPA，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl autoscale deployment nginx-deployment --cpu-percent<span style="color:#666">=</span><span style="color:#666">50</span> --min<span style="color:#666">=</span><span style="color:#666">1</span> --max<span style="color:#666">=</span><span style="color:#666">10</span>
</code></pre></div><!--
Now, the user would like to remove `replicas` from their configuration, so they
don't accidentally fight with the HPA controller. However, there is a race: it
might take some time before HPA feels the need to adjust `replicas`, and if
the user removes `replicas` before the HPA writes to the field and becomes
its owner, then apiserver will set `replicas` to 1, its default value. This
is not what the user wants to happen, even temporarily.
-->
<p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为 1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p>
<!--
There are two solutions:

- (basic) Leave `replicas` in the configuration; when HPA eventually writes to that
  field, the system gives the user a conflict over it. At that point, it is safe
  to remove from the configuration.

- (more advanced) If, however, the user doesn't want to wait, for example
  because they want to keep the cluster legible to coworkers, then they can take
  the following steps to make it safe to remove `replicas` from their
  configuration:

First, the user defines a new configuration containing only the `replicas` field:
-->
<p>这里有两个解决方案：</p>
<ul>
<li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li>
<li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li>
</ul>
<p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-replicas-only.yaml" download="application/ssa/nginx-deployment-replicas-only.yaml"><code>application/ssa/nginx-deployment-replicas-only.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-replicas-only-yaml')" title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-replicas-only-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
The user applies that configuration using the field manager name `handover-to-hpa`:
-->
<p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --server-side --field-manager<span style="color:#666">=</span>handover-to-hpa <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  --validate<span style="color:#666">=</span><span style="color:#a2f">false</span>
</code></pre></div><!--
If the apply results in a conflict with the HPA controller, then do nothing. The
conflict indicates the controller has claimed the field earlier in the
process than it sometimes does.

At this point the user may remove the `replicas` field from their configuration.
-->
<p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p>
<p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-no-replicas.yaml" download="application/ssa/nginx-deployment-no-replicas.yaml"><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-ssa-nginx-deployment-no-replicas-yaml')" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-ssa-nginx-deployment-no-replicas-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Note that whenever the HPA controller sets the `replicas` field to a new value,
the temporary field manager will no longer own any fields and will be
automatically deleted. No clean up is required.
-->
<p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p>
<!--
### Transferring Ownership Between Users

Users can transfer ownership of a field between each other by setting the field
to the same value in both of their applied configs, causing them to share
ownership of the field. Once the users share ownership of the field, one of them
can remove the field from their applied configuration to give up ownership and
complete the transfer to the other user.
-->
<h3 id="transferring-ownership-between-users">在用户之间转移所有权</h3>
<p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p>
<!--
## Comparison with Client Side Apply

A consequence of the conflict detection and resolution implemented by Server
Side Apply is that an applier always has up to date field values in their local
state. If they don't, they get a conflict the next time they apply. Any of the
three options to resolve conflicts results in the applied configuration being an
up to date subset of the object on the server's fields.

This is different from Client Side Apply, where outdated values which have been
overwritten by other users are left in an applier's local config. These values
only become accurate when the user updates that specific field, if ever, and an
applier has no way of knowing whether their next apply will overwrite other
users' changes.

Another difference is that an applier using Client Side Apply is unable to
change the API version they are using, but Server Side Apply supports this use
case.
-->
<h2 id="comparison-with-client-side-apply">与客户端应用的对比</h2>
<p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p>
<p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p>
<p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p>
<!--
## Upgrading from client-side apply to server-side apply

Client-side apply users who manage a resource with `kubectl apply` can start
using server-side apply with the following flag.
-->
<h2 id="upgrading-from-client-side-apply-to-server-side-apply">从客户端应用升级到服务器端应用</h2>
<p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!--
By default, field management of the object transfers from client-side apply to
kubectl server-side apply without encountering conflicts.

Keep the `last-applied-configuration` annotation up to date.
The annotation infers client-side apply's managed fields.
Any fields not managed by client-side apply raise conflicts.

For example, if you used `kubectl scale` to update the replicas field after
client-side apply, then this field is not owned by client-side apply and
creates conflicts on `kubectl apply --server-side`.

This behavior applies to server-side apply with the `kubectl` field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is `kubectl`.
-->
<p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p>
<p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p>

</div>

<p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!--
## Downgrading from server-side apply to client-side apply

If you manage a resource with `kubectl apply --server-side`,
you can downgrade to client-side apply directly with `kubectl apply`.

Downgrading works because kubectl server-side apply keeps the
`last-applied-configuration` annotation up-to-date if you use
`kubectl apply`.

This behavior applies to server-side apply with the `kubectl` field manager.
As an exception, you can opt-out of this behavior by specifying a different,
non-default field manager, as seen in the following example. The default field
manager for kubectl server-side apply is `kubectl`.
-->
<h2 id="downgrading-from-server-side-apply-to-client-side-apply">从服务器端应用降级到客户端应用</h2>
<p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p>
<p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p>
<p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply --server-side --field-manager<span style="color:#666">=</span>my-manager <span style="color:#666">[</span>--dry-run<span style="color:#666">=</span>server<span style="color:#666">]</span>
</code></pre></div><!--
## API Endpoint

With the Server Side Apply feature enabled, the `PATCH` endpoint accepts the
additional `application/apply-patch+yaml` content type. Users of Server Side
Apply can send partially specified objects as YAML to this endpoint.  When
applying a configuration, one should always include all the fields that they
have an opinion about.
-->
<h2 id="api-endpoint">API 端点</h2>
<p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl 格式的
部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p>
<!--
## Clearing ManagedFields

It is possible to strip all managedFields from an object by overwriting them
using `MergePatch`, `StrategicMergePatch`, `JSONPatch` or `Update`, so every
non-apply operation. This can be done by overwriting the managedFields field
with an empty entry. Two examples are:
-->
<h2 id="clearing-managedfields">清除 ManagedFields</h2>
<p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。以下是两个示例：</p>
<pre><code class="language-console" data-lang="console">PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/merge-patch+json
Accept: application/json
Data: {&quot;metadata&quot;:{&quot;managedFields&quot;: [{}]}}
</code></pre><pre><code class="language-console" data-lang="console">PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/json-patch+json
Accept: application/json
Data: [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/metadata/managedFields&quot;, &quot;value&quot;: [{}]}]
</code></pre><!--
This will overwrite the managedFields with a list containing a single empty
entry that then results in the managedFields being stripped entirely from the
object. Note that setting the managedFields to an empty list will not
reset the field. This is on purpose, so managedFields never get stripped by
clients not aware of the field.

In cases where the reset operation is combined with changes to other fields
than the managedFields, this will result in the managedFields being reset
first and the other changes being processed afterwards. As a result the
applier takes ownership of any fields updated in the same request.
-->
<p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p>
<p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p>
<!--
Server Side Apply does not correctly track ownership on
sub-resources that don't receive the resource object type. If you are
using Server Side Apply with such a sub-resource, the changed fields
won't be tracked.
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> 对于不接受资源对象类型的子资源（sub-resources），
服务器端应用不能正确地跟踪其所有权。
如果你对这样的子资源使用服务器端应用，变更的字段将不会被跟踪。
</div>


</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-79880efc25dc8cb3b6962ad78a964319">3 - 客户端库</h1>
    
	<!--
title: Client Libraries
reviewers:
- ahmetb
content_type: concept
weight: 30
-->
<!-- overview -->
<!--
This page contains an overview of the client libraries for using the Kubernetes
API from various programming languages.
-->
<p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p>
<!-- body -->
<!--
To write applications using the [Kubernetes REST API](/docs/reference/using-api/),
you do not need to implement the API calls and request/response types yourself.
You can use a client library for the programming language you are using.
-->
<p>在使用 <a href="/zh/docs/reference/using-api/">Kubernetes REST API</a> 编写应用程序时，
您并不需要自己实现 API 调用和 “请求/响应” 类型。
您可以根据自己的编程语言需要选择使用合适的客户端库。</p>
<!--
Client libraries often handle common tasks such as authentication for you.
Most client libraries can discover and use the Kubernetes Service Account to
authenticate if the API client is running inside the Kubernetes cluster, or can
understand the [kubeconfig file](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/)
format to read the credentials and the API Server address.
-->
<p>客户端库通常为您处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p>
<!--
## Officially-supported Kubernetes client libraries
-->
<h2 id="officially-supported-kubernetes-client-libraries">官方支持的 Kubernetes 客户端库 </h2>
<!--
The following client libraries are officially maintained by
[Kubernetes SIG API Machinery](https://github.com/kubernetes/community/tree/master/sig-api-machinery).
-->
<p>以下客户端库由 <a href="https://github.com/kubernetes/community/tree/master/sig-api-machinery">Kubernetes SIG API Machinery</a> 正式维护。</p>
<!--
| Language | Client Library | Sample Programs |
|----------|----------------|-----------------|
| dotnet   | [github.com/kubernetes-client/csharp](https://github.com/kubernetes-client/csharp) | [browse](https://github.com/kubernetes-client/csharp/tree/master/examples/simple)
| Go       | [github.com/kubernetes/client-go/](https://github.com/kubernetes/client-go/) | [browse](https://github.com/kubernetes/client-go/tree/master/examples)
| Haskell  | [github.com/kubernetes-client/haskell](https://github.com/kubernetes-client/haskell) | [browse](https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example)
| Java     | [github.com/kubernetes-client/java](https://github.com/kubernetes-client/java/) | [browse](https://github.com/kubernetes-client/java#installation)
| JavaScript   | [github.com/kubernetes-client/javascript](https://github.com/kubernetes-client/javascript) | [browse](https://github.com/kubernetes-client/javascript/tree/master/examples)
| Python   | [github.com/kubernetes-client/python/](https://github.com/kubernetes-client/python/) | [browse](https://github.com/kubernetes-client/python/tree/master/examples)
-->
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
<th>样例程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotnet</td>
<td><a href="https://github.com/kubernetes-client/csharp">github.com/kubernetes-client/csharp</a></td>
<td><a href="https://github.com/kubernetes-client/csharp/tree/master/examples/simple">浏览</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href="https://github.com/kubernetes/client-go/">github.com/kubernetes/client-go/</a></td>
<td><a href="https://github.com/kubernetes/client-go/tree/master/examples">浏览</a></td>
</tr>
<tr>
<td>Haskell</td>
<td><a href="https://github.com/kubernetes-client/haskell">github.com/kubernetes-client/haskell</a></td>
<td><a href="https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example">浏览</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href="https://github.com/kubernetes-client/java/">github.com/kubernetes-client/java</a></td>
<td><a href="https://github.com/kubernetes-client/java#installation">浏览</a></td>
</tr>
<tr>
<td>JavaScript</td>
<td><a href="https://github.com/kubernetes-client/javascript">github.com/kubernetes-client/javascript</a></td>
<td><a href="https://github.com/kubernetes-client/javascript/tree/master/examples">浏览</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/kubernetes-client/python/">github.com/kubernetes-client/python/</a></td>
<td><a href="https://github.com/kubernetes-client/python/tree/master/examples">浏览</a></td>
</tr>
</tbody>
</table>
<!--
## Community-maintained client libraries
-->
<h2 id="community-maintained-client-libraries">社区维护的客户端库 </h2>
<div class="alert alert-secondary callout third-party-content" role="alert"><strong>Note:</strong>
  This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href="/docs/contribute/style/content-guide/#third-party-content">content guide</a> before submitting a change. <a href="#third-party-content-disclaimer">More information.</a></div>
<!--
The following Kubernetes API client libraries are provided and maintained by
their authors, not the Kubernetes team.
-->
<p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p>
<!--
| Language             | Client Library                           |
| -------------------- | ---------------------------------------- |
| Clojure              | [github.com/yanatan16/clj-kubernetes-api](https://github.com/yanatan16/clj-kubernetes-api) |
| DotNet               | [github.com/tonnyeremin/kubernetes_gen](https://github.com/tonnyeremin/kubernetes_gen) |
| DotNet (RestSharp)   | [github.com/masroorhasan/Kubernetes.DotNet](https://github.com/masroorhasan/Kubernetes.DotNet) |
| Elixir               | [github.com/obmarg/kazan](https://github.com/obmarg/kazan/) |
| Elixir               | [github.com/coryodaniel/k8s](https://github.com/coryodaniel/k8s) |
| Go                   | [github.com/ericchiang/k8s](https://github.com/ericchiang/k8s) |
| Java (OSGi)          | [bitbucket.org/amdatulabs/amdatu-kubernetes](https://bitbucket.org/amdatulabs/amdatu-kubernetes) |
| Java (Fabric8, OSGi) | [github.com/fabric8io/kubernetes-client](https://github.com/fabric8io/kubernetes-client) |
| Java                 | [github.com/manusa/yakc](https://github.com/manusa/yakc) |
| Lisp                 | [github.com/brendandburns/cl-k8s](https://github.com/brendandburns/cl-k8s) |
| Lisp                 | [github.com/xh4/cube](https://github.com/xh4/cube) |
| Node.js (TypeScript) | [github.com/Goyoo/node-k8s-client](https://github.com/Goyoo/node-k8s-client) |
| Node.js              | [github.com/ajpauwels/easy-k8s](https://github.com/ajpauwels/easy-k8s)
| Node.js              | [github.com/godaddy/kubernetes-client](https://github.com/godaddy/kubernetes-client) |
| Node.js              | [github.com/tenxcloud/node-kubernetes-client](https://github.com/tenxcloud/node-kubernetes-client) |
| Perl                 | [metacpan.org/pod/Net::Kubernetes](https://metacpan.org/pod/Net::Kubernetes) |
| PHP                  | [github.com/allansun/kubernetes-php-client](https://github.com/allansun/kubernetes-php-client) |
| PHP                  | [github.com/maclof/kubernetes-client](https://github.com/maclof/kubernetes-client) |
| PHP                  | [github.com/travisghansen/kubernetes-client-php](https://github.com/travisghansen/kubernetes-client-php) |
| PHP                  | [github.com/renoki-co/php-k8s](https://github.com/renoki-co/php-k8s) |
| Python               | [github.com/fiaas/k8s](https://github.com/fiaas/k8s) |
| Python               | [github.com/gtsystem/lightkube](https://github.com/gtsystem/lightkube) |
| Python               | [github.com/mnubo/kubernetes-py](https://github.com/mnubo/kubernetes-py) |
| Python               | [github.com/tomplus/kubernetes_asyncio](https://github.com/tomplus/kubernetes_asyncio) |
| Python               | [github.com/Frankkkkk/pykorm](https://github.com/Frankkkkk/pykorm) |
| Ruby                 | [github.com/abonas/kubeclient](https://github.com/abonas/kubeclient) |
| Ruby                 | [github.com/k8s-ruby/k8s-ruby](https://github.com/k8s-ruby/k8s-ruby) |
| Ruby                 | [github.com/kontena/k8s-client](https://github.com/kontena/k8s-client) |
| Rust                 | [github.com/clux/kube-rs](https://github.com/clux/kube-rs) |
| Rust                 | [github.com/ynqa/kubernetes-rust](https://github.com/ynqa/kubernetes-rust) |
| Scala                | [github.com/hagay3/skuber](https://github.com/hagay3/skuber) |
| Scala                | [github.com/joan38/kubernetes-client](https://github.com/joan38/kubernetes-client) |
-->
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><a href="https://github.com/yanatan16/clj-kubernetes-api">github.com/yanatan16/clj-kubernetes-api</a></td>
</tr>
<tr>
<td>DotNet</td>
<td><a href="https://github.com/tonnyeremin/kubernetes_gen">github.com/tonnyeremin/kubernetes_gen</a></td>
</tr>
<tr>
<td>DotNet (RestSharp)</td>
<td><a href="https://github.com/masroorhasan/Kubernetes.DotNet">github.com/masroorhasan/Kubernetes.DotNet</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href="https://github.com/obmarg/kazan/">github.com/obmarg/kazan</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href="https://github.com/coryodaniel/k8s">github.com/coryodaniel/k8s</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href="https://github.com/ericchiang/k8s">github.com/ericchiang/k8s</a></td>
</tr>
<tr>
<td>Java (OSGi)</td>
<td><a href="https://bitbucket.org/amdatulabs/amdatu-kubernetes">bitbucket.org/amdatulabs/amdatu-kubernetes</a></td>
</tr>
<tr>
<td>Java (Fabric8, OSGi)</td>
<td><a href="https://github.com/fabric8io/kubernetes-client">github.com/fabric8io/kubernetes-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href="https://github.com/manusa/yakc">github.com/manusa/yakc</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href="https://github.com/brendandburns/cl-k8s">github.com/brendandburns/cl-k8s</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href="https://github.com/xh4/cube">github.com/xh4/cube</a></td>
</tr>
<tr>
<td>Node.js (TypeScript)</td>
<td><a href="https://github.com/Goyoo/node-k8s-client">github.com/Goyoo/node-k8s-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/ajpauwels/easy-k8s">github.com/ajpauwels/easy-k8s</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/godaddy/kubernetes-client">github.com/godaddy/kubernetes-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href="https://github.com/tenxcloud/node-kubernetes-client">github.com/tenxcloud/node-kubernetes-client</a></td>
</tr>
<tr>
<td>Perl</td>
<td><a href="https://metacpan.org/pod/Net::Kubernetes">metacpan.org/pod/Net::Kubernetes</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/allansun/kubernetes-php-client">github.com/allansun/kubernetes-php-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/maclof/kubernetes-client">github.com/maclof/kubernetes-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/travisghansen/kubernetes-client-php">github.com/travisghansen/kubernetes-client-php</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href="https://github.com/renoki-co/php-k8s">github.com/renoki-co/php-k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/fiaas/k8s">github.com/fiaas/k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/gtsystem/lightkube">github.com/gtsystem/lightkube</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/mnubo/kubernetes-py">github.com/mnubo/kubernetes-py</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/tomplus/kubernetes_asyncio">github.com/tomplus/kubernetes_asyncio</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href="https://github.com/Frankkkkk/pykorm">github.com/Frankkkkk/pykorm</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/abonas/kubeclient">github.com/abonas/kubeclient</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/k8s-ruby/k8s-ruby">github.com/k8s-ruby/k8s-ruby</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href="https://github.com/kontena/k8s-client">github.com/kontena/k8s-client</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href="https://github.com/clux/kube-rs">github.com/clux/kube-rs</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href="https://github.com/ynqa/kubernetes-rust">github.com/ynqa/kubernetes-rust</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href="https://github.com/hagay3/skuber">github.com/hagay3/skuber</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href="https://github.com/joan38/kubernetes-client">github.com/joan38/kubernetes-client</a></td>
</tr>
<tr>
<td>Swift</td>
<td><a href="https://github.com/swiftkube/client">github.com/swiftkube/client</a></td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8d2ce3e7b2223cda0ccd428f4d5ea24b">4 - Kubernetes 弃用策略</h1>
    
	<!--
reviewers:
- bgrant0607
- lavalamp
- thockin
title: Kubernetes Deprecation Policy
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
This document details the deprecation policy for various facets of the system.
-->
<p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p>
<!-- body -->
<!--
Kubernetes is a large system with many components and many contributors.  As
with any such software, the feature set naturally evolves over time, and
sometimes a feature may need to be removed. This could include an API, a flag,
or even an entire feature. To avoid breaking existing users, Kubernetes follows
a deprecation policy for aspects of the system that are slated to be removed.
-->
<p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、一个参数标志或者
甚至某整个功能特性。为了避免影响到现有用户，Kubernetes 对于其中渐次移除
的各个方面规定了一种弃用策略并遵从此策略。</p>
<!--
## Deprecating parts of the API

Since Kubernetes is an API-driven system, the API has evolved over time to
reflect the evolving understanding of the problem space. The Kubernetes API is
actually a set of APIs, called "API groups", and each API group is
independently versioned.  [API versions](/docs/reference/using-api/#api-versioning) fall
into 3 main tracks, each of which has different policies for deprecation:
-->
<h2 id="deprecating-parts-of-the-api">弃用 API 的一部分 </h2>
<p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，以反映
人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，其中每个
成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href="/zh/docs/reference/using-api/#api-versioning">API 版本</a>会有
三类，每类有不同的废弃策略：</p>
<!--
| Example  | Track                            |
|----------|----------------------------------|
| v1       | GA (generally available, stable) |
| v1beta1  | Beta (pre-release)               |
| v1alpha1 | Alpha (experimental)             |
-->
<table>
<thead>
<tr>
<th>示例</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>正式发布（Generally available，GA，稳定版本）</td>
</tr>
<tr>
<td>v1beta1</td>
<td>Beta （预发布）</td>
</tr>
<tr>
<td>v1alpha1</td>
<td>Alpha （试验性）</td>
</tr>
</tbody>
</table>
<!--
A given release of Kubernetes can support any number of API groups and any
number of versions of each.

The following rules govern the deprecation of elements of the API.  This
includes:
-->
<p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含
任意个数的版本。</p>
<p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p>
<!--
   * REST resources (aka API objects)
   * Fields of REST resources
   * Annotations on REST resources, including "beta" annotations but not
     including "alpha" annotations.
   * Enumerated or constant values
   * Component config structures
-->
<ul>
<li>REST 资源（也即 API 对象）</li>
<li>REST 资源的字段</li>
<li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li>
<li>枚举值或者常数值</li>
<li>组件配置结构</li>
</ul>
<!--
These rules are enforced between official releases, not between
arbitrary commits to master or release branches.

**Rule #1: API elements may only be removed by incrementing the version of the
API group.**

Once an API element has been added to an API group at a particular version, it
can not be removed from that version or have its behavior significantly
changed, regardless of track.
-->
<p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上
不同提交之间的变化。</p>
<p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p>
<p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p>
<!--
For historical reasons, there are 2 "monolithic" API groups - "core" (no
group name) and "extensions".  Resources will incrementally be moved from these
legacy API groups into more domain-specific API groups.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到
更为特定领域的 API 组中。
</div>
<!--
**Rule #2: API objects must be able to round-trip between API versions in a given
release without information loss, with the exception of whole REST resources
that do not exist in some versions.**
-->
<p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API 版本之间来回
转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p>
<!--
For example, an object can be written as v1 and then read back as v2 and
converted to v1, and the resulting v1 resource will be identical to the
original.  The representation in v2 might be different from v1, but the system
knows how to convert between them in both directions.  Additionally, any new
field added in v2 must be able to round-trip to v1 and back, which means v1
might have to add an equivalent field or represent it as an annotation.
-->
<p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须
与原来的 v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何
在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1 必须
添加一个新的等效字段或者将其表现为一个注解。</p>
<!--
**Rule #3: An API version in a given track may not be deprecated in favor of a less stable API version.**

  * GA API versions can replace beta and alpha API versions.
  * Beta API versions can replace earlier beta and alpha API versions, but *may not* replace GA API versions.
  * Alpha API versions can replace earlier alpha API versions, but *may not* replace GA or beta API versions.
-->
<p><strong>规则 #3：给定类别的 API 版本不可被弃用以支持稳定性更差的 API 版本。</strong></p>
<ul>
<li>一个正式发布的（GA）API 版本可替换 beta 或 alpha API 版本。</li>
<li>Beta API 版本可以替换早期的 beta 和 alpha API 版本，但 <strong>不可以</strong> 替换正式的 API 版本。</li>
<li>Alpha API 版本可以替换早期的 alpha API 版本，但 <strong>不可以</strong> 替换正式的或 beta API 版本。</li>
</ul>
<!--
**Rule #4a: minimum API lifetime is determined by the API stability level**

   * **GA API versions may be marked as deprecated, but must not be removed within a major version of Kubernetes**
   * **Beta API versions must be supported for 9 months or 3 releases (whichever is longer) after deprecation**
   * **Alpha API versions may be removed in any release without prior deprecation notice**

This ensures beta API support covers the [maximum supported version skew of 2 releases](/releases/version-skew-policy/).
-->
<p><strong>规则 #4a：最短 API 生命周期由 API 稳定性级别决定</strong></p>
<ul>
<li><strong>GA API 版本可以被标记为已弃用，但不得在 Kubernetes 的主要版本中删除</strong></li>
<li><strong>Beta API 版本必须支持 9 个月或弃用后的 3 个版本（以较长者为准）</strong></li>
<li><strong>Alpha API 版本可能会在任何版本中被删除，不另行通知</strong></li>
</ul>
<p>这确保了 beta API 支持涵盖了<a href="/zh/releases/version-skew-policy/">最多 2 个版本的支持版本偏差</a>。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
There are no current plans for a major version revision of Kubernetes that removes GA APIs.
-->
<p>目前没有删除正式版本 API 的 Kubernetes 主要版本修订计划。
</div>
<!--
Until [#52185](https://github.com/kubernetes/kubernetes/issues/52185) is
resolved, no API versions that have been persisted to storage may be removed.
Serving REST endpoints for those versions may be disabled (subject to the
deprecation timelines in this document), but the API server must remain capable
of decoding/converting previously persisted data from storage.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 在 <a href="https://github.com/kubernetes/kubernetes/issues/52185">#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。
</div>
<!--
**Rule #4b: The "preferred" API version and the "storage version" for a given
group may not advance until after a release has been made that supports both the
new version and the previous version**
-->
<p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes 发布
版本出来以前不可以提升其版本号。</strong></p>
<!--
Users must be able to upgrade to a new release of Kubernetes and then roll back
to a previous release, without converting anything to the new API version or
suffering breakages (unless they explicitly used features only available in the
newer version).  This is particularly evident in the stored representation of
objects.

All of this is best illustrated by examples.  Imagine a Kubernetes release,
version X, which introduces a new API group.  A new Kubernetes release is made
every approximately 4 months (3 per year).  The following table describes which
API versions are supported in a series of subsequent releases.
-->
<p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，且
整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p>
<p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了
新的 API 组。大约每隔 4 个月会有一个新的 Kubernetes 版本被发布（每年 3 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p>
<table>
  <thead>
    <tr>
      <!-- th>Release</th>
      <th>API Versions</th>
      <th>Preferred/Storage Version</th>
      <th>Notes</th -->
      <th>发布版本</th>
      <th>API 版本</th>
      <th>优选/存储版本</th>
      <th>注释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>X</td>
      <td>v1alpha1</td>
      <td>v1alpha1</td>
      <td></td>
    </tr>
    <tr>
      <td>X+1</td>
      <td>v1alpha2</td>
      <td>v1alpha2</td>
      <td>
        <ul>
           <!-- li>v1alpha1 is removed, "action required" relnote</li -->
           <li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+2</td>
      <td>v1beta1</td>
      <td>v1beta1</td>
      <td>
        <ul>
          <!-- li>v1alpha2 is removed, "action required" relnote</li -->
          <li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+3</td>
      <!-- td>v1beta2, v1beta1 (deprecated)</td -->
      <td>v1beta2、v1beta1（已弃用）</td>
      <td>v1beta1</td>
      <td>
        <ul>
          <!-- li>v1beta1 is deprecated, "action required" relnote</li -->
          <li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+4</td>
      <!-- td>v1beta2, v1beta1 (deprecated)</td -->
      <td>v1beta2、v1beta1（已弃用）</td>
      <td>v1beta2</td>
      <td></td>
    </tr>
    <tr>
      <td>X+5</td>
      <!-- td>v1, v1beta1 (deprecated), v1beta2 (deprecated)</td -->
      <td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td>
      <td>v1beta2</td>
      <td>
        <ul>
          <!-- li>v1beta2 is deprecated, "action required" relnote</li -->
          <li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+6</td>
      <!-- td>v1, v1beta2 (deprecated)</td -->
      <td>v1、v1beta2（已弃用）</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v1beta1 is removed, "action required" relnote</li -->
          <li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+7</td>
      <!-- td>v1, v1beta2 (deprecated)</td -->
      <td>v1、v1beta2（已弃用）</td>
      <td>v1</td>
      <td></td>
    </tr>
    <tr>
      <td>X+8</td>
      <td>v2alpha1、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v1beta2 is removed, "action required" relnote</li -->
          <li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+9</td>
      <td>v2alpha2、v1</td>
      <td>v1</td>
      <td>
        <ul>
           <!-- li>v2alpha1 is removed, "action required" relnote</li -->
           <li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+10</td>
      <td>v2beta1、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2alpha2 is removed, "action required" relnote</li -->
          <li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+11</td>
      <!-- td>v2beta2, v2beta1 (deprecated), v1</td -->
      <td>v2beta2、v2beta1（已弃用）、v1</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2beta1 is deprecated, "action required" relnote</li -->
          <li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+12</td>
      <!-- td>v2, v2beta2 (deprecated), v2beta1 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td>
      <td>v1</td>
      <td>
        <ul>
          <!-- li>v2beta2 is deprecated, "action required" relnote</li>
          <li>v1 is deprecated in favor of v2, but will not be removed</li -->
          <li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
          <li>v1 已被弃用，取而代之的是 v2，但不会被删除</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+13</td>
      <!-- td>v2, v2beta1 (deprecated), v2beta2 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td>
      <td>v2</td>
      <td></td>
    </tr>
    <tr>
      <td>X+14</td>
      <!-- td>v2, v2beta2 (deprecated), v1 (deprecated)</td -->
      <td>v2、v2beta2（已弃用）、v1（已弃用）</td>
      <td>v2</td>
      <td>
        <ul>
          <!-- li>v2beta1 is removed, "action required" relnote</li -->
          <li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>X+15</td>
      <!-- td>v2, v1 (deprecated)</td -->
      <td>v2、v1（已弃用）</td>
      <td>v2</td>
      <td>
        <ul>
          <!-- li>v2beta2 is removed, "action required" relnote</li -->
          <li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
<!--
### REST resources (aka API objects)

Consider a hypothetical REST resource named Widget, which was present in API v1
in the above timeline, and which needs to be deprecated.  We document and
[announce](https://groups.google.com/forum/#!forum/kubernetes-announce) the
deprecation in sync with release X+1.  The Widget resource still exists in API
version v1 (deprecated) but not in v2alpha1.  The Widget resource continues to
exist and function in releases up to and including X+8.  Only in release X+9,
when API v1 has aged out, does the Widget resource cease to exist, and the
behavior get removed.
-->
<h3 id="rest-resources-aka-api-objects">REST 资源（也即 API 对象） </h3>
<p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，
而现在打算将其弃用。
我们会在文档和
<a href="https://groups.google.com/forum/#!forum/kubernetes-announce">声明</a>
中与 X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p>
<!--
Starting in Kubernetes v1.19, making an API request to a deprecated REST API endpoint:

1. Returns a `Warning` header (as defined in [RFC7234, Section 5.5](https://tools.ietf.org/html/rfc7234#section-5.5)) in the API response.
2. Adds a `"k8s.io/deprecated":"true"` annotation to the [audit event](/docs/tasks/debug-application-cluster/audit/) recorded for the request.
3. Sets an `apiserver_requested_deprecated_apis` gauge metric to `1` in the `kube-apiserver`
   process. The metric has labels for `group`, `version`, `resource`, `subresource` that can be joined
   to the `apiserver_request_total` metric, and a `removed_release` label that indicates the
   Kubernetes release in which the API will no longer be served. The following Prometheus query
   returns information about requests made to deprecated APIs which will be removed in v1.22:

   ```promql
   apiserver_requested_deprecated_apis{removed_release="1.22"} * on(group,version,resource,subresource) group_right() apiserver_request_total
   ```
-->
<p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p>
<ol>
<li>
<p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href="https://tools.ietf.org/html/rfc7234#section-5.5">RFC7234 5.5 节</a>所定义）；</p>
</li>
<li>
<p>该请求会导致对应的
<a href="/zh/docs/tasks/debug-application-cluster/audit/">审计事件</a>
中会增加一个注解 <code>&quot;k8s.io/deprecated&quot;:&quot;true&quot;</code>。</p>
</li>
<li>
<p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被
设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API
的请求的信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-promql" data-lang="promql"><span style="color:#b8860b">apiserver_requested_deprecated_apis</span>{<span style="color:#a0a000">removed_release</span><span style="color:#666">=</span>&#34;<span style="color:#b44">1.22</span>&#34;}<span style="color:#bbb"> </span><span style="color:#666">*</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">on</span><span style="color:#666">(</span><span style="color:#a2f;font-weight:bold">group</span>,<span style="color:#b8860b">version</span>,<span style="color:#b8860b">resource</span>,<span style="color:#b8860b">subresource</span><span style="color:#666">)</span><span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">group_right</span><span style="color:#666">()</span><span style="color:#bbb"> </span><span style="color:#b8860b">apiserver_request_total</span><span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
### Fields of REST resources

As with whole REST resources, an individual field which was present in API v1
must exist and function until API v1 is removed.  Unlike whole resources, the
v2 APIs may choose a different representation for the field, as long as it can
be round-tripped.  For example a v1 field named "magnitude" which was
deprecated might be named "deprecatedMagnitude" in API v2.  When v1 is
eventually removed, the deprecated field can be removed from v2.
-->
<h3 id="fields-of-rest-resources">REST 资源的字段   </h3>
<p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除
之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 &quot;magnitude&quot; 的已弃用字段可能在 API v2 中被命名
为 &quot;deprecatedMagnitude&quot;。当 v1 最终被移除时，废弃的字段也可以从 v2
中移除。</p>
<!--
### Enumerated or constant values

As with whole REST resources and fields thereof, a constant value which was
supported in API v1 must exist and function until API v1 is removed.
-->
<h3 id="enumerated-or-constant-values">枚举值或常数值</h3>
<p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值
必须在 API v1 被移除之前一直存在且起作用。</p>
<!--
### Component config structures

Component configs are versioned and managed similar to REST resources.
-->
<h3 id="component-config-structures">组件配置结构 </h3>
<p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p>
<!--
### Future work

Over time, Kubernetes will introduce more fine-grained API versions, at which
point these rules will be adjusted as needed.
-->
<h3 id="future-work">将来的工作   </h3>
<p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p>
<!--
## Deprecating a flag or CLI

The Kubernetes system is comprised of several different programs cooperating.
Sometimes, a Kubernetes release might remove flags or CLI commands
(collectively "CLI elements") in these programs.  The individual programs
naturally sort into two main groups - user-facing and admin-facing programs,
which vary slightly in their deprecation policies.  Unless a flag is explicitly
prefixed or documented as "alpha" or "beta", it is considered GA.
-->
<h2 id="弃用一个标志或-cli-命令">弃用一个标志或 CLI 命令</h2>
<p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p>
<!--
CLI elements are effectively part of the API to the system, but since they are
not versioned in the same way as the REST API, the rules for deprecation are as
follows:
-->
<p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p>
<!--
**Rule #5a: CLI elements of user-facing components (e.g. kubectl) must function
after their announced deprecation for no less than:**

   * **GA: 12 months or 2 releases (whichever is longer)**
   * **Beta: 3 months or 1 release (whichever is longer)**
   * **Alpha: 0 releases**
-->
<p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其
在以下时长内仍能使用：</strong></p>
<ul>
<li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha：0 发布版本</strong></li>
</ul>
<!--
**Rule #5b: CLI elements of admin-facing components (e.g. kubelet) must function
after their announced deprecation for no less than:**

   * **GA: 6 months or 1 release (whichever is longer)**
   * **Beta: 3 months or 1 release (whichever is longer)**
   * **Alpha: 0 releases**
-->
<p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用
之后以下时长内保持可用：</strong></p>
<ul>
<li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<!--
**Rule #6: Deprecated CLI elements must emit warnings (optionally disable)
when used.**
-->
<p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的
产生是可以被禁止的。</strong></p>
<!--
## Deprecating a feature or behavior

Occasionally a Kubernetes release needs to deprecate some feature or behavior
of the system that is not controlled by the API or CLI.  In this case, the
rules for deprecation are as follows:
-->
<h2 id="deprecating-a-feature-or-behavior">弃用某功能特性或行为 </h2>
<p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能
特性或者行为，而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，
其弃用规则如下：</p>
<!--
**Rule #7: Deprecated behaviors must function for no less than 1 year after their
announced deprecation.**
-->
<p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p>
<!--
This does not imply that all changes to the system are governed by this policy.
This applies only to significant, user-visible behaviors which impact the
correctness of applications running on Kubernetes or that impact the
administration of Kubernetes clusters, and which are being removed entirely.
-->
<p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p>
<!--
An exception to the above rule is _feature gates_. Feature gates are key=value
pairs that allow for users to enable/disable experimental features.

Feature gates are intended to cover the development life cycle of a feature - they
are not intended to be long-term APIs. As such, they are expected to be deprecated
and removed after a feature becomes GA or is dropped.
-->
<p>上述规则的一个例外是 <em>特性门控（Feature Gates）</em>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p>
<p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p>
<!--
As a feature moves through the stages, the associated feature gate evolves.
The feature life cycle matched to its corresponding feature gate is:

  * Alpha: the feature gate is disabled by default and can be enabled by the user.
  * Beta: the feature gate is enabled by default and can be disabled by the user.
  * GA: the feature gate is deprecated (see ["Deprecation"](#deprecation)) and becomes
  non-operational.
  * GA, deprecation window complete: the feature gate is removed and calls to it are
  no longer accepted.
-->
<p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p>
<ul>
<li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li>
<li>Beta：特性门控默认被弃用，可被用户显式禁用。</li>
<li>GA: 特性门控被弃用（参见<a href="#deprecation">弃用</a>），并且不再起作用。</li>
<li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li>
</ul>
<!--
### Deprecation

Features can be removed at any point in the life cycle prior to GA. When features are
removed prior to GA, their associated feature gates are also deprecated.

When an invocation tries to disable a non-operational feature gate, the call fails in order
to avoid unsupported scenarios that might otherwise run silently.
-->
<h3 id="deprecation">弃用  </h3>
<p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p>
<p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免
毫无迹象地执行一些不受支持的场景。</p>
<!--
In some cases, removing pre-GA features requires considerable time. Feature gates can remain
operational until their associated feature is fully removed, at which point the feature gate
itself can be deprecated.

When removing a feature gate for a GA feature also requires considerable time, calls to
feature gates may remain operational if the feature gate has no effect on the feature,
and if the feature gate causes no errors.
-->
<p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。特性门控
可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控
自身才可被弃用。</p>
<p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性
门控的调用可能一直被允许，前提是特性门控对功能本身无影响且特性门控不会
引发任何错误。</p>
<!--
Features intended to be disabled by users should include a mechanism for disabling the
feature in the associated feature gate.

Versioning for feature gates is different from the previously discussed components,
therefore the rules for deprecation are as follows:
-->
<p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p>
<p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p>
<!--
**Rule #8: Feature gates must be deprecated when the corresponding feature they control
transitions a lifecycle stage as follows. Feature gates must function for no less than:**

   * **Beta feature to GA: 6 months or 2 releases (whichever is longer)**
   * **Beta feature to EOL: 3 months or 1 release (whichever is longer)**
   * **Alpha feature to EOL: 0 releases**
-->
<p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控
必须被弃用。特性门控弃用时必须在以下时长内保持其功能可用：</strong></p>
<ul>
<li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li>
</ul>
<!--
**Rule #9: Deprecated feature gates must respond with a warning when used. When a feature gate
is deprecated it must be documented in both in the release notes and the corresponding CLI help.
Both warnings and documentation must indicate whether a feature gate is non-operational.**
-->
<p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被
弃用时，必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p>
<!--
## Deprecating a metric

Each component of the Kubernetes control-plane exposes metrics (usually the
`/metrics` endpoint), which are typically ingested by cluster administrators.
Not all metrics are the same: some metrics are commonly used as SLIs or used
to determine SLOs, these tend to have greater import. Other metrics are more
experimental in nature or are used primarily in the Kubernetes development
process.

Accordingly, metrics fall under two stability classes (`ALPHA` and `STABLE`);
this impacts removal of a metric during a Kubernetes release. These classes
are determined by the perceived importance of the metric. The rules for
deprecating and removing a metric are as follows:
-->
<h3 id="deprecating-a-metric">弃用度量值   </h3>
<p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p>
<p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p>
<!--
**Rule #9a: Metrics, for the corresponding stability class, must function for no less than:**

   * **STABLE: 4 releases or 12 months (whichever is longer)**
   * **ALPHA: 0 releases**

**Rule #9b: Metrics, after their _announced deprecation_, must function for no less than:**

   * **STABLE: 3 releases or 9 months (whichever is longer)**
   * **ALPHA: 0 releases**
-->
<p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<!--
Deprecated metrics will have their description text prefixed with a deprecation notice
string '(Deprecated from x.y)' and a warning log will be emitted during metric
registration. Like their stable undeprecated counterparts, deprecated metrics will
be automatically registered to the metrics endpoint and therefore visible.
-->
<p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p>
<!--
On a subsequent release (when the metric's `deprecatedVersion` is equal to
_current_kubernetes_version - 3_)), a deprecated metric will become a _hidden_ metric.
**_Unlike_** their deprecated counterparts, hidden metrics will _no longer_ be
automatically registered to the metrics endpoint (hence hidden). However, they
can be explicitly enabled through a command line flag on the binary
(`--show-hidden-metrics-for-version=`). This provides cluster admins an
escape hatch to properly migrate off of a deprecated metric, if they were not
able to react to the earlier deprecation warnings. Hidden metrics should be
deleted after one release.
-->
<p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于_当前 Kubernetes 版本 - 3_），
被弃用的度量值将变成 _隐藏（Hidden）_ metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p>
<!--
## Exceptions

No policy can cover every possible situation.  This policy is a living
document, and will evolve over time.  In practice, there will be situations
that do not fit neatly into this policy, or for which this policy becomes a
serious impediment.  Such situations should be discussed with SIGs and project
leaders to find the best solutions for those specific cases, always bearing in
mind that Kubernetes is committed to being a stable system that, as much as
possible, never breaks users. Exceptions will always be announced in all
relevant release notes.
-->
<h2 id="exceptions">例外  </h2>
<p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间
推移演化。在实践中，会有一些情况无法很好地匹配到这里的弃用策略，或者
这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目牵头人讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个
稳定的系统，至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况
都会在所有相关的发布说明中公布。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2479c39af50fd55b898a3bcfb5988077">5 - 已弃用 API 的迁移指南</h1>
    
	<!--
reviewers:
- liggitt
- lavalamp
- thockin
- smarterclayton
title: "Deprecated API Migration Guide"
weight: 45
content_type: reference
-->
<!-- overview -->
<!--
As the Kubernetes API evolves, APIs are periodically reorganized or upgraded.
When APIs evolve, the old API is deprecated and eventually removed.
This page contains information you need to know when migrating from
deprecated API versions to newer and more stable API versions.
-->
<p>随着 Kubernetes API 的演化，APIs 会周期性地被重组或升级。
当 APIs 演化时，老的 API 会被弃用并被最终删除。
本页面包含你在将已弃用 API 版本迁移到新的更稳定的 API 版本时需要了解的知识。</p>
<!-- body -->
<!--
## Removed APIs by release
-->
<h2 id="removed-apis-by-release">各发行版本中移除的 API </h2>
<h3 id="v1-26">v1.26</h3>
<!--
The **v1.26** release will stop serving the following deprecated API versions:
-->
<p><strong>v1.26</strong> 发行版本中将去除以下已弃用的 API 版本：</p>
<!--
#### Flow control resources {#flowcontrol-resources-v126}
-->
<h4 id="flowcontrol-resources-v126">流控制资源    </h4>
<!--
The **flowcontrol.apiserver.k8s.io/v1beta1** API version of FlowSchema and PriorityLevelConfiguration will no longer be served in v1.26.

* Migrate manifests and API clients to use the **flowcontrol.apiserver.k8s.io/v1beta2** API version, available since v1.23.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API 版本的 FlowSchema
和 PriorityLevelConfiguration 将不会在 v1.26 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="horizontalpodautoscaler-v126">HorizontalPodAutoscaler</h4>
<!--
The **autoscaling/v2beta2** API version of HorizontalPodAutoscaler will no longer be served in v1.26.

* Migrate manifests and API clients to use the **autoscaling/v2** API version, available since v1.23.
* All existing persisted objects are accessible via the new API
-->
<p><strong>autoscaling/v2beta2</strong> API 版本的 HorizontalPodAutoscaler 将不会在
v1.26 版本中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h3 id="v1-25">v1.25</h3>
<!--
The **v1.25** release will stop serving the following deprecated API versions:
-->
<p><strong>v1.25</strong> 发行版本将停止提供以下已废弃 API 版本：</p>
<h4 id="cronjob-v125">CronJob</h4>
<!--
The **batch/v1beta1** API version of CronJob will no longer be served in v1.25.

* Migrate manifests and API clients to use the **batch/v1** API version, available since v1.21.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>batch/v1beta1</strong> API 版本的 CronJob 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>batch/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="endpointslice-v125">EndpointSlice</h4>
<!--
The **discovery.k8s.io/v1beta1** API version of EndpointSlice will no longer be served in v1.25.

* Migrate manifests and API clients to use the **discovery.k8s.io/v1** API version, available since v1.21.
* All existing persisted objects are accessible via the new API
* Notable changes in **discovery.k8s.io/v1**:
    * use per Endpoint `nodeName` field instead of deprecated `topology["kubernetes.io/hostname"]` field
    * use per Endpoint `zone` field instead of deprecated `topology["topology.kubernetes.io/zone"]` field
    * `topology` is replaced with the `deprecatedTopology` field which is not writable in v1
-->
<p><strong>discovery.k8s.io/v1beta1</strong> API 版本的 EndpointSlice 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>discovery.k8s.io/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>discovery.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li>使用每个 Endpoint 的 <code>nodeName</code> 字段而不是已被弃用的
<code>topology[&quot;kubernetes.io/hostname&quot;]</code> 字段；</li>
<li>使用每个 Endpoint 的 <code>zone</code> 字段而不是已被弃用的
<code>topology[&quot;kubernetes.io/zone&quot;]</code> 字段；</li>
<li><code>topology</code> 字段被替换为 <code>deprecatedTopology</code>，并且在 v1 版本中不可写入。</li>
</ul>
</li>
</ul>
<h4 id="event-v125">Event</h4>
<!--
The **events.k8s.io/v1beta1** API version of Event will no longer be served in v1.25.

* Migrate manifests and API clients to use the **events.k8s.io/v1** API version, available since v1.19.
* All existing persisted objects are accessible via the new API
-->
<p><strong>events.k8s.io/v1beta1</strong> API 版本的 Event 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>events.k8s.io/v1</strong> API 版本，此 API 从 v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes in **events.k8s.io/v1**:
    * `type` is limited to `Normal` and `Warning`
    * `involvedObject` is renamed to `regarding`
    * `action`, `reason`, `reportingController`, and `reportingInstance` are required when creating new **events.k8s.io/v1** Events
    * use `eventTime` instead of the deprecated `firstTimestamp` field (which is renamed to `deprecatedFirstTimestamp` and not permitted in new **events.k8s.io/v1** Events)
    * use `series.lastObservedTime` instead of the deprecated `lastTimestamp` field (which is renamed to `deprecatedLastTimestamp` and not permitted in new **events.k8s.io/v1** Events)
    * use `series.count` instead of the deprecated `count` field (which is renamed to `deprecatedCount` and not permitted in new **events.k8s.io/v1** Events)
    * use `reportingController` instead of the deprecated `source.component` field (which is renamed to `deprecatedSource.component` and not permitted in new **events.k8s.io/v1** Events)
    * use `reportingInstance` instead of the deprecated `source.host` field (which is renamed to `deprecatedSource.host` and not permitted in new **events.k8s.io/v1** Events)
-->
<ul>
<li><strong>events.k8s.io/v1</strong> 中值得注意的变更有：
<ul>
<li><code>type</code> 字段只能设置为 <code>Normal</code> 和 <code>Warning</code> 之一；</li>
<li><code>involvedObject</code> 字段被更名为 <code>regarding</code>；</li>
<li><code>action</code>、<code>reason</code>、<code>reportingController</code> 和 <code>reportingInstance</code> 字段
在创建新的 <strong>events.k8s.io/v1</strong> 版本 Event 时都是必需的字段；</li>
<li>使用 <code>eventTime</code> 而不是已被弃用的 <code>firstTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedFirstTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.lastObservedTime</code> 而不是已被弃用的 <code>lastTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedLastTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>series.count</code> 而不是已被弃用的 <code>count</code> 字段
（该字段已被更名为 <code>deprecatedCount</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingController</code> 而不是已被弃用的 <code>source.component</code> 字段
（该字段已被更名为 <code>deprecatedSource.component</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li>
<li>使用 <code>reportingInstance</code> 而不是已被弃用的 <code>source.host</code> 字段
（该字段已被更名为 <code>deprecatedSource.host</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）。</li>
</ul>
</li>
</ul>
<h4 id="horizontalpodautoscaler-v125">HorizontalPodAutoscaler</h4>
<!--
The **autoscaling/v2beta1** API version of HorizontalPodAutoscaler will no longer be served in v1.25.

* Migrate manifests and API clients to use the **autoscaling/v2** API version, available since v1.23.
* All existing persisted objects are accessible via the new API
-->
<p><strong>autoscaling/v2beta1</strong> API 版本的 HorizontalPodAutoscaler 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，此 API 从 v1.23 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id="poddisruptionbudget-v125">PodDisruptionBudget</h4>
<!--
The **policy/v1beta1** API version of PodDisruptionBudget will no longer be served in v1.25.

* Migrate manifests and API clients to use the **policy/v1** API version, available since v1.21.
* All existing persisted objects are accessible via the new API
* Notable changes in **policy/v1**:
  * an empty `spec.selector` (`{}`) written to a `policy/v1` PodDisruptionBudget selects all pods in the namespace (in `policy/v1beta1` an empty `spec.selector` selected no pods). An unset `spec.selector` selects no pods in either API version.
-->
<p><strong>policy/v1beta1</strong> API 版本的 PodDisruptionBudget 将不会在 v1.25 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li><strong>policy/v1</strong> 中需要额外注意的变更有：
<ul>
<li>在 <code>policy/v1</code> 版本的 PodDisruptionBudget 中将 <code>spec.selector</code>
设置为空（<code>{}</code>）时会选择名字空间中的所有 Pods（在 <code>policy/v1beta1</code>
版本中，空的 <code>spec.selector</code> 不会选择任何 Pods）。如果 <code>spec.selector</code>
未设置，则在两个 API 版本下都不会选择任何 Pods。</li>
</ul>
</li>
</ul>
<h4 id="psp-v125">PodSecurityPolicy</h4>
<!--
PodSecurityPolicy in the **policy/v1beta1** API version will no longer be served in v1.25, and the PodSecurityPolicy admission controller will be removed.

PodSecurityPolicy replacements are still under discussion, but current use can be migrated to
[3rd-party admission webhooks](/docs/reference/access-authn-authz/extensible-admission-controllers/) now.
-->
<p><strong>policy/v1beta1</strong> API 版本中的 PodSecurityPolicy 将不会在 v1.25 中提供，
并且 PodSecurityPolicy 准入控制器也会被删除。</p>
<p>PodSecurityPolicy 的替换方案仍在讨论过程中，不过当前的用法可以迁移到
<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">第三方准入性质的 Webhook</a>。</p>
<h4 id="runtimeclass-v125">RuntimeClass</h4>
<!--
RuntimeClass in the **node.k8s.io/v1beta1** API version will no longer be served in v1.25.

* Migrate manifests and API clients to use the **node.k8s.io/v1** API version, available since v1.20.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>node.k8s.io/v1beta1</strong> API 版本中的 RuntimeClass 将不会在 v1.25 中提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>node.k8s.io/v1</strong> API 版本，此 API 从 v1.20 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id="v1-22">v1.22</h3>
<!--
The **v1.22** release stopped serving the following deprecated API versions:
-->
<p><strong>v1.22</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<!--
#### Webhook resources {#webhook-resources-v122}
-->
<h4 id="webhook-resources-v122">Webhook 资源  </h4>
<!--
The **admissionregistration.k8s.io/v1beta1** API version of MutatingWebhookConfiguration and ValidatingWebhookConfiguration is no longer served as of v1.22.
-->
<p><strong>admissionregistration.k8s.io/v1beta1</strong> API 版本的 MutatingWebhookConfiguration
和 ValidatingWebhookConfiguration 不在 v1.22 版本中继续提供。</p>
<!--
* Migrate manifests and API clients to use the **admissionregistration.k8s.io/v1** API version, available since v1.16.
* All existing persisted objects are accessible via the new APIs
-->
<ul>
<li>迁移清单和 API 客户端使用 <strong>admissionregistration.k8s.io/v1</strong> API 版本，
此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `webhooks[*].failurePolicy` default changed from `Ignore` to `Fail` for v1
    * `webhooks[*].matchPolicy` default changed from `Exact` to `Equivalent` for v1
    * `webhooks[*].timeoutSeconds` default changed from `30s` to `10s` for v1
    * `webhooks[*].sideEffects` default value is removed, and the field made required, and only `None` and `NoneOnDryRun` are permitted for v1
    * `webhooks[*].admissionReviewVersions` default value is removed and the field made required for v1 (supported versions for AdmissionReview are `v1` and `v1beta1`)
    * `webhooks[*].name` must be unique in the list for objects created via `admissionregistration.k8s.io/v1`
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>webhooks[*].failurePolicy</code> 在 v1 版本中默认值从 <code>Ignore</code> 改为 <code>Fail</code></li>
<li><code>webhooks[*].matchPolicy</code> 在 v1 版本中默认值从 <code>Exact</code> 改为 <code>Equivalent</code></li>
<li><code>webhooks[*].timeoutSeconds</code> 在 v1 版本中默认值从 <code>30s</code> 改为 <code>10s</code></li>
<li><code>webhooks[*].sideEffects</code> 的默认值被删除，并且该字段变为必须指定；
在 v1 版本中可选的值只能是 <code>None</code> 和 <code>NoneOnDryRun</code> 之一</li>
<li><code>webhooks[*].admissionReviewVersions</code> 的默认值被删除，在 v1
版本中此字段变为必须指定（AdmissionReview 的被支持版本包括 <code>v1</code> 和 <code>v1beta1</code>）</li>
<li><code>webhooks[*].name</code> 必须在通过 <code>admissionregistration.k8s.io/v1</code>
创建的对象列表中唯一</li>
</ul>
</li>
</ul>
<h4 id="customresourcedefinition-v122">CustomResourceDefinition</h4>
<!--
The **apiextensions.k8s.io/v1beta1** API version of CustomResourceDefinition is no longer served as of v1.22.

* Migrate manifests and API clients to use the **apiextensions.k8s.io/v1** API version, available since v1.16.
* All existing persisted objects are accessible via the new API
-->
<p><strong>apiextensions.k8s.io/v1beta1</strong> API 版本的 CustomResourceDefinition
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiextensions/v1</strong> API 版本，此 API 从 v1.16 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.scope` is no longer defaulted to `Namespaced` and must be explicitly specified
    * `spec.version` is removed in v1; use `spec.versions` instead
    * `spec.validation` is removed in v1; use `spec.versions[*].schema` instead
    * `spec.subresources` is removed in v1; use `spec.versions[*].subresources` instead
    * `spec.additionalPrinterColumns` is removed in v1; use `spec.versions[*].additionalPrinterColumns` instead
    * `spec.conversion.webhookClientConfig` is moved to `spec.conversion.webhook.clientConfig` in v1
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.scope</code> 的默认值不再是 <code>Namespaced</code>，该字段必须显式指定</li>
<li><code>spec.version</code> 在 v1 版本中被删除；应改用 <code>spec.versions</code></li>
<li><code>spec.validation</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].schema</code></li>
<li><code>spec.subresources</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].subresources</code></li>
<li><code>spec.additionalPrinterColumns</code> 在 v1 版本中被删除；应改用
<code>spec.versions[*].additionalPrinterColumns</code></li>
<li><code>spec.conversion.webhookClientConfig</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.clientConfig</code> 中</li>
</ul>
  <!--
  * `spec.conversion.conversionReviewVersions` is moved to `spec.conversion.webhook.conversionReviewVersions` in v1
  * `spec.versions[*].schema.openAPIV3Schema` is now required when creating v1 CustomResourceDefinition objects, and must be a [structural schema](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema)
  * `spec.preserveUnknownFields: true` is disallowed when creating v1 CustomResourceDefinition objects; it must be specified within schema definitions as `x-kubernetes-preserve-unknown-fields: true`
  * In `additionalPrinterColumns` items, the `JSONPath` field was renamed to `jsonPath` in v1 (fixes [#66531](https://github.com/kubernetes/kubernetes/issues/66531))
  -->
<ul>
<li><code>spec.conversion.conversionReviewVersions</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.conversionReviewVersions</code></li>
<li><code>spec.versions[*].schema.openAPIV3Schema</code> 在创建 v1 版本的
CustomResourceDefinition 对象时变成必需字段，并且其取值必须是一个
<a href="/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">结构化的 Schema</a></li>
<li><code>spec.preserveUnknownFields: true</code> 在创建 v1 版本的 CustomResourceDefinition
对象时不允许指定；该配置必须在 Schema 定义中使用
<code>x-kubernetes-preserve-unknown-fields: true</code> 来设置</li>
<li>在 v1 版本中，<code>additionalPrinterColumns</code> 的条目中的 <code>JSONPath</code> 字段被更名为
<code>jsonPath</code>（补丁 <a href="https://github.com/kubernetes/kubernetes/issues/66531">#66531</a>）</li>
</ul>
</li>
</ul>
<h4 id="apiservice-v122">APIService</h4>
<!--
The **apiregistration.k8s.io/v1beta1** API version of APIService is no longer served as of v1.22.

* Migrate manifests and API clients to use the **apiregistration.k8s.io/v1** API version, available since v1.10.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>apiregistration/v1beta1</strong> API 版本的 APIService 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apiregistration.k8s.io/v1</strong> API 版本，此 API 从
v1.10 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="tokenreview-v122">TokenReview</h4>
<!--
The **authentication.k8s.io/v1beta1** API version of TokenReview is no longer served as of v1.22.

* Migrate manifests and API clients to use the **authentication.k8s.io/v1** API version, available since v1.6.
* No notable changes
-->
<p><strong>authentication.k8s.io/v1beta1</strong> API 版本的 TokenReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authentication.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="subjectaccessreview-resources-v122">SubjectAccessReview resources</h4>
<!--
The **authorization.k8s.io/v1beta1** API version of LocalSubjectAccessReview, SelfSubjectAccessReview, and SubjectAccessReview is no longer served as of v1.22.

* Migrate manifests and API clients to use the **authorization.k8s.io/v1** API version, available since v1.6.
* Notable changes:
    * `spec.group` was renamed to `spec.groups` in v1 (fixes [#32709](https://github.com/kubernetes/kubernetes/issues/32709))
-->
<p><strong>authorization.k8s.io/v1beta1</strong> API 版本的 LocalSubjectAccessReview、
SelfSubjectAccessReview、SubjectAccessReview 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>需要额外注意的变更：
<ul>
<li><code>spec.group</code> 在 v1 版本中被更名为 <code>spec.groups</code>
（补丁 <a href="https://github.com/kubernetes/kubernetes/issues/32709">#32709</a>）</li>
</ul>
</li>
</ul>
<h4 id="certificatesigningrequest-v122">CertificateSigningRequest</h4>
<!--
The **certificates.k8s.io/v1beta1** API version of CertificateSigningRequest is no longer served as of v1.22.

* Migrate manifests and API clients to use the **certificates.k8s.io/v1** API version, available since v1.19.
* All existing persisted objects are accessible via the new API
-->
<p><strong>certificates.k8s.io/v1beta1</strong> API 版本的 CertificateSigningRequest 不在
v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>certificates.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes in `certificates.k8s.io/v1`:
    * For API clients requesting certificates:
        * `spec.signerName` is now required (see [known Kubernetes signers](/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers)), and requests for `kubernetes.io/legacy-unknown` are not allowed to be created via the `certificates.k8s.io/v1` API
        * `spec.usages` is now required, may not contain duplicate values, and must only contain known usages
    * For API clients approving or signing certificates:
        * `status.conditions` may not contain duplicate types
        * `status.conditions[*].status` is now required
        * `status.certificate` must be PEM-encoded, and contain only `CERTIFICATE` blocks
-->
<ul>
<li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：
<ul>
<li>对于请求证书的 API 客户端而言：
<ul>
<li><code>spec.signerName</code> 现在变成必需字段（参阅
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers">已知的 Kubernetes 签署者</a>），
并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为
<code>kubernetes.io/legacy-unknown</code> 的请求</li>
<li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值，
并且只能包含已知的用法字符串</li>
</ul>
</li>
<li>对于要批准或者签署证书的 API 客户端而言：
<ul>
<li><code>status.conditions</code> 中不可以包含重复的类型</li>
<li><code>status.conditions[*].status</code> 字段现在变为必需字段</li>
<li><code>status.certificate</code> 必须是 PEM 编码的，而且其中只能包含 <code>CERTIFICATE</code>
数据块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lease-v122">Lease</h4>
<!--
The **coordination.k8s.io/v1beta1** API version of Lease is no longer served as of v1.22.

* Migrate manifests and API clients to use the **coordination.k8s.io/v1** API version, available since v1.14.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>coordination.k8s.io/v1beta1</strong> API 版本的 Lease 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>coordination.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="ingress-v122">Ingress</h4>
<!--
The **extensions/v1beta1** and **networking.k8s.io/v1beta1** API versions of Ingress is no longer served as of v1.22.

* Migrate manifests and API clients to use the **networking.k8s.io/v1** API version, available since v1.19.
* All existing persisted objects are accessible via the new API
-->
<p><strong>extensions/v1beta1</strong> 和 <strong>networking.k8s.io/v1beta1</strong> API 版本的 Ingress
不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.backend` is renamed to `spec.defaultBackend`
    * The backend `serviceName` field is renamed to `service.name`
    * Numeric backend `servicePort` fields are renamed to `service.port.number`
    * String backend `servicePort` fields are renamed to `service.port.name`
    * `pathType` is now required for each specified path. Options are `Prefix`, `Exact`, and `ImplementationSpecific`. To match the undefined `v1beta1` behavior, use `ImplementationSpecific`.
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.backend</code> 字段被更名为 <code>spec.defaultBackend</code></li>
<li>后端的  <code>serviceName</code> 字段被更名为 <code>service.name</code></li>
<li>数值表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.number</code></li>
<li>字符串表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.name</code></li>
<li>对所有要指定的路径，<code>pathType</code> 都成为必需字段。
可选项为 <code>Prefix</code>、<code>Exact</code> 和 <code>ImplementationSpecific</code>。
要匹配 <code>v1beta1</code> 版本中未定义路径类型时的行为，可使用 <code>ImplementationSpecific</code></li>
</ul>
</li>
</ul>
<h4 id="ingressclass-v122">IngressClass</h4>
<!--
The **networking.k8s.io/v1beta1** API version of IngressClass is no longer served as of v1.22.

* Migrate manifests and API clients to use the **networking.k8s.io/v1** API version, available since v1.19.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>networking.k8s.io/v1beta1</strong> API 版本的 IngressClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<!--
#### RBAC resources  {#rbac-resources-v122}

The **rbac.authorization.k8s.io/v1beta1** API version of ClusterRole, ClusterRoleBinding, Role, and RoleBinding is no longer served as of v1.22.

* Migrate manifests and API clients to use the **rbac.authorization.k8s.io/v1** API version, available since v1.8.
* All existing persisted objects are accessible via the new APIs
* No notable changes
-->
<h4 id="rbac-resources-v122">RBAC 资源  </h4>
<p><strong>rbac.authorization.k8s.io/v1beta1</strong> API 版本的 ClusterRole、ClusterRoleBinding、
Role 和 RoleBinding 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>rbac.authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h4 id="priorityclass-v122">PriorityClass</h4>
<!--
The **scheduling.k8s.io/v1beta1** API version of PriorityClass is no longer served as of v1.22.

* Migrate manifests and API clients to use the **scheduling.k8s.io/v1** API version, available since v1.14.
* All existing persisted objects are accessible via the new API
* No notable changes
-->
<p><strong>scheduling.k8s.io/v1beta1</strong> API 版本的 PriorityClass 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>scheduling.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<!--
#### Storage resources {#storage-resources-v122}
-->
<h4 id="storage-resources-v122">存储资源 </h4>
<!--
The **storage.k8s.io/v1beta1** API version of CSIDriver, CSINode, StorageClass, and VolumeAttachment is no longer served as of v1.22.

* Migrate manifests and API clients to use the **storage.k8s.io/v1** API version
  * CSIDriver is available in **storage.k8s.io/v1** since v1.19.
  * CSINode is available in **storage.k8s.io/v1** since v1.17
  * StorageClass is available in **storage.k8s.io/v1** since v1.6
  * VolumeAttachment is available in **storage.k8s.io/v1** v1.13
* All existing persisted objects are accessible via the new APIs
* No notable changes
-->
<p><strong>storage.k8s.io/v1beta1</strong> API 版本的 CSIDriver、CSINode、StorageClass
和 VolumeAttachment 不在 v1.22 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>storage.k8s.io/v1</strong> API 版本
<ul>
<li>CSIDriver 从 v1.19 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>CSINode 从 v1.17 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>StorageClass 从 v1.6 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
<li>VolumeAttachment 从 v1.13 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li>
</ul>
</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
<li>没有需要额外注意的变更</li>
</ul>
<h3 id="v1-16">v1.16</h3>
<!--
The **v1.16** release stopped serving the following deprecated API versions:
-->
<p><strong>v1.16</strong> 发行版本停止提供以下已废弃 API 版本：</p>
<h4 id="networkpolicy-v116">NetworkPolicy</h4>
<!--
The **extensions/v1beta1** API version of NetworkPolicy is no longer served as of v1.16.

* Migrate manifests and API clients to use the **networking.k8s.io/v1** API version, available since v1.8.
* All existing persisted objects are accessible via the new API
-->
<p><strong>extensions/v1beta1</strong> API 版本的 NetworkPolicy 不在 v1.16 版本中继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<h4 id="daemonset-v116">DaemonSet</h4>
<!--
The **extensions/v1beta1** and **apps/v1beta2** API versions of DaemonSet are no longer served as of v1.16.

* Migrate manifests and API clients to use the **apps/v1** API version, available since v1.9.
* All existing persisted objects are accessible via the new API
-->
<p><strong>extensions/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 DaemonSet 在
v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.templateGeneration` is removed
    * `spec.selector` is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades
    * `spec.updateStrategy.type` now defaults to `RollingUpdate` (the default in `extensions/v1beta1` was `OnDelete`)
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.templateGeneration</code> 字段被删除</li>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>extensions/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id="deployment-v116">Deployment</h4>
<!--
The **extensions/v1beta1**, **apps/v1beta1**, and **apps/v1beta2** API versions of Deployment are no longer served as of v1.16.

* Migrate manifests and API clients to use the **apps/v1** API version, available since v1.9.
* All existing persisted objects are accessible via the new API
-->
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
Deployment 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.rollbackTo` is removed
    * `spec.selector` is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades
    * `spec.progressDeadlineSeconds` now defaults to `600` seconds (the default in `extensions/v1beta1` was no deadline)
    * `spec.revisionHistoryLimit` now defaults to `10` (the default in `apps/v1beta1` was `2`, the default in `extensions/v1beta1` was to retain all)
    * `maxSurge` and `maxUnavailable` now default to `25%` (the default in `extensions/v1beta1` was `1`)
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.rollbackTo</code> 字段被删除</li>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 Deployment 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.progressDeadlineSeconds</code> 的默认值变为 <code>600</code> 秒
（<code>extensions/v1beta1</code> 中的默认值是没有期限）</li>
<li><code>spec.revisionHistoryLimit</code> 的默认值变为 <code>10</code>
（<code>apps/v1beta1</code> API 版本中此字段默认值为 <code>2</code>，在<code>extensions/v1beta1</code> API
版本中的默认行为是保留所有历史记录）。</li>
<li><code>maxSurge</code> 和 <code>maxUnavailable</code> 的默认值变为 <code>25%</code>
（在 <code>extensions/v1beta1</code> API 版本中，这些字段的默认值是 <code>1</code>）。</li>
</ul>
</li>
</ul>
<h4 id="statefulset-v116">StatefulSet</h4>
<!--
The **apps/v1beta1** and **apps/v1beta2** API versions of StatefulSet are no longer served as of v1.16.

* Migrate manifests and API clients to use the **apps/v1** API version, available since v1.9.
* All existing persisted objects are accessible via the new API
-->
<p><strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 StatefulSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.selector` is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades
    * `spec.updateStrategy.type` now defaults to `RollingUpdate` (the default in `apps/v1beta1` was `OnDelete`)
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 字段现在变为必需字段，并且在 StatefulSet 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li>
<li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>apps/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li>
</ul>
</li>
</ul>
<h4 id="replicaset-v116">ReplicaSet</h4>
<!--
The **extensions/v1beta1**, **apps/v1beta1**, and **apps/v1beta2** API versions of ReplicaSet are no longer served as of v1.16.

* Migrate manifests and API clients to use the **apps/v1** API version, available since v1.9.
* All existing persisted objects are accessible via the new API
-->
<p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
ReplicaSet 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li>
<li>所有的已保存的对象都可以通过新的 API 来访问；</li>
</ul>
<!--
* Notable changes:
    * `spec.selector` is now required and immutable after creation; use the existing template labels as the selector for seamless upgrades
-->
<ul>
<li>值得注意的变更：
<ul>
<li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li>
</ul>
</li>
</ul>
<h4 id="psp-v116">PodSecurityPolicy</h4>
<!--
The **extensions/v1beta1** API version of PodSecurityPolicy is no longer served as of v1.16.

* Migrate manifests and API client to use the **policy/v1beta1** API version, available since v1.10.
* Note that the **policy/v1beta1** API version of PodSecurityPolicy will be removed in v1.25.
-->
<p><strong>extensions/v1beta1</strong> API 版本的 PodSecurityPolicy 在 v1.16 版本中不再继续提供。</p>
<ul>
<li>迁移清单和 API 客户端使用 <strong>policy/v1beta1</strong> API 版本，此 API 从 v1.10 版本开始可用；</li>
<li>注意 <strong>policy/v1beta1</strong> API 版本的 PodSecurityPolicy 会在 v1.25 版本中移除。</li>
</ul>
<!--
## What to do

### Test with deprecated APIs disabled
-->
<h2 id="what-to-do">需要做什么  </h2>
<h3 id="在禁用已启用-api-的情况下执行测试">在禁用已启用 API 的情况下执行测试</h3>
<!--
You can test your clusters by starting an API server with specific API versions disabled
to simulate upcoming removals. Add the following flag to the API server startup arguments:
-->
<p>你可以通过在启动 API 服务器时禁用特定的 API 版本来模拟即将发生的
API 移除，从而完成测试。在 API 服务器启动参数中添加如下标志：</p>
<p><code>--runtime-config=&lt;group&gt;/&lt;version&gt;=false</code></p>
<!--
For example:
-->
<p>例如：</p>
<p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p>
<!--
### Locate use of deprecated APIs

Use [client warnings, metrics, and audit information available in 1.19+](https://kubernetes.io/blog/2020/09/03/warnings/#deprecation-warnings)
to locate use of deprecated APIs.
-->
<h3 id="定位何处使用了已弃用的-api">定位何处使用了已弃用的 API</h3>
<p>使用 <a href="https://kubernetes.io/blog/2020/09/03/warnings/#deprecation-warnings">client warnings, metrics, and audit information available in 1.19+</a>
来定位在何处使用了已启用的 API。</p>
<!--
### Migrate to non-deprecated APIs
-->
<h3 id="迁移到未被弃用的-api">迁移到未被弃用的 API</h3>
<!--
* Update custom integrations and controllers to call the non-deprecated APIs
* Change YAML files to reference the non-deprecated APIs
-->
<ul>
<li>更新自定义的集成组件和控制器，调用未被弃用的 API</li>
<li>更改 YAML 文件引用未被弃用的 API</li>
</ul>
<!--
You can use the `kubectl-convert` command (`kubectl convert` prior to v1.20)
to automatically convert an existing object:
-->
<p>你可以用 <code>kubectl-convert</code> 命令（在 v1.20 之前是 <code>kubectl convert</code>）
来自动转换现有对象：</p>
<p><code>kubectl-convert -f &lt;file&gt; --output-version &lt;group&gt;/&lt;version&gt;</code>.</p>
<!--
For example, to convert an older Deployment to `apps/v1`, you can run:
-->
<p>例如，要将较老的 Deployment 转换为 <code>apps/v1</code> 版本，你可以运行</p>
<p><code>kubectl-convert -f ./my-deployment.yaml --output-version apps/v1</code></p>
<!--
Note that this may use non-ideal default values. To learn more about a specific
resource, check the Kubernetes [API reference](/docs/reference/kubernetes-api/).
-->
<p>注意这种操作生成的结果中可能使用的默认值并不理想。
要进一步了解某个特定资源，可查阅 Kubernetes <a href="/zh/docs/reference/kubernetes-api/">API 参考</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e4dbb59f8f23854d7b7d574e169923c4">6 - Kubernetes API 健康端点</h1>
    
	<!-- 
title: Kubernetes API health endpoints
reviewers:
- logicalhan
content_type: concept
weight: 50
 -->
<!-- overview -->
<!-- 
The Kubernetes <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API server'>API server</a> provides API endpoints to indicate the current status of the API server.
This page describes these API endpoints and explains how you can use them. 
-->
<p>Kubernetes <a class='glossary-tooltip' title='提供 Kubernetes API 服务的控制面组件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/command-line-tools-reference/kube-apiserver/' target='_blank' aria-label='API 服务器'>API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p>
<!-- body -->
<!-- ## API endpoints for health -->
<h2 id="api-endpoints-for-health">API 健康端点 </h2>
<!-- 
The Kubernetes API server provides 3 API endpoints (`healthz`, `livez` and `readyz`) to indicate the current status of the API server.
The `healthz` endpoint is deprecated (since Kubernetes v1.16), and you should use the more specific `livez` and `readyz` endpoints instead.
The `livez` endpoint can be used with the `--livez-grace-period` [flag](/docs/reference/command-line-tools-reference/kube-apiserver) to specify the startup duration.
For a graceful shutdown you can specify the `--shutdown-delay-duration` [flag](/docs/reference/command-line-tools-reference/kube-apiserver) with the `/readyz` endpoint.
Machines that check the `healthz`/`livez`/`readyz` of the API server should rely on the HTTP status code.
A status code `200` indicates the API server is `healthy`/`live`/`ready`, depending on the called endpoint.
The more verbose options shown below are intended to be used by human operators to debug their cluster or understand the state of the API server.
-->
<p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver">标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href="/zh/docs/reference/command-line-tools-reference/kube-apiserver">标志</a>。
检查 API 服务器的 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或了解 API 服务器的状态。</p>
<!-- The following examples will show how you can interact with the health API endpoints. -->
<p>以下示例将显示如何与运行状况 API 端点进行交互。</p>
<!-- 
For all endpoints, you can use the `verbose` parameter to print out the checks and their status.
This can be useful for a human operator to debug the current status of the API server, it is not intended to be consumed by a machine:
-->
<p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k https://localhost:6443/livez?verbose
</code></pre></div><!-- or from a remote host with authentication: -->
<p>或从具有身份验证的远程主机：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get --raw<span style="color:#666">=</span><span style="color:#b44">&#39;/readyz?verbose&#39;</span>
</code></pre></div><!-- The output will look like this: -->
<p>输出将如下所示：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><!-- 
The Kubernetes API server also supports to exclude specific checks.
The query parameters can also be combined like in this example:
-->
<p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k <span style="color:#b44">&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</code></pre></div><!-- The output show that the `etcd` check is excluded: -->
<p>输出显示排除了 <code>etcd</code> 检查：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><!-- ## Individual health checks -->
<h2 id="individual-health-check">独立健康检查 </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code>
</div>


<!-- 
Each individual health check exposes an HTTP endpoint and can be checked individually.
The schema for the individual health checks is `/livez/<healthcheck-name>` where `livez` and `readyz` and be used to indicate if you want to check the liveness or the readiness of the API server.
The `<healthcheck-name>` path can be discovered using the `verbose` flag from above and take the path between `[+]` and `ok`.
These individual health checks should not be consumed by machines but can be helpful for a human operator to debug a system:
-->
<p>每个单独的健康检查都会公开一个 HTTP 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name&gt;</code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name&gt;</code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl -k https://localhost:6443/livez/etcd
</code></pre></div>
</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
