<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/reference/setup-tools/kubeadm/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/reference/setup-tools/kubeadm/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/reference/setup-tools/kubeadm/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/reference/setup-tools/kubeadm/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/reference/setup-tools/kubeadm/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/reference/setup-tools/kubeadm/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/reference/setup-tools/kubeadm/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>Kubeadm | Kubernetes</title><meta property="og:title" content="Kubeadm" />
<meta property="og:description" content="生产级别的容器编排系统" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/setup-tools/kubeadm/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="Kubeadm">
<meta itemprop="description" content="生产级别的容器编排系统"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kubeadm"/>
<meta name="twitter:description" content="生产级别的容器编排系统"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="Kubeadm 是一个提供了 kubeadm init 和 kubeadm join 的工具， 作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。
kubeadm 通过执行必要的操作来启动和运行最小可用集群。 按照设计，它只关注启动引导，而非配置机器。同样的， 安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、 监控方案、以及特定云平台的扩展，都不在讨论范围内。
相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具， 理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。
如何安装 要安装 kubeadm, 请查阅 安装指南.
What&#39;s next  kubeadm init 用于搭建控制平面节点 kubeadm join 用于搭建工作节点并将其加入到集群中 kubeadm upgrade 用于升级 Kubernetes 集群到新版本 kubeadm config 如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用 kubeadm upgrade 来配置你的集群 kubeadm token 用于管理 kubeadm join 使用的令牌 kubeadm reset 用于恢复通过 kubeadm init 或者 kubeadm join 命令对节点进行的任何变更 kubeadm certs 用于管理 Kubernetes 证书 kubeadm kubeconfig 用于管理 kubeconfig 文件 kubeadm version 用于打印 kubeadm 的版本信息 kubeadm alpha 用于预览一组可用于收集社区反馈的特性  ">
<meta property="og:description" content="Kubeadm 是一个提供了 kubeadm init 和 kubeadm join 的工具， 作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。
kubeadm 通过执行必要的操作来启动和运行最小可用集群。 按照设计，它只关注启动引导，而非配置机器。同样的， 安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、 监控方案、以及特定云平台的扩展，都不在讨论范围内。
相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具， 理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。
如何安装 要安装 kubeadm, 请查阅 安装指南.
What&#39;s next  kubeadm init 用于搭建控制平面节点 kubeadm join 用于搭建工作节点并将其加入到集群中 kubeadm upgrade 用于升级 Kubernetes 集群到新版本 kubeadm config 如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用 kubeadm upgrade 来配置你的集群 kubeadm token 用于管理 kubeadm join 使用的令牌 kubeadm reset 用于恢复通过 kubeadm init 或者 kubeadm join 命令对节点进行的任何变更 kubeadm certs 用于管理 Kubernetes 证书 kubeadm kubeconfig 用于管理 kubeconfig 文件 kubeadm version 用于打印 kubeadm 的版本信息 kubeadm alpha 用于预览一组可用于收集社区反馈的特性  ">
<meta name="twitter:description" content="Kubeadm 是一个提供了 kubeadm init 和 kubeadm join 的工具， 作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。
kubeadm 通过执行必要的操作来启动和运行最小可用集群。 按照设计，它只关注启动引导，而非配置机器。同样的， 安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、 监控方案、以及特定云平台的扩展，都不在讨论范围内。
相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具， 理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。
如何安装 要安装 kubeadm, 请查阅 安装指南.
What&#39;s next  kubeadm init 用于搭建控制平面节点 kubeadm join 用于搭建工作节点并将其加入到集群中 kubeadm upgrade 用于升级 Kubernetes 集群到新版本 kubeadm config 如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用 kubeadm upgrade 来配置你的集群 kubeadm token 用于管理 kubeadm join 使用的令牌 kubeadm reset 用于恢复通过 kubeadm init 或者 kubeadm join 命令对节点进行的任何变更 kubeadm certs 用于管理 Kubernetes 证书 kubeadm kubeconfig 用于管理 kubeconfig 文件 kubeadm version 用于打印 kubeadm 的版本信息 kubeadm alpha 用于预览一组可用于收集社区反馈的特性  ">
<meta property="og:url" content="http://localhost:1313/zh/docs/reference/setup-tools/kubeadm/">
<meta property="og:title" content="Kubeadm">
<meta name="twitter:title" content="Kubeadm">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/reference/setup-tools/kubeadm/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/reference/setup-tools/kubeadm/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/reference/setup-tools/kubeadm/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/reference/setup-tools/kubeadm/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/reference/setup-tools/kubeadm/">Français</a>
	
	<a class="dropdown-item" href="/es/docs/reference/setup-tools/kubeadm/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/reference/setup-tools/kubeadm/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/reference/setup-tools/kubeadm/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">Kubeadm</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-36c22b52e8447eb3d2452d4f56fbea9b">创建 Kubeadm</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>1.1: <a href="#pg-fd3ad295c1f10bfa333f841bbdffba81"></a></li>


    
  
    
    
	
<li>1.2: <a href="#pg-8df9aba508b2736a6712ef46227eea7d"></a></li>


    
  
    
    
	
<li>1.3: <a href="#pg-018648dfc6f28bc9b969f45af0563cae"></a></li>


    
  
    
    
	
<li>1.4: <a href="#pg-4a1ff27cdf01c1c47d034278048e776b"></a></li>


    
  
    
    
	
<li>1.5: <a href="#pg-5d6b2999153cd86f56329534249fc4ec"></a></li>


    
  
    
    
	
<li>1.6: <a href="#pg-adb5eecdc351074cc2e0cc2b1b4f04a8"></a></li>


    
  
    
    
	
<li>1.7: <a href="#pg-df4c2dc6cba0be90d8d7de2fca9b87f7"></a></li>


    
  
    
    
	
<li>1.8: <a href="#pg-6d6746e8ac1f1602f7dab1056b27e5c2"></a></li>


    
  
    
    
	
<li>1.9: <a href="#pg-7449c7fa06f25b967cf531e937b0f4b2"></a></li>


    
  
    
    
	
<li>1.10: <a href="#pg-b5c6ae77d3be9bd358c68667006cfc18"></a></li>


    
  
    
    
	
<li>1.11: <a href="#pg-4f804e59ec1739e733807d2b591d771f"></a></li>


    
  
    
    
	
<li>1.12: <a href="#pg-f5cf8caa95834803b133d53c321ab4a9"></a></li>


    
  
    
    
	
<li>1.13: <a href="#pg-ee770858e2bb767b79d572b4882af656"></a></li>


    
  
    
    
	
<li>1.14: <a href="#pg-7484bf11b6183f4c329b1f66734cc886"></a></li>


    
  
    
    
	
<li>1.15: <a href="#pg-bf444d915ab856dba693c36294c5427b"></a></li>


    
  
    
    
	
<li>1.16: <a href="#pg-f5c087e087714c5290b4967dd7924b3b"></a></li>


    
  
    
    
	
<li>1.17: <a href="#pg-20703ce1c236264ad78cb1ad7244723e"></a></li>


    
  
    
    
	
<li>1.18: <a href="#pg-49aaa494ef75de67609987a43e5ee520"></a></li>


    
  
    
    
	
<li>1.19: <a href="#pg-d63311c16e6468f5a5940aadd902faa7"></a></li>


    
  
    
    
	
<li>1.20: <a href="#pg-6678a79b85306310066616185153377d"></a></li>


    
  
    
    
	
<li>1.21: <a href="#pg-8f73e208cc67d221165f6294393881a7"></a></li>


    
  
    
    
	
<li>1.22: <a href="#pg-9aec3477159c105a46f4479de1c21418"></a></li>


    
  
    
    
	
<li>1.23: <a href="#pg-045e41c28798930e21f77a90c3a90263"></a></li>


    
  
    
    
	
<li>1.24: <a href="#pg-e7d83478123771ad14f475ee44440303"></a></li>


    
  
    
    
	
<li>1.25: <a href="#pg-57a6b20d9571220989a7a445d4459468"></a></li>


    
  
    
    
	
<li>1.26: <a href="#pg-92a2c11eef37937af846b55d9b87a544"></a></li>


    
  
    
    
	
<li>1.27: <a href="#pg-dcfffcaafb438cd650475945ddc129ee"></a></li>


    
  
    
    
	
<li>1.28: <a href="#pg-6eaa2624c512051ff2a9cdbc6ee54949"></a></li>


    
  
    
    
	
<li>1.29: <a href="#pg-4b7ada30e3923594b2907dcb8b431080"></a></li>


    
  
    
    
	
<li>1.30: <a href="#pg-6d1154da2e554de858cf4e7b37c054fa"></a></li>


    
  
    
    
	
<li>1.31: <a href="#pg-d3a16914ddc849435ed864163978ddbf"></a></li>


    
  
    
    
	
<li>1.32: <a href="#pg-8a257337ea78e5d9a0c54aa971eaf991"></a></li>


    
  
    
    
	
<li>1.33: <a href="#pg-77759011117e7974cbfee9694b6f8801"></a></li>


    
  
    
    
	
<li>1.34: <a href="#pg-8e1920b2caaa8de839cd3997edca80e9"></a></li>


    
  
    
    
	
<li>1.35: <a href="#pg-00aa8c2e4b3b2fd3a4b7986976b7bfda"></a></li>


    
  
    
    
	
<li>1.36: <a href="#pg-316aa97ee5719be5a723ac1b77c44f5a"></a></li>


    
  
    
    
	
<li>1.37: <a href="#pg-759e85e62b32c0697ab37c214e99a864"></a></li>


    
  
    
    
	
<li>1.38: <a href="#pg-2e7091074560abc2a8e7b897cdd8a7b6"></a></li>


    
  
    
    
	
<li>1.39: <a href="#pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3"></a></li>


    
  
    
    
	
<li>1.40: <a href="#pg-c55f2fa6bdaa124b37da090a3ef90902"></a></li>


    
  
    
    
	
<li>1.41: <a href="#pg-10f416336efdcee22d691869e7585b9f"></a></li>


    
  
    
    
	
<li>1.42: <a href="#pg-c4b6d149cda7cac896f4374c821b7fc6"></a></li>


    
  
    
    
	
<li>1.43: <a href="#pg-1db087626f4f368e932df6f12993a5ab"></a></li>


    
  
    
    
	
<li>1.44: <a href="#pg-e85da83e18a50e472eb56320af55768a"></a></li>


    
  
    
    
	
<li>1.45: <a href="#pg-eb911bdcb8bb53ceb8b253089ab0d814"></a></li>


    
  
    
    
	
<li>1.46: <a href="#pg-62c5dc89c39f3ecd6aee57545d12891a"></a></li>


    
  
    
    
	
<li>1.47: <a href="#pg-2a79e12b9455f0ca1a6d5b00a9841249"></a></li>


    
  
    
    
	
<li>1.48: <a href="#pg-a2c8efac328fcf416e558bf167ef417d"></a></li>


    
  
    
    
	
<li>1.49: <a href="#pg-d93bd37094201bdefdb3908c9a6c86b3"></a></li>


    
  
    
    
	
<li>1.50: <a href="#pg-efa9ae4c92ed1c26dc04bb049db38cec"></a></li>


    
  
    
    
	
<li>1.51: <a href="#pg-576c00359074987304b3b418cec9a5b1"></a></li>


    
  
    
    
	
<li>1.52: <a href="#pg-e6097fe5dd013abd9f356c2566ef7b63"></a></li>


    
  
    
    
	
<li>1.53: <a href="#pg-5ab65eab2498cc1893af5b3bf8fe08fc"></a></li>


    
  
    
    
	
<li>1.54: <a href="#pg-fcb78718510a9d3027d1bb9d379c0c17"></a></li>


    
  
    
    
	
<li>1.55: <a href="#pg-a0e1457f667eb757f82f8c42901aa6c5"></a></li>


    
  
    
    
	
<li>1.56: <a href="#pg-59e362bf565041872395d165e99eafc1"></a></li>


    
  
    
    
	
<li>1.57: <a href="#pg-2a5040747a02ae2b2326c9901f1725d3"></a></li>


    
  
    
    
	
<li>1.58: <a href="#pg-043bd19497eefb77a6ed30a4d704fe7c"></a></li>


    
  
    
    
	
<li>1.59: <a href="#pg-bffb0d67824e75ade7232d09754b9718"></a></li>


    
  
    
    
	
<li>1.60: <a href="#pg-a37b5872c572c71775e389df50fca215"></a></li>


    
  
    
    
	
<li>1.61: <a href="#pg-3f49598c499c3356d89d98fdc8c8ad79"></a></li>


    
  
    
    
	
<li>1.62: <a href="#pg-7d68ac74e5301f789ddd2e25dd36218e"></a></li>


    
  
    
    
	
<li>1.63: <a href="#pg-e7c1ae3d905d9b6854216e26651955cd"></a></li>


    
  
    
    
	
<li>1.64: <a href="#pg-967a98823c19c8338bfc0e1338a20fb1"></a></li>


    
  
    
    
	
<li>1.65: <a href="#pg-b5838cc93a3fdb37b61afd201a71edd9"></a></li>


    
  
    
    
	
<li>1.66: <a href="#pg-f54c84a0fdada369a87b2ced6ccfc38f"></a></li>


    
  
    
    
	
<li>1.67: <a href="#pg-0d96e214c09a8f014e984a6b980522b3"></a></li>


    
  
    
    
	
<li>1.68: <a href="#pg-48afa88840a20edf1ad613c18480d4fc"></a></li>


    
  
    
    
	
<li>1.69: <a href="#pg-14da359f76a0f36af507d289dd4a5050"></a></li>


    
  
    
    
	
<li>1.70: <a href="#pg-3fda282409b804a14879b9c65c035797"></a></li>


    
  
    
    
	
<li>1.71: <a href="#pg-e044e6c69c2b1512c8d89430e0400771"></a></li>


    
  
    
    
	
<li>1.72: <a href="#pg-9f968809f867b76728697577492429e8"></a></li>


    
  
    
    
	
<li>1.73: <a href="#pg-c3c506c1683aed34398a34ab66d609da"></a></li>


    
  
    
    
	
<li>1.74: <a href="#pg-2c1a5a4405dca745ef50b4e86f5977c7"></a></li>


    
  
    
    
	
<li>1.75: <a href="#pg-003aaef561d065ecdaeb2c325b6b9253"></a></li>


    
  
    
    
	
<li>1.76: <a href="#pg-535f050663a6d8db3a61df2b19a0714b"></a></li>


    
  
    
    
	
<li>1.77: <a href="#pg-2f0a684baffe3cdf830c16693412f8e0"></a></li>


    
  
    
    
	
<li>1.78: <a href="#pg-aba528e06c437710b269f4e41f854fdd"></a></li>


    
  
    
    
	
<li>1.79: <a href="#pg-1d7987a759cd1519def4d433710cdff1"></a></li>


    
  
    
    
	
<li>1.80: <a href="#pg-33216a69b333c330cb8b305a119abc7c"></a></li>


    
  
    
    
	
<li>1.81: <a href="#pg-53abd743076fc859067264f3e8e676e0"></a></li>


    
  
    
    
	
<li>1.82: <a href="#pg-3a08eb202d572e417768a942ad24c59f"></a></li>


    
  
    
    
	
<li>1.83: <a href="#pg-11ed4820a6c3b411d9c4b87163cf0ae7"></a></li>


    
  
    
    
	
<li>1.84: <a href="#pg-e81c9d9320242b5ed4b063beea6696f8"></a></li>


    
  
    
    
	
<li>1.85: <a href="#pg-47f2d404188d6eb1fbf6fffd7fba4e48"></a></li>


    
  
    
    
	
<li>1.86: <a href="#pg-257824537b4c6c6b33249aa786461156"></a></li>


    
  
    
    
	
<li>1.87: <a href="#pg-e10faf6f940de61052258af59e036518"></a></li>


    
  
    
    
	
<li>1.88: <a href="#pg-a46a193f2322aa88cb3b2de2447b0461"></a></li>


    
  
    
    
	
<li>1.89: <a href="#pg-f5b27d7bd0eeed918f8635c68d220dc5"></a></li>


    
  
    
    
	
<li>1.90: <a href="#pg-370e9ffda66b4c48dfa54ea37c3aad21"></a></li>


    
  
    
    
	
<li>1.91: <a href="#pg-6bd27042c883aa5c498647d37762392c"></a></li>


    
  
    
    
	
<li>1.92: <a href="#pg-3a000435e1cca0be398b44b487f530c8"></a></li>


    
  
    
    
	
<li>1.93: <a href="#pg-97fbe97ca22de377e7fbf2517e0451b6"></a></li>


    
  
    
    
	
<li>1.94: <a href="#pg-bee6749065a369c2ab5b311eb43c40ba"></a></li>


    
  
    
    
	
<li>1.95: <a href="#pg-bdd9680ec894593d17f782d5e5665fd4"></a></li>


    
  
    
    
	
<li>1.96: <a href="#pg-1d005baad1a1e217d7ae0210fec96c3f"></a></li>


    
  
    
    
	
<li>1.97: <a href="#pg-c79d11d27bed54caac743c93e0b2fb24"></a></li>


    
  
    
    
	
<li>1.98: <a href="#pg-ba78e64c325e4131dd741235e2a1b2c0"></a></li>


    
  
    
    
	
<li>1.99: <a href="#pg-872d33f1fbc83cb2f0bf89b4bd545174"></a></li>


    
  
    
    
	
<li>1.100: <a href="#pg-7d8c1710684742ca940f580674225d9d"></a></li>


    
  
    
    
	
<li>1.101: <a href="#pg-28dcf20d89c7bb1c8e7a3873d7703d5d"></a></li>


    
  
    
    
	
<li>1.102: <a href="#pg-f869b6331e40c6f9eb01314f96d3113e"></a></li>


    
  
    
    
	
<li>1.103: <a href="#pg-19a94d2f7649959b218952cef00729f4"></a></li>


    
  
    
    
	
<li>1.104: <a href="#pg-b22d3ed181fb7f926ae2081f8fc8c14d"></a></li>


    
  
    
    
	
<li>1.105: <a href="#pg-ae1ea74c2c21b25a3c1eacdaf549274b"></a></li>


    
  
    
    
	
<li>1.106: <a href="#pg-633020ef232bc34f60c82153578a6c9b"></a></li>


    
  
    
    
	
<li>1.107: <a href="#pg-e938edeb3d824f9b364de617a1f10a93"></a></li>


    
  
    
    
	
<li>1.108: <a href="#pg-aa9f718186487df2ab6885cae45f5d37"></a></li>


    
  
    
    
	
<li>1.109: <a href="#pg-60d816e74ec8e0301cc484b19d7694e6"></a></li>


    
  

    </ul>
    
  
    
    
	
<li>2: <a href="#pg-82b2fcf985bae77dcb754387a9fcc64f">kubeadm init</a></li>


    
  
    
    
	
<li>3: <a href="#pg-2a2b5f34806b4b1bd2c12682ac170d68">kubeadm join</a></li>


    
  
    
    
	
<li>4: <a href="#pg-2c20539d9fabf5982e2dd931742714bd">kubeadm upgrade</a></li>


    
  
    
    
	
<li>5: <a href="#pg-5042dc49c5348b3674d3878f37f7670b">kubeadm config</a></li>


    
  
    
    
	
<li>6: <a href="#pg-6eb5bc1e7114609930a76c683cc27c2b">kubeadm reset</a></li>


    
  
    
    
	
<li>7: <a href="#pg-516f4705fb2f5f62c76c7742772726a3">kubeadm token</a></li>


    
  
    
    
	
<li>8: <a href="#pg-34c4af6f36d969ed08ba840e7fb64c6d">kubeadm version</a></li>


    
  
    
    
	
<li>9: <a href="#pg-92a39c69c3689119dd5fa12886cb73a3">kubeadm alpha</a></li>


    
  
    
    
	
<li>10: <a href="#pg-6a1fed09235bbf3644c804339928f10e">kubeadm certs</a></li>


    
  
    
    
	
<li>11: <a href="#pg-fbe8dcd222ce5795a5c325670a26b067">kubeadm init phase</a></li>


    
  
    
    
	
<li>12: <a href="#pg-62a742c564b0b5b7ac12a95e67cc425a">kubeadm join phase</a></li>


    
  
    
    
	
<li>13: <a href="#pg-1ab2d643d770ca684548de4ddbc7d8c4">kubeadm kubeconfig</a></li>


    
  
    
    
	
<li>14: <a href="#pg-b969d0033ce5d9036463521fb1f150b3">kubeadm reset phase</a></li>


    
  
    
    
	
<li>15: <a href="#pg-dfd085b5ab706bd84dda15847dd27f1b">kubeadm upgrade phase</a></li>


    
  
    
    
	
<li>16: <a href="#pg-455b6412a275b743ee8ad90f35808393">实现细节</a></li>


    
  

    </ul>


<div class="content">
      <img src="/images/kubeadm-stacked-color.png" align="right" width="150px">
<!-- 
Kubeadm is a tool built to provide `kubeadm init` and `kubeadm join` as best-practice "fast paths" for creating Kubernetes clusters.
 -->
<p>Kubeadm 是一个提供了 <code>kubeadm init</code> 和 <code>kubeadm join</code> 的工具，
作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。</p>
<!-- 
kubeadm performs the actions necessary to get a minimum viable cluster up and running. By design, it cares only about bootstrapping,
not about provisioning machines. Likewise, installing various nice-to-have addons, like the Kubernetes Dashboard, monitoring solutions, and cloud-specific addons, is not in scope.
 -->
<p>kubeadm 通过执行必要的操作来启动和运行最小可用集群。
按照设计，它只关注启动引导，而非配置机器。同样的，
安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、
监控方案、以及特定云平台的扩展，都不在讨论范围内。</p>
<!-- 
Instead, we expect higher-level and more tailored tooling to be built on top of kubeadm, and ideally, using kubeadm as the basis of all deployments will make it easier to create conformant clusters.
 -->
<p>相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具，
理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。</p>
<!-- 
## How to install
 -->
<h2 id="如何安装">如何安装</h2>
<!-- 
To install kubeadm, see the [installation guide](/docs/setup/production-environment/tools/kubeadm/install-kubeadm).
-->
<p>要安装 kubeadm, 请查阅
<a href="/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">安装指南</a>.</p>
<h2 id="what-s-next">What's next</h2>
<!-- 
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join) to bootstrap a Kubernetes worker node and join it to the cluster
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade) to upgrade a Kubernetes cluster to a newer version
* [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config) if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for `kubeadm upgrade`
* [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token) to manage tokens for `kubeadm join`
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm certs](/docs/reference/setup-tools/kubeadm/kubeadm-certs) to manage Kubernetes certificates
* [kubeadm kubeconfig](/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig) to manage kubeconfig files
* [kubeadm version](/docs/reference/setup-tools/kubeadm/kubeadm-version) to print the kubeadm version
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha) to preview a set of features made available for gathering feedback from the community
 -->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init">kubeadm init</a>
用于搭建控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join">kubeadm join</a>
用于搭建工作节点并将其加入到集群中</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade">kubeadm upgrade</a>
用于升级 Kubernetes 集群到新版本</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config">kubeadm config</a>
如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用
<code>kubeadm upgrade</code> 来配置你的集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token">kubeadm token</a>
用于管理 <code>kubeadm join</code> 使用的令牌</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset">kubeadm reset</a>
用于恢复通过 <code>kubeadm init</code> 或者 <code>kubeadm join</code> 命令对节点进行的任何变更</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-certs">kubeadm certs</a>
用于管理 Kubernetes 证书</li>
<li><a href="/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig">kubeadm kubeconfig</a>
用于管理 kubeconfig 文件</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-version">kubeadm version</a>
用于打印 kubeadm 的版本信息</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha">kubeadm alpha</a>
用于预览一组可用于收集社区反馈的特性</li>
</ul>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-36c22b52e8447eb3d2452d4f56fbea9b">1 - 创建 Kubeadm</h1>
    
	
</div>



    
      
  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-fd3ad295c1f10bfa333f841bbdffba81">1.1 - </h1>
    
	<p>kubeadm: 轻松创建一个安全的 Kubernetes 集群</p>
<h3 id="摘要">摘要</h3>
<!--
    ┌──────────────────────────────────────────────────────────┐
    │ KUBEADM                                                  │
    │ Easily bootstrap a secure Kubernetes cluster             │
    │                                                          │
    │ Please give us feedback at:                              │
    │ https://github.com/kubernetes/kubeadm/issues             │
    └──────────────────────────────────────────────────────────┘
-->
<pre><code>┌──────────────────────────────────────────────────────────┐
│ KUBEADM                                                  │
│ 轻松创建一个安全的 Kubernetes 集群                       │
│                                                          │
│ 给我们反馈意见的地址：                                   │
│ https://github.com/kubernetes/kubeadm/issues             │
└──────────────────────────────────────────────────────────┘
</code></pre><!-- 
Example usage: 
-->
<p>用途示例：</p>
<!-- 
    Create a two-machine cluster with one control-plane node
    (which controls the cluster), and one worker node
    (where your workloads, like Pods and Deployments run). 
-->
<p>创建一个有两台机器的集群，包含一个主节点（用来控制集群），和一个工作节点（运行您的工作负载，像 Pod 和 Deployment）。</p>
<!--
    ┌──────────────────────────────────────────────────────────┐
    │ On the first machine:                                    │
    ├──────────────────────────────────────────────────────────┤
    │ control-plane# kubeadm init                              │
    └──────────────────────────────────────────────────────────┘

    ┌──────────────────────────────────────────────────────────┐
    │ On the second machine:                                   │
    ├──────────────────────────────────────────────────────────┤
    │ worker# kubeadm join &lt;arguments-returned-from-init&gt;      │
    └──────────────────────────────────────────────────────────┘

    You can then repeat the second step on as many other machines as you like.
-->
<pre><code>┌──────────────────────────────────────────────────────────┐
│ 在第一台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ control-plane# kubeadm init                              │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ 在第二台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ worker# kubeadm join &amp;lt;arguments-returned-from-init&amp;gt;│
└──────────────────────────────────────────────────────────┘
</code></pre><p>您可以重复第二步，向集群添加更多机器。</p>
<!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>help for kubeadm</p>
-->
<p>kubeadm 操作的帮助信息<p>
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p>
-->
<p>[实验] 指向 '真实' 宿主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8df9aba508b2736a6712ef46227eea7d">1.2 - </h1>
    
	<!--
Commands related to handling kubernetes certificates
-->
<p>处理 Kubernetes 证书的相关命令</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
Commands related to handling kubernetes certificates
-->
<p>处理 Kubernetes 证书相关的命令</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;"><p>help for certs</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!-- help for certs--><p>certs 命令的帮助</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[实验] 到'真实'主机根文件系统的路径。</p></td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-018648dfc6f28bc9b969f45af0563cae">1.3 - </h1>
    
	<!--
Generate certificate keys
-->
<p>生成证书密钥</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.
-->
<p>该命令将打印出可以与 &quot;init&quot; 命令一起使用的安全的随机生成的证书密钥。</p>
<!--
You can also use "kubeadm init -upload-certs" without specifying a certificate key and it will generate and print one for you.
-->
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
help for certificate-key
-->
certificate-key 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4a1ff27cdf01c1c47d034278048e776b">1.4 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
Checks expiration for the certificates in the local PKI managed by kubeadm.
-->
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!--
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> 
-->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for check-expiration</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5d6b2999153cd86f56329534249fc4ec">1.5 - </h1>
    
	<p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 &quot;users &gt; user &gt; client-key-data&quot; 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 &quot;.csr&quot; 文件。</p>
<!--  
This command is designed for use in [Kubeadm External CA Mode](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode). It generates CSRs which you can then submit to your external certificate authority for signing.
-->
<p>此命令设计用于
<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Kubeadm 外部 CA 模式</a>。 
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<!--  
The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users &gt; user &gt; client-certificate-data" field.
-->
<p>应使用 &quot;.crt&quot; 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 &quot;users &gt; user &gt; client-certificate-data&quot; 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!-- 
```
  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
```
-->
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for generate-csr</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">generate-csr 命令的帮助</td>
</tr>
<tr>
<!-- td colspan="2">-kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td -->
<td colspan="2">--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the kubeconfig file.</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-adb5eecdc351074cc2e0cc2b1b4f04a8">1.6 - </h1>
    
	<!--
Renew certificates for a Kubernetes cluster
-->
<p>为 Kubernetes 集群更新证书</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
help for renew
-->
renew 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-df4c2dc6cba0be90d8d7de2fca9b87f7">1.7 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.
-->
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for admin.conf -->
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.  -->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6d6746e8ac1f1602f7dab1056b27e5c2">1.8 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.
-->
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7449c7fa06f25b967cf531e937b0f4b2">1.9 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate the apiserver uses to access etcd.
-->
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create CSRs instead of generating certificates -->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use the Kubernetes certificate API to renew certificates -->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b5c6ae77d3be9bd358c68667006cfc18">1.10 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for the API server to connect to kubelet.
-->
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4f804e59ec1739e733807d2b591d771f">1.11 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for serving the Kubernetes API.
-->
<p>续订用于提供 Kubernetes API 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5cf8caa95834803b133d53c321ab4a9">1.12 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the controller manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager.conf
-->
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ee770858e2bb767b79d572b4882af656">1.13 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for liveness probes to healthcheck etcd.
-->
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7484bf11b6183f4c329b1f66734cc886">1.14 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for etcd nodes to communicate with each other.
-->
<p>续订 etcd 节点间用来相互通信的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-peer
-->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bf444d915ab856dba693c36294c5427b">1.15 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for serving etcd.
-->
<p>续订用于提供 etcd 服务的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5c087e087714c5290b4967dd7924b3b">1.16 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate for the front proxy client.
-->
<p>为前端代理客户端续订证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-20703ce1c236264ad78cb1ad7244723e">1.17 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler.conf
-->
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-49aaa494ef75de67609987a43e5ee520">1.18 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Output shell completion code for the specified shell (bash or zsh).
The shell code must be evaluated to provide interactive
completion of kubeadm commands. This can be done by sourcing it from
the .bash_profile.
-->
<p>为指定的 shell（bash 或 zsh）输出 shell 自动补全代码。
必须激活 shell 代码以提供交互式 kubeadm 命令补全。这可以通过加载 .bash_profile 文件完成。</p>
<!--
Note: this requires the bash-completion framework.
-->
<p>注意: 此功能依赖于 <code>bash-completion</code> 框架。</p>
<!--
To install it on Mac use homebrew:
    $ brew install bash-completion
Once installed, bash_completion must be evaluated. This can be done by adding the
following line to the .bash_profile
    $ source $(brew --prefix)/etc/bash_completion
-->
<p>在 Mac 上使用 homebrew 安装:</p>
<pre><code>brew install bash-completion
</code></pre><p>安装后，必须激活 bash_completion。这可以通过在 .bash_profile 文件中添加下面的命令行来完成</p>
<pre><code>source $(brew --prefix)/etc/bash_completion
</code></pre><!--
If bash-completion is not installed on Linux, please install the 'bash-completion' package
via your distribution's package manager.
-->
<p>如果在 Linux 上没有安装 bash-completion，请通过您的发行版的包管理器安装 <code>bash-completion</code> 软件包。</p>
<!--
Note for zsh users: [1] zsh completions are only supported in versions of zsh &gt;= 5.2
-->
<p>zsh 用户注意事项：[1] zsh 自动补全仅在 &gt;=v5.2 及以上版本中支持。</p>
<pre><code>kubeadm completion SHELL [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Install bash completion on a Mac using homebrew
brew install bash-completion
printf "\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n" >> $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for bash into the current shell
source <(kubeadm completion bash)

# Write bash completion code to a file and source if from .bash_profile
kubeadm completion bash > ~/.kube/kubeadm_completion.bash.inc
printf "\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n" >> $HOME/.bash_profile
source $HOME/.bash_profile

# Load the kubeadm completion code for zsh[1] into the current shell
source <(kubeadm completion zsh)
-->
<pre><code># 在 Mac 上使用 homebrew 安装 bash completion
brew install bash-completion
printf &quot;\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 bash 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion bash)

# 将 bash 自动补全完成代码写入文件并且从 .bash_profile 文件加载它
printf &quot;\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 zsh 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion zsh)
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for completion -->
completion 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d63311c16e6468f5a5940aadd902faa7">1.19 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
There is a ConfigMap in the kube-system namespace called "kubeadm-config" that kubeadm
uses to store internal configuration about the cluster. kubeadm CLI v1.8.0+ automatically
creates this ConfigMap with the config used with 'kubeadm init', but if you
initialized your cluster using kubeadm v1.7.x or lower, you must use the 'config upload'
command to create this ConfigMap. This is required so that 'kubeadm upgrade' can configure
your upgraded cluster correctly.
-->
<p>kube-system 命名空间里有一个名为 &quot;kubeadm-config&quot; 的 ConfigMap，kubeadm 用它来存储有关集群的内部配置。
kubeadm CLI v1.8.0+ 通过一个配置自动创建该 ConfigMap，这个配置是和 'kubeadm init' 共用的。
但是您如果使用 kubeadm v1.7.x 或更低的版本初始化集群，那么必须使用 'config upload' 命令创建该 ConfigMap。
这是必要的操作，目的是使 'kubeadm upgrade' 能够正确地配置升级后的集群。</p>
<pre><code>kubeadm config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for config -->
config 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster.
If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6678a79b85306310066616185153377d">1.20 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Interact with container images used by kubeadm.
-->
<p>与 kubeadm 使用的容器镜像交互。</p>
<pre><code>kubeadm config images [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for images
-->
images 的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8f73e208cc67d221165f6294393881a7">1.21 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized.
-->
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），用于描述各种特征。选项是：
<br/>Auditing=true|false (ALPHA - 默认=false)
<br/>CoreDNS=true|false (默认=true)
<br/>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for list
-->
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- --image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io" -->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9aec3477159c105a46f4479de1c21418">1.22 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Pull images used by kubeadm.
-->
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一系列键值对（key=value），用于描述各种特征。可选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for pull
-->
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-045e41c28798930e21f77a90c3a90263">1.23 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:
- kubeadm.k8s.io/v1beta2
-->
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<!--
Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta2", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.
-->
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<!--
In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"
-->
<p>换句话说，如果您将此文件传递给 &quot;kubeadm init&quot;，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for migrate -->
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan="2">--new-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.
-->
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan="2">--old-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.
-->
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e7d83478123771ad14f475ee44440303">1.24 - </h1>
    
	<!--
Print configuration
-->
<p>打印配置</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command prints configurations for subcommands provided.
For details, see: https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories
-->
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅: <a href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories">https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p>
<pre><code>kubeadm config print [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p><!--help for print-->print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承而来的选项">从父命令继承而来的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-57a6b20d9571220989a7a445d4459468">1.25 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default init configuration that is used for 'kubeadm init'.
-->
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init-defaults
-->
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-92a2c11eef37937af846b55d9b87a544">1.26 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default join configuration that is used for 'kubeadm join'.
-->
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join-defaults
-->
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dcfffcaafb438cd650475945ddc129ee">1.27 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run this command in order to set up the Kubernetes control plane
-->
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<!--
The "init" command executes the following phases: 
-->
<p>&quot;init&quot; 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't apply any changes; just output what would be done.
-->
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init
-->
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}\.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef
-->
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan="2">
<!--
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6eaa2624c512051ff2a9cdbc6ee54949">1.28 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the init workflow
-->
<p>使用此命令可以调用 init 工作流程的单个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选择项">继承于父命令的选择项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4b7ada30e3923594b2907dcb8b431080">1.29 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for addon
-->
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6d1154da2e554de858cf4e7b37c054fa">1.30 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install all the addons
-->
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），描述了各种特征。选项包括：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d3a16914ddc849435ed864163978ddbf">1.31 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.
-->
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for coredns -->
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative range of IP address for service VIPs.  -->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative domain for services, e.g. "myorg.internal".  -->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8a257337ea78e5d9a0c54aa971eaf991">1.32 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Install the kube-proxy addon components via the API server.
-->
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-proxy
-->
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-77759011117e7974cbfee9694b6f8801">1.33 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.
-->
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<!--
This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.
-->
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Make all the bootstrap token configurations and create an initial token, functionally equivalent to what generated by kubeadm init.
-->
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for bootstrap-token
-->
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-8e1920b2caaa8de839cd3997edca80e9">1.34 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令中继承的选项">从父指令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-00aa8c2e4b3b2fd3a4b7986976b7bfda">1.35 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all certificates
-->
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令 
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-316aa97ee5719be5a723ac1b77c44f5a">1.36 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.cert and apiserver-etcd-client.key files.
-->
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1" -->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem. -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-759e85e62b32c0697ab37c214e99a864">1.37 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.cert and apiserver-kubelet-client.key files.
-->
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2e7091074560abc2a8e7b897cdd8a7b6">1.38 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for serving the Kubernetes API, and save them into apiserver.cert and apiserver.key files.
-->
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<!--
Default SANs are kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local, 10.96.0.1, 127.0.0.1
-->
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3">1.39 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.cert and ca.key files.
-->
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for ca
-->
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c55f2fa6bdaa124b37da090a3ef90902">1.40 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.cert and etcd/ca.key files.
-->
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-ca
-->
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-10f416336efdcee22d691869e7585b9f">1.41 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.cert and etcd/healthcheck-client.key files.
-->
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书存储的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c4b6d149cda7cac896f4374c821b7fc6">1.42 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.cert and etcd/peer.key files.
-->
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd-peer -->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1db087626f4f368e932df6f12993a5ab">1.43 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for serving etcd, and save them into etcd/server.crt and etcd/server.key files.
-->
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.crt 和 etcd/server.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>The path where to save and store the certificates.</p>
-->
<p>保存和存储证书的路径。<p>
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>Path to a kubeadm configuration file.</p>
-->
<p>kubeadm 配置文件的路径。<p>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>help for etcd-server</p>
-->
<p>etcd-server 操作的帮助命令<p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>Choose a specific Kubernetes version for the control plane.</p>
-->
<p>为控制平面指定特定的 Kubernetes 版本。<p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p>
-->
<p>[实验] 到 '真实' 主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e85da83e18a50e472eb56320af55768a">1.44 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.cert and front-proxy-ca.key files.
-->
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-ca
-->
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-eb911bdcb8bb53ceb8b253089ab0d814">1.45 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificate for the front proxy client, and save them into front-proxy-client.cert and front-proxy-client.key files.
If both files already exist, kubeadm skips the generation step and existing files will be used.
Alpha Disclaimer: this command is currently alpha.
-->
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-62c5dc89c39f3ecd6aee57545d12891a">1.46 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for sa
-->
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a79e12b9455f0ca1a6d5b00a9841249">1.47 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for control-plane -->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a2c8efac328fcf416e558bf167ef417d">1.48 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all static Pod manifest files
-->
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre><!--
### Examples


```
# Generates all static Pod manifest files for control plane components,
# functionally equivalent to what is generated by kubeadm init.
# Generates all static Pod manifest files using options read from a configuration file.
```
-->
<h3 id="示例">示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<!-- td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td -->
<td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
形式为 &lt;flagname&gt;=&lt;value&gt; 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname&gt;=&lt;value&gt; 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令继承的选项">从父指令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-d93bd37094201bdefdb3908c9a6c86b3">1.49 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
Generates the kube-apiserver static Pod manifest 
-->
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-efa9ae4c92ed1c26dc04bb049db38cec">1.50 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generates the kube-controller-manager static Pod manifest
-->
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-576c00359074987304b3b418cec9a5b1">1.51 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generates the kube-scheduler static Pod manifest
-->
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e6097fe5dd013abd9f356c2566ef7b63">1.52 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd -->
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5ab65eab2498cc1893af5b3bf8fe08fc">1.53 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the static Pod manifest file for a local, single-node local etcd instance
-->
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Generates the static Pod manifest file for etcd, functionally
# equivalent to what is generated by kubeadm init.
# Generates the static Pod manifest file for etcd using options
# read from a configuration file.
-->
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for local -->
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fcb78718510a9d3027d1bb9d379c0c17">1.54 - </h1>
    
	<h3 id="概要">概要</h3>
<!-- 
This command is not meant to be run on its own. See list of available subcommands. 
-->
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a0e1457f667eb757f82f8c42901aa6c5">1.55 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.
-->
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for admin
-->
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-59e362bf565041872395d165e99eafc1">1.56 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate all kubeconfig files
-->
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a5040747a02ae2b2326c9901f1725d3">1.57 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file
-->
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>    
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-043bd19497eefb77a6ed30a4d704fe7c">1.58 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.
-->
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<!--
Please note that this should *only* be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.
-->
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet
-->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bffb0d67824e75ade7232d09754b9718">1.59 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.
-->
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a37b5872c572c71775e389df50fca215">1.60 - </h1>
    
	<p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for kubelet-finalize</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3f49598c499c3356d89d98fdc8c8ad79">1.61 - </h1>
    
	<p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- <td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for all</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7d68ac74e5301f789ddd2e25dd36218e">1.62 - </h1>
    
	<p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for experimental-cert-rotation</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e7c1ae3d905d9b6854216e26651955cd">1.63 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
-->
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-967a98823c19c8338bfc0e1338a20fb1">1.64 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre><!--
### Examples

# Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
# Applies control-plane label and taint to a specific node
-->
<h3 id="示例">示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b5838cc93a3fdb37b61afd201a71edd9">1.65 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm init.
-->
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre><!--
### Examples
-->
<h3 id="案例">案例</h3>
<!--
# Run pre-flight checks for kubeadm init using a config file.
-->
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f54c84a0fdada369a87b2ced6ccfc38f">1.66 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-certs
-->
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<!-- td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-0d96e214c09a8f014e984a6b980522b3">1.67 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-config
-->
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-48afa88840a20edf1ad613c18480d4fc">1.68 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload all configuration to a config map
-->
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-14da359f76a0f36af507d289dd4a5050">1.69 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.
-->
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<!--
Alternatively, you can use kubeadm config.
-->
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# upload the configuration of your cluster
-->
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeadm
-->
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3fda282409b804a14879b9c65c035797">1.70 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload kubelet configuration extracted from the kubeadm InitConfiguration object to a ConfigMap of the form kubelet-config-1.X in the cluster, where X is the minor version of the current (API Server) Kubernetes version.
-->
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
```
-->
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubelet -->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e044e6c69c2b1512c8d89430e0400771">1.71 - </h1>
    
	<h3 id="摘要">摘要</h3>
<!--
When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).
-->
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<!--
There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. This file
can be a local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.
-->
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<!--
If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type&gt;:&lt;hex-encoded-value&gt;",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.
-->
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 &quot;&lt;hash-type&gt;:&lt;hex-encoded-value&gt;&quot;，其中支持的哈希类型为 &quot;sha256&quot;。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 &quot;kubeadm init&quot; 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<!--
If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.
-->
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<!--
The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.

Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.
-->
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<!-- 
The "join [api-server-endpoint]" command executes the following phases:
-->
<p>&quot;join [api-server-endpoint]&quot; 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type&gt;:&lt;value&gt;")。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join
-->
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9f968809f867b76728697577492429e8">1.72 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the join workflow
-->
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c3c506c1683aed34398a34ab66d609da">1.73 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Join a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
# Joins a machine as a control plane instance
kubeadm join phase control-plane-join all
```
-->
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-join
-->
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2c1a5a4405dca745ef50b4e86f5977c7">1.74 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Joins a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令      
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-003aaef561d065ecdaeb2c325b6b9253">1.75 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Add a new local etcd member
-->
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd
-->
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-535f050663a6d8db3a61df2b19a0714b">1.76 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2f0a684baffe3cdf830c16693412f8e0">1.77 - </h1>
    
	<h2 id="概要">概要</h2>
<!-- 
Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap 
-->
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm config file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create a new control plane instance on this node -->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-status -->
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Specify the node name.  -->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aba528e06c437710b269f4e41f854fdd">1.78 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><!--
### Examples
-->
<!--
# Prepares the machine for serving a control plane
-->
<h3 id="示例">示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-prepare
-->
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1d7987a759cd1519def4d433710cdff1">1.79 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-33216a69b333c330cb8b305a119abc7c">1.80 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the certificates for the new control plane components
-->
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-53abd743076fc859067264f3e8e676e0">1.81 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the manifests for the new control plane components
-->
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane
-->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3a08eb202d572e417768a942ad24c59f">1.82 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
-->
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-11ed4820a6c3b411d9c4b87163cf0ae7">1.83 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Generate the kubeconfig for the new control plane components
-->
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e81c9d9320242b5ed4b063beea6696f8">1.84 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
For file-based discovery, a file or URL from which to load cluster information.
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-47f2d404188d6eb1fbf6fffd7fba4e48">1.85 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm join.
-->
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><!--
### Examples
# Run join pre-flight checks using a config file.
-->
<h3 id="示例">示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-257824537b4c6c6b33249aa786461156">1.86 - </h1>
    
	<!--
Kubeconfig file utilities

### Synopsis

Kubeconfig file utilities.

### Options
-->
<p>Kubeconfig 文件工具。</p>
<h3 id="概要">概要</h3>
<p>kubeconfig 文件工具。</p>
<h3 id="选项">选项</h3>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubeconfig -->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e10faf6f940de61052258af59e036518">1.87 - </h1>
    
	<!--
Output a kubeconfig file for an additional user

### Synopsis

Output a kubeconfig file for an additional user.
-->
<p>为其他用户输出一个 kubeconfig 文件。</p>
<h3 id="概要">概要</h3>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<pre><code>kubeadm alpha kubeconfig user [flags]
</code></pre><!--
### Examples

```
  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm alpha kubeconfig user --client-name=foo --config=bar
```
-->
<h3 id="示例">示例</h3>
<pre><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--client-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The name of user. It will be used as the CN if client certificates are created
-->
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for user
-->
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--org strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The orgnizations of the client certificate. It will be used as the O if client certificates are created
-->
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates
-->
应该用此令牌做为 kubeconfig 的身份验证机制，而不是客户端证书
</td>
</tr>
<tr>
<td colspan="2">--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!--The validity period of the client certificate. It is an offset from the current time.-->
<p>
客户证书的合法期限。所设置值为相对当前时间的偏移。
</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-a46a193f2322aa88cb3b2de2447b0461">1.88 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'
-->
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<!--
The "reset" command executes the following phases:
-->
<p>&quot;reset&quot; 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for reset
-->
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- List of phases to be skipped -->
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f5b27d7bd0eeed918f8635c68d220dc5">1.89 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the reset workflow
-->
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-370e9ffda66b4c48dfa54ea37c3aad21">1.90 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run cleanup node.
-->
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for cleanup-node
-->
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6bd27042c883aa5c498647d37762392c">1.91 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm reset.
-->
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-3a000435e1cca0be398b44b487f530c8">1.92 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upload configuration about the current state, so that 'kubeadm upgrade' can later know how to configure the upgraded cluster.
-->
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-97fbe97ca22de377e7fbf2517e0451b6">1.93 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Remove this node from the ClusterStatus object if the node is a control plane node.
-->
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre><code>kubeadm reset phase update-cluster-status [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-cluster-status -->
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bee6749065a369c2ab5b311eb43c40ba">1.94 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command manages bootstrap tokens. It is optional and needed only for advanced use cases.
-->
<p>此命令管理引导令牌（bootstrap token）。它是可选的，仅适用于高级用例。</p>
<!--
In short, bootstrap tokens are used for establishing bidirectional trust between a client and a server.
A bootstrap token can be used when a client (for example a node that is about to join the cluster) needs
to trust the server it is talking to. Then a bootstrap token with the "signing" usage can be used.
-->
<p>简而言之，引导令牌（bootstrap token）用于在客户端和服务器之间建立双向信任。
当客户端（例如，即将加入集群的节点）需要时，可以使用引导令牌相信正在与之通信的服务器。
然后可以使用具有 “签名” 的引导令牌。</p>
<!--
bootstrap tokens can also function as a way to allow short-lived authentication to the API Server
(the token serves as a way for the API Server to trust the client), for example for doing the TLS Bootstrap.
-->
<p>引导令牌还可以作为一种允许对 API 服务器进行短期身份验证的方法（令牌用作 API 服务器信任客户端的方式），例如用于执行 TLS 引导程序。</p>
<!--
What is a bootstrap token more exactly?
 - It is a Secret in the kube-system namespace of type "bootstrap.kubernetes.io/token".
 - A bootstrap token must be of the form "[a-z0-9]{6}.[a-z0-9]{16}". The former part is the public token ID,
   while the latter is the Token Secret and it must be kept private at all circumstances!
 - The name of the Secret must be named "bootstrap-token-(token-id)".
 -->
<p>引导令牌准确来说是什么？</p>
<ul>
<li>它是位于 kube-system 命名空间中类型为 “bootstrap.kubernetes.io/token” 的一个 Secret。</li>
<li>引导令牌的格式必须为 “[a-z0-9]{6}.[a-z0-9]{16}”，前一部分是公共令牌 ID，而后者是令牌秘钥，必须在任何情况下都保密！</li>
<li>必须将 Secret 的名称命名为 “bootstrap-token-(token-id)”。</li>
</ul>
<!--
You can read more about bootstrap tokens here:
  /docs/admin/bootstrap-tokens/
-->
<p>您可以在此处阅读有关引导令牌（bootstrap token）的更多信息：
/docs/admin/bootstrap-tokens/</p>
<pre><code>kubeadm token [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Whether to enable dry-run mode or not</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for token</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for token
-->
token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置，则搜索一组标准位置以查找现有 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bdd9680ec894593d17f782d5e5665fd4">1.95 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.

The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.
-->
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，&quot;有效时间&quot; 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--description string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A human friendly description of how this token is used.
-->
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [system:bootstrappers:kubeadm:default-node-token]
-->
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Extra groups that this token will authenticate as when used for authentication. Must match "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
-->
此令牌用于身份验证时将进行身份验证的其他组。必须匹配  "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for create
-->
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--print-join-command</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.
-->
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [signing,authentication]
-->
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]
-->
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1d005baad1a1e217d7ae0210fec96c3f">1.96 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will delete a list of bootstrap tokens for you.

The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.
-->
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot; 形式的完整令牌或者是 &quot;[a-z0-9]{6}&quot; 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for delete
-->
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-c79d11d27bed54caac743c93e0b2fb24">1.97 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.

You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.

You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.
-->
<p>此命令将打印一个随机生成的可以被 &quot;init&quot; 和 &quot;join&quot; 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 &quot;kubeadm init&quot; 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for generate
-->
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ba78e64c325e4131dd741235e2a1b2c0">1.98 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
This command will list all bootstrap tokens for you.
-->
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for list -->
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-872d33f1fbc83cb2f0bf89b4bd545174">1.99 - </h1>
    
	<p>此命令能将集群平滑升级到新版本</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
Upgrade your cluster smoothly to a newer version with this command
-->
<p>此命令能将集群平滑升级到新版本</p>
<pre><code>kubeadm upgrade [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>help for upgrade</p>
-->
<p>upgrade 操作的帮助命令<p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p>
-->
<p>[实验] 指向 '真实' 宿主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7d8c1710684742ca940f580674225d9d">1.100 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade your Kubernetes cluster to the specified version
-->
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.
-->
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.
-->
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output what actions would be performed.
-->
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true
-->
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能。选项包括：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Force upgrading although some requirements might not be met. This also implies non-interactive mode.
-->
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apply
-->
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies whether the configuration file that will be used in the upgrade should be printed or not.
-->
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan="2">-y, --yes</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade and do not prompt for confirmation (non-interactive mode).
-->
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-28dcf20d89c7bb1c8e7a3873d7703d5d">1.101 - </h1>
    
	<h3 id="概述">概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre><!--

### Options

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to API server manifest</td>
</tr>
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">API服务器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td>
</tr>
-->
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">How many lines of context in the diff</td>
</tr>
-->
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">差异中有多少行上下文</td>
</tr>
<!--
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to controller manifest</td>
</tr>
-->
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">控制器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for diff</td>
</tr>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<!--
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
</tr>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<!--
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to scheduler manifest</td>
</tr>
</tbody>
</table>
-->
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">调度程序清单的路径</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
</tr>

</tbody>
</table>

-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f869b6331e40c6f9eb01314f96d3113e">1.102 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade commands for a node in the cluster
-->
<p>升级集群中某个节点的命令</p>
<!--
The "node" command executes the following phases:
-->
<p>&quot;node&quot; 命令执行以下阶段：</p>
<!--
```
preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
```
-->
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output the actions that would be performed.
-->
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
-->
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for node
-->
node 操作的帮助命令
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The *desired* version for the kubelet config after the upgrade. If not specified, the KubernetesVersion from the kubeadm-config ConfigMap will be used
-->
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-19a94d2f7649959b218952cef00729f4">1.103 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the node workflow
-->
<p>使用此命令调用 node 工作流的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b22d3ed181fb7f926ae2081f8fc8c14d">1.104 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Upgrade the control plane instance deployed on this node, if any
-->
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">更新在升级期间变更的组件使用的证书。</td>
</tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the renewal of certificates used by component changed during upgrades.</td>
-->
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的动作。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Do not change any state, just output the actions that would be performed.</td>
-->
<tr>
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">执行 etcd 的升级。</td>
</tr>
<!--
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td> 
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the upgrade of etcd.</td>
-->
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where kustomize patches for static pod manifests are stored.</td>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">control-plane 的帮助信息</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for control-plane</td>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<!--
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
-->
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
-->
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-ae1ea74c2c21b25a3c1eacdaf549274b">1.105 - </h1>
    
	<p>从群集中 &quot;kubelet-config-1.X&quot; 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置操作的帮助信息</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<!--
### Options inherited from parent commands
-->
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-633020ef232bc34f60c82153578a6c9b">1.106 - </h1>
    
	<p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for preflight</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</td> 
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-e938edeb3d824f9b364de617a1f10a93">1.107 - </h1>
    
	<h3 id="概述">概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-aa9f718186487df2ab6885cae45f5d37">1.108 - </h1>
    
	<h3 id="概要">概要</h3>
<!--
Print the version of kubeadm
-->
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for version
-->
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">-o, --output string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Output format; available options are 'yaml', 'json' and 'short'
-->
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-60d816e74ec8e0301cc484b19d7694e6">1.109 - </h1>
    
	<p>此目录下的所有文件都是从其他仓库自动生成的。 <strong>不要人工编辑它们。 您必须在上游仓库中编辑它们</strong></p>

</div>



    
	
  

    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-82b2fcf985bae77dcb754387a9fcc64f">2 - kubeadm init</h1>
    
	<!--
reviewers:
- luxas
- jbeda
title: kubeadm init
content_type: concept
weight: 20
-->
<!-- overview -->
<!--
This command initializes a Kubernetes control-plane node.
-->
<p>此命令初始化一个 Kubernetes 控制平面节点。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Run this command in order to set up the Kubernetes control plane
-->
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<!--
The "init" command executes the following phases: 
-->
<p>&quot;init&quot; 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't apply any changes; just output what would be done.
-->
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init
-->
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token to use for establishing bidirectional trust between nodes and control-plane nodes. The format is [a-z0-9]{6}\.[a-z0-9]{16} - e.g. abcdef.0123456789abcdef
-->
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan="2">
<!--
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!--
### Init workflow {#init-workflow}
-->
<h3 id="init-workflow">Init 命令的工作流程</h3>
<!--
`kubeadm init` bootstraps a Kubernetes control-plane node by executing the
following steps:
-->
<p><code>kubeadm init</code> 命令通过执行下列步骤来启动一个 Kubernetes 控制平面节点。</p>
<!--
1. Runs a series of pre-flight checks to validate the system state
   before making changes. Some checks only trigger warnings, others are
   considered errors and will exit kubeadm until the problem is corrected or the
   user specifies `--ignore-preflight-errors=<list-of-errors>`.
-->
<ol>
<li>在做出变更前运行一系列的预检项来验证系统状态。一些检查项目仅仅触发警告，
其它的则会被视为错误并且退出 kubeadm，除非问题得到解决或者用户指定了
<code>--ignore-preflight-errors=&lt;错误列表&gt;</code> 参数。</li>
</ol>
<!--
1. Generates a self-signed CA to set up identities for each component in the cluster. The user can provide their
   own CA cert and/or key by dropping it in the cert directory configured via `--cert-dir`
   (`/etc/kubernetes/pki` by default).
   The APIServer certs will have additional SAN entries for any `--apiserver-cert-extra-sans` arguments, lowercased if necessary.
-->
<ol start="2">
<li>生成一个自签名的 CA 证书来为集群中的每一个组件建立身份标识。
用户可以通过将其放入 <code>--cert-dir</code> 配置的证书目录中（默认为 <code>/etc/kubernetes/pki</code>）
来提供他们自己的 CA 证书以及/或者密钥。
APIServer 证书将为任何 <code>--apiserver-cert-extra-sans</code> 参数值提供附加的 SAN 条目，必要时将其小写。</li>
</ol>
<!--
1. Writes kubeconfig files in `/etc/kubernetes/`  for
   the kubelet, the controller-manager and the scheduler to use to connect to the
   API server, each with its own identity, as well as an additional
   kubeconfig file for administration named `admin.conf`.
-->
<ol start="3">
<li>将 kubeconfig 文件写入 <code>/etc/kubernetes/</code> 目录以便 kubelet、控制器管理器和调度器用来连接到
API 服务器，它们每一个都有自己的身份标识，同时生成一个名为 <code>admin.conf</code> 的独立的 kubeconfig
文件，用于管理操作。</li>
</ol>
<!--
1. Generates static Pod manifests for the API server,
   controller-manager and scheduler. In case an external etcd is not provided,
   an additional static Pod manifest is generated for etcd.

   Static Pod manifests are written to `/etc/kubernetes/manifests`; the kubelet
   watches this directory for Pods to create on startup.

   Once control plane Pods are up and running, the `kubeadm init` sequence can continue.
-->
<ol start="4">
<li>
<p>为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。假使没有提供一个外部的 etcd
服务的话，也会为 etcd 生成一份额外的静态 Pod 清单文件。</p>
<p>静态 Pod 的清单文件被写入到 <code>/etc/kubernetes/manifests</code> 目录;
kubelet 会监视这个目录以便在系统启动的时候创建 Pod。</p>
<p>一旦控制平面的 Pod 都运行起来， <code>kubeadm init</code> 的工作流程就继续往下执行。</p>
</li>
</ol>
<!--
1. Apply labels and taints to the control-plane node so that no additional workloads will
   run there.
-->
<ol start="5">
<li>对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</li>
</ol>
<!--
1. Generates the token that additional nodes can use to register
   themselves with a control-plane in the future. Optionally, the user can provide a
   token via `--token`, as described in the
   [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token/) docs.
-->
<ol start="6">
<li>生成令牌，将来其他节点可使用该令牌向控制平面注册自己。
如 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a> 文档所述，
用户可以选择通过 <code>--token</code> 提供令牌。</li>
</ol>
<!--
1. Makes all the necessary configurations for allowing node joining with the
   [Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) and
   [TLS Bootstrap](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)
   mechanism:

   - Write a ConfigMap for making available all the information required
     for joining, and set up related RBAC access rules.

   - Let Bootstrap Tokens access the CSR signing API.

   - Configure auto-approval for new CSR requests.

   See [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) for additional info.
-->
<ol start="7">
<li>
<p>为了使得节点能够遵照<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">启动引导令牌</a>
和 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 启动引导</a>
这两份文档中描述的机制加入到集群中，kubeadm 会执行所有的必要配置：</p>
<ul>
<li>
<p>创建一个 ConfigMap 提供添加集群节点所需的信息，并为该 ConfigMap 设置相关的 RBAC 访问规则。</p>
</li>
<li>
<p>允许启动引导令牌访问 CSR 签名 API。</p>
</li>
<li>
<p>配置自动签发新的 CSR 请求。</p>
</li>
</ul>
<p>更多相关信息，请查看 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>。</p>
</li>
</ol>
<!-- 
1. Installs a DNS server (CoreDNS) and the kube-proxy addon components via the API server.
   In Kubernetes version 1.11 and later CoreDNS is the default DNS server.
   Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.

   <div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> kube-dns usage with kubeadm is deprecated as of v1.18 and is removed in v1.21.
</div>


-->
<ol start="8">
<li>
<p>通过 API 服务器安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件。
在 Kubernetes 版本 1.11 和更高版本中，CoreDNS 是默认的 DNS 服务器。
请注意，尽管已部署 DNS 服务器，但直到安装 CNI 时才调度它。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> 从 v1.18 开始，在 kubeadm 中使用 kube-dns 的支持已被废弃，并已在 v1.21 版本中删除。
</div>


</li>
</ol>
<!--
### Using init phases with kubeadm {#init-phases}

Kubeadm allows you to create a control-plane node in phases using the `kubeadm init phase` command.
-->
<h3 id="init-phases">在 kubeadm 中使用 init phases</h3>
<p>Kubeadm 允许你使用 <code>kubeadm init phase</code> 命令分阶段创建控制平面节点。</p>
<!--
To view the ordered list of phases and sub-phases you can call `kubeadm init -help`. The list will be located at the top of the help screen and each phase will have a description next to it.
Note that by calling `kubeadm init` all of the phases and sub-phases will be executed in this exact order.
-->
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm init --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm init</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<!--
Some phases have unique flags, so if you want to have a look at the list of available options add `-help`, for example:
-->
<p>某些阶段具有唯一的标志，因此，如果要查看可用选项的列表，请添加 <code>--help</code>，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane controller-manager --help
</code></pre></div><!--
You can also use `-help` to see the list of sub-phases for a certain parent phase:
-->
<p>你也可以使用 <code>--help</code> 查看特定父阶段的子阶段列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane --help
</code></pre></div><!--
`kubeadm init` also exposes a flag called `-skip-phases` that can be used to skip certain phases. The flag accepts a list of phase names and the names can be taken from the above ordered list.
-->
<p><code>kubeadm init</code> 还公开了一个名为 <code>--skip-phases</code> 的参数，该参数可用于跳过某些阶段。
参数接受阶段名称列表，并且这些名称可以从上面的有序列表中获取。</p>
<!--
An example:
-->
<p>例如：</p>
<!--
# you can now modify the control plane and etcd manifest files
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm init phase control-plane all --config<span style="color:#666">=</span>configfile.yaml
sudo kubeadm init phase etcd <span style="color:#a2f">local</span> --config<span style="color:#666">=</span>configfile.yaml
<span style="color:#080;font-style:italic"># 你现在可以修改控制平面和 etcd 清单文件</span>
sudo kubeadm init --skip-phases<span style="color:#666">=</span>control-plane,etcd --config<span style="color:#666">=</span>configfile.yaml
</code></pre></div><!--
What this example would do is write the manifest files for the control plane and etcd in `/etc/kubernetes/manifests` based on the configuration in `configfile.yaml`. This allows you to modify the files and then skip these phases using `-skip-phases`. By calling the last command you will create a control plane node with the custom manifest files.
-->
<p>该示例将执行的操作是基于 <code>configfile.yaml</code> 中的配置在 <code>/etc/kubernetes/manifests</code>
中写入控制平面和 etcd 的清单文件。
这允许你修改文件，然后使用 <code>--skip-phases</code> 跳过这些阶段。
通过调用最后一个命令，你将使用自定义清单文件创建一个控制平面节点。</p>
<!--
### Using kubeadm init with a configuration file {#config-file}
-->
<h3 id="config-file">结合一份配置文件来使用 kubeadm init</h3>
<!--
The config file is still considered beta and may change in future versions.
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> 配置文件的功能仍然处于 alpha 状态并且在将来的版本中可能会改变。
</div>

<!--
It's possible to configure `kubeadm init` with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the `--config` flag and it must
contain a `ClusterConfiguration` structure and optionally more structures separated by `---\n`
Mixing `--config` with others flags may not be allowed in some cases.
-->
<p>通过一份配置文件而不是使用命令行参数来配置 <code>kubeadm init</code> 命令是可能的，
但是一些更加高级的功能只能够通过配置文件设定。
这份配置文件通过 <code>--config</code> 选项参数指定的，
它必须包含 <code>ClusterConfiguration</code> 结构，并可能包含更多由 <code>---\n</code> 分隔的结构。
在某些情况下，可能不允许将 <code>--config</code> 与其他标志混合使用。</p>
<!--
The default configuration can be printed out using the
[kubeadm config print](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

If your configuration is not using the latest version it is **recommended** that you migrate using
the [kubeadm config migrate](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

For more information on the fields and usage of the configuration you can navigate to our API reference
page and pick a version from [the list](https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories).
-->
<p>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config print</a>
命令打印出默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config migrate</a>
命令进行迁移。</p>
<p>有关配置的字段和用法的更多信息，
你可以访问 API 参考页面并从
<a href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories">列表</a>
中选择一个版本。</p>
<!--
### Adding kube-proxy parameters {#kube-proxy}
-->
<h3 id="kube-proxy">添加 kube-proxy 参数</h3>
<!--
For information about kube-proxy parameters in the kubeadm configuration see:
- [kube-proxy reference](/docs/reference/config-api/kube-proxy-config.v1alpha1/)

For information about enabling IPVS mode with kubeadm see:
- [IPVS](https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md)
-->
<p>kubeadm 配置中有关 kube-proxy 的说明请查看：</p>
<ul>
<li><a href="/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/">kube-proxy 参考</a></li>
</ul>
<p>使用 kubeadm 启用 IPVS 模式的说明请查看：</p>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md">IPVS</a></li>
</ul>
<!--
### Passing custom flags to control plane components {#control-plane-flags}
-->
<h3 id="control-plane-flags">向控制平面组件传递自定义的命令行参数</h3>
<!--
For information about passing flags to control plane components see:
- [control-plane-flags](/docs/setup/production-environment/tools/kubeadm/control-plane-flags/) -->
<p>有关向控制平面组件传递命令行参数的说明请查看：
<a href="/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">控制平面命令行参数</a></p>
<!--
### Using custom images {#custom-images}
-->
<h3 id="custom-images">使用自定义的镜像</h3>
<!--
By default, kubeadm pulls images from `k8s.gcr.io`. If the
requested Kubernetes version is a CI label (such as `ci/latest`)
`gcr.io/k8s-staging-ci-images` is used.
-->
<p>默认情况下, kubeadm 会从 <code>k8s.gcr.io</code> 仓库拉取镜像。如果请求的 Kubernetes 版本是 CI 标签
（例如 <code>ci/latest</code>），则使用 <code>gcr.io/k8s-staging-ci-images</code>。</p>
<!--
You can override this behavior by using [kubeadm with a configuration file](#config-file).
-->
<p>你可以通过使用<a href="#config-file">带有配置文件的 kubeadm</a> 来重写此操作。</p>
<!--
Allowed customization are:

* To provide an alternative `imageRepository` to be used instead of
  `k8s.gcr.io`.
* To set `useHyperKubeImage` to `true` to use the HyperKube image.
* To provide a specific `imageRepository` and `imageTag` for etcd or DNS add-on.
-->
<p>允许的自定义功能有：</p>
<ul>
<li>使用其他的 <code>imageRepository</code> 来代替 <code>k8s.gcr.io</code>。</li>
<li>将 <code>useHyperKubeImage</code> 设置为 <code>true</code>，使用 HyperKube 镜像。</li>
<li>为 etcd 或 DNS 附件提供特定的 <code>imageRepository</code> 和 <code>imageTag</code>。</li>
</ul>
<!--
Please note that the configuration field `kubernetesVersion` or the command line flag
`-kubernetes-version` affect the version of the images.
-->
<p>请注意配置文件中的配置项 <code>kubernetesVersion</code> 或者命令行参数 <code>--kubernetes-version</code>
会影响到镜像的版本。</p>
<!--
### Uploading control-plane certificates to the cluster
-->
<h3 id="将控制平面证书上传到集群">将控制平面证书上传到集群</h3>
<!--
By adding the flag `-upload-certs` to `kubeadm init` you can temporary upload
the control-plane certificates to a Secret in the cluster. Please note that this Secret
will expire automatically after 2 hours. The certificates are encrypted using
a 32byte key that can be specified using `-certificate-key`. The same key can be used
to download the certificates when additional control-plane nodes are joining, by passing
`-control-plane` and `-certificate-key` to `kubeadm join`.
-->
<p>通过将参数 <code>--upload-certs</code> 添加到 <code>kubeadm init</code>，你可以将控制平面证书临时上传到集群中的 Secret。
请注意，此 Secret 将在 2 小时后自动过期。证书使用 32 字节密钥加密，可以使用 <code>--certificate-key</code> 指定。
通过将 <code>--control-plane</code> 和 <code>--certificate-key</code> 传递给 <code>kubeadm join</code>，
可以在添加其他控制平面节点时使用相同的密钥下载证书。</p>
<!--
The following phase command can be used to re-upload the certificates after expiration:
-->
<p>以下阶段命令可用于证书到期后重新上传证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm init phase upload-certs --upload-certs --certificate-key<span style="color:#666">=</span>SOME_VALUE --config<span style="color:#666">=</span>SOME_YAML_FILE
</code></pre></div><!--
If the flag `-certificate-key` is not passed to `kubeadm init` and
`kubeadm init phase upload-certs` a new key will be generated automatically.
-->
<p>如果未将参数 <code>--certificate-key</code> 传递给 <code>kubeadm init</code> 和 <code>kubeadm init phase upload-certs</code>，
则会自动生成一个新密钥。</p>
<!--
The following command can be used to generate a new key on demand:
-->
<p>以下命令可用于按需生成新密钥：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm certs certificate-key
</code></pre></div><!-- ### Certificate management with kubeadm -->
<h3 id="使用-kubeadm-管理证书">使用 kubeadm 管理证书</h3>
<!--  
For detailed information on certificate management with kubeadm see
[Certificate Management with kubeadm](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/).
The document includes information about using external CA, custom certificates
and certificate renewal.
-->
<p>有关使用 kubeadm 进行证书管理的详细信息，请参阅
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">使用 kubeadm 进行证书管理</a>。
该文档包括有关使用外部 CA，自定义证书和证书更新的信息。</p>
<!--
### Managing the kubeadm drop-in file for the kubelet {#kubelet-drop-in}
-->
<h3 id="kubelet-drop-in">管理 kubeadm 为 kubelet 提供的 systemd 配置文件</h3>
<!--
The `kubeadm` package ships with a configuration file for running the `kubelet` by `systemd`. Note that the kubeadm CLI never touches this drop-in file. This drop-in file is part of the kubeadm DEB/RPM package.
-->
<p><code>kubeadm</code> 包自带了关于 <code>systemd</code> 如何运行 <code>kubelet</code> 的配置文件。
请注意 <code>kubeadm</code> 客户端命令行工具永远不会修改这份 <code>systemd</code> 配置文件。
这份 <code>systemd</code> 配置文件属于 kubeadm DEB/RPM 包。</p>
<!--
For further information, see [Managing the kubeadm drop-in file for systemd](/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd).
-->
<p>有关更多信息，请阅读
<a href="/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd">管理 systemd 的 kubeadm 内嵌文件</a>。</p>
<!--
### Use kubeadm with CRI runtimes
-->
<h3 id="结合-cri-运行时使用-kubeadm">结合 CRI 运行时使用 kubeadm</h3>
<!--
By default kubeadm attempts to detect your container runtime. For more details on this detection, see
the [kubeadm CRI installation guide](/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime).
-->
<p>默认情况下，kubeadm 尝试检测你的容器运行环境。有关此检测的更多详细信息，请参见
<a href="/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime">kubeadm CRI 安装指南</a>。</p>
<!--
### Setting the node name
-->
<h3 id="设置节点的名称">设置节点的名称</h3>
<!--
By default, `kubeadm` assigns a node name based on a machine's host address. You can override this setting with the `-node-name` flag.
The flag passes the appropriate [`-hostname-override`](/docs/reference/command-line-tools-reference/kubelet/#options)
value to the kubelet.
-->
<p>默认情况下, <code>kubeadm</code> 基于机器的主机地址分配一个节点名称。你可以使用 <code>--node-name</code> 参数覆盖此设置。
此标识将合适的
<a href="/zh/docs/reference/command-line-tools-reference/kubelet/#options"><code>--hostname-override</code></a>
值传递给 kubelet。</p>
<!--
### Running kubeadm without an internet connection
-->
<h3 id="在没有互联网连接的情况下运行-kubeadm">在没有互联网连接的情况下运行 kubeadm</h3>
<!--
For running kubeadm without an internet connection you have to pre-pull the required control-plane images.
-->
<p>要在没有互联网连接的情况下运行 kubeadm，你必须提前拉取所需的控制平面镜像。</p>
<!--
You can list and pull the images using the `kubeadm config images` sub-command:
-->
<p>你可以使用 <code>kubeadm config images</code> 子命令列出并拉取镜像：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm config images list
kubeadm config images pull
</code></pre></div><!--
All images that kubeadm requires such as `k8s.gcr.io/kube-*`, `k8s.gcr.io/etcd` and `k8s.gcr.io/pause` support multiple architectures.
-->
<p>kubeadm 需要的所有镜像，例如 <code>k8s.gcr.io/kube-*</code>、<code>k8s.gcr.io/etcd</code> 和 <code>k8s.gcr.io/pause</code>
都支持多种架构。</p>
<!--
### Automating kubeadm
-->
<h3 id="kubeadm-自动化">kubeadm 自动化</h3>
<!--
Rather than copying the token you obtained from `kubeadm init` to each node, as
in the [basic kubeadm tutorial](/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/), you can parallelize the
token distribution for easier automation. To implement this automation, you must
know the IP address that the control-plane node will have after it is started,
or use a DNS name or an address of a load balancer.
-->
<p>除了像文档 <a href="/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubeadm 基础教程</a>
中所描述的那样，将从 <code>kubeadm init</code> 取得的令牌复制到每个节点，
你还可以并行地分发令牌以实现简单自动化。
要实现自动化，你必须知道控制平面节点启动后将拥有的 IP 地址，或使用 DNS 名称或负载均衡器的地址。</p>
<!--
1.  Generate a token. This token must have the form  `<6 character string>.<16
character string>`. More formally, it must match the regex: `[a-z0-9]{6}\.[a-z0-9]{16}`.
kubeadm can generate a token for you:
-->
<ol>
<li>
<p>生成一个令牌。这个令牌必须具有以下格式：<code>&lt; 6 个字符的字符串&gt;.&lt; 16 个字符的字符串&gt;</code>。
更加正式的说法是，它必须符合以下正则表达式：<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>kubeadm 可以为你生成一个令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm token generate
</code></pre></div></li>
</ol>
<!--
2.  Start both the control-plane node and the worker nodes concurrently with this token.
As they come up they should find each other and form the cluster. The same `-token` argument can be used on both `kubeadm init` and `kubeadm join`. 
-->
<ol start="2">
<li>使用这个令牌同时启动控制平面节点和工作节点。它们一旦运行起来应该就会互相寻找对方并且建立集群。
同样的 <code>--token</code> 参数可以同时用于 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令。</li>
</ol>
<!--
3.  Similar can be done for `-certificate-key` when joining additional control-plane nodes. The key can be generated using:
-->
<ol start="3">
<li>
<p>当加入其他控制平面节点时，可以对 <code>--certificate-key</code> 执行类似的操作。可以使用以下方式生成密钥：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm certs certificate-key
</code></pre></div></li>
</ol>
<!--
Once the cluster is up, you can grab the admin credentials from the control-plane node
at `/etc/kubernetes/admin.conf` and use that to talk to the cluster.
-->
<p>一旦集群启动起来，你就可以从控制平面节点的 <code>/etc/kubernetes/admin.conf</code> 文件获取管理凭证，
并使用这个凭证同集群通信。</p>
<!--
Note that this style of bootstrap has some relaxed security guarantees because
it does not allow the root CA hash to be validated with
`-discovery-token-ca-cert-hash` (since it's not generated when the nodes are
provisioned). For details, see the [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/).
-->
<p>注意这种搭建集群的方式在安全保证上会有一些宽松，因为这种方式不允许使用 <code>--discovery-token-ca-cert-hash</code>
来验证根 CA 的哈希值（因为当配置节点的时候，它还没有被生成）。
更多信息请参阅 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 文档。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init phase](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/) to understand more about
`kubeadm init` phases
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a Kubernetes cluster to a newer version
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>进一步阅读了解 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/">kubeadm init phase</a></li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
启动一个 Kubernetes 工作节点并且将其加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a>
将 Kubernetes 集群升级到新版本</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对节点所作的变更</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2a2b5f34806b4b1bd2c12682ac170d68">3 - kubeadm join</h1>
    
	<!-- overview -->
<!--
This command initializes a Kubernetes worker node and joins it to the cluster.
-->
<p>此命令用来初始化 Kubernetes 工作节点并将其加入集群。</p>
<!-- body -->

	<h3 id="摘要">摘要</h3>
<!--
When joining a kubeadm initialized cluster, we need to establish
bidirectional trust. This is split into discovery (having the Node
trust the Kubernetes Control Plane) and TLS bootstrap (having the
Kubernetes Control Plane trust the Node).
-->
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<!--
There are 2 main schemes for discovery. The first is to use a shared
token along with the IP address of the API server. The second is to
provide a file - a subset of the standard kubeconfig file. This file
can be a local file or downloaded via an HTTPS URL. The forms are
kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443,
kubeadm join --discovery-file path/to/file.conf, or kubeadm join
--discovery-file https://url/file.conf. Only one form can be used. If
the discovery information is loaded from a URL, HTTPS must be used.
Also, in that case the host installed CA bundle is used to verify
the connection.
-->
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<!--
If you use a shared token for discovery, you should also pass the
--discovery-token-ca-cert-hash flag to validate the public key of the
root certificate authority (CA) presented by the Kubernetes Control Plane.
The value of this flag is specified as "&lt;hash-type&gt;:&lt;hex-encoded-value&gt;",
where the supported hash type is "sha256". The hash is calculated over
the bytes of the Subject Public Key Info (SPKI) object (as in RFC7469).
This value is available in the output of "kubeadm init" or can be
calculated using standard tools. The --discovery-token-ca-cert-hash flag
may be repeated multiple times to allow more than one public key.
-->
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 &quot;&lt;hash-type&gt;:&lt;hex-encoded-value&gt;&quot;，其中支持的哈希类型为 &quot;sha256&quot;。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 &quot;kubeadm init&quot; 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<!--
If you cannot know the CA public key hash ahead of time, you can pass
the --discovery-token-unsafe-skip-ca-verification flag to disable this
verification. This weakens the kubeadm security model since other nodes
can potentially impersonate the Kubernetes Control Plane.
-->
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<!--
The TLS bootstrap mechanism is also driven via a shared token. This is
used to temporarily authenticate with the Kubernetes Control Plane to submit a
certificate signing request (CSR) for a locally created key pair. By
default, kubeadm will set up the Kubernetes Control Plane to automatically
approve these signing requests. This token is passed in with the
--tls-bootstrap-token abcdef.1234567890abcdef flag.

Often times the same token is used for both parts. In this case, the
--token flag can be used instead of specifying each token individually.
-->
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<!-- 
The "join [api-server-endpoint]" command executes the following phases:
-->
<p>&quot;join [api-server-endpoint]&quot; 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre><!-- 
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type&gt;:&lt;value&gt;")。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join
-->
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!--
### The join workflow {#join-workflow}
-->
<h3 id="join-workflow">join 工作流</h3>
<!--  
`kubeadm join` bootstraps a Kubernetes worker node and joins it to the cluster.
This action consists of the following steps:
-->
<p><code>kubeadm join</code> 初始化 Kubernetes 工作节点并将其加入集群。
该操作过程包含下面几个步骤：</p>
<!--
1. kubeadm downloads necessary cluster information from the API server.
   By default, it uses the bootstrap token and the CA key hash to verify the
   authenticity of that data. The root CA can also be discovered directly via a
   file or URL.
-->
<ol>
<li>kubeadm 从 API 服务器下载必要的集群信息。
默认情况下，它使用引导令牌和 CA 密钥哈希来验证数据的真实性。
也可以通过文件或 URL 直接发现根 CA。</li>
</ol>
<!--  
1. Once the cluster information is known, kubelet can start the TLS bootstrapping
   process.

   The TLS bootstrap uses the shared token to temporarily authenticate
   with the Kubernetes API server to submit a certificate signing request (CSR); by
   default the control plane signs this CSR request automatically.
-->
<ol start="2">
<li>
<p>一旦知道集群信息，kubelet 就可以开始 TLS 引导过程。</p>
<p>TLS 引导程序使用共享令牌与 Kubernetes API 服务器进行临时的身份验证，以提交证书签名请求 (CSR)；
默认情况下，控制平面自动对该 CSR 请求进行签名。</p>
</li>
</ol>
<!-- 
1. Finally, kubeadm configures the local kubelet to connect to the API
   server with the definitive identity assigned to the node.
-->
<ol start="3">
<li>最后，kubeadm 配置本地 kubelet 使用分配给节点的确定标识连接到 API 服务器。</li>
</ol>
<!-- 
For control-plane nodes additional steps are performed:

1. Downloading certificates shared among control-plane nodes from the cluster
  (if explicitly requested by the user).

1. Generating control-plane component manifests, certificates and kubeconfig.

1. Adding new local etcd member.
-->
<p>对于控制平面节点，执行额外的步骤：</p>
<ol>
<li>
<p>从集群下载控制平面节点之间共享的证书（如果用户明确要求）。</p>
</li>
<li>
<p>生成控制平面组件清单、证书和 kubeconfig。</p>
</li>
<li>
<p>添加新的本地 etcd 成员。</p>
</li>
</ol>
<!-- 
### Using join phases with kubeadm {#join-phases}
-->
<h3 id="join-phases">使用 kubeadm 的 join phase 命令</h3>
<!-- 
Kubeadm allows you join a node to the cluster in phases using `kubeadm join phase`.
-->
<p>Kubeadm 允许你使用 <code>kubeadm join phase</code> 分阶段将节点加入集群。</p>
<!--  
To view the ordered list of phases and sub-phases you can call `kubeadm join --help`. The list will be located
at the top of the help screen and each phase will have a description next to it.
Note that by calling `kubeadm join` all of the phases and sub-phases will be executed in this exact order.
-->
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm join --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm join</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<!--  
Some phases have unique flags, so if you want to have a look at the list of available options add `--help`, for example:
-->
<p>有些阶段具有唯一的标志，因此，如果要查看可用选项列表，请添加 <code>--help</code>，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join phase kubelet-start --help
</code></pre></div><!-- 
Similar to the [kubeadm init phase](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases)
command, `kubeadm join phase` allows you to skip a list of phases using the `--skip-phases` flag.

For example:
-->
<p>类似于 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases">kubeadm init phase</a>命令，
<code>kubeadm join phase</code> 允许你使用 <code>--skip-phases</code> 标志跳过阶段列表。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sudo kubeadm join --skip-phases<span style="color:#666">=</span>preflight --config<span style="color:#666">=</span>config.yaml
</code></pre></div>




<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>


<!--
Alternatively, you can use the `skipPhases` field in `JoinConfiguration`.
-->
<p>或者，你可以使用 <code>JoinConfiguration</code> 中的 <code>skipPhases</code> 字段。</p>
<!--
### Discovering what cluster CA to trust
-->
<h3 id="发现要信任的集群-ca">发现要信任的集群 CA</h3>
<!-- 
The kubeadm discovery has several options, each with security tradeoffs.
The right method for your environment depends on how you provision nodes and the
security expectations you have about your network and node lifecycles.
-->
<p>Kubeadm 的发现有几个选项，每个选项都有安全性上的优缺点。
适合你的环境的正确方法取决于节点是如何准备的以及你对网络的安全性期望
和节点的生命周期特点。</p>
<!--
#### Token-based discovery with CA pinning
-->
<h4 id="带-ca-锁定模式的基于令牌的发现">带 CA 锁定模式的基于令牌的发现</h4>
<!-- 
This is the default mode in Kubernetes 1.8 and above. In this mode, kubeadm downloads
the cluster configuration (including root CA) and validates it using the token
as well as validating that the root CA public key matches the provided hash and
that the API server certificate is valid under the root CA.
-->
<p>这是 Kubernetes 1.8 及以上版本中的默认模式。
在这种模式下，kubeadm 下载集群配置（包括根CA）并使用令牌验证它，
并且会验证根 CA 的公钥与所提供的哈希是否匹配，
以及 API 服务器证书在根 CA 下是否有效。</p>
<!--
The CA key hash has the format `sha256:<hex_encoded_hash>`. By default, the hash value is returned in the `kubeadm join` command printed at the end of `kubeadm init` or in the output of `kubeadm token create --print-join-command`. It is in a standard format (see [RFC7469](https://tools.ietf.org/html/rfc7469#section-2.4)) and can also be calculated by 3rd party tools or provisioning systems. For example, using the OpenSSL CLI:
-->
<p>CA 键哈希格式为 <code>sha256:&lt;hex_encoded_hash&gt;</code>。
默认情况下，在 <code>kubeadm init</code> 最后打印的 <code>kubeadm join</code> 命令
或者 <code>kubeadm token create --print-join-command</code> 的输出信息中返回哈希值。
它使用标准格式 (请参考 <a href="https://tools.ietf.org/html/rfc7469#section-2.4">RFC7469</a>)
并且也能通过第三方工具或者制备系统进行计算。
例如，使用 OpenSSL CLI：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style="color:#b44">&#39;s/^.* //&#39;</span>
</code></pre></div><!--
**Example `kubeadm join` command:**
-->
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<!--
For worker nodes:
-->
<p>对于工作节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</code></pre></div><!--
For control-plane nodes:
-->
<p>对于控制面节点：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</code></pre></div><!-- 
You can also call `join` for a control-plane node with `--certificate-key` to copy certificates to this node,
if the `kubeadm init` command was called with `--upload-certs`.
-->
<p>如果使用 <code>--upload-certs</code> 调用 <code>kubeadm init</code> 命令，
你也可以对控制平面节点调用带 <code>--certificate-key</code> 参数的 <code>join</code> 命令，
将证书复制到该节点。</p>
<!--
**Advantages:**

 - Allows bootstrapping nodes to securely discover a root of trust for the
   master even if other worker nodes or the network are compromised.

 - Convenient to execute manually since all of the information required fits
   into a single `kubeadm join` command.
-->
<p><strong>优势：</strong></p>
<ul>
<li>
<p>允许引导节点安全地发现主节点的信任根，即使其他工作节点或网络受到损害。</p>
</li>
<li>
<p>方便手动执行，因为所需的所有信息都可放到一个 <code>kubeadm join</code> 命令中。</p>
</li>
</ul>
<!-- 
**Disadvantages:**

- The CA hash is not normally known until the master has been provisioned,
  which can make it more difficult to build automated provisioning tools that
  use kubeadm. By generating your CA in beforehand, you may workaround this
  limitation though.
-->
<p><strong>劣势：</strong></p>
<ul>
<li>CA 哈希通常在主节点被提供之前是不知道的，这使得构建使用 kubeadm 的自动化配置工具更加困难。
通过预先生成CA，你可以解除这个限制。</li>
</ul>
<!--   
#### Token-based discovery without CA pinning
-->
<h4 id="无-ca-锁定模式的基于令牌的发现">无 CA 锁定模式的基于令牌的发现</h4>
<!--  
_This was the default in Kubernetes 1.7 and earlier_, but comes with some
important caveats. This mode relies only on the symmetric token to sign
(HMAC-SHA256) the discovery information that establishes the root of trust for
the master. It's still possible in Kubernetes 1.8 and above using the
`--discovery-token-unsafe-skip-ca-verification` flag, but you should consider
using one of the other modes if possible.

**Example `kubeadm join` command:**
-->
<p>_这是 Kubernetes 1.7 和早期版本_中的默认设置；使用时要注意一些重要的补充说明。
此模式仅依赖于对称令牌来签名(HMAC-SHA256)发现信息，这些发现信息为主节点建立信任根。
在 Kubernetes 1.8 及以上版本中仍然可以使用 <code>--discovery-token-unsafe-skip-ca-verification</code>
参数，但是如果可能的话，你应该考虑使用一种其他模式。</p>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</code></pre></div><!--
**Advantages:**

- Still protects against many network-level attacks.

- The token can be generated ahead of time and shared with the master and
  worker nodes, which can then bootstrap in parallel without coordination. This
  allows it to be used in many provisioning scenarios.
-->
<p><strong>优势</strong></p>
<ul>
<li>
<p>仍然可以防止许多网络级攻击。</p>
</li>
<li>
<p>可以提前生成令牌并与主节点和工作节点共享，这样主节点和工作节点就可以并行引导而无需协调。
这允许它在许多配置场景中使用。</p>
</li>
</ul>
<!--
**Disadvantages:**

- If an attacker is able to steal a bootstrap token via some vulnerability,
  they can use that token (along with network-level access) to impersonate the
  master to other bootstrapping nodes. This may or may not be an appropriate
  tradeoff in your environment.
-->
<p><strong>劣势</strong></p>
<ul>
<li>如果攻击者能够通过某些漏洞窃取引导令牌，那么他们可以使用该令牌（连同网络级访问）
为其它处于引导过程中的节点提供假冒的主节点。
在你的环境中，这可能是一个适当的折衷方法，也可能不是。</li>
</ul>
<!--
#### File or HTTPS-based discovery
-->
<h4 id="基于-https-或文件发现">基于 HTTPS 或文件发现</h4>
<!-- 
This provides an out-of-band way to establish a root of trust between the control-plane node
and bootstrapping nodes. Consider using this mode if you are building automated provisioning
using kubeadm. The format of the discovery file is a regular Kubernetes
[kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters/) file.

In case the discovery file does not contain credentials, the TLS discovery token will be used.
-->
<p>这种方案提供了一种带外方式在主节点和引导节点之间建立信任根。
如果使用 kubeadm 构建自动配置，请考虑使用此模式。
发现文件的格式为常规的 Kubernetes
<a href="/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/">kubeconfig</a> 文件。</p>
<p>如果发现文件不包含凭据，则将使用 TLS 发现令牌。</p>
<!--
**Example `kubeadm join` commands:**
-->
<p><strong><code>kubeadm join</code> 命令示例：</strong></p>
<ul>
<li>
<p><code>kubeadm join --discovery-file path/to/file.conf</code> （本地文件）</p>
</li>
<li>
<p><code>kubeadm join --discovery-file https://url/file.conf</code> (远程 HTTPS URL)</p>
</li>
</ul>
<!--
**Advantages:**

- Allows bootstrapping nodes to securely discover a root of trust for the
  master even if the network or other worker nodes are compromised.
-->
<p><strong>优势：</strong></p>
<ul>
<li>允许引导节点安全地发现主节点的信任根，即使网络或其他工作节点受到损害。</li>
</ul>
<!--
**Disadvantages:**

- Requires that you have some way to carry the discovery information from
  the master to the bootstrapping nodes. This might be possible, for example,
  via your cloud provider or provisioning tool. The information in this file is
  not secret, but HTTPS or equivalent is required to ensure its integrity.
-->
<p><strong>劣势：</strong></p>
<ul>
<li>要求你有某种方法将发现信息从主节点传送到引导节点。
例如，这可以通过云提供商或驱动工具实现。
该文件中的信息不是加密的，而是需要 HTTPS 或等效文件来保证其完整性。</li>
</ul>
<!--
### Securing your installation even more {#securing-more}
-->
<h3 id="securing-more">确保你的安装更加安全</h3>
<!-- 
The defaults for kubeadm may not work for everyone. This section documents how to tighten up a kubeadm installation
at the cost of some usability.
-->
<p>Kubeadm 的默认值可能不适用于所有人。
本节说明如何以牺牲可用性为代价来加强 kubeadm 安装。</p>
<!--
#### Turning off auto-approval of node client certificates
-->
<h4 id="关闭节点客户端证书的自动批准">关闭节点客户端证书的自动批准</h4>
<!-- 
By default, there is a CSR auto-approver enabled that basically approves any client certificate request
for a kubelet when a Bootstrap Token was used when authenticating. If you don't want the cluster to
automatically approve kubelet client certs, you can turn it off by executing this command:
-->
<p>默认情况下，Kubernetes 启用了 CSR 自动批准器，如果在身份验证时使用启动引导令牌，
它会批准对 kubelet 的任何客户端证书的请求。
如果不希望集群自动批准kubelet客户端证书，可以通过执行以下命令关闭它：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</code></pre></div><!--
After that, `kubeadm join` will block until the admin has manually approved the CSR in flight:
-->
<p>关闭后，<code>kubeadm join</code> 操作将会被阻塞，直到管理员已经手动批准了在途中的 CSR 才会继续：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>certificatesigningrequest &quot;node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ&quot; approved
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre><!--  
This forces the workflow that `kubeadm join` will only succeed if `kubectl certificate approve` has been run.
-->
<p>这迫使工作流只有在运行了 kubectl 证书批准后，kubeadm join 才能成功。</p>
<!--
#### Turning off public access to the cluster-info ConfigMap
-->
<h4 id="关闭对集群信息-configmap-的公开访问">关闭对集群信息 ConfigMap 的公开访问</h4>
<!-- 
In order to achieve the joining flow using the token as the only piece of validation information, a
 ConfigMap with some data needed for validation of the master's identity is exposed publicly by
default. While there is no private data in this ConfigMap, some users might wish to turn
it off regardless. Doing so will disable the ability to use the `--discovery-token` flag of the
`kubeadm join` flow. Here are the steps to do so:
-->
<p>为了实现使用令牌作为唯一验证信息的加入工作流，默认情况下会公开带有验证主节点标识
所需数据的 ConfigMap。
虽然此 ConfigMap 中没有私有数据，但一些用户可能希望无论如何都关闭它。
这样做需要禁用 <code>kubeadm join</code> 工作流的 <code>--discovery-token</code> 参数。
以下是实现步骤：</p>
<!-- 
* Fetch the `cluster-info` file from the API Server:
-->
<ul>
<li>从 API 服务器获取 <code>cluster-info</code> 文件：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-public get cm cluster-info -o yaml | grep <span style="color:#b44">&#34;kubeconfig:&#34;</span> -A11 | grep <span style="color:#b44">&#34;apiVersion&#34;</span> -A10 | sed <span style="color:#b44">&#34;s/    //&#34;</span> | tee cluster-info.yaml
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;ca-cert&gt;
    server: https://&lt;ip&gt;:&lt;port&gt;
  name: &quot;&quot;
contexts: []
current-context: &quot;&quot;
preferences: {}
users: []
</code></pre><!--
* Use the `cluster-info.yaml` file as an argument to `kubeadm join --discovery-file`.

* Turn off public access to the `cluster-info` ConfigMap:
-->
<ul>
<li>
<p>使用 <code>cluster-info.yaml</code> 文件作为 <code>kubeadm join --discovery-file</code> 参数。</p>
</li>
<li>
<p>关闭 <code>cluster-info</code> ConfigMap 的公开访问：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</code></pre></div></li>
</ul>
<!--
These commands should be run after `kubeadm init` but before `kubeadm join`.
-->
<p>这些命令应该在执行 <code>kubeadm init</code> 之后、在<code>kubeadm join</code> 之前执行。</p>
<!-- 
### Using kubeadm join with a configuration file {#config-file}
-->
<h3 id="使用带有配置文件的-kubeadm-join">使用带有配置文件的 kubeadm join</h3>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--The config file is still considered alpha and may change in future versions.-->
<p>配置文件目前是 alpha 功能，在将来的版本中可能会变动。
</div>

<!--
It's possible to configure `kubeadm join` with a configuration file instead of command
line flags, and some more advanced features may only be available as
configuration file options. This file is passed using the `--config` flag and it must
contain a `JoinConfiguration` structure. Mixing `--config` with others flags may not be
allowed in some cases.
-->
<p>可以用配置文件替代命令行参数的方法配置 <code>kubeadm join</code>，一些高级功能也只有在使用配置文件时才可选用。
该文件通过 <code>--config</code> 参数来传递，并且文件中必须包含 <code>JoinConfiguration</code> 结构。
在某些情况下，不允许将 <code>--config</code> 与其他标志混合使用。</p>
<!--  
The default configuration can be printed out using the
[kubeadm config print](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.

If your configuration is not using the latest version it is **recommended** that you migrate using
the [kubeadm config migrate](/docs/reference/setup-tools/kubeadm/kubeadm-config/) command.
-->
<p>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config print</a>
命令可以打印默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config migrate</a>
命令转换。</p>
<!--
For more information on the fields and usage of the configuration you can navigate to our
[API reference](/docs/reference/config-api/kubeadm-config.v1beta3/).
-->
<p>有关配置的字段和用法的更多信息，你可以导航到我们的
<a href="/zh/docs/reference/config-api/kubeadm-config.v1beta3/">API 参考页</a>。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes master node
* [kubeadm token](/docs/reference/setup-tools/kubeadm/kubeadm-token/) to manage tokens for `kubeadm join`
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
初始化 Kubernetes 主节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/">kubeadm token</a>
管理 <code>kubeadm join</code> 的令牌</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
将 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对主机的更改恢复到之前状态</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-2c20539d9fabf5982e2dd931742714bd">4 - kubeadm upgrade</h1>
    
	<!--
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm upgrade
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
`kubeadm upgrade` is a user-friendly command that wraps complex upgrading logic
behind one command, with support for both planning an upgrade and actually performing it. -->
<p><code>kubeadm upgrade</code> 是一个对用户友好的命令，它将复杂的升级逻辑包装在一个命令后面，支持升级的规划和实际执行。</p>
<!-- body -->
<!--
## kubeadm upgrade guidance
-->
<h2 id="kubeadm-upgrade-指南">kubeadm upgrade 指南</h2>
<!--
The steps for performing an upgrade using kubeadm are outlined in [this document](/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/).
For older versions of kubeadm, please refer to older documentation sets of the Kubernetes website.
-->
<p><a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">本文档</a>概述
使用 kubeadm 执行升级的步骤。
与 kubeadm 旧版本相关的文档，请参阅 Kubernetes 网站的旧版文档。</p>
<!--
You can use `kubeadm upgrade diff` to see the changes that would be applied to static pod manifests.
-->
<p>你可以使用 <code>kubeadm upgrade diff</code> 来查看将应用于静态 Pod 清单的更改。</p>
<!--
In Kubernetes v1.15.0 and later, `kubeadm upgrade apply` and `kubeadm upgrade node` will also
automatically renew the kubeadm managed certificates on this node, including those stored in kubeconfig files.
To opt-out, it is possible to pass the flag `--certificate-renewal=false`. For more details about certificate
renewal see the [certificate management documentation](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs).
-->
<p>在 Kubernetes v1.15.0 和更高版本中，<code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade node</code>
也将自动续订该节点上的 kubeadm 托管证书，包括存储在 kubeconfig 文件中的证书。
要选择退出，可以传递参数 <code>--certificate-renewal=false</code>。
有关证书续订的更多详细信息请参见<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs">证书管理文档</a>。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
The commands `kubeadm upgrade apply` and `kubeadm upgrade plan` have a legacy `--config`
flag which makes it possible to reconfigure the cluster, while performing planning or upgrade of that particular
control-plane node. Please be aware that the upgrade workflow was not designed for this scenario and there are
reports of unexpected results.
-->
<p><code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade plan</code> 命令都具有遗留的 <code>--config</code> 标志，
可以在执行特定控制平面节点的规划或升级时重新配置集群。
请注意，升级工作流不是为这种情况而设计的，并且有意外结果的报告。
</div>
<h2 id="cmd-upgrade-plan">kubeadm upgrade plan</h2>

	<h3 id="概述">概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-apply">kubeadm upgrade apply </h2>

	<h3 id="概要">概要</h3>
<!--
Upgrade your Kubernetes cluster to the specified version
-->
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show unstable versions of Kubernetes as an upgrade alternative and allow upgrading to an alpha/beta/release candidate versions of Kubernetes.
-->
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Show release candidate versions of Kubernetes as an upgrade alternative and allow upgrading to a release candidate versions of Kubernetes.
-->
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan="2">--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output what actions would be performed.
-->
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true
-->
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能。选项包括：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Force upgrading although some requirements might not be met. This also implies non-interactive mode.
-->
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apply
-->
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--print-config</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specifies whether the configuration file that will be used in the upgrade should be printed or not.
-->
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan="2">-y, --yes</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade and do not prompt for confirmation (non-interactive mode).
-->
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-diff">kubeadm upgrade diff</h2>

	<h3 id="概述">概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre><!--

### Options

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to API server manifest</td>
</tr>
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">API服务器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td>
</tr>
-->
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">How many lines of context in the diff</td>
</tr>
-->
<tr>
<td colspan="2">-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">差异中有多少行上下文</td>
</tr>
<!--
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to controller manifest</td>
</tr>
-->
<tr>
<td colspan="2">--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">控制器清单的路径</td>
</tr>
<!--
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for diff</td>
</tr>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">帮助</td>
</tr>
<!--
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
</tr>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<!--
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">path to scheduler manifest</td>
</tr>
</tbody>
</table>
-->
<tr>
<td colspan="2">--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">调度程序清单的路径</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands

   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>

<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
</tr>

</tbody>
</table>

-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>

<h2 id="cmd-upgrade-node">kubeadm upgrade node</h2>

	<h3 id="概要">概要</h3>
<!--
Upgrade commands for a node in the cluster
-->
<p>升级集群中某个节点的命令</p>
<!--
The "node" command executes the following phases:
-->
<p>&quot;node&quot; 命令执行以下阶段：</p>
<!--
```
preflight       Run upgrade node pre-flight checks
control-plane   Upgrade the control plane instance deployed on this node, if any
kubelet-config  Upgrade the kubelet configuration for this node
```
-->
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the renewal of certificates used by component changed during upgrades.
-->
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Do not change any state, just output the actions that would be performed.
-->
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
-->
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Perform the upgrade of etcd.
-->
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for node
-->
node 操作的帮助命令
</td>
</tr>
<tr>
<!-- 
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The *desired* version for the kubelet config after the upgrade. If not specified, the KubernetesVersion from the kubeadm-config ConfigMap will be used
-->
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
List of phases to be skipped
-->
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config/) if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for `kubeadm upgrade`
-->
<ul>
<li>如果你使用 kubeadm v1.7.x 或更低版本初始化集群，则可以参考
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm 配置</a>
配置集群用于 <code>kubeadm upgrade</code>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5042dc49c5348b3674d3878f37f7670b">5 - kubeadm config</h1>
    
	<!-- overview -->
<!--
During `kubeadm init`, kubeadm uploads the `ClusterConfiguration` object to your cluster
in a ConfigMap called `kubeadm-config` in the `kube-system` namespace. This configuration is then read during
`kubeadm join`, `kubeadm reset` and `kubeadm upgrade`. To view this ConfigMap call `kubeadm config view`.
-->
<p>在 <code>kubeadm init</code> 执行期间，kubeadm 将 <code>ClusterConfiguration</code> 对象上传
到你的集群的 <code>kube-system</code> 名字空间下名为 <code>kubeadm-config</code> 的 ConfigMap 对象中。
然后在 <code>kubeadm join</code>、<code>kubeadm reset</code> 和 <code>kubeadm upgrade</code> 执行期间读取此配置。
要查看此 ConfigMap，请调用 <code>kubeadm config view</code>。</p>
<!--
You can use `kubeadm config print` to print the default configuration and `kubeadm config migrate` to
convert your old configuration files to a newer version. `kubeadm config images list` and
`kubeadm config images pull` can be used to list and pull the images that kubeadm requires.
-->
<p>你可以使用 <code>kubeadm config print</code> 命令打印默认配置，
并使用 <code>kubeadm config migrate</code> 命令将旧版本的配置转化成新版本。
<code>kubeadm config images list</code> 和 <code>kubeadm config images pull</code>
命令可以用来列出并拉取 kubeadm 所需的镜像。</p>
<!--
For more information navigate to
[Using kubeadm init with a configuration file](/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file)
or [Using kubeadm join with a configuration file](/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file).
-->
<p>更多信息请浏览<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file">使用带配置文件的 kubeadm init</a>
或<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file">使用带配置文件的 kubeadm join</a>.</p>
<!--
You can also configure several kubelet-configuration options with `kubeadm init`. These options will be the same on any node in your cluster. 
See [Configuring each kubelet in your cluster using kubeadm](/docs/setup/production-environment/tools/kubeadm/kubelet-integration/) for details.
-->
<p>你也可以在使用 <code>kubeadm init</code> 命令时配置若干 kubelet 配置选项。
这些选项对于集群中所有节点而言都是相同的。
参阅<a href="/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/">使用 kubeadm 来配置集群中的各个 kubelet</a>
了解详细信息。</p>
<!--
In Kubernetes v1.13.0 and later to list/pull kube-dns images instead of the CoreDNS image
the `--config` method described [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon)
has to be used.
-->
<p>在 Kubernetes v1.13.0 及更高版本中，要列出/拉取 kube-dns 镜像而不是 CoreDNS 镜像，
必须使用<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">这里</a>
所描述的 <code>--config</code> 方法。</p>
<!-- body -->
<h2 id="cmd-config-from-file">kubeadm config upload from-file</h2>
<h2 id="cmd-config-view">kubeadm config print</h2>

	<!--
Print configuration
-->
<p>打印配置</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command prints configurations for subcommands provided.
For details, see: https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories
-->
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅: <a href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories">https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p>
<pre><code>kubeadm config print [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p><!--help for print-->print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承而来的选项">从父命令继承而来的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<!--Default:-->默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!--td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-print-init-defaults">kubeadm config print init-defaults</h2>

	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default init configuration that is used for 'kubeadm init'.
-->
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for init-defaults
-->
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-print-join-defaults">kubeadm config print join-defaults</h2>

	<h3 id="概要">概要</h3>
<!--
This command prints objects such as the default join configuration that is used for 'kubeadm join'.
-->
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<!--
Note that sensitive values like the Bootstrap Token fields are replaced with placeholder values like {"abcdef.0123456789abcdef" "" "nil" &lt;nil&gt; [] []} in order to pass validation but
not perform the real computation for creating a token.
-->
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {&quot;abcdef.0123456789abcdef&quot; &quot;&quot; &quot;nil&quot; &lt;nil&gt; [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A comma-separated list for component config API objects to print the default values for. Available values: [KubeProxyConfiguration KubeletConfiguration]. If this flag is not set, no component configs will be printed.
-->
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for join-defaults
-->
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-migrate">kubeadm config migrate</h2>

	<h3 id="概要">概要</h3>
<!--
This command lets you convert configuration objects of older versions to the latest supported version,
locally in the CLI tool without ever touching anything in the cluster.
In this version of kubeadm, the following API versions are supported:
- kubeadm.k8s.io/v1beta2
-->
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<!--
Further, kubeadm can only write out config of version "kubeadm.k8s.io/v1beta2", but read both types.
So regardless of what version you pass to the --old-config parameter here, the API object will be
read, deserialized, defaulted, converted, validated, and re-serialized when written to stdout or
--new-config if specified.
-->
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<!--
In other words, the output of this command is what kubeadm actually would read internally if you
submitted this file to "kubeadm init"
-->
<p>换句话说，如果您将此文件传递给 &quot;kubeadm init&quot;，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for migrate -->
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan="2">--new-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the resulting equivalent kubeadm config file using the new API version. Optional, if not specified output will be sent to STDOUT.
-->
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan="2">--old-config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the kubeadm config file that is using an old API version and should be converted. This flag is mandatory.
-->
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-images-list">kubeadm config images list</h2>

	<h3 id="概要">概要</h3>
<!--
Print a list of images kubeadm will use. The configuration file is used in case any images or image repositories are customized.
-->
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），用于描述各种特征。选项是：
<br/>Auditing=true|false (ALPHA - 默认=false)
<br/>CoreDNS=true|false (默认=true)
<br/>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for list
-->
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- --image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io" -->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-config-images-pull">kubeadm config images pull</h2>

	<h3 id="概要">概要</h3>
<!--
Pull images used by kubeadm.
-->
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一系列键值对（key=value），用于描述各种特征。可选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for pull
-->
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a Kubernetes cluster to a newer version
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a>
将 Kubernetes 集群升级到更新版本 [kubeadm upgrade]</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6eb5bc1e7114609930a76c683cc27c2b">6 - kubeadm reset</h1>
    
	<!-- ---
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm reset
content_type: concept
weight: 60
--- -->
<!-- overview -->
<!-- Performs a best effort revert of changes made by `kubeadm init` or `kubeadm join`. -->
<p>该命令尽力还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Performs a best effort revert of changes made to this host by 'kubeadm init' or 'kubeadm join'
-->
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<!--
The "reset" command executes the following phases:
-->
<p>&quot;reset&quot; 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for reset
-->
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- List of phases to be skipped -->
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<!-- ### Reset workflow {#reset-workflow} -->
<h3 id="reset-workflow">Reset 工作流程</h3>
<!-- `kubeadm reset` is responsible for cleaning up a node local file system from files that were created using
the `kubeadm init` or `kubeadm join` commands. For control-plane nodes `reset` also removes the local stacked
etcd member of this node from the etcd cluster.
-->
<p><code>kubeadm reset</code> 负责从使用 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令创建的文件中清除节点本地文件系统。
对于控制平面节点，<code>reset</code> 还从 etcd 集群中删除该节点的本地 etcd Stacked 部署的成员。</p>
<!-- `kubeadm reset phase` can be used to execute the separate phases of the above workflow.
To skip a list of phases you can use the `--skip-phases` flag, which works in a similar way to
the `kubeadm join` and `kubeadm init` phase runners. -->
<p><code>kubeadm reset phase</code> 可用于执行上述工作流程的各个阶段。
要跳过阶段列表，你可以使用 <code>--skip-phases</code> 参数，该参数的工作方式类似于 <code>kubeadm join</code> 和 <code>kubeadm init</code> 阶段运行器。</p>
<!-- ### External etcd clean up -->
<h3 id="外部-etcd-清理">外部 etcd 清理</h3>
<!-- `kubeadm reset` will not delete any etcd data if external etcd is used. This means that if you run `kubeadm init` again using the same etcd endpoints, you will see state from previous clusters. -->
<p>如果使用了外部 etcd，<code>kubeadm reset</code> 将不会删除任何 etcd 中的数据。这意味着，如果再次使用相同的 etcd 端点运行 <code>kubeadm init</code>，你将看到先前集群的状态。</p>
<!-- To wipe etcd data it is recommended you use a client like etcdctl, such as: -->
<p>要清理 etcd 中的数据，建议你使用 etcdctl 这样的客户端，例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">etcdctl del <span style="color:#b44">&#34;&#34;</span> --prefix
</code></pre></div><!-- See the [etcd documentation](https://github.com/coreos/etcd/tree/master/etcdctl) for more information. -->
<p>更多详情请参考 <a href="https://github.com/coreos/etcd/tree/master/etcdctl">etcd 文档</a>。</p>
<h2 id="what-s-next">What's next</h2>
<!-- * [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster -->
<ul>
<li>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> 来初始化 Kubernetes 主节点。</li>
<li>参考 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 来初始化 Kubernetes 工作节点并加入集群。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-516f4705fb2f5f62c76c7742772726a3">7 - kubeadm token</h1>
    
	<!--
---
reviewers:
- mikedanese
- luxas
- jbeda
title: kubeadm token
content_type: concept
weight: 70
---
-->
<!-- overview -->
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining
the cluster and a master node, as described in [authenticating with bootstrap tokens](/docs/reference/access-authn-authz/bootstrap-tokens/).
-->
<p>如<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用引导令牌进行身份验证</a>所描述的，引导令牌用于在即将加入集群的节点和主节点间建立双向认证。</p>
<!--
`kubeadm init` creates an initial token with a 24-hour TTL. The following commands allow you to manage
such a token and also to create and manage new ones.
-->
<p><code>kubeadm init</code> 创建了一个有效期为 24 小时的令牌，下面的命令允许你管理令牌，也可以创建和管理新的令牌。</p>
<!-- body -->
<h2 id="cmd-token-create">kubeadm token create</h2>

	<h3 id="概要">概要</h3>
<!--
This command will create a bootstrap token for you.
You can specify the usages for this token, the "time to live" and an optional human friendly description.

The [token] is the actual token to write.
This should be a securely generated random token of the form "[a-z0-9]{6}.[a-z0-9]{16}".
If no [token] is given, kubeadm will generate a random token instead.
-->
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，&quot;有效时间&quot; 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--description string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A human friendly description of how this token is used.
-->
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [system:bootstrappers:kubeadm:default-node-token]
-->
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Extra groups that this token will authenticate as when used for authentication. Must match "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
-->
此令牌用于身份验证时将进行身份验证的其他组。必须匹配  "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for create
-->
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--print-join-command</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Instead of printing only the token, print the full 'kubeadm join' flag needed to join the cluster using the token.
-->
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 24h0m0s
-->
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The duration before the token is automatically deleted (e.g. 1s, 2m, 3h). If set to '0', the token will never expire
-->
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: [signing,authentication]
-->
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Describes the ways in which this token can be used. You can pass --usages multiple times or provide a comma separated list of options. Valid options: [signing,authentication]
-->
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-delete">kubeadm token delete</h2>

	<h3 id="概要">概要</h3>
<!--
This command will delete a list of bootstrap tokens for you.

The [token-value] is the full Token of the form "[a-z0-9]{6}.[a-z0-9]{16}" or the
Token ID of the form "[a-z0-9]{6}" to delete.
-->
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot; 形式的完整令牌或者是 &quot;[a-z0-9]{6}&quot; 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for delete
-->
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Whether to enable dry-run mode or not
-->
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-generate">kubeadm token generate</h2>

	<h3 id="概要">概要</h3>
<!--
This command will print out a randomly-generated bootstrap token that can be used with
the "init" and "join" commands.

You don't have to use this command in order to generate a token. You can do so
yourself as long as it is in the format "[a-z0-9]{6}.[a-z0-9]{16}". This
command is provided for convenience to generate tokens in the given format.

You can also use "kubeadm init" without specifying a token and it will
generate and print one for you.
-->
<p>此命令将打印一个随机生成的可以被 &quot;init&quot; 和 &quot;join&quot; 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 &quot;kubeadm init&quot; 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for generate
-->
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="cmd-token-list">kubeadm token list</h2>

	<h3 id="概要">概要</h3>
<!--
This command will list all bootstrap tokens for you.
-->
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true -->
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- 
If true, ignore any errors in templates when a field or map key is missing in the template. Only applies to golang and jsonpath output formats.
-->
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan="2">
<!-- -o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "text" -->
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Output format. One of: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.
-->
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for list -->
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Whether to enable dry-run mode or not -->
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to bootstrap a Kubernetes worker node and join it to the cluster
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 引导 Kubernetes 工作节点并将其加入集群</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-34c4af6f36d969ed08ba840e7fb64c6d">8 - kubeadm version</h1>
    
	<!--
reviewers:
- luxas
- jbeda
title: kubeadm version
content_type: concept
weight: 80
-->
<!-- overview -->
<!--
This command prints the version of kubeadm.
-->
<p>此命令用来输出 kubeadm 的版本。</p>
<!-- body -->

	<h3 id="概要">概要</h3>
<!--
Print the version of kubeadm
-->
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for version
-->
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">-o, --output string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Output format; available options are 'yaml', 'json' and 'short'
-->
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>


</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-92a39c69c3689119dd5fa12886cb73a3">9 - kubeadm alpha</h1>
    
	<!--
title: kubeadm alpha
content_type: concept
weight: 90
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
`kubeadm alpha` provides a preview of a set of features made available for gathering feedback
 from the community. Please try it out and give us feedback!
 -->
<p><code>kubeadm alpha</code> 提供了一组可用于收集社区反馈的预览性质功能。
请试用这些功能并给我们提供反馈！
</div>

<!--
Currently there are no experimental commands under `kubeadm alpha`.
-->
<p>目前在 <code>kubeadm alpha</code> 之下没有试验性质的命令。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>用来启动引导 Kubernetes 控制平面节点的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
命令</li>
<li>用来还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
命令</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6a1fed09235bbf3644c804339928f10e">10 - kubeadm certs</h1>
    
	<!--
`kubeadm certs` provides utilities for managing certificates.
For more details on how these commands can be used, see
[Certificate Management with kubeadm](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/).
-->
<p><code>kubeadm certs</code> 提供管理证书的工具。关于如何使用这些命令的细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/">使用 kubeadm 管理证书</a>。</p>
<h2 id="cmd-certs">kubeadm certs</h2>
<!--
A collection of operations for operating Kubernetes certificates.
-->
<p>用来操作 Kubernetes 证书的一组命令。</p>
<ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">概览</a></li>
	  </ul>
<div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0">

<p><!--
Commands related to handling kubernetes certificates
-->
<p>处理 Kubernetes 证书的相关命令</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
Commands related to handling kubernetes certificates
-->
<p>处理 Kubernetes 证书相关的命令</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;"><p>help for certs</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!-- help for certs--><p>certs 命令的帮助</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p></td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;"><p>[实验] 到'真实'主机根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-renew">kubeadm certs renew</h2>
<!--
You can renew all Kubernetes certificates using the `all` subcommand or renew them selectively.
For more details see [Manual certificate renewal](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal).
-->
<p>你可以使用 <code>all</code> 子命令来续订所有 Kubernetes 证书，也可以选择性地续订部分证书。
更多的相关细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal">手动续订证书</a>。</p>
<ul class="nav nav-tabs" id="tab-certs-renew" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-renew-0" role="tab" aria-controls="tab-certs-renew-0" aria-selected="true">renew</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-1" role="tab" aria-controls="tab-certs-renew-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-2" role="tab" aria-controls="tab-certs-renew-2">admin.conf</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-3" role="tab" aria-controls="tab-certs-renew-3">apiserver-etcd-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-4" role="tab" aria-controls="tab-certs-renew-4">apiserver-kubelet-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-5" role="tab" aria-controls="tab-certs-renew-5">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-6" role="tab" aria-controls="tab-certs-renew-6">controller-manager.conf</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-7" role="tab" aria-controls="tab-certs-renew-7">etcd-healthcheck-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-8" role="tab" aria-controls="tab-certs-renew-8">etcd-peer</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-9" role="tab" aria-controls="tab-certs-renew-9">etcd-server</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-10" role="tab" aria-controls="tab-certs-renew-10">front-proxy-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-renew-11" role="tab" aria-controls="tab-certs-renew-11">scheduler.conf</a></li></ul>
<div class="tab-content" id="tab-certs-renew"><div id="tab-certs-renew-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-renew-0">

<p><!--
Renew certificates for a Kubernetes cluster
-->
<p>为 Kubernetes 集群更新证书</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
help for renew
-->
renew 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-1">

<p><h3 id="概要">概要</h3>
<!--
Renew all known certificates necessary to run the control plane. Renewals are run unconditionally, regardless of expiration date. Renewals can also be run individually for more control.
-->
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-2">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself.
-->
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- --cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for admin.conf -->
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.  -->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-3">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate the apiserver uses to access etcd.
-->
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!-- cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki" -->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path to output the CSRs and private keys to -->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create CSRs instead of generating certificates -->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use the Kubernetes certificate API to renew certificates -->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-4">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for the API server to connect to kubelet.
-->
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-5">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for serving the Kubernetes API.
-->
<p>续订用于提供 Kubernetes API 的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-6">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the controller manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager.conf
-->
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-7">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for liveness probes to healthcheck etcd.
-->
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-8">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for etcd nodes to communicate with each other.
-->
<p>续订 etcd 节点间用来相互通信的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-peer
-->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-9">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for serving etcd.
-->
<p>续订用于提供 etcd 服务的证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-server
-->
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-10">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate for the front proxy client.
-->
<p>为前端代理客户端续订证书。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-renew-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-renew-11">

<p><h3 id="概要">概要</h3>
<!--
Renew the certificate embedded in the kubeconfig file for the scheduler manager to use.
-->
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<!--
Renewals run unconditionally, regardless of certificate expiration date; extra attributes such as SANs will be based on the existing file/certificates, there is no need to resupply them.
-->
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<!--
Renewal by default tries to use the certificate authority in the local PKI managed by kubeadm; as alternative it is possible to use K8s certificate API for certificate renewal, or as a last option, to generate a CSR request.
-->
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<!--
After renewal, in order to make changes effective, is is required to restart control-plane components and eventually re-distribute the renewed certificate in case the file is used elsewhere.
-->
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the certificates.
-->
保存证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--csr-dir string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to output the CSRs and private keys to
-->
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan="2">--csr-only</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create CSRs instead of generating certificates
-->
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler.conf
-->
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--use-api</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use the Kubernetes certificate API to renew certificates
-->
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-certificate-key">kubeadm certs certificate-key</h2>
<!--
This command can be used to generate a new control-plane certificate key.
The key can be passed as `--certificate-key` to [`kubeadm init`](/docs/reference/setup-tools/kubeadm/kubeadm-init)
and [`kubeadm join`](/docs/reference/setup-tools/kubeadm/kubeadm-join)
to enable the automatic copy of certificates when joining additional control-plane nodes.
-->
<p>此命令可用来生成一个新的控制面证书密钥。密钥可以作为 <code>--certificate-key</code>
标志的取值传递给 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init"><code>kubeadm init</code></a>
和 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join"><code>kubeadm join</code></a>
命令，从而在添加新的控制面节点时能够自动完成证书复制。</p>
<ul class="nav nav-tabs" id="tab-certs-certificate-key" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-certificate-key-0" role="tab" aria-controls="tab-certs-certificate-key-0" aria-selected="true">certificate-key</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-certificate-key"><div id="tab-certs-certificate-key-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-certificate-key-0">

<p><!--
Generate certificate keys
-->
<p>生成证书密钥</p>
<!--
### Synopsis
-->
<h3 id="概要">概要</h3>
<!--
This command will print out a secure randomly-generated certificate key that can be used with
the "init" command.
-->
<p>该命令将打印出可以与 &quot;init&quot; 命令一起使用的安全的随机生成的证书密钥。</p>
<!--
You can also use "kubeadm init -upload-certs" without specifying a certificate key and it will generate and print one for you.
-->
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
help for certificate-key
-->
certificate-key 操作的帮助命令
</p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<p>
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</p>
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-check-expiration">kubeadm certs check-expiration</h2>
<!--
This command checks expiration for the certificates in the local PKI managed by kubeadm.
For more details see
[Check certificate expiration](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration).
-->
<p>此命令检查 kubeadm 所管理的本地 PKI 中的证书是否以及何时过期。
更多的相关细节，可参见
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration">检查证书过期</a>。</p>
<ul class="nav nav-tabs" id="tab-certs-check-expiration" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-check-expiration-0" role="tab" aria-controls="tab-certs-check-expiration-0" aria-selected="true">check-expiration</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-check-expiration"><div id="tab-certs-check-expiration-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-check-expiration-0">

<p><h3 id="概要">概要</h3>
<!-- 
Checks expiration for the certificates in the local PKI managed by kubeadm.
-->
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!--
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> 
-->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td>
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for check-expiration</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-certs-generate-csr">kubeadm certs generate-csr</h2>
<!--
This command can be used to generate keys and CSRs for all control-plane certificates and kubeconfig files.
The user can then sign the CSRs with a CA of their choice.
-->
<p>此命令可用来为所有控制面证书和 kubeconfig 文件生成密钥和 CSR（签名请求）。
用户可以根据自身需要选择 CA 为 CSR 签名。</p>
<ul class="nav nav-tabs" id="tab-certs-generate-csr" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-generate-csr-0" role="tab" aria-controls="tab-certs-generate-csr-0" aria-selected="true">generate-csr</a></li>
	  </ul>
<div class="tab-content" id="tab-certs-generate-csr"><div id="tab-certs-generate-csr-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-generate-csr-0">

<p><p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 &quot;users &gt; user &gt; client-key-data&quot; 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 &quot;.csr&quot; 文件。</p>
<!--  
This command is designed for use in [Kubeadm External CA Mode](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode). It generates CSRs which you can then submit to your external certificate authority for signing.
-->
<p>此命令设计用于
<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode">Kubeadm 外部 CA 模式</a>。 
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<!--  
The PEM encoded signed certificates should then be saved alongside the key files, using ".crt" as the file extension, or in the case of kubeconfig files, the PEM encoded signed certificate should be base64 encoded and added to the kubeconfig file in the "users &gt; user &gt; client-certificate-data" field.
-->
<p>应使用 &quot;.crt&quot; 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 &quot;users &gt; user &gt; client-certificate-data&quot; 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!-- 
```
  # The following command will generate keys and CSRs for all control-plane certificates and kubeconfig files:
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
```
-->
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the certificates</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存证书的路径</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">help for generate-csr</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">generate-csr 命令的帮助</td>
</tr>
<tr>
<!-- td colspan="2">-kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"</td -->
<td colspan="2">--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save the kubeconfig file.</td-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
-->
<ul>
<li>用来启动引导 Kubernetes 控制面节点的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
命令</li>
<li>用来回滚 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对当前主机所做修改的
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
命令</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-fbe8dcd222ce5795a5c325670a26b067">11 - kubeadm init phase</h1>
    
	<!--
title: kubeadm init phase
weight: 90
content_type: concept
-->
<!--
`kubeadm init phase` enables you to invoke atomic steps of the bootstrap process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm init phase</code> 能确保调用引导过程的原子步骤。
因此，如果希望自定义应用，则可以让 kubeadm 做一些工作，然后填补空白。</p>
<!--
`kubeadm init phase` is consistent with the [kubeadm init workflow](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm init phase</code> 与 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">kubeadm init 工作流</a>
一致，后台都使用相同的代码。</p>
<!--
## kubeadm init phase preflight {#cmd-phase-preflight}
-->
<h2 id="cmd-phase-preflight">kubeadm init phase preflight</h2>
<!--
Using this command you can execute preflight checks on a control-plane node.
-->
<p>使用此命令可以在控制平面节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm init.
-->
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre><!--
### Examples
-->
<h3 id="案例">案例</h3>
<!--
# Run pre-flight checks for kubeadm init using a config file.
-->
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase kubelet-start {#cmd-phase-kubelet-start}
-->
<h2 id="cmd-phase-kubelet-start">kubeadm init phase kubelet-start</h2>
<!--
This phase will write the kubelet configuration file and environment file and then start the kubelet.
-->
<p>此阶段将检查 kubelet 配置文件和环境文件，然后启动 kubelet。</p>
<ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li>
	  </ul>
<div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0">

<p><h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Writes a dynamic environment file with kubelet flags from a InitConfiguration file.
-->
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase certs {#cmd-phase-certs}
-->
<h2 id="cmd-phase-certs">kubeadm init phase certs</h2>
<!--
Can be used to create all required certificates by kubeadm.
-->
<p>该阶段可用于创建 kubeadm 所需的所有证书。</p>
<ul class="nav nav-tabs" id="tab-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-certs-0" role="tab" aria-controls="tab-certs-0" aria-selected="true">certs</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-1" role="tab" aria-controls="tab-certs-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-2" role="tab" aria-controls="tab-certs-2">ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-3" role="tab" aria-controls="tab-certs-3">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-4" role="tab" aria-controls="tab-certs-4">apiserver-kubelet-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-5" role="tab" aria-controls="tab-certs-5">front-proxy-ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-6" role="tab" aria-controls="tab-certs-6">front-proxy-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-7" role="tab" aria-controls="tab-certs-7">etcd-ca</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-8" role="tab" aria-controls="tab-certs-8">etcd-server</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-9" role="tab" aria-controls="tab-certs-9">etcd-peer</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-10" role="tab" aria-controls="tab-certs-10">healthcheck-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-11" role="tab" aria-controls="tab-certs-11">apiserver-etcd-client</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-certs-12" role="tab" aria-controls="tab-certs-12">sa</a></li></ul>
<div class="tab-content" id="tab-certs"><div id="tab-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-certs-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令中继承的选项">从父指令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all certificates
-->
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令 
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-2">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components, and save them into ca.cert and ca.key files.
-->
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for ca
-->
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for serving the Kubernetes API, and save them into apiserver.cert and apiserver.key files.
-->
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<!--
Default SANs are kubernetes, kubernetes.default, kubernetes.default.svc, kubernetes.default.svc.cluster.local, 10.96.0.1, 127.0.0.1
-->
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Optional extra Subject Alternative Names (SANs) to use for the API Server serving certificate. Can be both IP addresses and DNS names.
-->
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for the API server to connect to kubelet, and save them into apiserver-kubelet-client.cert and apiserver-kubelet-client.key files.
-->
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver-kubelet-client
-->
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for front proxy, and save them into front-proxy-ca.cert and front-proxy-ca.key files.
-->
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-ca
-->
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-6" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-6">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for the front proxy client, and save them into front-proxy-client.cert and front-proxy-client.key files.
If both files already exist, kubeadm skips the generation step and existing files will be used.
Alpha Disclaimer: this command is currently alpha.
-->
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for front-proxy-client
-->
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-7" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-7">

<p><h3 id="概要">概要</h3>
<!--
Generate the self-signed CA to provision identities for etcd, and save them into etcd/ca.cert and etcd/ca.key files.
-->
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-ca
-->
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-8" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-8">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for serving etcd, and save them into etcd/server.crt and etcd/server.key files.
-->
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.crt 和 etcd/server.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>The path where to save and store the certificates.</p>
-->
<p>保存和存储证书的路径。<p>
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>Path to a kubeadm configuration file.</p>
-->
<p>kubeadm 配置文件的路径。<p>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>help for etcd-server</p>
-->
<p>etcd-server 操作的帮助命令<p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>Choose a specific Kubernetes version for the control plane.</p>
-->
<p>为控制平面指定特定的 Kubernetes 版本。<p>
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
<p>[EXPERIMENTAL] The path to the 'real' host root filesystem.</p>
-->
<p>[实验] 到 '真实' 主机根文件系统的路径。<p>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-9" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-9">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for etcd nodes to communicate with each other, and save them into etcd/peer.cert and etcd/peer.key files.
-->
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<!--
Default SANs are localhost, 127.0.0.1, 127.0.0.1, ::1
-->
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd-peer -->
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-10" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-10">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate for liveness probes to healthcheck etcd, and save them into etcd/healthcheck-client.cert and etcd/healthcheck-client.key files.
-->
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
证书存储的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd-healthcheck-client
-->
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-11" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-11">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificate the apiserver uses to access etcd, and save them into apiserver-etcd-client.cert and apiserver-etcd-client.key files.
-->
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<!--
If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
证书的存储路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for apiserver-etcd-client -->
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1" -->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem. -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-certs-12" class="tab-pane" role="tabpanel" aria-labelledby="tab-certs-12">

<p><h3 id="概要">概要</h3>
<!--
Generate the private key for signing service account tokens along with its public key, and save them into sa.key and sa.pub files. If both files already exist, kubeadm skips the generation step and existing files will be used.
-->
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<!--
Alpha Disclaimer: this command is currently alpha.
-->
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for sa
-->
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase kubeconfig {#cmd-phase-kubeconfig}
-->
<h2 id="cmd-phase-kubeconfig">kubeadm init phase kubeconfig</h2>
<!--
You can create all required kubeconfig files by calling the `all` subcommand or call them individually.
-->
<p>可以通过调用 <code>all</code> 子命令来创建所有必需的 kubeconfig 文件，或者分别调用它们。</p>
<ul class="nav nav-tabs" id="tab-kubeconfig" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-0" role="tab" aria-controls="tab-kubeconfig-0" aria-selected="true">kubeconfig</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-1" role="tab" aria-controls="tab-kubeconfig-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-2" role="tab" aria-controls="tab-kubeconfig-2">admin</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-3" role="tab" aria-controls="tab-kubeconfig-3">kubelet</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-4" role="tab" aria-controls="tab-kubeconfig-4">controller-manager</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubeconfig-5" role="tab" aria-controls="tab-kubeconfig-5">scheduler</a></li></ul>
<div class="tab-content" id="tab-kubeconfig"><div id="tab-kubeconfig-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-0">

<p><h3 id="概要">概要</h3>
<!-- 
This command is not meant to be run on its own. See list of available subcommands. 
-->
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all kubeconfig files
-->
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-2">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the admin and for kubeadm itself, and save it to admin.conf file.
-->
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for admin
-->
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the kubelet to use and save it to kubelet.conf file.
-->
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<!--
Please note that this should *only* be used for cluster bootstrapping purposes. After your control plane is up, you should request all kubelet credentials from the CSR API.
-->
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet
-->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the controller manager to use and save it to controller-manager.conf file
-->
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>    
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"> 
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubeconfig-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubeconfig-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig file for the scheduler to use and save it to scheduler.conf file.
-->
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes"
-->
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save the kubeconfig file.
-->
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase control-plane {#cmd-phase-control-plane}
-->
<h2 id="cmd-phase-control-plane">kubeadm init phase control-plane</h2>
<!--
Using this phase you can create all required static Pod files for the control plane components.
-->
<p>使用此阶段，可以为控制平面组件创建所有必需的静态 Pod 文件。</p>
<ul class="nav nav-tabs" id="tab-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-0" role="tab" aria-controls="tab-control-plane-0" aria-selected="true">control-plane</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-1" role="tab" aria-controls="tab-control-plane-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-2" role="tab" aria-controls="tab-control-plane-2">apiserver</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-3" role="tab" aria-controls="tab-control-plane-3">controller-manager</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-4" role="tab" aria-controls="tab-control-plane-4">scheduler</a></li></ul>
<div class="tab-content" id="tab-control-plane"><div id="tab-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for control-plane -->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-1">

<p><h3 id="概要">概要</h3>
<!--
Generate all static Pod manifest files
-->
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre><!--
### Examples


```
# Generates all static Pod manifest files for control plane components,
# functionally equivalent to what is generated by kubeadm init.
# Generates all static Pod manifest files using options read from a configuration file.
```
-->
<h3 id="示例">示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<!-- td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443</td -->
<td colspan="2">--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
形式为 &lt;flagname&gt;=&lt;value&gt; 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组形式为 &lt;flagname&gt;=&lt;value&gt; 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname&gt;=&lt;value&gt; 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父指令继承的选项">从父指令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-2">

<p><h3 id="概要">概要</h3>
<!-- 
Generates the kube-apiserver static Pod manifest 
-->
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan="2">--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the API Server or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)<br/>PublicKeysECDSA=true|false (ALPHA - default=false)
-->
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br/>IPv6DualStack=true|false (ALPHA - 默认=false)
<br/>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for apiserver
-->
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<!-- 
### Options inherited from parent commands 
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-3">

<p><h3 id="概要">概要</h3>
<!--
Generates the kube-controller-manager static Pod manifest
-->
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Controller Manager or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for controller-manager
-->
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-4">

<p><h3 id="概要">概要</h3>
<!--
Generates the kube-scheduler static Pod manifest
-->
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path where to save and store the certificates.
-->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for scheduler
-->
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of extra flags to pass to the Scheduler or override default ones in form of &lt;flagname&gt;=&lt;value&gt;
-->
一组 &lt;flagname&gt;=&lt;value&gt; 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase etcd {#cmd-phase-etcd}
-->
<h2 id="cmd-phase-etcd">kubeadm init phase etcd</h2>
<!--
Use the following phase to create a local etcd instance based on a static Pod file.
-->
<p>根据静态 Pod 文件，使用以下阶段创建本地 etcd 实例。</p>
<ul class="nav nav-tabs" id="tab-etcd" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-etcd-0" role="tab" aria-controls="tab-etcd-0" aria-selected="true">etcd</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-etcd-1" role="tab" aria-controls="tab-etcd-1">local</a></li></ul>
<div class="tab-content" id="tab-etcd"><div id="tab-etcd-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-etcd-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for etcd -->
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-etcd-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-etcd-1">

<p><h3 id="概要">概要</h3>
<!--
Generate the static Pod manifest file for a local, single-node local etcd instance
-->
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Generates the static Pod manifest file for etcd, functionally
# equivalent to what is generated by kubeadm init.
# Generates the static Pod manifest file for etcd using options
# read from a configuration file.
-->
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- The path where to save and store the certificates.  -->
存储证书的路径。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for local -->
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a container registry to pull control plane images from -->
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase upload-config {#cmd-phase-upload-config}
-->
<h2 id="cmd-phase-upload-config">kubeadm init phase upload-config</h2>
<!--
You can use this command to upload the kubeadm configuration to your cluster.
Alternatively, you can use [kubeadm config](/docs/reference/setup-tools/kubeadm/kubeadm-config/).
-->
<p>可以使用此命令将 kubeadm 配置文件上传到集群。或者使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/">kubeadm config</a>。</p>
<ul class="nav nav-tabs" id="upload-config" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#upload-config-0" role="tab" aria-controls="upload-config-0" aria-selected="true">upload-config</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-1" role="tab" aria-controls="upload-config-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-2" role="tab" aria-controls="upload-config-2">kubeadm</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#upload-config-3" role="tab" aria-controls="upload-config-3">kubelet</a></li></ul>
<div class="tab-content" id="upload-config"><div id="upload-config-0" class="tab-pane show active" role="tabpanel" aria-labelledby="upload-config-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-config
-->
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-1" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-1">

<p><h3 id="概要">概要</h3>
<!--
Upload all configuration to a config map
-->
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-2" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-2">

<p><h3 id="概要">概要</h3>
<!--
Upload the kubeadm ClusterConfiguration to a ConfigMap called kubeadm-config in the kube-system namespace. This enables correct configuration of system components and a seamless user experience when upgrading.
-->
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<!--
Alternatively, you can use kubeadm config.
-->
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# upload the configuration of your cluster
-->
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeadm
-->
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="upload-config-3" class="tab-pane" role="tabpanel" aria-labelledby="upload-config-3">

<p><h3 id="概要">概要</h3>
<!--
Upload kubelet configuration extracted from the kubeadm InitConfiguration object to a ConfigMap of the form kubelet-config-1.X in the cluster, where X is the minor version of the current (API Server) Kubernetes version.
-->
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
  # Upload the kubelet configuration from the kubeadm Config file to a ConfigMap in the cluster.
  kubeadm init phase upload-config kubelet --config kubeadm.yaml
```
-->
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to a kubeadm configuration file.  -->
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubelet -->
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!-- kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf" -->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase upload-certs {#cmd-phase-upload-certs}
-->
<h2 id="cmd-phase-upload-certs">kubeadm init phase upload-certs</h2>
<!--
Use the following phase to upload control-plane certificates to the cluster.
By default the certs and encryption key expire after two hours.
-->
<p>使用以下阶段将控制平面证书上传到集群。默认情况下，证书和加密密钥会在两个小时后过期。</p>
<ul class="nav nav-tabs" id="tab-upload-certs" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-upload-certs-0" role="tab" aria-controls="tab-upload-certs-0" aria-selected="true">upload-certs</a></li>
	  </ul>
<div class="tab-content" id="tab-upload-certs"><div id="tab-upload-certs-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-upload-certs-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Key used to encrypt the control-plane certificates in the kubeadm-certs Secret.
-->
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for upload-certs
-->
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<!-- td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Don't print the key used to encrypt the control-plane certificates.
-->
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan="2">--upload-certs</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Upload control-plane certificates to the kubeadm-certs Secret.
-->
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase mark-control-plane {#cmd-phase-mark-control-plane}
-->
<h2 id="cmd-phase-mark-control-plane">kubeadm init phase mark-control-plane</h2>
<!--
Use the following phase to label and taint the node with the `node-role.kubernetes.io/master=""` key-value pair.
-->
<p>使用以下阶段来给具有 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 键值对的节点
打标签（label）和记录污点（taint）。</p>
<ul class="nav nav-tabs" id="tab-mark-control-plane" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-mark-control-plane-0" role="tab" aria-controls="tab-mark-control-plane-0" aria-selected="true">mark-control-plane</a></li>
	  </ul>
<div class="tab-content" id="tab-mark-control-plane"><div id="tab-mark-control-plane-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-mark-control-plane-0">

<p><h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre><!--
### Examples

# Applies control-plane label and taint to the current node, functionally equivalent to what executed by kubeadm init.
# Applies control-plane label and taint to a specific node
-->
<h3 id="示例">示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase bootstrap-token {#cmd-phase-bootstrap-token}
-->
<h2 id="cmd-phase-bootstrap-token">kubeadm init phase bootstrap-token</h2>
<!--
Use the following phase to configure bootstrap tokens.
-->
<p>使用以下阶段来配置引导令牌。</p>
<ul class="nav nav-tabs" id="tab-bootstrap-token" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-bootstrap-token-0" role="tab" aria-controls="tab-bootstrap-token-0" aria-selected="true">bootstrap-token</a></li>
	  </ul>
<div class="tab-content" id="tab-bootstrap-token"><div id="tab-bootstrap-token-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-bootstrap-token-0">

<p><h3 id="概要">概要</h3>
<!--
Bootstrap tokens are used for establishing bidirectional trust between a node joining the cluster and a control-plane node.
-->
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<!--
This command makes all the configurations required to make bootstrap tokens works and then creates an initial token.
-->
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
# Make all the bootstrap token configurations and create an initial token, functionally equivalent to what generated by kubeadm init.
-->
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for bootstrap-token
-->
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">--skip-token-print</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Skip printing of the default bootstrap token generated by 'kubeadm init'.
-->
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-phase-kubelet-finalize-all">kubeadm init phase kubelet-finalize</h2>
<!-- 
Use the following phase to update settings relevant to the kubelet after TLS
bootstrap. You can use the `all` subcommand to run all `kubelet-finalize`
phases.
-->
<p>使用以下阶段在 TLS 引导后更新与 kubelet 相关的设置。
你可以使用 <code>all</code> 子命令来运行所有 <code>kubelet-finalize</code> 阶段。</p>
<ul class="nav nav-tabs" id="tab-kubelet-finalize" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-finalize-0" role="tab" aria-controls="tab-kubelet-finalize-0" aria-selected="true">kubelet-finalize</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-1" role="tab" aria-controls="tab-kubelet-finalize-1">kubelet-finalize-all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-kubelet-finalize-2" role="tab" aria-controls="tab-kubelet-finalize-2">kubelet-finalize-cert-rotation</a></li></ul>
<div class="tab-content" id="tab-kubelet-finalize"><div id="tab-kubelet-finalize-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-finalize-0">

<p><p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for kubelet-finalize</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubelet-finalize-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-1">

<p><p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre><!-- ### Examples -->
<h3 id="示例">示例</h3>
<!--  
```
  # Updates settings relevant to the kubelet after TLS bootstrap
  kubeadm init phase kubelet-finalize all --config
```
-->
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- <td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td> -->
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for all</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-kubelet-finalize-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-kubelet-finalize-2">

<p><p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">The path where to save and store the certificates.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">Path to a kubeadm configuration file.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for experimental-cert-rotation</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm init phase addon {#cmd-phase-addon}
-->
<h2 id="cmd-phase-addon">kubeadm init phase addon</h2>
<!--
You can install all the available addons with the `all` subcommand, or
install them selectively.
-->
<p>可以使用 <code>all</code> 子命令安装所有可用的插件，或者有选择性地安装它们。</p>
<ul class="nav nav-tabs" id="tab-addon" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-addon-0" role="tab" aria-controls="tab-addon-0" aria-selected="true">addon</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-1" role="tab" aria-controls="tab-addon-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-2" role="tab" aria-controls="tab-addon-2">coredns</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-addon-3" role="tab" aria-controls="tab-addon-3">kube-proxy</a></li></ul>
<div class="tab-content" id="tab-addon"><div id="tab-addon-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-addon-0">

<p><h3 id="概要">概要</h3>
<!--
This command is not meant to be run on its own. See list of available subcommands.
-->
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for addon
-->
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-1">

<p><h3 id="概要">概要</h3>
<!--
Install all the addons
-->
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组键值对（key=value），描述了各种特征。选项包括：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative range of IP address for service VIPs.
-->
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use alternative domain for services, e.g. "myorg.internal".
-->
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-2">

<p><h3 id="概要">概要</h3>
<!--
Install the CoreDNS addon components via the API server. Please note that although the DNS server is deployed, it will not be scheduled until CNI is installed.
-->
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--feature-gates string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A set of key=value pairs that describe feature gates for various features. Options are:<br/>IPv6DualStack=true|false (ALPHA - default=false)
-->
一组用来描述各种功能特性的键值（key=value）对。选项是：<br/>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for coredns -->
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Choose a specific Kubernetes version for the control plane.  -->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "10.96.0.0/12"
-->
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative range of IP address for service VIPs.  -->
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "cluster.local"
-->
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Use alternative domain for services, e.g. "myorg.internal".  -->
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-addon-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-addon-3">

<p><h3 id="概要">概要</h3>
<!--
Install the kube-proxy addon components via the API server.
-->
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Port for the API Server to bind to.
-->
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify a stable IP address or DNS name for the control plane.
-->
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kube-proxy
-->
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">
<!--
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "k8s.gcr.io"
-->
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a container registry to pull control plane images from
-->
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"
-->
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.
-->
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "stable-1"
-->
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Choose a specific Kubernetes version for the control plane.
-->
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan="2">--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify range of IP addresses for the pod network. If set, the control plane will automatically allocate CIDRs for every node.
-->
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
For more details on each field in the `v1beta3` configuration you can navigate to our
[API reference pages.](/docs/reference/config-api/kubeadm-config.v1beta3/)
-->
<p>有关 <code>v1beta3</code> 配置中每个字段的更多详细信息，可以访问
<a href="/zh/docs/reference/config-api/kubeadm-config.v1beta3/">API</a>。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-62a742c564b0b5b7ac12a95e67cc425a">12 - kubeadm join phase</h1>
    
	<!--
title: kubeadm join phase
weight: 90
-->
<!--
`kubeadm join phase` enables you to invoke atomic steps of the join process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm join phase</code> 使你能够调用 <code>join</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<!--
`kubeadm join phase` is consistent with the [kubeadm join workflow](/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm join phase</code> 与
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow">kubeadm join 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id="cmd-join-phase">kubeadm join phase</h2>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  </ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the join workflow
-->
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for phase -->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-preflight">kubeadm join phase preflight</h2>
<!--
Using this phase you can execute preflight checks on a joining node.
-->
<p>使用此命令可以在即将加入集群的节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm join.
-->
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre><!--
### Examples
# Run join pre-flight checks using a config file.
-->
<h3 id="示例">示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-control-plane-prepare">kubeadm join phase control-plane-prepare</h2>
<!--
Using this phase you can prepare a node for serving a control-plane.
-->
<p>使用此阶段，你可以准备一个作为控制平面的节点。</p>
<ul class="nav nav-tabs" id="tab-control-plane-prepare" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-prepare-0" role="tab" aria-controls="tab-control-plane-prepare-0" aria-selected="true">control-plane-prepare</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-1" role="tab" aria-controls="tab-control-plane-prepare-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-2" role="tab" aria-controls="tab-control-plane-prepare-2">download-certs</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-3" role="tab" aria-controls="tab-control-plane-prepare-3">certs</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-4" role="tab" aria-controls="tab-control-plane-prepare-4">kubeconfig</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-prepare-5" role="tab" aria-controls="tab-control-plane-prepare-5">control-plane</a></li></ul>
<div class="tab-content" id="tab-control-plane-prepare"><div id="tab-control-plane-prepare-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-prepare-0">

<p><h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre><!--
### Examples
-->
<!--
# Prepares the machine for serving a control plane
-->
<h3 id="示例">示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-prepare
-->
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-1">

<p><h3 id="概要">概要</h3>
<!--
Prepare the machine for serving a control plane
-->
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-2">

<p><h3 id="概要">概要</h3>
<!--
[EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
-->
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-3">

<p><h3 id="概要">概要</h3>
<!--
Generate the certificates for the new control plane components
-->
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for certs
-->
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-4">

<p><h3 id="概要">概要</h3>
<!--
Generate the kubeconfig for the new control plane components
-->
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-key string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this key to decrypt the certificate secrets uploaded by init.
-->
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubeconfig
-->
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-prepare-5" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-prepare-5">

<p><h3 id="概要">概要</h3>
<!--
Generate the manifests for the new control plane components
-->
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">
<!--
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 6443
-->
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the port for the API Server to bind to.
-->
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane
-->
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-kubelet-start">kubeadm join phase kubelet-start</h2>
<!--
Using this phase you can write the kubelet settings, certificates and (re)start the kubelet.
-->
<p>使用此阶段，你可以配置 kubelet 设置、证书和（重新）启动 kubelet。</p>
<ul class="nav nav-tabs" id="tab-kubelet-start" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubelet-start-0" role="tab" aria-controls="tab-kubelet-start-0" aria-selected="true">kubelet-start</a></li>
	  </ul>
<div class="tab-content" id="tab-kubelet-start"><div id="tab-kubelet-start-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubelet-start-0">

<p><h3 id="概要">概要</h3>
<!--
Write a file with KubeletConfiguration and an environment file with node specific kubelet settings, and then (re)start kubelet.
-->
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">--discovery-file string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
For file-based discovery, a file or URL from which to load cluster information.
<!--
For file-based discovery, a file or URL from which to load cluster information.
-->
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, the token used to validate cluster information fetched from the API server.
-->
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, validate that the root CA public key matches this hash (format: "&lt;type&gt;:&lt;value&gt;").
-->
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type&gt;:&lt;value&gt;"）。
</td>
</tr>
<tr>
<td colspan="2">--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
For token-based discovery, allow joining without --discovery-token-ca-cert-hash pinning.
-->
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for kubelet-start
-->
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
<tr>
<td colspan="2">--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the token used to temporarily authenticate with the Kubernetes Control Plane while joining the node.
-->
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Use this token for both discovery-token and tls-bootstrap-token when those values are not provided.
-->
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-join-phase-control-plane-join">kubeadm join phase control-plane-join</h2>
<!--
Using this phase you can join a node as a control-plane instance.
-->
<p>使用此阶段，你可以将节点作为控制平面实例加入。</p>
<ul class="nav nav-tabs" id="tab-control-plane-join" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-control-plane-join-0" role="tab" aria-controls="tab-control-plane-join-0" aria-selected="true">control-plane-join</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-1" role="tab" aria-controls="tab-control-plane-join-1">all</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-2" role="tab" aria-controls="tab-control-plane-join-2">etcd</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-3" role="tab" aria-controls="tab-control-plane-join-3">update-status</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-control-plane-join-4" role="tab" aria-controls="tab-control-plane-join-4">mark-control-plane</a></li></ul>
<div class="tab-content" id="tab-control-plane-join"><div id="tab-control-plane-join-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-control-plane-join-0">

<p><h3 id="概要">概要</h3>
<!--
Join a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre><!--
### Examples
-->
<h3 id="示例">示例</h3>
<!--
```
# Joins a machine as a control plane instance
kubeadm join phase control-plane-join all
```
-->
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for control-plane-join
-->
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-1">

<p><h3 id="概要">概要</h3>
<!--
Joins a machine as a control plane instance
-->
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm config file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for all
-->
all 操作的帮助命令      
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-2">

<p><h3 id="概要">概要</h3>
<!--
Add a new local etcd member
-->
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for etcd
-->
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-3">

<p><h2 id="概要">概要</h2>
<!-- 
Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap 
-->
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre><!-- 
### Options 
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
If the node should host a new control plane instance, the IP address the API Server will advertise it's listening on. If not set the default network interface will be used.
-->
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Path to kubeadm config file.  -->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Create a new control plane instance on this node -->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for update-status -->
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- Specify the node name.  -->
指定节点名称。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- [EXPERIMENTAL] The path to the 'real' host root filesystem.  -->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-control-plane-join-4" class="tab-pane" role="tabpanel" aria-labelledby="tab-control-plane-join-4">

<p><h3 id="概要">概要</h3>
<!--
Mark a node as a control-plane
-->
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to kubeadm configuration file.
-->
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan="2">--control-plane</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Create a new control plane instance on this node
-->
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for mark-control-plane
-->
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--node-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Specify the node name.
-->
指定节点的名称
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令中继承的选项">从父命令中继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点添加到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1ab2d643d770ca684548de4ddbc7d8c4">13 - kubeadm kubeconfig</h1>
    
	<!--
`kubeadm kubeconfig` provides utilities for managing kubeconfig files.

For examples on how to use `kubeadm kubeconfig user` see
[Generating kubeconfig files for additional users](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#kubeconfig-additional-users).
-->
<p><code>kubeadm kubeconfig</code> 提供用来管理 kubeconfig 文件的工具。</p>
<p>如果希望查看如何使用 <code>kubeadm kubeconfig user</code> 的示例，请参阅
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#kubeconfig-additional-users">为其他用户生成 kubeconfig 文件</a>.</p>
<h2 id="cmd-kubeconfig">kubeadm kubeconfig</h2>
<ul class="nav nav-tabs" id="tab-kubeconfig" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-0" role="tab" aria-controls="tab-kubeconfig-0" aria-selected="true">overview</a></li>
	  </ul>
<div class="tab-content" id="tab-kubeconfig"><div id="tab-kubeconfig-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-0">

<p><!--
Kubeconfig file utilities

### Synopsis

Kubeconfig file utilities.

### Options
-->
<p>Kubeconfig 文件工具。</p>
<h3 id="概要">概要</h3>
<p>kubeconfig 文件工具。</p>
<h3 id="选项">选项</h3>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!-- help for kubeconfig -->
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-kubeconfig-user">kubeadm kubeconfig user</h2>
<!--
This command can be used to output a kubeconfig file for an additional user.
-->
<p>此命令可用来为其他用户生成一个 kubeconfig 文件。</p>
<ul class="nav nav-tabs" id="tab-kubeconfig-user" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-kubeconfig-user-0" role="tab" aria-controls="tab-kubeconfig-user-0" aria-selected="true">user</a></li>
	  </ul>
<div class="tab-content" id="tab-kubeconfig-user"><div id="tab-kubeconfig-user-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-kubeconfig-user-0">

<p><!--
Output a kubeconfig file for an additional user

### Synopsis

Output a kubeconfig file for an additional user.
-->
<p>为其他用户输出一个 kubeconfig 文件。</p>
<h3 id="概要">概要</h3>
<p>为其他用户输出一个 kubeconfig 文件。</p>
<pre><code>kubeadm alpha kubeconfig user [flags]
</code></pre><!--
### Examples

```
  # Output a kubeconfig file for an additional user named foo using a kubeadm config file bar
  kubeadm alpha kubeconfig user --client-name=foo --config=bar
```
-->
<h3 id="示例">示例</h3>
<pre><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--client-name string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The name of user. It will be used as the CN if client certificates are created
-->
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan="2">--config string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to a kubeadm configuration file.
-->
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for user
-->
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--org strings</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The orgnizations of the client certificate. It will be used as the O if client certificates are created
-->
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan="2">--token string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The token that should be used as the authentication mechanism for this kubeconfig, instead of client certificates
-->
应该用此令牌做为 kubeconfig 的身份验证机制，而不是客户端证书
</td>
</tr>
<tr>
<td colspan="2">--validity-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 8760h0m0s</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;"><!--The validity period of the client certificate. It is an offset from the current time.-->
<p>
客户证书的合法期限。所设置值为相对当前时间的偏移。
</p></td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>
</div></div>


</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-b969d0033ce5d9036463521fb1f150b3">14 - kubeadm reset phase</h1>
    
	<!--
title: kubeadm reset phase
content_type: concept
weight: 90
-->
<!--
`kubeadm reset phase` enables you to invoke atomic steps of the node reset process.
Hence, you can let kubeadm do some of the work and you can fill in the gaps
if you wish to apply customization.
-->
<p><code>kubeadm reset phase</code> 使你能够调用 <code>reset</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<!--
`kubeadm reset phase` is consistent with the [kubeadm reset workflow](/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow),
and behind the scene both use the same code.
-->
<p><code>kubeadm reset phase</code> 与
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow">kubeadm reset 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id="cmd-reset-phase">kubeadm reset phase</h2>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  </ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the reset workflow
-->
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="cmd-reset-phase-preflight">kubeadm reset phase preflight</h2>
<!--
Using this phase you can execute preflight checks on a node that is being reset.
-->
<p>使用此阶段，你可以在要重置的节点上执行启动前检查阶段。</p>
<ul class="nav nav-tabs" id="tab-preflight" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-preflight-0" role="tab" aria-controls="tab-preflight-0" aria-selected="true">preflight</a></li>
	  </ul>
<div class="tab-content" id="tab-preflight"><div id="tab-preflight-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-preflight-0">

<p><h3 id="概要">概要</h3>
<!--
Run pre-flight checks for kubeadm reset.
-->
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-f, --force</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Reset the node without prompting for confirmation.
-->
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for preflight
-->
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.
-->
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm reset phase remove-etcd-member
-->
<h2 id="cmd-reset-phase-remove-etcd-member">kubeadm reset phase remove-etcd-member</h2>
<!--
Using this phase you can remove this control-plane node's etcd member from the etcd cluster.
-->
<p>使用此阶段，你可以从 etcd 集群中删除此控制平面节点的 etcd 成员。</p>
<ul class="nav nav-tabs" id="tab-remove-etcd-member" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-remove-etcd-member-0" role="tab" aria-controls="tab-remove-etcd-member-0" aria-selected="true">remove-etcd-member</a></li>
	  </ul>
<div class="tab-content" id="tab-remove-etcd-member"><div id="tab-remove-etcd-member-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-remove-etcd-member-0">

<p><h3 id="概要">概要</h3>
<!--
Upload configuration about the current state, so that 'kubeadm upgrade' can later know how to configure the upgraded cluster.
-->
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<!-- td colspan="2">kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td -->
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">The KubeConfig file to use when talking to the cluster. If the flag is not set, a set of standard locations are searched for an existing KubeConfig file.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<!--
## kubeadm reset phase cleanup-node
-->
<h2 id="cmd-reset-phase-cleanup-node">kubeadm reset phase cleanup-node</h2>
<!--
Using this phase you can perform cleanup on this node.
-->
<p>使用此阶段，你可以在此节点上执行清理工作。</p>
<ul class="nav nav-tabs" id="tab-cleanup-node" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-cleanup-node-0" role="tab" aria-controls="tab-cleanup-node-0" aria-selected="true">cleanup-node</a></li>
	  </ul>
<div class="tab-content" id="tab-cleanup-node"><div id="tab-cleanup-node-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-cleanup-node-0">

<p><h3 id="概要">概要</h3>
<!--
Run cleanup node.
-->
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">
<!--
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"
-->
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
The path to the directory where the certificates are stored. If specified, clean this directory.
-->
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan="2">--cri-socket string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
Path to the CRI socket to connect. If empty kubeadm will try to auto-detect this value; use this option only if you have more than one CRI installed or if you have non-standard CRI socket.
-->
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for cleanup-node
-->
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a>
将节点添加到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a>
尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-dfd085b5ab706bd84dda15847dd27f1b">15 - kubeadm upgrade phase</h1>
    
	<!--
In v1.15.0, kubeadm introduced preliminary support for `kubeadm upgrade node` phases.
Phases for other `kubeadm upgrade` sub-commands such as `apply`, could be added in the
following releases.
-->
<p>在 Kubernetes v1.15.0 版本中，kubeadm 引入了对 <code>kubeadm upgrade node</code> 阶段的初步支持。其他 <code>kubeadm upgrade</code> 子命令如 <code>apply</code> 等阶段将在未来发行版中添加。</p>
<!--
## kubeadm upgrade node phase {#cmd-node-phase}
-->
<h2 id="cmd-node-phase">kubeadm upgrade node phase</h2>
<!--
Using this phase you can choose to execute the separate steps of the upgrade of
secondary control-plane or worker nodes. Please note that `kubeadm upgrade apply` still has to
be called on a primary control-plane node.
-->
<p>使用此阶段，可以选择执行辅助控制平面或工作节点升级的单独步骤。请注意，<code>kubeadm upgrade apply</code> 命令仍然必须在主控制平面节点上调用。</p>
<ul class="nav nav-tabs" id="tab-phase" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-phase-0" role="tab" aria-controls="tab-phase-0" aria-selected="true">phase</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-1" role="tab" aria-controls="tab-phase-1">preflight</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-2" role="tab" aria-controls="tab-phase-2">control-plane</a></li>
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-phase-3" role="tab" aria-controls="tab-phase-3">kubelet-config</a></li></ul>
<div class="tab-content" id="tab-phase"><div id="tab-phase-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-phase-0">

<p><h3 id="概要">概要</h3>
<!--
Use this command to invoke single phase of the node workflow
-->
<p>使用此命令调用 node 工作流的某个阶段</p>
<!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
help for phase
-->
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--
[EXPERIMENTAL] The path to the 'real' host root filesystem.
-->
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-phase-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-1">

<p><p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre><!-- ### Options -->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">help for preflight</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan="2">--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">A list of checks whose errors will be shown as warnings. Example: 'IsPrivilegedUser,Swap'. Value 'all' ignores errors from all checks.</td> 
-->
<td></td><td style="line-height: 130%; word-wrap: break-word;">错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<!-- ### Options inherited from parent commands -->
<h3 id="继承于父命令的选项">继承于父命令的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<!-- <td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td> -->
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
  <div id="tab-phase-2" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-2">

<p><h3 id="概要">概要</h3>
<!--
Upgrade the control plane instance deployed on this node, if any
-->
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--certificate-renewal</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">更新在升级期间变更的组件使用的证书。</td>
</tr>
<!-- 
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the renewal of certificates used by component changed during upgrades.</td>
-->
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的动作。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Do not change any state, just output the actions that would be performed.</td>
-->
<tr>
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">执行 etcd 的升级。</td>
</tr>
<!--
<td colspan="2">--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td> 
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">Perform the upgrade of etcd.</td>
-->
<tr>
<td colspan="2">--experimental-patches string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">
<!--  
Path to a directory that contains files named "target[suffix][+patchtype].extension". For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "patchtype" can be one of "strategic", "merge" or "json" and they match the patch formats supported by kubectl. The default "patchtype" is "strategic". "extension" must be either "json" or "yaml". "suffix" is an optional string that can be used to determine which patches are applied first alpha-numerically.
-->
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。 
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The path where kustomize patches for static pod manifests are stored.</td>
-->
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">control-plane 的帮助信息</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">help for control-plane</td>
-->
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<!--
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
-->
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">The kubeconfig file to use when talking to the cluster. If the flag is not set, a set of standard locations can be searched for an existing kubeconfig file.</td>
-->
</tbody>
</table>
<!--
### Options inherited from parent commands
-->
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
<!--
<td></td><td style="line-height: 130%; word-wrap: break-word;">[EXPERIMENTAL] The path to the 'real' host root filesystem.</td>
-->
</tbody>
</table>
</div>
  <div id="tab-phase-3" class="tab-pane" role="tabpanel" aria-labelledby="tab-phase-3">

<p><p>从群集中 &quot;kubelet-config-1.X&quot; 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><!--
### Options
-->
<h3 id="选项">选项</h3>
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--dry-run</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan="2">-h, --help</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">配置操作的帮助信息</td>
</tr>
<tr>
<td colspan="2">--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan="2">--kubelet-version string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id="从父命令继承的选项">从父命令继承的选项</h3>
<!--
### Options inherited from parent commands
-->
   <table style="width: 100%; table-layout: fixed;">
<colgroup>
<col span="1" style="width: 10px;" />
<col span="1" />
</colgroup>
<tbody>
<tr>
<td colspan="2">--rootfs string</td>
</tr>
<tr>
<td></td><td style="line-height: 130%; word-wrap: break-word;">[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>

<h2 id="what-s-next">What's next</h2>
<!--
* [kubeadm init](/docs/reference/setup-tools/kubeadm/kubeadm-init/) to bootstrap a Kubernetes control-plane node
* [kubeadm join](/docs/reference/setup-tools/kubeadm/kubeadm-join/) to connect a node to the cluster
* [kubeadm reset](/docs/reference/setup-tools/kubeadm/kubeadm-reset/) to revert any changes made to this host by `kubeadm init` or `kubeadm join`
* [kubeadm upgrade](/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/) to upgrade a kubeadm node
* [kubeadm alpha](/docs/reference/setup-tools/kubeadm/kubeadm-alpha/) to try experimental functionality
-->
<ul>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init</a> 引导一个 Kubernetes 控制平面节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join</a> 将节点加入到集群</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset</a> 还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对主机所做的任何更改</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/">kubeadm upgrade</a> 升级 kubeadm 节点</li>
<li><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/">kubeadm alpha</a> 尝试实验性功能</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-455b6412a275b743ee8ad90f35808393">16 - 实现细节</h1>
    
	<!--  
reviewers:
- luxas
- jbeda
title: Implementation details
content_type: concept
weight: 100
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code>
</div>


<!--  
`kubeadm init` and `kubeadm join` together provides a nice user experience for creating a best-practice but bare Kubernetes cluster from scratch.
However, it might not be obvious _how_ kubeadm does that.
-->
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 结合在一起提供了良好的用户体验，因为从头开始创建实践最佳而配置最基本的 Kubernetes 集群。
但是，kubeadm <em>如何</em> 做到这一点可能并不明显。</p>
<!-- 
This document provides additional details on what happen under the hood, 
with the aim of sharing knowledge on Kubernetes cluster best practices. 
-->
<p>本文档提供了更多幕后的详细信息，旨在分享有关 Kubernetes 集群最佳实践的知识。</p>
<!-- body -->
<!--
## Core design principles
-->
<h2 id="core-design-principles">核心设计原则   </h2>
<!-- The cluster that `kubeadm init` and `kubeadm join` set up should be: -->
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 设置的集群该是：</p>
<!-- 
 - **Secure**: It should adopt latest best-practices like:
   - enforcing RBAC
   - using the Node Authorizer
   - using secure communication between the control plane components
   - using secure communication between the API server and the kubelets
   - lock-down the kubelet API
   - locking down access to the API for system components like the kube-proxy and CoreDNS
   - locking down what a Bootstrap Token can access
 - **User-friendly**: The user should not have to run anything more than a couple of commands:
   - `kubeadm init`
   - `export KUBECONFIG=/etc/kubernetes/admin.conf`
   - `kubectl apply -f <network-of-choice.yaml>`
   - `kubeadm join --token <token> <endpoint>:<port>`
 - **Extendable**:
   - It should _not_ favor any particular network provider. Configuring the cluster network is out-of-scope
   - It should provide the possibility to use a config file for customizing various parameters
-->
<ul>
<li><strong>安全的</strong>：它应采用最新的最佳实践，例如：
<ul>
<li>实施 RBAC 访问控制</li>
<li>使用节点鉴权机制（Node Authorizer）</li>
<li>在控制平面组件之间使用安全通信</li>
<li>在 API 服务器和 kubelet 之间使用安全通信</li>
<li>锁定 kubelet API</li>
<li>锁定对系统组件（例如 kube-proxy 和 CoreDNS）的 API 的访问</li>
<li>锁定启动引导令牌（Bootstrap Token）可以访问的内容</li>
</ul>
</li>
<li><strong>用户友好</strong>：用户只需要运行几个命令即可：
<ul>
<li><code>kubeadm init</code></li>
<li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li>
<li><code>kubectl apply -f &lt;所选网络.yaml&gt;</code></li>
<li><code>kubeadm join --token &lt;令牌&gt; &lt;端点&gt;:&lt;端口&gt;</code></li>
</ul>
</li>
<li><strong>可扩展的</strong>：
<ul>
<li><em>不</em> 应偏向任何特定的网络提供商。不涉及配置集群网络</li>
<li>应该可以使用配置文件来自定义各种参数</li>
</ul>
</li>
</ul>
<!--
## Constants and well-known values and paths
-->
<h2 id="constants-and-well-known-values-and-paths">常量以及众所周知的值和路径 </h2>
<!-- 
In order to reduce complexity and to simplify development of higher level tools that build on top of kubeadm, it uses a
limited set of constant values for well-known paths and file names.
-->
<p>为了降低复杂性并简化基于 kubeadm 的高级工具的开发，对于众所周知的路径和文件名，
kubeadm 使用了一组有限的常量值。</p>
<!--  
The Kubernetes directory `/etc/kubernetes` is a constant in the application, since it is clearly the given path
in a majority of cases, and the most intuitive location; other constants paths and file names are:
-->
<p>Kubernetes 目录 <code>/etc/kubernetes</code> 在应用程序中是一个常量，因为在大多数情况下
它显然是给定的路径，并且是最直观的位置；其他路径常量和文件名有：</p>
<!--  
- `/etc/kubernetes/manifests` as the path where kubelet should look for static Pod manifests. Names of static Pod manifests are:
    - `etcd.yaml`
    - `kube-apiserver.yaml`
    - `kube-controller-manager.yaml`
    - `kube-scheduler.yaml`
- `/etc/kubernetes/` as the path where kubeconfig files with identities for control plane components are stored. Names of kubeconfig files are:
    - `kubelet.conf` (`bootstrap-kubelet.conf` during TLS bootstrap)
    - `controller-manager.conf`
    - `scheduler.conf`
    - `admin.conf` for the cluster admin and kubeadm itself
- Names of certificates and key files :
    - `ca.crt`, `ca.key` for the Kubernetes certificate authority
    - `apiserver.crt`, `apiserver.key` for the API server certificate
    - `apiserver-kubelet-client.crt`, `apiserver-kubelet-client.key` for the client certificate used by the API server to connect to the kubelets securely
    - `sa.pub`, `sa.key` for the key used by the controller manager when signing ServiceAccount
    - `front-proxy-ca.crt`, `front-proxy-ca.key` for the front proxy certificate authority
    - `front-proxy-client.crt`, `front-proxy-client.key` for the front proxy client
-->
<ul>
<li><code>/etc/kubernetes/manifests</code> 作为 kubelet 查找静态 Pod 清单的路径。静态 Pod 清单的名称为：
<ul>
<li><code>etcd.yaml</code></li>
<li><code>kube-apiserver.yaml</code></li>
<li><code>kube-controller-manager.yaml</code></li>
<li><code>kube-scheduler.yaml</code></li>
</ul>
</li>
<li><code>/etc/kubernetes/</code> 作为带有控制平面组件身份标识的 kubeconfig 文件的路径。kubeconfig 文件的名称为：
<ul>
<li><code>kubelet.conf</code> (在 TLS 引导时名称为 <code>bootstrap-kubelet.conf</code> )</li>
<li><code>controller-manager.conf</code></li>
<li><code>scheduler.conf</code></li>
<li><code>admin.conf</code> 用于集群管理员和 kubeadm 本身</li>
</ul>
</li>
<li>证书和密钥文件的名称：
<ul>
<li><code>ca.crt</code>, <code>ca.key</code> 用于 Kubernetes 证书颁发机构</li>
<li><code>apiserver.crt</code>, <code>apiserver.key</code> 用于 API 服务器证书</li>
<li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code>
用于 API 服务器安全地连接到 kubelet 的客户端证书</li>
<li><code>sa.pub</code>, <code>sa.key</code> 用于控制器管理器签署 ServiceAccount 时使用的密钥</li>
<li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> 用于前端代理证书颁发机构</li>
<li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> 用于前端代理客户端</li>
</ul>
</li>
</ul>
<!--
## kubeadm init workflow internal design
-->
<h2 id="kubeadm-init-workflow-internal-design">kubeadm init 工作流程内部设计 </h2>
<!--  
The `kubeadm init` [internal workflow](/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow) consists of a sequence of atomic work tasks to perform,
as described in `kubeadm init`.
-->
<p><code>kubeadm init</code> <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow">内部工作流程</a>
包含一系列要执行的原子性工作任务，如 <code>kubeadm init</code> 中所述。</p>
<!--  
The [`kubeadm init phase`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/) command allows users to invoke each task individually, and ultimately offers a reusable and composable API/toolbox that can be used by other Kubernetes bootstrap tools, by any IT automation tool or by an advanced user for creating custom clusters.
-->
<p><a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/"><code>kubeadm init phase</code></a>
命令允许用户分别调用每个任务，并最终提供可重用且可组合的 API 或工具箱，
其他 Kubernetes 引导工具、任何 IT 自动化工具和高级用户都可以使用它来
创建自定义集群。</p>
<!--
### Preflight checks
-->
<h3 id="preflight-checks">预检 </h3>
<!-- 
Kubeadm executes a set of preflight checks before starting the init, with the aim to verify preconditions and avoid common cluster startup problems.
The user can skip specific preflight checks or all of them with the `--ignore-preflight-errors` option. 
-->
<p>Kubeadm 在启动 init 之前执行一组预检，目的是验证先决条件并避免常见的集群启动问题。
用户可以使用 <code>--ignore-preflight-errors</code> 选项跳过特定的预检查或全部检查。</p>
<!--  
- [warning] If the Kubernetes version to use (specified with the `--kubernetes-version` flag) is at least one minor version higher than the kubeadm CLI version.
- Kubernetes system requirements:
  - if running on linux:
    - [error] if Kernel is older than the minimum required version
    - [error] if required cgroups subsystem aren't in set up
  - if using docker:
    - [warning/error] if Docker service does not exist, if it is disabled, if it is not active.
    - [error] if Docker endpoint does not exist or does not work
    - [warning] if docker version is not in the list of validated docker versions
  - If using other cri engine:
    - [error] if crictl socket does not answer
-->
<ul>
<li>[警告] 如果要使用的 Kubernetes 版本（由 <code>--kubernetes-version</code> 标志指定）比 kubeadm CLI
版本至少高一个小版本。</li>
<li>Kubernetes 系统要求：
<ul>
<li>如果在 linux上运行：
<ul>
<li>[错误] 如果内核早于最低要求的版本</li>
<li>[错误] 如果未设置所需的 cgroups 子系统</li>
</ul>
</li>
<li>如果使用 docker：
<ul>
<li>[警告/错误] 如果 Docker 服务不存在、被禁用或未激活。</li>
<li>[错误] 如果 Docker 端点不存在或不起作用</li>
<li>[警告] 如果 docker 版本不在经过验证的 docker 版本列表中</li>
</ul>
</li>
<li>如果使用其他 cri 引擎：
<ul>
<li>[错误] 如果 crictl 套接字未应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<!--  
- [error] if user is not root
- [error] if the machine hostname is not a valid DNS subdomain
- [warning] if the host name cannot be reached via network lookup
- [error] if kubelet version is lower that the minimum kubelet version supported by kubeadm (current minor -1)
- [error] if kubelet version is at least one minor higher than the required controlplane version (unsupported version skew)
- [warning] if kubelet service does not exist or if it is disabled
- [warning] if firewalld is active
- [error] if API server bindPort or ports 10250/10251/10252 are used
- [Error] if `/etc/kubernetes/manifest` folder already exists and it is not empty
- [Error] if `/proc/sys/net/bridge/bridge-nf-call-iptables` file does not exist/does not contain 1
- [Error] if advertise address is ipv6 and `/proc/sys/net/bridge/bridge-nf-call-ip6tables` does not exist/does not contain 1.
- [Error] if swap is on
- [Error] if `conntrack`, `ip`, `iptables`,  `mount`, `nsenter` commands are not present in the command path
- [warning] if `ebtables`, `ethtool`, `socat`, `tc`, `touch`, `crictl` commands are not present in the command path
- [warning] if extra arg flags for API server, controller manager,  scheduler contains some invalid options
- [warning] if connection to https://API.AdvertiseAddress:API.BindPort goes through proxy
- [warning] if connection to services subnet goes through proxy (only first address checked)
- [warning] if connection to Pods subnet goes through proxy (only first address checked)
-->
<ul>
<li>[错误] 如果用户不是 root 用户</li>
<li>[错误] 如果机器主机名不是有效的 DNS 子域</li>
<li>[警告] 如果通过网络查找无法访问主机名</li>
<li>[错误] 如果 kubelet 版本低于 kubeadm 支持的最低 kubelet 版本（当前小版本 -1）</li>
<li>[错误] 如果 kubelet 版本比所需的控制平面板版本至少高一个小（不支持的版本偏斜）</li>
<li>[警告] 如果 kubelet 服务不存在或已被禁用</li>
<li>[警告] 如果 firewalld 处于活动状态</li>
<li>[错误] 如果 API ​​服务器绑定的端口或 10250/10251/10252 端口已被占用</li>
<li>[错误] 如果 <code>/etc/kubernetes/manifest</code> 文件夹已经存在并且不为空</li>
<li>[错误] 如果 <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> 文件不存在或不包含 1</li>
<li>[错误] 如果建议地址是 ipv6，并且 <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> 不存在或不包含 1</li>
<li>[错误] 如果启用了交换分区</li>
<li>[错误] 如果命令路径中没有 <code>conntrack</code>、<code>ip</code>、<code>iptables</code>、<code>mount</code>、<code>nsenter</code> 命令</li>
<li>[警告] 如果命令路径中没有 <code>ebtables</code>、<code>ethtool</code>、<code>socat</code>、<code>tc</code>、<code>touch</code>、<code>crictl</code> 命令</li>
<li>[警告] 如果 API 服务器、控制器管理器、调度程序的其他参数标志包含一些无效选项</li>
<li>[警告] 如果与 https://API.AdvertiseAddress:API.BindPort 的连接通过代理</li>
<li>[警告] 如果服务子网的连接通过代理（仅检查第一个地址）</li>
<li>[警告] 如果 Pod 子网的连接通过代理（仅检查第一个地址）</li>
</ul>
<!-- 
- If external etcd is provided:
  - [Error] if etcd version is older than the minimum required version
  - [Error] if etcd certificates or keys are specified, but not provided
- If external etcd is NOT provided (and thus local etcd will be installed):
  - [Error] if ports 2379 is used
  - [Error] if Etcd.DataDir folder already exists and it is not empty
- If authorization mode is ABAC:
  - [Error] if abac_policy.json does not exist
- If authorization mode is WebHook
  - [Error] if webhook_authz.conf does not exist
-->
<ul>
<li>如果提供了外部 etcd：
<ul>
<li>[错误] 如果 etcd 版本低于最低要求版本</li>
<li>[错误] 如果指定了 etcd 证书或密钥，但无法找到</li>
</ul>
</li>
<li>如果未提供外部 etcd（因此将安装本地 etcd）：
<ul>
<li>[错误] 如果端口 2379 已被占用</li>
<li>[错误] 如果 Etcd.DataDir 文件夹已经存在并且不为空</li>
</ul>
</li>
<li>如果授权模式为 ABAC：
<ul>
<li>[错误] 如果 abac_policy.json 不存在</li>
</ul>
</li>
<li>如果授权方式为 Webhook
<ul>
<li>[错误] 如果 webhook_authz.conf 不存在</li>
</ul>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. Preflight checks can be invoked individually with the [`kubeadm init phase preflight`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight) command
-->
<ol>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight"><code>kubeadm init phase preflight</code></a>
命令单独触发预检。</li>
</ol>
<!--
### Generate the necessary certificates
-->
<h3 id="generate-the-necessary-certificate">生成必要的证书 </h3>
<!-- Kubeadm generates certificate and private key pairs for different purposes: -->
<p>Kubeadm 生成用于不同目的的证书和私钥对：</p>
<!-- 
 - A self signed certificate authority for the Kubernetes cluster saved into `ca.crt` file and `ca.key` private key file 
 - A serving certificate for the API server, generated using `ca.crt` as the CA, and saved into `apiserver.crt` file with
   its private key `apiserver.key`. This certificate should contain following alternative names:
     - The Kubernetes service's internal clusterIP (the first address in the services CIDR, e.g. `10.96.0.1` if service subnet is `10.96.0.0/12`)
     - Kubernetes DNS names, e.g.  `kubernetes.default.svc.cluster.local` if `--service-dns-domain` flag value is `cluster.local`, plus default DNS names `kubernetes.default.svc`, `kubernetes.default`, `kubernetes`
     - The node-name
     - The `--apiserver-advertise-address`
     - Additional alternative names specified by the user
 - A client certificate for the API server to connect to the kubelets securely, generated using `ca.crt` as the CA and saved into
   `apiserver-kubelet-client.crt` file with its private key `apiserver-kubelet-client.key`.
   This certificate should be in the `system:masters` organization
 - A private key for signing ServiceAccount Tokens saved into `sa.key` file along with its public key `sa.pub`
 - A certificate authority for the front proxy saved into `front-proxy-ca.crt` file with its key `front-proxy-ca.key`
 - A client cert for the front proxy client, generated using `front-proxy-ca.crt` as the CA and saved into `front-proxy-client.crt` file
   with its private key`front-proxy-client.key`
-->
<ul>
<li>
<p>Kubernetes 集群的自签名证书颁发机构会保存到 <code>ca.crt</code> 文件和 <code>ca.key</code> 私钥文件中</p>
</li>
<li>
<p>用于 API 服务器的服务证书，使用 <code>ca.crt</code> 作为 CA 生成，并将证书保存到 <code>apiserver.crt</code>
文件中，私钥保存到 <code>apiserver.key</code> 文件中
该证书应包含以下备用名称：</p>
<ul>
<li>Kubernetes 服务的内部 clusterIP（服务 CIDR 的第一个地址。
例如：如果服务的子网是 <code>10.96.0.0/12</code>，则为 <code>10.96.0.1</code>）</li>
<li>Kubernetes DNS 名称，例如：如果 <code>--service-dns-domain</code> 标志值是 <code>cluster.local</code>，
则为 <code>kubernetes.default.svc.cluster.local</code>；
加上默认的 DNS 名称 <code>kubernetes.default.svc</code>、<code>kubernetes.default</code> 和 <code>kubernetes</code>，</li>
<li>节点名称</li>
<li><code>--apiserver-advertise-address</code></li>
<li>用户指定的其他备用名称</li>
</ul>
</li>
<li>
<p>用于 API 服务器安全连接到 kubelet 的客户端证书，使用 <code>ca.crt</code> 作为 CA 生成，
并保存到 <code>apiserver-kubelet-client.crt</code>，私钥保存到 <code>apiserver-kubelet-client.key</code>
文件中。该证书应该在 <code>system:masters</code> 组织中。</p>
</li>
<li>
<p>用于签名 ServiceAccount 令牌的私钥保存到 <code>sa.key</code> 文件中，公钥保存到 <code>sa.pub</code> 文件中</p>
</li>
<li>
<p>用于前端代理的证书颁发机构保存到 <code>front-proxy-ca.crt</code> 文件中，私钥保存到
<code>front-proxy-ca.key</code> 文件中</p>
</li>
<li>
<p>前端代理客户端的客户端证书，使用 <code>front-proxy-ca.crt</code> 作为 CA 生成，并保存到
<code>front-proxy-client.crt</code> 文件中，私钥保存到 <code>front-proxy-client.key</code> 文件中</p>
</li>
</ul>
<!-- 
Certificates are stored by default in `/etc/kubernetes/pki`, but this directory is configurable using the `--cert-dir` flag. 
-->
<p>证书默认情况下存储在 <code>/etc/kubernetes/pki</code> 中，但是该目录可以使用 <code>--cert-dir</code> 标志进行配置。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!-- 
1. If a given certificate and private key pair both exist, and its content is evaluated compliant with the above specs, the existing files will
   be used and the generation phase for the given certificate skipped. This means the user can, for example, copy an existing CA to
   `/etc/kubernetes/pki/ca.{crt,key}`, and then kubeadm will use those files for signing the rest of the certs.
   See also [using custom certificates](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates)
2. Only for the CA, it is possible to provide the `ca.crt` file but not the `ca.key` file, if all other certificates and kubeconfig files
   already are in place kubeadm recognize this condition and activates the ExternalCA , which also implies the `csrsigner`controller in
   controller-manager won't be started
3. If kubeadm is running in [external CA mode](/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode);
   all the certificates must be provided by the user, because kubeadm cannot generate them by itself
4. In case of kubeadm is executed in the `--dry-run` mode, certificates files are written in a temporary folder
5. Certificate generation can be invoked individually with the [`kubeadm init phase certs all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs) command
-->
<ol>
<li>如果证书和私钥对都存在，并且其内容经过评估符合上述规范，将使用现有文件，
并且跳过给定证书的生成阶段。
这意味着用户可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.{crt,key}</code>，
kubeadm 将使用这些文件对其余证书进行签名。
请参阅<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates">使用自定义证书</a>。</li>
<li>仅对 CA 来说，如果所有其他证书和 kubeconfig 文件都已就位，则可以只提供 <code>ca.crt</code> 文件，
而不提供 <code>ca.key</code> 文件。
kubeadm 能够识别出这种情况并启用 ExternalCA，这也意味着了控制器管理器中的
<code>csrsigner</code> 控制器将不会启动</li>
<li>如果 kubeadm 在
<a href="/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode">外部 CA 模式</a>
下运行，所有证书必须由用户提供，因为 kubeadm 无法自行生成它们。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，证书文件将写入一个临时文件夹中</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs"><code>kubeadm init phase certs all</code></a> 
命令单独生成证书。</li>
</ol>
<!--
### Generate kubeconfig files for control plane components
-->
<h3 id="generate-kubeconfig-files-for-control-plane-components">为控制平面组件生成 kubeconfig 文件 </h3>
<!-- 
Kubeadm generates kubeconfig files with identities for control plane components:
-->
<p>Kubeadm 生成具有用于控制平面组件身份标识的 kubeconfig 文件：</p>
<!--  
- A kubeconfig file for the kubelet to use during TLS bootstrap - /etc/kubernetes/bootstrap-kubelet.conf. Inside this file there is a bootstrap-token or embedded client certificates for authenticating this node with the cluster.
  This client cert should:
    - Be in the `system:nodes` organization, as required by the [Node Authorization](/docs/reference/access-authn-authz/node/) module
    - Have the Common Name (CN) `system:node:<hostname-lowercased>`
- A kubeconfig file for controller-manager, `/etc/kubernetes/controller-manager.conf`; inside this file is embedded a client
  certificate with controller-manager identity. This client cert should have the CN `system:kube-controller-manager`, as defined
by default [RBAC core components roles](/docs/reference/access-authn-authz/rbac/#core-component-roles)
- A kubeconfig file for scheduler, `/etc/kubernetes/scheduler.conf`; inside this file is embedded a client certificate with scheduler identity.
  This client cert should have the CN `system:kube-scheduler`, as defined by default [RBAC core components roles](/docs/reference/access-authn-authz/rbac/#core-component-roles)
-->
<ul>
<li>
<p>供 kubelet 在 TLS 引导期间使用的 kubeconfig 文件 —— <code>/etc/kubernetes/bootstrap-kubelet.conf</code>。
在此文件中，有一个引导令牌或内嵌的客户端证书，向集群表明此节点身份。
此客户端证书应：</p>
<ul>
<li>根据<a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a>模块的要求，属于 <code>system:nodes</code> 组织</li>
<li>具有通用名称（CN）：<code>system:node:&lt;小写主机名&gt;</code></li>
</ul>
</li>
<li>
<p>控制器管理器的 kubeconfig 文件 —— <code>/etc/kubernetes/controller-manager.conf</code>；
在此文件中嵌入了一个具有控制器管理器身份标识的客户端证书。
此客户端证书应具有 CN：<code>system:kube-controller-manager</code>，
该 CN 由 <a href="/zh/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC 核心组件角色</a>
默认定义的。</p>
</li>
<li>
<p>调度器的 kubeconfig 文件 —— <code>/etc/kubernetes/scheduler.conf</code>；
此文件中嵌入了具有调度器身份标识的客户端证书。此客户端证书应具有 CN：<code>system:kube-scheduler</code>，
该 CN 由 <a href="/zh/docs/reference/access-authn-authz/rbac/#core-component-roles">RBAC 核心组件角色</a>
默认定义的。</p>
</li>
</ul>
<!-- 
Additionally, a kubeconfig file for kubeadm itself and the admin is generated and saved into the `/etc/kubernetes/admin.conf` file.
The "admin" here is defined as the actual person(s) that is administering the cluster and wants to have full control (**root**) over the cluster.
The embedded client certificate for admin should be in the `system:masters` organization, as defined by default
[RBAC user facing role bindings](/docs/reference/access-authn-authz/rbac/#user-facing-roles). It should also include a
CN. Kubeadm uses the `kubernetes-admin` CN.
-->
<p>另外，用于 kubeadm 本身和 admin 的 kubeconfig 文件也被生成并保存到
<code>/etc/kubernetes/admin.conf</code> 文件中。
此处的 admin 定义为正在管理集群并希望完全控制集群（<strong>root</strong>）的实际人员。
内嵌的 admin 客户端证书应是  <code>system:masters</code> 组织的成员，
这一组织名由默认的 <a href="/zh/docs/reference/access-authn-authz/rbac/#user-facing-roles">RBAC 面向用户的角色绑定</a>
定义。它还应包括一个 CN。kubeadm 使用 <code>kubernetes-admin</code> CN。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. `ca.crt` certificate is embedded in all the kubeconfig files.
2. If a given kubeconfig file exists, and its content is evaluated compliant with the above specs, the existing file will be used and the generation phase for the given kubeconfig skipped
3. If kubeadm is running in [ExternalCA mode](/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode), all the required kubeconfig must be provided by the user as well, because kubeadm cannot generate any of them by itself
4. In case of kubeadm is executed in the `--dry-run` mode, kubeconfig files are written in a temporary folder
5. Kubeconfig files generation can be invoked individually with the [`kubeadm init phase kubeconfig all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig) command
-->
<ol>
<li><code>ca.crt</code> 证书内嵌在所有 kubeconfig 文件中。</li>
<li>如果给定的 kubeconfig 文件存在且其内容经过评估符合上述规范，则 kubeadm 将使用现有文件，
并跳过给定 kubeconfig 的生成阶段</li>
<li>如果 kubeadm 以 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode">ExternalCA 模式</a>
运行，则所有必需的 kubeconfig 也必须由用户提供，因为 kubeadm 不能自己生成</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则 kubeconfig 文件将写入一个临时文件夹中</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig"><code>kubeadm init phase kubeconfig all</code></a>
命令分别生成 kubeconfig 文件。</li>
</ol>
<!--
### Generate static Pod manifests for control plane components
-->
<h3 id="generate-static-pod-manifests-for-control-plane-components">为控制平面组件生成静态 Pod 清单 </h3>
<!--  
Kubeadm writes static Pod manifest files for control plane components to `/etc/kubernetes/manifests`. The kubelet watches this directory for Pods to create on startup.
-->
<p>Kubeadm 将用于控制平面组件的静态 Pod 清单文件写入 <code>/etc/kubernetes/manifests</code> 目录。
Kubelet 启动后会监视这个目录以便创建 Pod。</p>
<!-- Static Pod manifest share a set of common properties: -->
<p>静态 Pod 清单有一些共同的属性：</p>
<!--  
- All static Pods are deployed on `kube-system` namespace
- All static Pods get `tier:control-plane` and `component:{component-name}` labels
- All static Pods use the `system-node-critical` priority class
- `hostNetwork: true` is set on all static Pods to allow control plane startup before a network is configured; as a consequence:
  * The `address` that the controller-manager and the scheduler use to refer the API server is `127.0.0.1`
  * If using a local etcd server, `etcd-servers` address will be set to `127.0.0.1:2379`
- Leader election is enabled for both the controller-manager and the scheduler
- Controller-manager and the scheduler will reference kubeconfig files with their respective, unique identities
- All static Pods get any extra flags specified by the user as described in [passing custom arguments to control plane components](/docs/setup/production-environment/tools/kubeadm/control-plane-flags/)
- All static Pods get any extra Volumes specified by the user (Host path)
-->
<ul>
<li>
<p>所有静态 Pod 都部署在 <code>kube-system</code> 名字空间</p>
</li>
<li>
<p>所有静态 Pod 都打上 <code>tier:ontrol-plane</code> 和 <code>component:{组件名称}</code> 标签</p>
</li>
<li>
<p>所有静态 Pod 均使用 <code>system-node-critical</code> 优先级</p>
</li>
<li>
<p>所有静态 Pod 都设置了 <code>hostNetwork:true</code>，使得控制平面在配置网络之前启动；结果导致：</p>
<ul>
<li>控制器管理器和调度器用来调用 API 服务器的地址为 127.0.0.1。</li>
<li>如果使用本地 etcd 服务器，则 <code>etcd-servers</code> 地址将设置为 <code>127.0.0.1:2379</code></li>
</ul>
</li>
<li>
<p>同时为控制器管理器和调度器启用了领导者选举</p>
</li>
<li>
<p>控制器管理器和调度器将引用 kubeconfig 文件及其各自的唯一标识</p>
</li>
<li>
<p>如<a href="/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/">将自定义参数传递给控制平面组件</a>
中所述，所有静态 Pod 都会获得用户指定的额外标志</p>
</li>
<li>
<p>所有静态 Pod 都会获得用户指定的额外卷（主机路径）</p>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. All images will be pulled from k8s.gcr.io by default. See [using custom images](/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images) for customizing the image repository
2. In case of kubeadm is executed in the `-dry-run` mode, static Pods files are written in a temporary folder
3. Static Pod manifest generation for control plane components can be invoked individually with the [`kubeadm init phase control-plane all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane) command
-->
<ol>
<li>所有镜像默认从 k8s.gcr.io 拉取。 
关于自定义镜像仓库，请参阅
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a>。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则静态 Pod 文件写入一个临时文件夹中。</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane"><code>kubeadm init phase control-plane all</code></a> 
命令分别生成主控组件的静态 Pod 清单。</li>
</ol>
<!--
#### API server

The static Pod manifest for the API server is affected by following parameters provided by the users: 
-->
<h4 id="api-server">API 服务器 </h4>
<p>API 服务器的静态 Pod 清单会受到用户提供的以下参数的影响:</p>
<!--  
 - The `apiserver-advertise-address` and `apiserver-bind-port` to bind to; if not provided, those value defaults to the IP address of
   the default network interface on the machine and port 6443
 - The `service-cluster-ip-range` to use for services
 - If an external etcd server is specified, the `etcd-servers` address and related TLS settings (`etcd-cafile`, `etcd-certfile`, `etcd-keyfile`);
   if an external etcd server is not be provided, a local etcd will be used (via host network)
 - If a cloud provider is specified, the corresponding `--cloud-provider` is configured, together with the  `--cloud-config` path
   if such file exists (this is experimental, alpha and will be removed in a future version)
-->
<ul>
<li>要绑定的 <code>apiserver-advertise-address</code> 和 <code>apiserver-bind-port</code>；
如果未提供，则这些值默认为机器上默认网络接口的 IP 地址和 6443 端口。</li>
<li><code>service-cluster-ip-range</code> 给 service 使用</li>
<li>如果指定了外部 etcd 服务器，则应指定 <code>etcd-servers</code> 地址和相关的 TLS 设置
（<code>etcd-cafile</code>，<code>etcd-certfile</code>，<code>etcd-keyfile</code>）；
如果未提供外部 etcd 服务器，则将使用本地 etcd（通过主机网络）</li>
<li>如果指定了云提供商，则配置相应的 <code>--cloud-provider</code>，如果该路径存在，则配置 <code>--cloud-config</code>
（这是实验性的，是 Alpha 版本，将在以后的版本中删除）</li>
</ul>
<!-- Other API server flags that are set unconditionally are: -->
<p>无条件设置的其他 API 服务器标志有：</p>
<!--  
 - `--insecure-port=0` to avoid insecure connections to the api server
 - `--enable-bootstrap-token-auth=true` to enable the `BootstrapTokenAuthenticator` authentication module.
   See [TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) for more details
 - `--allow-privileged` to `true` (required e.g. by kube proxy)
 - `--requestheader-client-ca-file` to `front-proxy-ca.crt`
-->
<ul>
<li><code>--insecure-port=0</code> 禁止到 API 服务器不安全的连接</li>
<li><code>--enable-bootstrap-token-auth=true</code> 启用 <code>BootstrapTokenAuthenticator</code> 身份验证模块。
更多细节请参见 <a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 引导</a>。</li>
<li><code>--allow-privileged</code> 设为 <code>true</code>（诸如 kube-proxy 这些组件有此要求）</li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
</ul>
<!--
 - `--enable-admission-plugins` to:
    - [`NamespaceLifecycle`](/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle) e.g. to avoid deletion of
      system reserved namespaces
    - [`LimitRanger`](/docs/reference/access-authn-authz/admission-controllers/#limitranger) and [`ResourceQuota`](/docs/reference/access-authn-authz/admission-controllers/#resourcequota) to enforce limits on namespaces
    - [`ServiceAccount`](/docs/reference/access-authn-authz/admission-controllers/#serviceaccount) to enforce service account automation
    - [`PersistentVolumeLabel`](/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel) attaches region or zone labels to
      PersistentVolumes as defined by the cloud provider (This admission controller is deprecated and will be removed in a future version.
      It is not deployed by kubeadm by default with v1.9 onwards when not explicitly opting into using `gce` or `aws` as cloud providers)
    - [`DefaultStorageClass`](/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass) to enforce default storage class on `PersistentVolumeClaim` objects
    - [`DefaultTolerationSeconds`](/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds)
    - [`NodeRestriction`](/docs/reference/access-authn-authz/admission-controllers/#noderestriction) to limit what a kubelet can modify
      (e.g. only pods on this node)
-->
<ul>
<li><code>--enable-admission-plugins</code> 设为：
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle"><code>NamespaceLifecycle</code></a> 
例如，避免删除系统保留的名字空间</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#limitranger"><code>LimitRanger</code></a> 和
<a href="/zh/docs/reference/access-authn-authz/admission-controllers/#resourcequota"><code>ResourceQuota</code></a>
对名字空间实施限制</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#serviceaccount"><code>ServiceAccount</code></a>
实施服务账户自动化</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel"><code>PersistentVolumeLabel</code></a> 
将区域（Region）或区（Zone）标签附加到由云提供商定义的 PersistentVolumes
（此准入控制器已被弃用并将在以后的版本中删除）。
如果未明确选择使用 <code>gce</code> 或 <code>aws</code> 作为云提供商，则默认情况下，v1.9 以后的版本 kubeadm 都不会部署。</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass"><code>DefaultStorageClass</code></a> 
在 <code>PersistentVolumeClaim</code> 对象上强制使用默认存储类型</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds"><code>DefaultTolerationSeconds</code></a></li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction"><code>NodeRestriction</code></a> 
限制 kubelet 可以修改的内容（例如，仅此节点上的 pod）</li>
</ul>
</li>
</ul>
<!--
 - `--kubelet-preferred-address-types` to `InternalIP,ExternalIP,Hostname;` this makes `kubectl logs` and other API server-kubelet
   communication work in environments where the hostnames of the nodes aren't resolvable
 - Flags for using certificates generated in previous steps:
    - `--client-ca-file` to `ca.crt`
    - `--tls-cert-file` to `apiserver.crt`
    - `--tls-private-key-file` to `apiserver.key`
    - `--kubelet-client-certificate` to `apiserver-kubelet-client.crt`
    - `--kubelet-client-key` to `apiserver-kubelet-client.key`
    - `--service-account-key-file` to `sa.pub`
    - `--requestheader-client-ca-file` to`front-proxy-ca.crt`
    - `--proxy-client-cert-file` to `front-proxy-client.crt`
    - `--proxy-client-key-file` to `front-proxy-client.key`
 - Other flags for securing the front proxy ([API Aggregation](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)) communications:
    - `--requestheader-username-headers=X-Remote-User`
    - `--requestheader-group-headers=X-Remote-Group`
    - `--requestheader-extra-headers-prefix=X-Remote-Extra-`
    - `--requestheader-allowed-names=front-proxy-client`
-->
<ul>
<li>
<p><code>--kubelet-preferred-address-types</code> 设为 <code>InternalIP,ExternalIP,Hostname;</code> 
这使得在节点的主机名无法解析的环境中，<code>kubectl log</code> 和 API 服务器与 kubelet
的其他通信可以工作</p>
</li>
<li>
<p>使用在前面步骤中生成的证书的标志：</p>
<ul>
<li><code>--client-ca-file</code> 设为 <code>ca.crt</code></li>
<li><code>--tls-cert-file</code> 设为 <code>apiserver.crt</code></li>
<li><code>--tls-private-key-file</code> 设为 <code>apiserver.key</code></li>
<li><code>--kubelet-client-certificate</code> 设为 <code>apiserver-kubelet-client.crt</code></li>
<li><code>--kubelet-client-key</code> 设为 <code>apiserver-kubelet-client.key</code></li>
<li><code>--service-account-key-file</code> 设为 <code>sa.pub</code></li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
<li><code>--proxy-client-cert-file</code> 设为 <code>front-proxy-client.crt</code></li>
<li><code>--proxy-client-key-file</code> 设为 <code>front-proxy-client.key</code></li>
</ul>
</li>
<li>
<p>其他用于保护前端代理（
<a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">API 聚合层</a>）
通信的标志:</p>
<ul>
<li><code>--requestheader-username-headers=X-Remote-User</code></li>
<li><code>--requestheader-group-headers=X-Remote-Group</code></li>
<li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li>
<li><code>--requestheader-allowed-names=front-proxy-client</code></li>
</ul>
</li>
</ul>
<!--
#### Controller manager
-->
<h4 id="controller-manager">控制器管理器 </h4>
<!-- 
The static Pod manifest for the controller manager is affected by following parameters provided by the users: 
-->
<p>控制器管理器的静态 Pod 清单受用户提供的以下参数的影响:</p>
<!-- 
- If kubeadm is invoked specifying a `--pod-network-cidr`, the subnet manager feature required for some CNI network plugins is enabled by
   setting:
   - `--allocate-node-cidrs=true`
   - `--cluster-cidr` and `--node-cidr-mask-size` flags according to the given CIDR
 - If a cloud provider is specified, the corresponding `--cloud-provider` is specified, together with the  `--cloud-config` path
   if such configuration file exists (this is experimental, alpha and will be removed in a future version)
-->
<ul>
<li>如果调用 kubeadm 时指定了 <code>--pod-network-cidr</code> 参数，则可以通过以下方式启用
某些 CNI 网络插件所需的子网管理器功能：
<ul>
<li>设置 <code>--allocate-node-cidrs=true</code></li>
<li>根据给定 CIDR 设置 <code>--cluster-cidr</code> 和 <code>--node-cidr-mask-size</code> 标志</li>
</ul>
</li>
<li>如果指定了云提供商，则指定相应的 <code>--cloud-provider</code>，如果存在这样的配置文件，
则指定 <code>--cloud-config</code> 路径（此为试验性功能，是 Alpha 版本，将在以后的版本中删除）。</li>
</ul>
<!-- Other flags that are set unconditionally are: -->
<p>其他无条件设置的标志包括：</p>
<!--  
 - `--controllers` enabling all the default controllers plus `BootstrapSigner` and `TokenCleaner` controllers for TLS bootstrap.
   See [TLS Bootstrapping](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/) for more details
 - `--use-service-account-credentials` to `true`
 - Flags for using certificates generated in previous steps:
    - `--root-ca-file` to `ca.crt`
    - `--cluster-signing-cert-file` to `ca.crt`, if External CA mode is disabled, otherwise to `""`
    - `--cluster-signing-key-file` to `ca.key`, if External CA mode is disabled, otherwise to `""`
    - `--service-account-private-key-file` to `sa.key`
-->
<ul>
<li>
<p><code>--controllers</code> 为 TLS 引导程序启用所有默认控制器以及 <code>BootstrapSigner</code> 和
<code>TokenCleaner</code> 控制器。详细信息请参阅
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS 引导</a></p>
</li>
<li>
<p><code>--use-service-account-credentials</code> 设为 <code>true</code></p>
</li>
<li>
<p>使用先前步骤中生成的证书的标志：</p>
<p>-<code>--root-ca-file</code> 设为 <code>ca.crt</code></p>
<ul>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-cert-file</code> 设为 <code>ca.crt</code>，否则设为 <code>&quot;&quot;</code></li>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-key-file</code> 设为 <code>ca.key</code>，否则设为 <code>&quot;&quot;</code></li>
<li><code>--service-account-private-key-file</code> 设为 <code>sa.key</code></li>
</ul>
</li>
</ul>
<!--
#### Scheduler

The static Pod manifest for the scheduler is not affected by parameters provided by the users. 
-->
<h4 id="scheduler">调度器 </h4>
<p>调度器的静态 Pod 清单不受用户提供的参数的影响。</p>
<!--
### Generate static Pod manifest for local etcd
-->
<h3 id="generate-static-pod-manifest-for-local-etcd">为本地 etcd 生成静态 Pod 清单 </h3>
<!--  
If the user specified an external etcd this step will be skipped, otherwise kubeadm generates a static Pod manifest file for creating
a local etcd instance running in a Pod with following attributes:
-->
<p>如果用户指定了外部 etcd，则将跳过此步骤，否则 kubeadm 会生成静态 Pod 清单文件，
以创建在 Pod 中运行的具有以下属性的本地 etcd 实例：</p>
<!--  
- listen on `localhost:2379` and use `HostNetwork=true`
- make a `hostPath` mount out from the `dataDir` to the host's filesystem
- Any extra flags specified by the user
-->
<ul>
<li>在 <code>localhost:2379</code> 上监听并使用 <code>HostNetwork=true</code></li>
<li>将 <code>hostPath</code> 从 <code>dataDir</code> 挂载到主机的文件系统</li>
<li>用户指定的任何其他标志</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. The etcd image will be pulled from `k8s.gcr.io` by default. See [using custom images](/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images) for customizing the image repository
2. in case of kubeadm is executed in the `--dry-run` mode, the etcd static Pod manifest is written in a temporary folder
3. Static Pod manifest generation for local etcd can be invoked individually with the [`kubeadm init phase etcd local`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd) command
-->
<ol>
<li>etcd 镜像默认从 <code>k8s.gcr.io</code> 拉取。有关自定义镜像仓库，请参阅
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images">使用自定义镜像</a>。</li>
<li>如果 kubeadm 以 <code>--dry-run</code> 模式执行，etcd 静态 Pod 清单将写入一个临时文件夹。</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd">'kubeadm init phase etcd local'</a>
命令单独为本地 etcd 生成静态 Pod 清单</li>
</ol>
<!--
### Wait for the control plane to come up
-->
<h3 id="wait-for-the-control-plane-to-come-up">等待控制平面启动 </h3>
<!--  
kubeadm waits (upto 4m0s) until `localhost:6443/healthz` (kube-apiserver liveness) returns `ok`. However in order to detect
deadlock conditions, kubeadm fails fast if `localhost:10255/healthz` (kubelet liveness) or
`localhost:10255/healthz/syncloop` (kubelet readiness) don't return `ok` within 40s and 60s respectively.
-->
<p>kubeadm 等待（最多 4m0s），直到 <code>localhost:6443/healthz</code>（kube-apiserver 存活）返回 <code>ok</code>。 
但是为了检测死锁条件，如果 <code>localhost:10255/healthz</code>（kubelet 存活）或
<code>localhost:10255/healthz/syncloop</code>（kubelet 就绪）未能在 40s 和 60s 内未返回 <code>ok</code>，
则 kubeadm 会快速失败。</p>
<!--  
kubeadm relies on the kubelet to pull the control plane images and run them properly as static Pods.
After the control plane is up, kubeadm completes the tasks described in following paragraphs.
-->
<p>kubeadm 依靠 kubelet 拉取控制平面镜像并将其作为静态 Pod 正确运行。
控制平面启动后，kubeadm 将完成以下段落中描述的任务。</p>
<!--
### Save the kubeadm ClusterConfiguration in a ConfigMap for later reference
-->
<h3 id="save-the-kubeadm-clusterConfiguration-in-a-configMap-for-later-reference">将 kubeadm ClusterConfiguration 保存在 ConfigMap 中以供以后参考 </h3>
<!-- 
kubeadm saves the configuration passed to `kubeadm init` in a ConfigMap named `kubeadm-config` under `kube-system` namespace. 
-->
<p>kubeadm 将传递给 <code>kubeadm init</code> 的配置保存在 <code>kube-system</code> 名字空间下名为
<code>kubeadm-config</code> 的 ConfigMap 中。</p>
<!--  
This will ensure that kubeadm actions executed in future (e.g `kubeadm upgrade`) will be able to determine the actual/current cluster
state and make new decisions based on that data.
-->
<p>这将确保将来执行的 kubeadm 操作（例如 <code>kubeadm upgrade</code>）将能够确定实际/当前集群状态，
并根据该数据做出新的决策。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. Before saving the ClusterConfiguration, sensitive information like the token is stripped from the configuration
2. Upload of control plane ndoe configuration can be invoked individually with the [`kubeadm init phase upload-config`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config) command
-->
<ol>
<li>在保存 ClusterConfiguration 之前，从配置中删除令牌等敏感信息。</li>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config"><code>kubeadm init phase upload-config</code></a> 
命令单独上传主控节点配置。</li>
</ol>
<!--
### Mark the node as control-plane
-->
<h3 id="mark-the-node-as-control-plane">将节点标记为控制平面 </h3>
<!--
As soon as the control plane is available, kubeadm executes following actions:
-->
<p>一旦控制平面可用，kubeadm 将执行以下操作：</p>
<!-- 
- Labels the node as control-plane with `node-role.kubernetes.io/master=""`
- Taints the node with `node-role.kubernetes.io/master:NoSchedule`
-->
<ul>
<li>给节点打上 <code>node-role.kubernetes.io/master=&quot;&quot;</code> 标签，标记其为控制平面</li>
<li>给节点打上 <code>node-role.kubernetes.io/master:NoSchedule</code> 污点</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. Mark control-plane phase can be invoked individually with the [`kubeadm init phase mark-control-plane`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane) command
-->
<ol>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane"><code>kubeadm init phase mark-control-plane</code></a> 
命令单独触发控制平面标记</li>
</ol>
<!--
### Configure TLS-Bootstrapping for node joining
-->
<h3 id="configure-tls-bootstrapping-for-node-joining">为即将加入的节点加入 TLS 启动引导 </h3>
<!--
Kubeadm uses [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) for joining new nodes to an
existing cluster; for more details see also [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md).
-->
<p>Kubeadm 使用<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">引导令牌认证</a>
将新节点连接到现有集群；
更多的详细信息，请参见
<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计提案</a>。</p>
<!-- 
`kubeadm init` ensures that everything is properly configured for this process, and this includes following steps as well as
setting API server and controller flags as already described in previous paragraphs.
-->
<p><code>kubeadm init</code> 确保为该过程正确配置了所有内容，这包括以下步骤以及设置 API 服务器
和控制器标志，如前几段所述。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!-- 
1. TLS bootstrapping for nodes can be configured with the [`kubeadm init phase bootstrap-token`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token)
   command, executing all the configuration steps described in following paragraphs; alternatively, each step can be invoked individually
-->
<ol>
<li>可以使用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token"><code>kubeadm init phase bootstrap-token</code></a> 
命令配置节点的 TLS 引导，执行以下段落中描述的所有配置步骤；
或者每个步骤都单独触发。</li>
</ol>
<!--
#### Create a bootstrap token
-->
<h4 id="create-a-bootstrap-token">创建引导令牌 </h4>
<!--  
`kubeadm init` create a first bootstrap token, either generated automatically or provided by the user with the `--token` flag; as documented
in bootstrap token specification, token should be saved as secrets with name `bootstrap-token-<token-id>` under `kube-system` namespace.
-->
<p><code>kubeadm init</code> 创建第一个引导令牌，该令牌是自动生成的或由用户提供的 <code>--token</code>
标志的值；如引导令牌规范中记录的那样，
令牌应保存在 <code>kube-system</code> 名字空间下名为 <code>bootstrap-token-&lt;令牌-id&gt;</code>
的 Secret 中。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!--  
1. The default token created by `kubeadm init` will be used to validate temporary user during TLS bootstrap process; those users will
   be member of  `system:bootstrappers:kubeadm:default-node-token` group
2. The token has a limited validity, default 24 hours (the interval may be changed with the `—token-ttl` flag)
3. Additional tokens can be created with the [`kubeadm token`](/docs/reference/setup-tools/kubeadm/kubeadm-token/) command, that provide as well other useful functions
   for token management
-->
<ol>
<li>由 <code>kubeadm init</code> 创建的默认令牌将用于在 TLS 引导过程中验证临时用户；
这些用户会成为 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的成员。</li>
<li>令牌的有效期有限，默认为 24 小时（间隔可以通过 <code>-token-ttl</code> 标志进行更改）</li>
<li>可以使用 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/"><code>kubeadm token</code></a>
命令创建其他令牌，这些令牌还提供其他有用的令牌管理功能</li>
</ol>
<!--
#### Allow joining nodes to call CSR API
-->
<h4 id="allow-joining-nodes-to-call-csr-api">允许加入的节点调用 CSR API </h4>
<!--
Kubeadm ensures that users in  `system:bootstrappers:kubeadm:default-node-token` group are able to access the certificate signing API.
-->
<p>Kubeadm 确保 <code>system:bootstrappers:kubeadm:default-node-token</code> 组中的用户
能够访问证书签名 API。</p>
<!-- 
This is implemented by creating a ClusterRoleBinding named `kubeadm:kubelet-bootstrap` between the group above and the default
RBAC role `system:node-bootstrapper`.
-->
<p>这是通过在上述组与默认 RBAC 角色 <code>system:node-bootstrapper</code> 之间创建名为
<code>kubeadm:kubelet-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<!--
#### Setup auto approval for new bootstrap tokens
-->
<h4 id="setup-auto-approval-for-new-bootstrap-tokens">为新的引导令牌设置自动批准 </h4>
<!--
Kubeadm ensures that the Bootstrap Token will get its CSR request automatically approved by the csrapprover controller.
-->
<p>Kubeadm 确保 csrapprover 控制器自动批准引导令牌的 CSR 请求。</p>
<!-- 
This is implemented by creating ClusterRoleBinding named `kubeadm:node-autoapprove-bootstrap` between
the  `system:bootstrappers:kubeadm:default-node-token` group and the default role `system:certificates.k8s.io:certificatesigningrequests:nodeclient`.
-->
<p>这是通过在 <code>system:bootstrappers:kubeadm:default-node-token</code> 用户组和
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 默认角色之间
创建名为 <code>kubeadm:node-autoapprove-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<!-- 
The role `system:certificates.k8s.io:certificatesigningrequests:nodeclient` should be created as well, granting
POST permission to `/apis/certificates.k8s.io/certificatesigningrequests/nodeclient`.
-->
<p>还应创建 <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 角色，
授予对 <code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>
执行 POST 的权限。</p>
<!--
#### Setup nodes certificate rotation with auto approval
-->
<h4 id="setup-nodes-certificate-rotation-with-auto-approval">通过自动批准设置节点证书轮换</h4>
<!-- 
Kubeadm ensures that certificate rotation is enabled for nodes, and that new certificate request for nodes will get its CSR request
automatically approved by the csrapprover controller. 
-->
<p>Kubeadm 确保节点启用了证书轮换，csrapprover 控制器将自动批准节点的
新证书的 CSR 请求。</p>
<!-- 
This is implemented by creating ClusterRoleBinding named `kubeadm:node-autoapprove-certificate-rotation` between the  `system:nodes` group
and the default role `system:certificates.k8s.io:certificatesigningrequests:selfnodeclient`.
-->
<p>这是通过在 <code>system:nodes</code> 组和
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>
默认角色之间创建名为 <code>kubeadm:node-autoapprove-certificate-rotation</code> 的
ClusterRoleBinding 来实现的。</p>
<!--
#### Create the public cluster-info ConfigMap
-->
<h4 id="创建公共-cluster-info-configmap">创建公共 cluster-info ConfigMap</h4>
<!--
This phase creates the `cluster-info` ConfigMap in the `kube-public` namespace.
-->
<p>本步骤在 <code>kube-public</code> 名字空间中创建名为 <code>cluster-info</code> 的 ConfigMap。</p>
<!--  
Additionally it creates a Role and a RoleBinding granting access to the ConfigMap for unauthenticated users
(i.e. users in RBAC group `system:unauthenticated`).
-->
<p>另外，它创建一个 Role 和一个 RoleBinding，为未经身份验证的用户授予对 ConfigMap
的访问权限（即 RBAC 组 <code>system:unauthenticated</code> 中的用户）。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!--  
1. The access to the `cluster-info` ConfigMap _is not_ rate-limited. This may or may not be a problem if you expose your cluster's API server
to the internet; worst-case scenario here is a DoS attack where an attacker uses all the in-flight requests the kube-apiserver
can handle to serving the `cluster-info` ConfigMap.
-->
<ol>
<li>对 <code>cluster-info</code> ConfigMap 的访问 <em>不受</em> 速率限制。
如果你把 API 服务器暴露到外网，这可能是一个问题，也可能不是；
这里最坏的情况是 DoS 攻击，攻击者使用 kube-apiserver 能够处理的所有动态请求
来为 <code>cluster-info</code> ConfigMap 提供服务。</li>
</ol>
<!--
### Install addons
-->
<h3 id="install-addons">安装插件 </h3>
<!--
Kubeadm installs the internal DNS server and the kube-proxy addon components via the API server.
-->
<p>Kubeadm 通过 API 服务器安装内部 DNS 服务器和 kube-proxy 插件。</p>
<!--
Please note that:
-->
<p>请注意：</p>
<!-- 
1. This phase can be invoked individually with the [`kubeadm init phase addon all`](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon) command. 
-->
<ol>
<li>此步骤可以调用
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">'kubeadm init phase addon all'</a>
命令单独执行。</li>
</ol>
<!--
#### proxy

A ServiceAccount for `kube-proxy` is created in the `kube-system` namespace; then kube-proxy is deployed as a DaemonSet: 
-->
<h4 id="proxy">代理 </h4>
<p>在 <code>kube-system</code> 名字空间中创建一个用于 <code>kube-proxy</code> 的 ServiceAccount；
然后以 DaemonSet 的方式部署 kube-proxy：</p>
<!--  
- The credentials (`ca.crt` and `token`) to the control plane come from the ServiceAccount
- The location (URL) of the API server comes from a ConfigMap
- The `kube-proxy` ServiceAccount is bound to the privileges in the `system:node-proxier` ClusterRole
-->
<ul>
<li>主控节点凭据（<code>ca.crt</code> 和 <code>token</code>）来自 ServiceAccount</li>
<li>API 服务器节点的位置（URL）来自 ConfigMap</li>
<li><code>kube-proxy</code> 的 ServiceAccount 绑定了 <code>system:node-proxier</code> ClusterRole
中的特权</li>
</ul>
<h4 id="dns">DNS</h4>
<!--  
- The CoreDNS service is named `kube-dns`. This is done to prevent any interruption
  in service when the user is switching the cluster DNS from kube-dns to CoreDNS,
  the `--config` method described [here](/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon)
- A ServiceAccount for CoreDNS is created in the `kube-system` namespace.
- The `coredns` ServiceAccount is bound to the privileges in the `system:coredns` ClusterRole
-->
<ul>
<li>CoreDNS 服务的名称为 <code>kube-dns</code>。这样做是为了防止当用户将集群 DNS 从 kube-dns
切换到 CoreDNS 时出现服务中断。<code>--config</code> 方法在
<a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon">这里</a>
有描述。</li>
<li>在 <code>kube-system</code> 名字空间中创建 CoreDNS 的 ServiceAccount</li>
<li><code>coredns</code> 的 ServiceAccount 绑定了 <code>system:coredns</code> ClusterRole 中的特权</li>
</ul>
<!--
In Kubernetes version 1.21, support for using `kube-dns` with kubeadm was removed.
You can use CoreDNS with kubeadm even when the related Service is named `kube-dns`.
-->
<p>在 Kubernetes 1.21 版本中，kubeadm 对 <code>kube-dns</code> 的支持被移除。
你可以在 kubeadm 使用 CoreDNS，即使相关的 Service 名字仍然是 <code>kube-dns</code>。</p>
<!--
## kubeadm join phases internal design
-->
<h2 id="kubeadm-join-phases-internal-design">kubeadm join 步骤内部设计 </h2>
<!-- 
Similarly to `kubeadm init`, also `kubeadm join` internal workflow consists of a sequence of atomic work tasks to perform. 
-->
<p>与 <code>kubeadm init</code> 类似，<code>kubeadm join</code> 内部工作流由一系列待执行的原子工作任务组成。</p>
<!-- 
This is split into discovery (having the Node trust the Kubernetes Master) and TLS bootstrap (having the Kubernetes Master trust the Node). 
-->
<p>这分为发现（让该节点信任 Kubernetes 的主控节点）和 TLS 引导
（让 Kubernetes 的主控节点信任该节点）。</p>
<!-- 
see [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/) or the corresponding [design proposal](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md). 
-->
<p>请参阅<a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用引导令牌进行身份验证</a>
或相应的<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md">设计提案</a>。</p>
<!--
### Preflight checks
-->
<h3 id="preflight-checks">预检 </h3>
<!-- 
`kubeadm` executes a set of preflight checks before starting the join, with the aim to verify preconditions and avoid common
cluster startup problems.
-->
<p><code>kubeadm</code> 在开始执行之前执行一组预检，目的是验证先决条件，避免常见的集群启动问题。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1. `kubeadm join` preflight checks are basically a subset `kubeadm init` preflight checks
1. Starting from 1.9, kubeadm provides better support for CRI-generic functionality; in that case, docker specific controls
   are skipped or replaced by similar controls for crictl.
1. Starting from 1.9, kubeadm provides support for joining nodes running on Windows; in that case, linux specific controls are skipped.
1. In any case the user can skip specific preflight checks (or eventually all preflight checks) with the `--ignore-preflight-errors` option.
-->
<ol>
<li><code>kubeadm join</code> 预检基本上是 <code>kubeadm init</code> 预检的一个子集</li>
<li>从 1.9 开始，kubeadm 为 CRI 通用的功能提供了更好的支持；在这种情况下，
Docker 特定的控制参数将跳过或替换为 crictl 中与之相似的控制参数。</li>
<li>从 1.9 开始，kubeadm 支持加入在 Windows 上运行的节点；在这种情况下，
将跳过 Linux 特定的控制参数。</li>
<li>在任何情况下，用户都可以通过 <code>--ignore-preflight-errors</code> 选项跳过
特定的预检（或者进而跳过所有预检）。</li>
</ol>
<!--
### Discovery cluster-info
-->
<h3 id="discovery-cluster-info">发现 cluster-info </h3>
<!--  
There are 2 main schemes for discovery. The first is to use a shared token along with the IP address of the API server.
The second is to provide a file (that is a subset of the standard kubeconfig file).
-->
<p>主要有两种发现方案。第一种是使用一个共享令牌以及 API 服务器的 IP 地址。
第二种是提供一个文件（它是标准 kubeconfig 文件的子集）。</p>
<!--
#### Shared token discovery
-->
<h4 id="shared-token-discovery">共享令牌发现 </h4>
<!--  
If `kubeadm join` is invoked with `--discovery-token`, token discovery is used; in this case the node basically retrieves
the cluster CA certificates from the  `cluster-info` ConfigMap in the `kube-public` namespace.
-->
<p>如果带 <code>--discovery-token</code> 参数调用 <code>kubeadm join</code>，则使用了令牌发现功能；
在这种情况下，节点基本上从 <code>kube-public</code> 名字空间中的 <code>cluster-info</code> ConfigMap
中检索集群 CA 证书。</p>
<!-- In order to prevent "man in the middle" attacks, several steps are taken: -->
<p>为了防止“中间人”攻击，采取了以下步骤：</p>
<!--  
- First, the CA certificate is retrieved via insecure connection (this is possible because `kubeadm init` granted access to  `cluster-info` users for `system:unauthenticated` )
- Then the CA certificate goes trough following validation steps:
  - Basic validation: using the token ID against a JWT signature
  - Pub key validation: using provided `--discovery-token-ca-cert-hash`. This value is available in the output of `kubeadm init` or can
    be calculated using standard tools (the hash is calculated over the bytes of the Subject Public Key Info (SPKI) object as in RFC7469).
    The `--discovery-token-ca-cert-hash flag` may be repeated multiple times to allow more than one public key.
  - As a additional validation, the CA certificate is retrieved via secure connection and then compared with the CA retrieved initially
-->
<ul>
<li>首先，通过不安全连接检索 CA 证书（这是可能的，因为 <code>kubeadm init</code> 授予
<code>system:unauthenticated</code> 的用户对 <code>cluster-info</code> 访问权限）</li>
<li>然后 CA 证书通过以下验证步骤：
<ul>
<li>基本验证：使用令牌 ID 而不是 JWT 签名</li>
<li>公钥验证：使用提供的 <code>--discovery-token-ca-cert-hash</code>。这个值来自 <code>kubeadm init</code> 的输出，
或者可以使用标准工具计算（哈希值是按 RFC7469 中主体公钥信息（SPKI）对象的字节计算的）
<code>--discovery-token-ca-cert-hash</code> 标志可以重复多次，以允许多个公钥。</li>
<li>作为附加验证，通过安全连接检索 CA 证书，然后与初始检索的 CA 进行比较</li>
</ul>
</li>
</ul>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
1.  Pub key validation can be skipped passing `--discovery-token-unsafe-skip-ca-verification` flag; This weakens the kubeadm security
    model since others can potentially impersonate the Kubernetes Master.
-->
<ol>
<li>通过 <code>--discovery-token-unsafe-skip-ca-verification</code> 标志可以跳过公钥验证；
这削弱了 kubeadm 安全模型，因为其他人可能冒充 Kubernetes 主控节点。</li>
</ol>
<!--
#### File/https discovery
-->
<h4 id="file-or-https-discovery">文件/HTTPS 发现 </h4>
<!-- 
If `kubeadm join` is invoked with `--discovery-file`, file discovery is used; this file can be a local file or downloaded via an HTTPS URL; in case of HTTPS, the host installed CA bundle is used to verify the connection. 
-->
<p>如果带 <code>--discovery-file</code> 参数调用 <code>kubeadm join</code>，则使用文件发现功能；
该文件可以是本地文件或通过 HTTPS URL 下载；对于 HTTPS，主机安装的 CA 包
用于验证连接。</p>
<!--  
With file discovery, the cluster CA certificates is provided into the file itself; in fact, the discovery file is a kubeconfig
file with only `server` and `certificate-authority-data` attributes set, as described in [`kubeadm join`](/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery) reference doc;
when the connection with the cluster is established, kubeadm try to access the `cluster-info` ConfigMap, and if available, uses it.
-->
<p>通过文件发现，集群 CA 证书是文件本身提供；事实上，这个发现文件是一个 kubeconfig 文件，
只设置了 <code>server</code> 和 <code>certificate-authority-data</code> 属性，
如 <a href="/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery"><code>kubeadm join</code></a>
参考文档中所述，当与集群建立连接时，kubeadm 尝试访问 <code>cluster-info</code> ConfigMap，
如果可用，就使用它。</p>
<!--
## TLS Bootstrap
-->
<h2 id="tls-boostrap">TLS 引导 </h2>
<!--  
Once the cluster info are known, the file `bootstrap-kubelet.conf` is written, thus allowing kubelet to do TLS Bootstrapping.
-->
<p>知道集群信息后，kubeadm 将写入文件 <code>bootstrap-kubelet.conf</code>，从而允许 kubelet 执行
TLS 引导。</p>
<!--  
The TLS bootstrap mechanism uses the shared token to temporarily authenticate with the Kubernetes API server to submit a certificate
signing request (CSR) for a locally created key pair.
-->
<p>TLS 引导机制使用共享令牌对 Kubernetes API 服务器进行临时身份验证，以便
为本地创建的密钥对提交证书签名请求（CSR）。</p>
<!--  
The request is then automatically approved and the operation completes saving `ca.crt` file and `kubelet.conf` file to be used
by kubelet for joining the cluster, while`bootstrap-kubelet.conf` is deleted.
-->
<p>该请求会被自动批准，并且该操作保存 <code>ca.crt</code> 文件和 <code>kubelet.conf</code> 文件，用于
kubelet 加入集群，同时删除 <code>bootstrap-kubelet.conf</code>。</p>
<!-- Please note that: -->
<p>请注意：</p>
<!--  
- The temporary authentication is validated against the token saved during the `kubeadm init` process (or with additional tokens
  created with `kubeadm token`)
- The temporary authentication resolve to a user member of `system:bootstrappers:kubeadm:default-node-token` group which was granted
  access to CSR api during the `kubeadm init` process
- The automatic CSR approval is managed by the csrapprover controller, according with configuration done the `kubeadm init` process
-->
<ul>
<li>临时身份验证根据 <code>kubeadm init</code> 过程中保存的令牌进行验证（或者使用 <code>kubeadm token</code>
创建的其他令牌）</li>
<li>临时身份验证解析到 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的一个用户成员，
该成员在 <code>kubeadm init</code> 过程中被授予对 CSR API 的访问权</li>
<li>根据 <code>kubeadm init</code> 过程的配置，自动 CSR 审批由 csrapprover 控制器管理</li>
</ul>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
