<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="pt-br" href="http://localhost:1313/pt-br/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/concepts/overview/working-with-objects/">
<link rel="alternate" hreflang="ru" href="http://localhost:1313/ru/docs/concepts/overview/working-with-objects/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/concepts/overview/working-with-objects/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>使用 Kubernetes 对象 | Kubernetes</title><meta property="og:title" content="使用 Kubernetes 对象" />
<meta property="og:description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/concepts/overview/working-with-objects/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="使用 Kubernetes 对象">
<meta itemprop="description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="使用 Kubernetes 对象"/>
<meta name="twitter:description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
">
<meta property="og:description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
">
<meta name="twitter:description" content="Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。
">
<meta property="og:url" content="http://localhost:1313/zh/docs/concepts/overview/working-with-objects/">
<meta property="og:title" content="使用 Kubernetes 对象">
<meta name="twitter:title" content="使用 Kubernetes 对象">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/concepts/overview/working-with-objects/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/concepts/overview/working-with-objects/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/concepts/overview/working-with-objects/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/concepts/overview/working-with-objects/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/concepts/overview/working-with-objects/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/concepts/overview/working-with-objects/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/concepts/overview/working-with-objects/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/concepts/overview/working-with-objects/">Français</a>
	
	<a class="dropdown-item" href="/es/docs/concepts/overview/working-with-objects/">Español</a>
	
	<a class="dropdown-item" href="/pt-br/docs/concepts/overview/working-with-objects/">Português</a>
	
	<a class="dropdown-item" href="/id/docs/concepts/overview/working-with-objects/">Bahasa Indonesia</a>
	
	<a class="dropdown-item" href="/ru/docs/concepts/overview/working-with-objects/">Русский</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/concepts/overview/working-with-objects/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">使用 Kubernetes 对象</h1>
<div class="lead">Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-9f5adfa77f48c50d5cc81155a3cecb98">理解 Kubernetes 对象</a></li>


    
  
    
    
	
<li>2: <a href="#pg-6751db8ff5409476de8225d17d6c42dd">Kubernetes 对象管理</a></li>


    
  
    
    
	
<li>3: <a href="#pg-f37749a83c2916b63279ea60f3cfe53e">对象名称和 IDs</a></li>


    
  
    
    
	
<li>4: <a href="#pg-1127165f472b7181b9c1d5a0b187d620">名字空间</a></li>


    
  
    
    
	
<li>5: <a href="#pg-f1dec4557fb8ffbac9f11390aaaf9fa4">标签和选择算符</a></li>


    
  
    
    
	
<li>6: <a href="#pg-93cd7a1d4e1623e2bf01afc49a5af69c">注解</a></li>


    
  
    
    
	
<li>7: <a href="#pg-13ce5627ef1dc8cbb4530ed231cb7d38">Finalizers</a></li>


    
  
    
    
	
<li>8: <a href="#pg-046c03090d47bc4b89b818dc645c3865">字段选择器</a></li>


    
  
    
    
	
<li>9: <a href="#pg-efaa7a58910b58892dafd50e3b43c93c">属主与附属</a></li>


    
  
    
    
	
<li>10: <a href="#pg-5dd62c6a4a481b4cf1ac50f6799eb581">推荐使用的标签</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-9f5adfa77f48c50d5cc81155a3cecb98">1 - 理解 Kubernetes 对象</h1>
    
	<!---
title: Understanding Kubernetes Objects
content_type: concept
weight: 10
card: 
  name: concepts
  weight: 40
-->
<!-- overview -->
<!--
This page explains how Kubernetes objects are represented in the Kubernetes API, and how you can express them in `.yaml` format.
-->
<p>本页说明了 Kubernetes 对象在 Kubernetes API 中是如何表示的，以及如何在 <code>.yaml</code> 格式的文件中表示。</p>
<!-- body -->
<!--
## Understanding Kubernetes Objects

*Kubernetes Objects* are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Specifically, they can describe:

* What containerized applications are running (and on which nodes)
* The resources available to those applications
* The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance
-->
<h2 id="理解-kubernetes-对象">理解 Kubernetes 对象</h2>
<p>在 Kubernetes 系统中，<em>Kubernetes 对象</em> 是持久化的实体。
Kubernetes 使用这些实体去表示整个集群的状态。特别地，它们描述了如下信息：</p>
<ul>
<li>哪些容器化应用在运行（以及在哪些节点上）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li>
</ul>
<!--
A Kubernetes object is a "record of intent" - once you create the object, the Kubernetes system will constantly work to ensure that object exists. By creating an object, you're effectively telling the Kubernetes system what you want your cluster's workload to look like; this is your cluster's *desired state*.

To work with Kubernetes objects - whether to create, modify, or delete them - you'll need to use the [Kubernetes API](/docs/concepts/overview/kubernetes-api/). When you use the `kubectl` command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use the Kubernetes API directly in your own programs using one of the [Client Libraries](/docs/reference/using-api/client-libraries/).
-->
<p>Kubernetes 对象是 “目标性记录” —— 一旦创建对象，Kubernetes 系统将持续工作以确保对象存在。
通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，
这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p>
<p>操作 Kubernetes 对象 —— 无论是创建、修改，或者删除 —— 需要使用
<a href="/zh/docs/concepts/overview/kubernetes-api">Kubernetes API</a>。
比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，
也可以在程序中使用
<a href="/zh/docs/reference/using-api/client-libraries/">客户端库</a>直接调用 Kubernetes API。</p>
<!--
### Object Spec and Status

Almost every Kubernetes object includes two nested object fields that govern
the object's configuration: the object *`spec`* and the object *`status`*.
For objects that have a `spec`, you have to set this when you create the object,
providing a description of the characteristics you want the resource to have:
its _desired state_.
-->
<h3 id="object-spec-and-status">对象规约（Spec）与状态（Status）   </h3>
<p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置：
对象 <em><code>spec</code>（规约）</em> 和 对象 <em><code>status</code>（状态）</em> 。
对于具有 <code>spec</code> 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征：
<em>期望状态（Desired State）</em> 。</p>
<!--
The `status` describes the _current state_ of the object, supplied and updated
by the Kubernetes system and its components. The Kubernetes
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a> continually
and actively manages every object's actual state to match the desired state you
supplied.
-->
<p><code>status</code> 描述了对象的 <em>当前状态（Current State）</em>，它是由 Kubernetes 系统和组件
设置并更新的。在任何时刻，Kubernetes
<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制平面'>控制平面</a>
都一直积极地管理着对象的实际状态，以使之与期望状态相匹配。</p>
<!--
For example: in Kubernetes, a Deployment is an object that can represent an
application running on your cluster. When you create the Deployment, you
might set the Deployment `spec` to specify that you want three replicas of
the application to be running. The Kubernetes system reads the Deployment
spec and starts three instances of your desired application-updating
the status to match your spec. If any of those instances should fail
(a status change), the Kubernetes system responds to the difference
between spec and status by making a correction-in this case, starting
a replacement instance.
-->
<p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。
当创建 Deployment 时，可能需要设置 Deployment 的 <code>spec</code>，以指定该应用需要有 3 个副本运行。
Kubernetes 系统读取 Deployment 规约，并启动我们所期望的应用的 3 个实例
—— 更新状态以与规约相匹配。
如果这些实例中有的失败了（一种状态变更），Kubernetes 系统通过执行修正操作
来响应规约和状态间的不一致 —— 在这里意味着它会启动一个新的实例来替换。</p>
<!--
For more information on the object spec, status, and metadata, see the [Kubernetes API Conventions](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md).
-->
<p>关于对象 spec、status 和 metadata 的更多信息，可参阅
<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md">Kubernetes API 约定</a>。</p>
<!--
### Describing a Kubernetes Object

When you create an object in Kubernetes, you must provide the object spec that describes its desired state, as well as some basic information about the object (such as a name). When you use the Kubernetes API to create the object (either directly or via `kubectl`), that API request must include that information as JSON in the request body. **Most often, you provide the information to `kubectl` in a .yaml file.** `kubectl` converts the information to JSON when making the API request.

Here's an example `.yaml` file that shows the required fields and object spec for a Kubernetes Deployment:
-->
<h3 id="描述-kubernetes-对象">描述 Kubernetes 对象</h3>
<p>创建 Kubernetes 对象时，必须提供对象的规约，用来描述该对象的期望状态，
以及关于对象的一些基本信息（例如名称）。
当使用 Kubernetes API 创建对象时（或者直接创建，或者基于<code>kubectl</code>），
API 请求必须在请求体中包含 JSON 格式的信息。
<strong>大多数情况下，需要在 .yaml 文件中为 <code>kubectl</code> 提供这些信息</strong>。
<code>kubectl</code> 在发起 API 请求时，将这些信息转换成 JSON 格式。</p>
<p>这里有一个 <code>.yaml</code> 示例文件，展示了 Kubernetes Deployment 的必需字段和对象规约：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/deployment.yaml" download="application/deployment.yaml"><code>application/deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb"> </span><span style="color:#080;font-style:italic"># tells deployment to run 2 pods matching the template</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
One way to create a Deployment using a `.yaml` file like the one above is to use the
[`kubectl apply`](/docs/reference/generated/kubectl/kubectl-commands#apply) command
in the `kubectl` command-line interface, passing the `.yaml` file as an argument. Here's an example:
-->
<p>使用类似于上面的 <code>.yaml</code> 文件来创建 Deployment的一种方式是使用 <code>kubectl</code> 命令行接口（CLI）中的
<a href="/docs/reference/generated/kubectl/kubectl-commands#apply"><code>kubectl apply</code></a> 命令，
将 <code>.yaml</code> 文件作为参数。下面是一个示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似如下这样：</p>
<pre><code>deployment.apps/nginx-deployment created
</code></pre><!--
### Required Fields

In the `.yaml` file for the Kubernetes object you want to create, you'll need to set values for the following fields:

* `apiVersion` - Which version of the Kubernetes API you're using to create this object
* `kind` - What kind of object you want to create
* `metadata` - Data that helps uniquely identify the object, including a `name` string, `UID`, and optional `namespace`
* `spec` - What state you desire for the object
-->
<h3 id="required-fields">必需字段 </h3>
<p>在想要创建的 Kubernetes 对象对应的 <code>.yaml</code> 文件中，需要配置如下的字段：</p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类别</li>
<li><code>metadata</code> - 帮助唯一性标识对象的一些数据，包括一个 <code>name</code> 字符串、UID 和可选的 <code>namespace</code></li>
<li><code>spec</code> - 你所期望的该对象的状态</li>
</ul>
<!--
The precise format of the object `spec` is different for every Kubernetes object, and contains nested fields specific to that object. The [Kubernetes API Reference](https://kubernetes.io/docs/reference/kubernetes-api/) can help you find the spec format for all of the objects you can create using Kubernetes.
-->
<p>对象 <code>spec</code> 的精确格式对每个 Kubernetes 对象来说是不同的，包含了特定于该对象的嵌套字段。
<a href="https://kubernetes.io/docs/reference/kubernetes-api/">Kubernetes API 参考</a>
能够帮助我们找到任何我们想创建的对象的规约格式。</p>
<!--
For example, see the [`spec` field](/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec)
for the Pod API reference.
For each Pod, the `.spec` field specifies the pod and its desired state (such as the container image name for
each container within that pod).
Another example of an object specification is the
[`spec` field](/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec)
for the StatefulSet API. For StatefulSet, the `.spec` field specifies the StatefulSet and
its desired state.
Within the `.spec` of a StatefulSet is a [template](/docs/concepts/workloads/pods/#pod-templates)
for Pod objects. That template describes Pods that the StatefulSet controller will create in order to
satisfy the StatefulSet specification.
Different kinds of object can also have different `.status`; again, the API reference pages
detail the structure of that `.status` field, and its content for each different type of object.
-->
<p>例如，参阅 Pod API 参考文档中
<a href="/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec"><code>spec</code> 字段</a>。
对于每个 Pod，其 <code>.spec</code> 字段设置了 Pod 及其期望状态（例如 Pod 中每个容器的容器镜像名称）。
另一个对象规约的例子是 StatefulSet API 中的
<a href="/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec"><code>spec</code> 字段</a>。
对于 StatefulSet 而言，其 <code>.spec</code> 字段设置了 StatefulSet 及其期望状态。
在 StatefulSet 的 <code>.spec</code> 内，有一个为 Pod 对象提供的<a href="/zh/docs/concepts/workloads/pods/#pod-templates">模板</a>。该模板描述了 StatefulSet 控制器为了满足 StatefulSet 规约而要创建的 Pod。
不同类型的对象可以由不同的 <code>.status</code> 信息。API 参考页面给出了 <code>.status</code> 字段的详细结构，
以及针对不同类型 API 对象的具体内容。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* Learn about the most important basic Kubernetes objects, such as [Pod](/docs/concepts/workloads/pods/).
* Learn about [controllers](/docs/concepts/architecture/controller/) in Kubernetes.
* [Using the Kubernetes API](/docs/reference/using-api/) explains some more API concepts.
-->
<ul>
<li>了解最重要的 Kubernetes 基本对象，例如 <a href="/zh/docs/concepts/workloads/pods/">Pod</a>。</li>
<li>了解 Kubernetes 中的<a href="/zh/docs/concepts/architecture/controller/">控制器</a>。</li>
<li><a href="/zh/docs/reference/using-api/">使用 Kubernetes API</a> 一节解释了一些 API 概念。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6751db8ff5409476de8225d17d6c42dd">2 - Kubernetes 对象管理</h1>
    
	<!-- overview -->
<!--
The `kubectl` command-line tool supports several different ways to create and manage
Kubernetes objects. This document provides an overview of the different
approaches. Read the [Kubectl book](https://kubectl.docs.kubernetes.io) for
details of managing objects by Kubectl.
-->
<p><code>kubectl</code> 命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。
本文档概述了不同的方法。
阅读 <a href="https://kubectl.docs.kubernetes.io">Kubectl book</a> 来了解 kubectl
管理对象的详细信息。</p>
<!-- body -->
<!--
## Management techniques
-->
<h2 id="管理技巧">管理技巧</h2>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <!--
A Kubernetes object should be managed using only one technique. Mixing
and matching techniques for the same object results in undefined behavior.
-->
<p>应该只使用一种技术来管理 Kubernetes 对象。混合和匹配技术作用在同一对象上将导致未定义行为。
</div>


<!--
| Management technique             | Operates on          |Recommended environment | Supported writers  | Learning curve |
|----------------------------------|----------------------|------------------------|--------------------|----------------|
| Imperative commands              | Live objects         | Development projects   | 1+                 | Lowest         |
| Imperative object configuration  | Individual files     | Production projects    | 1                  | Moderate       |
| Declarative object configuration | Directories of files | Production projects    | 1+                 | Highest        |
-->
<table>
<thead>
<tr>
<th>管理技术</th>
<th>作用于</th>
<th>建议的环境</th>
<th>支持的写者</th>
<th>学习难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>指令式命令</td>
<td>活跃对象</td>
<td>开发项目</td>
<td>1+</td>
<td>最低</td>
</tr>
<tr>
<td>指令式对象配置</td>
<td>单个文件</td>
<td>生产项目</td>
<td>1</td>
<td>中等</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>文件目录</td>
<td>生产项目</td>
<td>1+</td>
<td>最高</td>
</tr>
</tbody>
</table>
<!--
## Imperative commands
-->
<h2 id="指令式命令">指令式命令</h2>
<!--
When using imperative commands, a user operates directly on live objects
in a cluster. The user provides operations to
the `kubectl` command as arguments or flags.
-->
<p>使用指令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给
<code>kubectl</code> 命令作为参数或标志。</p>
<!--
This is the recommended way to get started or to run a one-off task in
a cluster. Because this technique operates directly on live
objects, it provides no history of previous configurations.
-->
<p>这是开始或者在集群中运行一次性任务的推荐方法。因为这个技术直接在活跃对象
上操作，所以它不提供以前配置的历史记录。</p>
<!--
### Examples
-->
<h3 id="例子">例子</h3>
<!--
Run an instance of the nginx container by creating a Deployment object:
-->
<p>通过创建 Deployment 对象来运行 nginx 容器的实例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl create deployment nginx --image nginx
</code></pre></div><!--
### Trade-offs
-->
<h3 id="权衡">权衡</h3>
<!--
Advantages compared to object configuration:

- Commands are simple, easy to learn and easy to remember.
- Commands require only a single step to make changes to the cluster.
-->
<p>与对象配置相比的优点：</p>
<ul>
<li>命令简单，易学且易于记忆。</li>
<li>命令仅需一步即可对集群进行更改。</li>
</ul>
<!--
Disadvantages compared to object configuration:

- Commands do not integrate with change review processes.
- Commands do not provide an audit trail associated with changes.
- Commands do not provide a source of records except for what is live.
- Commands do not provide a template for creating new objects.
-->
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不与变更审查流程集成。</li>
<li>命令不提供与更改关联的审核跟踪。</li>
<li>除了实时内容外，命令不提供记录源。</li>
<li>命令不提供用于创建新对象的模板。</li>
</ul>
<!--
## Imperative object configuration
-->
<h2 id="指令式对象配置">指令式对象配置</h2>
<!--
In imperative object configuration, the kubectl command specifies the
operation (create, replace, etc.), optional flags and at least one file
name. The file specified must contain a full definition of the object
in YAML or JSON format.
-->
<p>在指令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和
至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p>
<!--
See the [API reference](/docs/reference/generated/kubernetes-api/v1.23/)
for more details on object definitions.
-->
<p>有关对象定义的详细信息，请查看
<a href="/docs/reference/generated/kubernetes-api/v1.23/">API 参考</a>。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <!--
The imperative `replace` command replaces the existing
spec with the newly provided one, dropping all changes to the object missing from
the configuration file.  This approach should not be used with resource
types whose specs are updated independently of the configuration file.
Services of type `LoadBalancer`, for example, have their `externalIPs` field updated
independently from the configuration by the cluster.
-->
<p><code>replace</code> 指令式命令将现有规范替换为新提供的规范，并放弃对配置文件中
缺少的对象的所有更改。此方法不应与对象规约被独立于配置文件进行更新的
资源类型一起使用。比如类型为 <code>LoadBalancer</code> 的服务，它的 <code>externalIPs</code>
字段就是独立于集群配置进行更新。
</div>


<!--
### Examples

Create the objects defined in a configuration file:
-->
<h3 id="例子-1">例子</h3>
<p>创建配置文件中定义的对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl create -f nginx.yaml
</code></pre></div><!--
Delete the objects defined in two configuration files:
-->
<p>删除两个配置文件中定义的对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl delete -f nginx.yaml -f redis.yaml
</code></pre></div><!--
Update the objects defined in a configuration file by overwriting
the live configuration:
-->
<p>通过覆盖活动配置来更新配置文件中定义的对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl replace -f nginx.yaml
</code></pre></div><!--
### Trade-offs
-->
<h3 id="权衡-1">权衡</h3>
<!--
Advantages compared to imperative commands:

- Object configuration can be stored in a source control system such as Git.
- Object configuration can integrate with processes such as reviewing changes before push and audit trails.
- Object configuration provides a template for creating new objects.
-->
<p>与指令式命令相比的优点：</p>
<ul>
<li>对象配置可以存储在源控制系统中，比如 Git。</li>
<li>对象配置可以与流程集成，例如在推送和审计之前检查更新。</li>
<li>对象配置提供了用于创建新对象的模板。</li>
</ul>
<!--
Disadvantages compared to imperative commands:

- Object configuration requires basic understanding of the object schema.
- Object configuration requires the additional step of writing a YAML file.
-->
<p>与指令式命令相比的缺点：</p>
<ul>
<li>对象配置需要对对象架构有基本的了解。</li>
<li>对象配置需要额外的步骤来编写 YAML 文件。</li>
</ul>
<!--
Advantages compared to declarative object configuration:

- Imperative object configuration behavior is simpler and easier to understand.
- As of Kubernetes version 1.5, imperative object configuration is more mature.
-->
<p>与声明式对象配置相比的优点：</p>
<ul>
<li>指令式对象配置行为更加简单易懂。</li>
<li>从 Kubernetes 1.5 版本开始，指令对象配置更加成熟。</li>
</ul>
<!--
Disadvantages compared to declarative object configuration:

- Imperative object configuration works best on files, not directories.
- Updates to live objects must be reflected in configuration files, or they will be lost during the next replacement.
-->
<p>与声明式对象配置相比的缺点：</p>
<ul>
<li>指令式对象配置更适合文件，而非目录。</li>
<li>对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。</li>
</ul>
<!--
## Declarative object configuration
-->
<h2 id="声明式对象配置">声明式对象配置</h2>
<!--
When using declarative object configuration, a user operates on object
configuration files stored locally, however the user does not define the
operations to be taken on the files. Create, update, and delete operations
are automatically detected per-object by `kubectl`. This enables working on
directories, where different operations might be needed for different objects.
-->
<p>使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户
未定义要对该文件执行的操作。
<code>kubectl</code> 会自动检测每个文件的创建、更新和删除操作。
这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Declarative object configuration retains changes made by other
writers, even if the changes are not merged back to the object configuration file.
This is possible by using the `patch` API operation to write only
observed differences, instead of using the `replace`
API operation to replace the entire object configuration.
-->
<p>声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中。
可以通过使用 <code>patch</code> API 操作仅写入观察到的差异，而不是使用 <code>replace</code> API
操作来替换整个对象配置来实现。
</div>
<!--
### Examples
-->
<h3 id="例子-2">例子</h3>
<!--
Process all object configuration files in the `configs` directory, and create or
patch the live objects. You can first `diff` to see what changes are going to be
made, and then apply:
-->
<p>处理 <code>configs</code> 目录中的所有对象配置文件，创建并更新活跃对象。
可以首先使用 <code>diff</code> 子命令查看将要进行的更改，然后在进行应用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl diff -f configs/
kubectl apply -f configs/
</code></pre></div><!--
Recursively process directories:
-->
<p>递归处理目录：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">kubectl diff -R -f configs/
kubectl apply -R -f configs/
</code></pre></div><!--
### Trade-offs

Advantages compared to imperative object configuration:

- Changes made directly to live objects are retained, even if they are not merged back into the configuration files.
- Declarative object configuration has better support for operating on directories and automatically detecting operation types (create, patch, delete) per-object.
-->
<h3 id="权衡-2">权衡</h3>
<p>与指令式对象配置相比的优点：</p>
<ul>
<li>对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。</li>
<li>声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。</li>
</ul>
<!--
Disadvantages compared to imperative object configuration:

- Declarative object configuration is harder to debug and understand results when they are unexpected.
- Partial updates using diffs create complex merge and patch operations.
-->
<p>与指令式对象配置相比的缺点：</p>
<ul>
<li>声明式对象配置难于调试并且出现异常时结果难以理解。</li>
<li>使用 diff 产生的部分更新会创建复杂的合并和补丁操作。</li>
</ul>
<h2 id="what-s-next">What's next</h2>
<!--
- [Managing Kubernetes Objects Using Imperative Commands](/docs/tasks/manage-kubernetes-objects/imperative-command/)
- [Managing Kubernetes Objects Using Object Configuration (Imperative)](/docs/tasks/manage-kubernetes-objects/imperative-config/)
- [Managing Kubernetes Objects Using Object Configuration (Declarative)](/docs/tasks/manage-kubernetes-objects/declarative-config/)
- [Managing Kubernetes Objects Using Kustomize (Declarative)](/docs/tasks/manage-kubernetes-objects/kustomization/)
- [Kubectl Command Reference](/docs/reference/generated/kubectl/kubectl-commands/)
- [Kubectl Book](https://kubectl.docs.kubernetes.io)
- [Kubernetes API Reference](/docs/reference/generated/kubernetes-api/v1.23/)
-->
<ul>
<li><a href="/zh/docs/tasks/manage-kubernetes-objects/imperative-command/">使用指令式命令管理 Kubernetes 对象</a></li>
<li><a href="/zh/docs/tasks/manage-kubernetes-objects/imperative-config/">使用对象配置管理 Kubernetes 对象（指令式）</a></li>
<li><a href="/zh/docs/tasks/manage-kubernetes-objects/declarative-config/">使用对象配置管理 Kubernetes 对象（声明式）</a></li>
<li><a href="/zh/docs/tasks/manage-kubernetes-objects/kustomization/">使用 Kustomize（声明式）管理 Kubernetes 对象</a></li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands/">Kubectl 命令参考</a></li>
<li><a href="https://kubectl.docs.kubernetes.io">Kubectl Book</a></li>
<li><a href="/docs/reference/generated/kubernetes-api/v1.23/">Kubernetes API 参考</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f37749a83c2916b63279ea60f3cfe53e">3 - 对象名称和 IDs</h1>
    
	<!-- overview -->
<!--
Each object in your cluster has a [_Name_](#names) that is unique for that type of resource.
Every Kubernetes object also has a [_UID_](#uids) that is unique across your whole cluster.

For example, you can only have one Pod named `myapp-1234` within the same [namespace](/docs/concepts/overview/working-with-objects/namespaces/), but you can have one Pod and one Deployment that are each named `myapp-1234`.
-->
<p>集群中的每一个对象都有一个<a href="#names"><em>名称</em></a> 来标识在同类资源中的唯一性。</p>
<p>每个 Kubernetes 对象也有一个<a href="#uids"><em>UID</em></a> 来标识在整个集群中的唯一性。</p>
<p>比如，在同一个<a href="/zh/docs/concepts/overview/working-with-objects/namespaces/">名字空间</a>
中有一个名为 <code>myapp-1234</code> 的 Pod, 但是可以命名一个 Pod 和一个 Deployment 同为 <code>myapp-1234</code>.</p>
<!--
For non-unique user-provided attributes, Kubernetes provides [labels](/docs/user-guide/labels) and [annotations](/docs/concepts/overview/working-with-objects/annotations/).
-->
<p>对于用户提供的非唯一性的属性，Kubernetes 提供了
<a href="/zh/docs/concepts/working-with-objects/labels">标签（Labels）</a>和
<a href="/zh/docs/concepts/overview/working-with-objects/annotations/">注解（Annotation）</a>机制。</p>
<!-- body -->
<!--
## Names
-->
<h2 id="names">名称 </h2>
<!--
---
title: Name
id: name
date: 2018-04-12
full_link: /docs/concepts/overview/working-with-objects/names/
short_description: >
  A client-provided string that refers to an object in a resource URL, such as `/api/v1/pods/some-name`.

aka: 
tags:
- fundamental
---
-->
<!--
 A client-provided string that refers to an object in a resource URL, such as `/api/v1/pods/some-name`.
-->
<p>客户端提供的字符串，引用资源 url 中的对象，如<code>/api/v1/pods/some name</code>。</p>
<!--
Only one object of a given kind can have a given name at a time. However, if you delete the object, you can make a new object with the same name.
-->
<p>某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
In cases when objects represent a physical entity, like a Node representing a physical host, when the host is re-created under the same name without deleting and re-creating the Node, Kubernetes treats the new host as the old one, which may lead to inconsistencies.
-->
<p>当对象所代表的是一个物理实体（例如代表一台物理主机的 Node）时，
如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机，
则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。
</div>
<!--
Below are four types of commonly used name constraints for resources.
-->
<p>以下是比较常见的四种资源命名约束。</p>
<!--
### DNS Subdomain Names

Most resource types require a name that can be used as a DNS subdomain name
as defined in [RFC 1123](https://tools.ietf.org/html/rfc1123).
This means the name must:

- contain no more than 253 characters
- contain only lowercase alphanumeric characters, '-' or '.'
- start with an alphanumeric character
- end with an alphanumeric character
-->
<h3 id="dns-subdomain-names">DNS 子域名 </h3>
<p>很多资源类型需要可以用作 DNS 子域名的名称。
DNS 子域名的定义可参见 <a href="https://tools.ietf.org/html/rfc1123">RFC 1123</a>。
这一要求意味着名称必须满足如下规则：</p>
<ul>
<li>不能超过253个字符</li>
<li>只能包含小写字母、数字，以及'-' 和 '.'</li>
<li>须以字母数字开头</li>
<li>须以字母数字结尾</li>
</ul>
<!--
### DNS Label Names

Some resource types require their names to follow the DNS
label standard as defined in [RFC 1123](https://tools.ietf.org/html/rfc1123).
This means the name must:

- contain at most 63 characters
- contain only lowercase alphanumeric characters or '-'
- start with an alphanumeric character
- end with an alphanumeric character
-->
<h3 id="dns-label-names">RFC 1123 标签名   </h3>
<p>某些资源类型需要其名称遵循 <a href="https://tools.ietf.org/html/rfc1123">RFC 1123</a>
所定义的 DNS 标签标准。也就是命名必须满足如下规则：</p>
<ul>
<li>最多 63 个字符</li>
<li>只能包含小写字母、数字，以及 '-'</li>
<li>须以字母数字开头</li>
<li>须以字母数字结尾</li>
</ul>
<!--
### RFC 1035 Label Names

Some resource types require their names to follow the DNS
label standard as defined in [RFC 1035](https://tools.ietf.org/html/rfc1035).
This means the name must:

- contain at most 63 characters
- contain only lowercase alphanumeric characters or '-'
- start with an alphabetic character
- end with an alphanumeric character
-->
<h3 id="rfc-1035-label-names">RFC 1035 标签名  </h3>
<p>某些资源类型需要其名称遵循 <a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a>
所定义的 DNS 标签标准。也就是命名必须满足如下规则：</p>
<ul>
<li>最多 63 个字符</li>
<li>只能包含小写字母、数字，以及 '-'</li>
<li>须以字母开头</li>
<li>须以字母数字结尾</li>
</ul>
<!--
### Path Segment Names

Some resource types require their names to be able to be safely encoded as a
path segment. In other words, the name may not be "." or ".." and the name may
not contain "/" or "%".
-->
<h3 id="path-segment-names">路径分段名称   </h3>
<p>某些资源类型要求名称能被安全地用作路径中的片段。
换句话说，其名称不能是 <code>.</code>、<code>..</code>，也不可以包含 <code>/</code> 或 <code>%</code> 这些字符。</p>
<!--
Here’s an example manifest for a Pod named `nginx-demo`.
-->
<p>下面是一个名为<code>nginx-demo</code>的 Pod 的配置清单：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-demo<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.14.2<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></code></pre></div><!--
Some resource types have additional restrictions on their names.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 某些资源类型可能具有额外的命名约束。
</div>
<h2 id="uids">UIDs</h2>
<!--
---
title: UID
id: uid
date: 2018-04-12
full_link: /docs/concepts/overview/working-with-objects/names
short_description: >
  A Kubernetes systems-generated string to uniquely identify objects.

aka: 
tags:
- fundamental
---
-->
<!--
 A Kubernetes systems-generated string to uniquely identify objects.
-->
<p>Kubernetes 系统生成的字符串，唯一标识对象。</p>
<!--
Every object created over the whole lifetime of a Kubernetes cluster has a distinct UID. It is intended to distinguish between historical occurrences of similar entities.
-->
<p>在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 uid，它旨在区分类似实体的历史事件。</p>
<!--
Kubernetes UIDs are universally unique identifiers (also known as UUIDs).
UUIDs are standardized as ISO/IEC 9834-8 and as ITU-T X.667.
-->
<p>Kubernetes UIDs 是全局唯一标识符（也叫 UUIDs）。
UUIDs 是标准化的，见 ISO/IEC 9834-8 和 ITU-T X.667.</p>
<h2 id="what-s-next">What's next</h2>
<!--
* Read about [labels](/docs/concepts/overview/working-with-objects/labels/) in Kubernetes.
* See the [Identifiers and Names in Kubernetes](https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md) design document.
-->
<ul>
<li>进一步了解 Kubernetes <a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签</a></li>
<li>参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md">Kubernetes 标识符和名称</a>的设计文档</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1127165f472b7181b9c1d5a0b187d620">4 - 名字空间</h1>
    
	<!--
reviewers:
- derekwaynecarr
- mikedanese
- thockin
title: Namespaces
content_type: concept
weight: 30
-->
<!-- overview -->
<!--
In Kubernetes, _namespaces_ provides a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects _(e.g. Deployments, Services, etc)_ and not for cluster-wide objects _(e.g. StorageClass, Nodes, PersistentVolumes, etc)_.
-->
<p>在 Kubernetes 中，“名字空间（Namespace）”提供一种机制，将同一集群中的资源划分为相互隔离的组。
同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求。
名字空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等，
这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。</p>
<!-- body -->
<!--
## When to Use Multiple Namespaces
-->
<h2 id="何时使用多个名字空间">何时使用多个名字空间</h2>
<!--
Namespaces are intended for use in environments with many users spread across multiple
teams, or projects.  For clusters with a few to tens of users, you should not
need to create or think about namespaces at all.  Start using namespaces when you
need the features they provide.
-->
<p>名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。当需要名称空间提供的功能时，请开始使用它们。</p>
<!--
Namespaces provide a scope for names.  Names of resources need to be unique within a namespace,
but not across namespaces. Namespaces can not be nested inside one another and each Kubernetes
resource can only be in one namespace.
-->
<p>名字空间为名称提供了一个范围。资源的名称需要在名字空间内是唯一的，但不能跨名字空间。
名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。</p>
<!--
Namespaces are a way to divide cluster resources between multiple users (via [resource quota](/docs/concepts/policy/resource-quotas/)).
-->
<p>名字空间是在多个用户之间划分集群资源的一种方法（通过<a href="/zh/docs/concepts/policy/resource-quotas/">资源配额</a>）。</p>
<!--
It is not necessary to use multiple namespaces to separate slightly different
resources, such as different versions of the same software: use
<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='labels'>labels</a> to distinguish
resources within the same namespace.
-->
<p>不必使用多个名字空间来分隔仅仅轻微不同的资源，例如同一软件的不同版本：
应该使用<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>
来区分同一名字空间中的不同资源。</p>
<!--
## Working with Namespaces

Creation and deletion of namespaces are described in the [Admin Guide documentation
for namespaces](/docs/tasks/administer-cluster/namespaces/).
-->
<h2 id="使用名字空间">使用名字空间</h2>
<p>名字空间的创建和删除在<a href="/zh/docs/tasks/administer-cluster/namespaces/">名字空间的管理指南文档</a>描述。</p>
<!--
Avoid creating namespaces with the prefix `kube-`, since it is reserved for Kubernetes system namespaces.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 避免使用前缀 <code>kube-</code> 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。
</div>
<!--
### Viewing namespaces

You can list the current namespaces in a cluster using:
-->
<h3 id="查看名字空间">查看名字空间</h3>
<p>你可以使用以下命令列出集群中现存的名字空间：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get namespace
</code></pre></div><pre><code>NAME          STATUS    AGE
default       Active    1d
kube-node-lease   Active   1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><!--
Kubernetes starts with four initial namespaces:

   * `default` The default namespace for objects with no other namespace
   * `kube-system` The namespace for objects created by the Kubernetes system
   * `kube-public` This namespace is created automatically and is readable by all users (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement.
   * `kube-node-lease` This namespace holds [Lease](/docs/reference/kubernetes-api/cluster-resources/lease-v1/)
      objects associated with each node. Node leases allow the kubelet to send
      [heartbeats](/docs/concepts/architecture/nodes/#heartbeats) so that the control plane
      can detect node failure.
-->
<p>Kubernetes 会创建四个初始名字空间：</p>
<ul>
<li><code>default</code> 没有指明使用其它名字空间的对象所使用的默认名字空间</li>
<li><code>kube-system</code> Kubernetes 系统创建对象所使用的名字空间</li>
<li><code>kube-public</code> 这个名字空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。
这个名字空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。
这个名字空间的公共方面只是一种约定，而不是要求。</li>
<li><code>kube-node-lease</code> 此名字空间用于与各个节点相关的
<a href="/docs/reference/kubernetes-api/cluster-resources/lease-v1/">租约（Lease）</a>对象。
节点租期允许 kubelet 发送<a href="/zh/docs/concepts/architecture/nodes/#heartbeats">心跳</a>，由此控制面能够检测到节点故障。</li>
</ul>
<!--
### Setting the namespace for a request

To set the namespace for a current request, use the `-namespace` flag.

For example:
-->
<h3 id="为请求设置名字空间">为请求设置名字空间</h3>
<p>要为当前请求设置名字空间，请使用 <code>--namespace</code> 参数。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run nginx --image<span style="color:#666">=</span>nginx --namespace<span style="color:#666">=</span>&lt;名字空间名称&gt;
kubectl get pods --namespace<span style="color:#666">=</span>&lt;名字空间名称&gt;
</code></pre></div><!--
### Setting the namespace preference

You can permanently save the namespace for all subsequent kubectl commands in that
context.
-->
<h3 id="设置名字空间偏好">设置名字空间偏好</h3>
<p>你可以永久保存名字空间，以用于对应上下文中所有后续 kubectl 命令。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config set-context --current --namespace<span style="color:#666">=</span>&lt;名字空间名称&gt;
<span style="color:#080;font-style:italic"># 验证之</span>
kubectl config view | grep namespace:
</code></pre></div><!--
## Namespaces and DNS

When you create a [Service](/docs/user-guide/services), it creates a corresponding [DNS entry](/docs/concepts/services-networking/dns-pod-service/).
-->
<h2 id="名字空间和-dns">名字空间和 DNS</h2>
<p>当你创建一个<a href="/zh/docs/concepts/services-networking/service/">服务</a> 时，
Kubernetes 会创建一个相应的 <a href="/zh/docs/concepts/services-networking/dns-pod-service/">DNS 条目</a>。</p>
<!--
This entry is of the form `<service-name>.<namespace-name>.svc.cluster.local`, which means
that if a container only uses `<service-name>`, it will resolve to the service which
is local to a namespace.  This is useful for using the same configuration across
multiple namespaces such as Development, Staging and Production.  If you want to reach
across namespaces, you need to use the fully qualified domain name (FQDN).
-->
<p>该条目的形式是 <code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code>，这意味着如果容器只使用
<code>&lt;服务名称&gt;</code>，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、分级和生产）
使用相同的配置非常有用。如果你希望跨名字空间访问，则需要使用完全限定域名（FQDN）。</p>
<!--
As a result, all namespace names must be valid
[RFC 1123 DNS labels](/docs/concepts/overview/working-with-objects/names/#dns-label-names).
-->
<p>因此，所有的名字空间名称都必须是合法的
<a href="/zh/docs/concepts/overview/working-with-objects/names/#dns-label-names">RFC 1123 DNS 标签</a>。</p>
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <!--
By creating namespaces with the same name as [public top-level
domains](https://data.iana.org/TLD/tlds-alpha-by-domain.txt), Services in these
namespaces can have short DNS names that overlap with public DNS records.
Workloads from any namespace performing a DNS lookup without a [trailing dot](https://datatracker.ietf.org/doc/html/rfc1034#page-8) will
be redirected to those services, taking precedence over public DNS.
-->
<p>通过创建与<a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt">公共顶级域名</a>
同名的名字空间，这些名字空间中的服务可以拥有与公共 DNS 记录重叠的、较短的 DNS 名称。
所有名字空间中的负载在执行 DNS 查找时，如果查找的名称没有
<a href="https://datatracker.ietf.org/doc/html/rfc1034#page-8">尾部句点</a>，
就会被重定向到这些服务上，因此呈现出比公共 DNS 更高的优先序。</p>
<!--
To mitigate this, limit privileges for creating namespaces to trusted users. If
required, you could additionally configure third-party security controls, such
as [admission
webhooks](/docs/reference/access-authn-authz/extensible-admission-controllers/),
to block creating any namespace with the name of [public
TLDs](https://data.iana.org/TLD/tlds-alpha-by-domain.txt).
-->
<p>为了缓解这类问题，需要将创建名字空间的权限授予可信的用户。
如果需要，你可以额外部署第三方的安全控制机制，例如以
<a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">准入 Webhook</a>
的形式，阻止用户创建与公共 <a href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt">TLD</a>
同名的名字空间。</p>

</div>


<!--
## Not All Objects are in a Namespace
-->
<h2 id="并非所有对象都在名字空间中">并非所有对象都在名字空间中</h2>
<!--
Most Kubernetes resources (e.g. pods, services, replication controllers, and others) are
in some namespaces.  However namespace resources are not themselves in a namespace.
And low-level resources, such as [nodes](/docs/concepts/architecture/nodes/) and
persistentVolumes, are not in any namespace.
-->
<p>大多数 kubernetes 资源（例如 Pod、Service、副本控制器等）都位于某些名字空间中。
但是名字空间资源本身并不在名字空间中。而且底层资源，例如
<a href="/zh/docs/concepts/architecture/nodes/">节点</a> 和持久化卷不属于任何名字空间。</p>
<!--
To see which Kubernetes resources are and aren't in a namespace:
-->
<p>查看哪些 Kubernetes 资源在名字空间中，哪些不在名字空间中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 位于名字空间中的资源</span>
kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">true</span>

<span style="color:#080;font-style:italic"># 不在名字空间中的资源</span>
kubectl api-resources --namespaced<span style="color:#666">=</span><span style="color:#a2f">false</span>
</code></pre></div><!--
## Automatic labelling
-->
<h2 id="automatic-labelling">自动打标签  </h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code>
</div>


<!--
The Kubernetes control plane sets an immutable <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label'>label</a>
`kubernetes.io/metadata.name` on all namespaces, provided that the `NamespaceDefaultLabelName`
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/) is enabled.
The value of the label is the namespace name.
-->
<p>Kubernetes 控制面会为所有名字空间设置一个不可变更的
<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>
<code>kubernetes.io/metadata.name</code>，只要 <code>NamespaceDefaultLabelName</code> 这一
<a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>
被启用。标签的值是名字空间的名称。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* Learn more about [creating a new namespace](/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace).
* Learn more about [deleting a namespace](/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace).
-->
<ul>
<li>进一步了解<a href="/zh/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace">建立新的名字空间</a>。</li>
<li>进一步了解<a href="/zh/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace">删除名字空间</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f1dec4557fb8ffbac9f11390aaaf9fa4">5 - 标签和选择算符</h1>
    
	<!--
reviewers:
- mikedanese
title: Labels and Selectors
content_type: concept
weight: 40
-->
<!-- overview -->
<!--
_Labels_ are key/value pairs that are attached to objects, such as pods.
Labels are intended to be used to specify identifying attributes of objects that are meaningful and relevant to users, but do not directly imply semantics to the core system.
Labels can be used to organize and to select subsets of objects.
Labels can be attached to objects at creation time and subsequently added and modified at any time.
Each object can have a set of key/value labels defined.  Each Key must be unique for a given object.
-->
<p><em>标签（Labels）</em> 是附加到 Kubernetes 对象（比如 Pods）上的键值对。
标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。
标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。
每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#b44">&#34;metadata&#34;</span><span style="">:</span> {
  <span style="color:#008000;font-weight:bold">&#34;labels&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;key1&#34;</span> : <span style="color:#b44">&#34;value1&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;key2&#34;</span> : <span style="color:#b44">&#34;value2&#34;</span>
  }
}
</code></pre></div><!--
Labels allow for efficient queries and watches and are ideal for use in UIs
and CLIs. Non-identifying information should be recorded using
[annotations](/docs/concepts/overview/working-with-objects/annotations/).
-->
<p>标签能够支持高效的查询和监听操作，对于用户界面和命令行是很理想的。
应使用<a href="/zh/docs/concepts/overview/working-with-objects/annotations/">注解</a> 记录非识别信息。</p>
<!-- body -->
<!--
## Motivation

Labels enable users to map their own organizational structures onto system objects in a loosely coupled fashion, without requiring clients to store these mappings.
-->
<h2 id="动机">动机</h2>
<p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<!--
Service deployments and batch processing pipelines are often multi-dimensional entities (e.g., multiple partitions or deployments, multiple release tracks, multiple tiers, multiple micro-services per tier). Management often requires cross-cutting operations, which breaks encapsulation of strictly hierarchical representations, especially rigid hierarchies determined by the infrastructure rather than by users.

Example labels:
-->
<p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。
管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p>
<p>示例标签：</p>
<ul>
<li><code>&quot;release&quot; : &quot;stable&quot;</code>, <code>&quot;release&quot; : &quot;canary&quot;</code></li>
<li><code>&quot;environment&quot; : &quot;dev&quot;</code>, <code>&quot;environment&quot; : &quot;qa&quot;</code>, <code>&quot;environment&quot; : &quot;production&quot;</code></li>
<li><code>&quot;tier&quot; : &quot;frontend&quot;</code>, <code>&quot;tier&quot; : &quot;backend&quot;</code>, <code>&quot;tier&quot; : &quot;cache&quot;</code></li>
<li><code>&quot;partition&quot; : &quot;customerA&quot;</code>, <code>&quot;partition&quot; : &quot;customerB&quot;</code></li>
<li><code>&quot;track&quot; : &quot;daily&quot;</code>, <code>&quot;track&quot; : &quot;weekly&quot;</code></li>
</ul>
<!--
These are examples of [commonly used labels](/docs/concepts/overview/working-with-objects/common-labels/); you are free to develop your own conventions. Keep in mind that label Key must be unique for a given object.
-->
<p>有一些<a href="/zh/docs/concepts/overview/working-with-objects/common-labels/">常用标签</a>的例子; 你可以任意制定自己的约定。
请记住，标签的 Key 对于给定对象必须是唯一的。</p>
<!--
## Syntax and character set

_Labels_ are key/value pairs. Valid label keys have two segments: an optional prefix and name, separated by a slash (`/`).  The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.  The prefix is optional.  If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (`.`), not longer than 253 characters in total, followed by a slash (`/`).

If the prefix is omitted, the label Key is presumed to be private to the user. Automated system components (e.g. `kube-scheduler`, `kube-controller-manager`, `kube-apiserver`, `kubectl`, or other third-party automation) which add labels to end-user objects must specify a prefix.

The `kubernetes.io/` and `k8s.io/` prefixes are [reserved](/docs/reference/labels-annotations-taints/) for Kubernetes core components.
-->
<h2 id="语法和字符集">语法和字符集</h2>
<p><em>标签</em> 是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（<code>/</code>）分隔。
名称段是必需的，必须小于等于 63 个字符，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，
带有破折号（<code>-</code>），下划线（<code>_</code>），点（ <code>.</code>）和之间的字母数字。
前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（<code>.</code>）分隔的一系列 DNS 标签，总共不超过 253 个字符，
后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定标签键对用户是私有的。
向最终用户对象添加标签的自动系统组件（例如 <code>kube-scheduler</code>、<code>kube-controller-manager</code>、
<code>kube-apiserver</code>、<code>kubectl</code> 或其他第三方自动化工具）必须指定前缀。</p>
<p><code>kubernetes.io/</code> 和 <code>k8s.io/</code> 前缀是为 Kubernetes 核心组件<a href="/zh/docs/reference/labels-annotations-taints/">保留的</a>。</p>
<!--
Valid label value:

* must be 63 characters or less (can be empty),
* unless empty, must begin and end with an alphanumeric character (`[a-z0-9A-Z]`),
* could contain dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
-->
<p>有效标签值：</p>
<ul>
<li>必须为 63 个字符或更少（可以为空）</li>
<li>除非标签值为空，必须以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾</li>
<li>包含破折号（<code>-</code>）、下划线（<code>_</code>）、点（<code>.</code>）和字母或数字。</li>
</ul>
<!--
## Label selectors

Unlike [names and UIDs](/docs/user-guide/identifiers), labels do not provide uniqueness. In general, we expect many objects to carry the same label(s).
-->
<h2 id="label-selectors">标签选择算符  </h2>
<p>与<a href="/zh/docs/concepts/overview/working-with-objects/names/">名称和 UID</a> 不同，
标签不支持唯一性。通常，我们希望许多对象携带相同的标签。</p>
<!--
Via a _label selector_, the client/user can identify a set of objects. The label selector is the core grouping primitive in Kubernetes.
-->
<p>通过 <em>标签选择算符</em>，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。</p>
<!--
The API currently supports two types of selectors: _equality-based_ and _set-based_.
A label selector can be made of multiple _requirements_ which are comma-separated. In the case of multiple requirements, all must be satisfied so the comma separator acts as a logical _AND_ (`&&`) operator.
-->
<p>API 目前支持两种类型的选择算符：<em>基于等值的</em> 和 <em>基于集合的</em>。
标签选择算符可以由逗号分隔的多个 <em>需求</em> 组成。
在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑 <em>与</em>（<code>&amp;&amp;</code>）运算符。</p>
<!--
The semantics of empty or non-specified selectors are dependent on the context,
and API types that use selectors should document the validity and meaning of
them.
-->
<p>空标签选择算符或者未指定的选择算符的语义取决于上下文，
支持使用选择算符的 API 类别应该将算符的合法性和含义用文档记录下来。</p>
<!--
For some API types, such as ReplicaSets, the label selectors of two instances must not overlap within a namespace, or the controller can see that as conflicting instructions and fail to determine how many replicas should be present.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 对于某些 API 类别（例如 ReplicaSet）而言，两个实例的标签选择算符不得在命名空间内重叠，
否则它们的控制器将互相冲突，无法确定应该存在的副本个数。
</div>
<!--
For both equality-based and set-based conditions there is no logical _OR_ (`||`) operator. Ensure your filter statements are structured accordingly.
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> 对于基于等值的和基于集合的条件而言，不存在逻辑或（<code>||</code>）操作符。
你要确保你的过滤语句按合适的方式组织。
</div>

<!--
### _Equality-based_ requirement

_Equality-_ or _inequality-based_ requirements allow filtering by label keys and values. Matching objects must satisfy all of the specified label constraints, though they may have additional labels as well.
Three kinds of operators are admitted `=`,`==`,`!=`. The first two represent _equality_ (and are simply synonyms), while the latter represents _inequality_. For example:
-->
<h3 id="基于等值的-需求"><em>基于等值的</em> 需求</h3>
<p><em>基于等值</em> 或 <em>基于不等值</em> 的需求允许按标签键和值进行过滤。
匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其他标签。
可接受的运算符有<code>=</code>、<code>==</code> 和 <code>!=</code> 三种。
前两个表示 <em>相等</em>（并且只是同义词），而后者表示 <em>不相等</em>。例如：</p>
<pre><code>environment = production
tier != frontend
</code></pre><!--
The former selects all resources with key equal to `environment` and value equal to `production`.
The latter selects all resources with key equal to `tier` and value distinct from `frontend`, and all resources with no labels with the `tier` key.
One could filter for resources in `production` excluding `frontend` using the comma operator: `environment=production,tier!=frontend`
-->
<p>前者选择所有资源，其键名等于 <code>environment</code>，值等于 <code>production</code>。
后者选择所有资源，其键名等于 <code>tier</code>，值不同于 <code>frontend</code>，所有资源都没有带有 <code>tier</code> 键的标签。
可以使用逗号运算符来过滤 <code>production</code> 环境中的非 <code>frontend</code> 层资源：<code>environment=production,tier!=frontend</code>。</p>
<!--
One usage scenario for equality-based label requirement is for Pods to specify
node selection criteria. For example, the sample Pod below selects nodes with
the label "`accelerator=nvidia-tesla-p100`".
-->
<p>基于等值的标签要求的一种使用场景是 Pod 要指定节点选择标准。
例如，下面的示例 Pod 选择带有标签 &quot;<code>accelerator=nvidia-tesla-p100</code>&quot;。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cuda-test<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>cuda-test<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">resources</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">limits</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">nvidia.com/gpu</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">nodeSelector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">accelerator</span>:<span style="color:#bbb"> </span>nvidia-tesla-p100<span style="color:#bbb">
</span></code></pre></div><!--
### _Set-based_ requirement

_Set-based_ label requirements allow filtering keys according to a set of values. Three kinds of operators are supported: `in`,`notin` and `exists` (only the key identifier). For example:
-->
<h3 id="基于集合-的需求"><em>基于集合</em> 的需求</h3>
<p><em>基于集合</em> 的标签需求允许你通过一组值来过滤键。
支持三种操作符：<code>in</code>、<code>notin</code> 和 <code>exists</code> (只可以用在键标识符上)。例如：</p>
<pre><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><!--
* The first example selects all resources with key equal to `environment` and value equal to `production` or `qa`.
* The second example selects all resources with key equal to `tier` and values other than `frontend` and `backend`, and all resources with no labels with the `tier` key.
* The third example selects all resources including a label with key `partition`; no values are checked.
* The fourth example selects all resources without a label with key `partition`; no values are checked.

Similarly the comma separator acts as an _AND_ operator. So filtering resources with a `partition` key (no matter the value) and with `environment` different than  `qa` can be achieved using `partition,environment notin (qa)`.
-->
<ul>
<li>第一个示例选择了所有键等于 <code>environment</code> 并且值等于 <code>production</code> 或者 <code>qa</code> 的资源。</li>
<li>第二个示例选择了所有键等于 <code>tier</code> 并且值不等于 <code>frontend</code> 或者 <code>backend</code> 的资源，以及所有没有 <code>tier</code> 键标签的资源。</li>
<li>第三个示例选择了所有包含了有 <code>partition</code> 标签的资源；没有校验它的值。</li>
<li>第四个示例选择了所有没有 <code>partition</code> 标签的资源；没有校验它的值。</li>
</ul>
<p>类似地，逗号分隔符充当 <em>与</em> 运算符。因此，使用 <code>partition</code> 键（无论为何值）和
<code>environment</code> 不同于 <code>qa</code> 来过滤资源可以使用 <code>partition, environment notin（qa)</code> 来实现。</p>
<!--
The _set-based_ label selector is a general form of equality since `environment=production` is equivalent to `environment in (production)`; similarly for `!=` and `notin`.
-->
<p><em>基于集合</em> 的标签选择算符是相等标签选择算符的一般形式，因为 <code>environment=production</code>
等同于 <code>environment in（production）</code>；<code>!=</code> 和 <code>notin</code> 也是类似的。</p>
<!--
_Set-based_ requirements can be mixed with _equality-based_ requirements. For example: `partition in (customerA, customerB),environment!=qa`.
-->
<p><em>基于集合</em> 的要求可以与基于 <em>相等</em> 的要求混合使用。例如：<code>partition in (customerA, customerB),environment!=qa</code>。</p>
<h2 id="api">API</h2>
<!--
### LIST and WATCH filtering

LIST and WATCH operations may specify label selectors to filter the sets of objects returned using a query parameter. Both requirements are permitted (presented here as they would appear in a URL query string):
-->
<h3 id="list-和-watch-过滤">LIST 和 WATCH 过滤</h3>
<p>LIST 和 WATCH 操作可以使用查询参数指定标签选择算符过滤一组对象。
两种需求都是允许的。（这里显示的是它们出现在 URL 查询字符串中）</p>
<!--
* _equality-based_ requirements: `?labelSelector=environment%3Dproduction,tier%3Dfrontend`
* _set-based_ requirements: `?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29`
-->
<ul>
<li><em>基于等值</em> 的需求: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li><em>基于集合</em> 的需求: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
<!--
Both label selector styles can be used to list or watch resources via a REST client. For example, targeting `apiserver` with `kubectl` and using _equality-based_ one may write:
-->
<p>两种标签选择算符都可以通过 REST 客户端用于 list 或者 watch 资源。
例如，使用 <code>kubectl</code> 定位 <code>apiserver</code>，可以使用 <em>基于等值</em> 的标签选择算符可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">environment</span><span style="color:#666">=</span>production,tier<span style="color:#666">=</span>frontend
</code></pre></div><!-- or using _set-based_ requirements: -->
<p>或者使用 <em>基于集合的</em> 需求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b44">&#39;environment in (production),tier in (frontend)&#39;</span>
</code></pre></div><!--
As already mentioned _set-based_ requirements are more expressive.  For instance, they can implement the _OR_ operator on values:
-->
<p>正如刚才提到的，<em>基于集合</em> 的需求更具有表达力。例如，它们可以实现值的 <em>或</em> 操作：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b44">&#39;environment in (production, qa)&#39;</span>
</code></pre></div><!-- or restricting negative matching via _exists_ operator: -->
<p>或者通过 <em>exists</em> 运算符限制不匹配：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b44">&#39;environment,environment notin (frontend)&#39;</span>
</code></pre></div><!--
### Set references in API objects

Some Kubernetes objects, such as [`services`](/docs/concepts/services-networking/service/)
and [`replicationcontrollers`](/docs/concepts/workloads/controllers/replicationcontroller/),
also use label selectors to specify sets of other resources, such as
[pods](/docs/concepts/workloads/pods/).
-->
<h3 id="在-api-对象中设置引用">在 API 对象中设置引用</h3>
<p>一些 Kubernetes 对象，例如 <a href="/zh/docs/concepts/services-networking/service/"><code>services</code></a>
和 <a href="/zh/docs/concepts/workloads/controllers/replicationcontroller/"><code>replicationcontrollers</code></a> ，
也使用了标签选择算符去指定了其他资源的集合，例如
<a href="/zh/docs/concepts/workloads/pods/">pods</a>。</p>
<!--
#### Service and ReplicationController

The set of pods that a `service` targets is defined with a label selector. Similarly, the population of pods that a `replicationcontroller` should manage is also defined with a label selector.

Labels selectors for both objects are defined in `json` or `yaml` files using maps, and only _equality-based_ requirement selectors are supported:
-->
<h4 id="service-和-replicationcontroller">Service 和 ReplicationController</h4>
<p>一个 <code>Service</code> 指向的一组 Pods 是由标签选择算符定义的。同样，一个 <code>ReplicationController</code>
应该管理的 pods 的数量也是由标签选择算符定义的。</p>
<p>两个对象的标签选择算符都是在 <code>json</code> 或者 <code>yaml</code> 文件中使用映射定义的，并且只支持
<em>基于等值</em> 需求的选择算符：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#b44">&#34;selector&#34;</span><span style="">:</span> {
    <span style="color:#008000;font-weight:bold">&#34;component&#34;</span> : <span style="color:#b44">&#34;redis&#34;</span>,
}
</code></pre></div><!-- or -->
<p>或者</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span></code></pre></div><!---
this selector (respectively in `json` or `yaml` format) is equivalent to `component=redis` or `component in (redis)`.
-->
<p>这个选择算符(分别在 <code>json</code> 或者 <code>yaml</code> 格式中) 等价于 <code>component=redis</code> 或 <code>component in (redis)</code> 。</p>
<!--
#### Resources that support set-based requirements

Newer resources, such as [`Job`](/docs/concepts/jobs/run-to-completion-finite-workloads/), [`Deployment`](/docs/concepts/workloads/controllers/deployment/), [`Replica Set`](/docs/concepts/workloads/controllers/replicaset/), and [`Daemon Set`](/docs/concepts/workloads/controllers/daemonset/), support _set-based_ requirements as well.
-->
<h4 id="支持基于集合需求的资源">支持基于集合需求的资源</h4>
<p>比较新的资源，例如 <a href="/zh/docs/concepts/workloads/controllers/job/"><code>Job</code></a>、
<a href="/zh/docs/concepts/workloads/controllers/deployment/"><code>Deployment</code></a>、
<a href="/zh/docs/concepts/workloads/controllers/replicaset/"><code>Replica Set</code></a> 和
<a href="/zh/docs/concepts/workloads/controllers/daemonset/"><code>DaemonSet</code></a> ，
也支持 <em>基于集合的</em> 需求。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">component</span>:<span style="color:#bbb"> </span>redis<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">matchExpressions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- {<span style="color:#008000;font-weight:bold">key: tier, operator: In, values</span>:<span style="color:#bbb"> </span>[cache]}<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- {<span style="color:#008000;font-weight:bold">key: environment, operator: NotIn, values</span>:<span style="color:#bbb"> </span>[dev]}<span style="color:#bbb">
</span></code></pre></div><!--
`matchLabels` is a map of `{key,value}` pairs. A single `{key,value}` in the `matchLabels` map is equivalent to an element of `matchExpressions`, whose `key` field is "key", the `operator` is "In", and the `values` array contains only "value". `matchExpressions` is a list of pod selector requirements. Valid operators include In, NotIn, Exists, and DoesNotExist. The values set must be non-empty in the case of In and NotIn. All of the requirements, from both `matchLabels` and `matchExpressions` are ANDed together - they must all be satisfied in order to match.
-->
<p><code>matchLabels</code> 是由 <code>{key,value}</code> 对组成的映射。
<code>matchLabels</code> 映射中的单个 <code>{key,value }</code> 等同于 <code>matchExpressions</code> 的元素，
其 <code>key</code> 字段为 &quot;key&quot;，<code>operator</code> 为 &quot;In&quot;，而 <code>values</code> 数组仅包含 &quot;value&quot;。
<code>matchExpressions</code> 是 Pod 选择算符需求的列表。
有效的运算符包括 <code>In</code>、<code>NotIn</code>、<code>Exists</code> 和 <code>DoesNotExist</code>。
在 <code>In</code> 和 <code>NotIn</code> 的情况下，设置的值必须是非空的。
来自 <code>matchLabels</code> 和 <code>matchExpressions</code> 的所有要求都按逻辑与的关系组合到一起
-- 它们必须都满足才能匹配。</p>
<!--
#### Selecting sets of nodes

One use case for selecting over labels is to constrain the set of nodes onto which a pod can schedule.
See the documentation on [node selection](/docs/concepts/configuration/assign-pod-node/) for more information.
-->
<h4 id="选择节点集">选择节点集</h4>
<p>通过标签进行选择的一个用例是确定节点集，方便 Pod 调度。
有关更多信息，请参阅<a href="/zh/docs/concepts/scheduling-eviction/assign-pod-node/">选择节点</a>文档。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-93cd7a1d4e1623e2bf01afc49a5af69c">6 - 注解</h1>
    
	<!--
title: Annotations
content_type: concept
weight: 50
-->
<!-- overview -->
<!--
You can use Kubernetes annotations to attach arbitrary non-identifying metadata
to objects. Clients such as tools and libraries can retrieve this metadata.
-->
<p>你可以使用 Kubernetes 注解为对象附加任意的非标识的元数据。客户端程序（例如工具和库）能够获取这些元数据信息。</p>
<!-- body -->
<!--
## Attaching metadata to objects

You can use either labels or annotations to attach metadata to Kubernetes
objects. Labels can be used to select objects and to find
collections of objects that satisfy certain conditions. In contrast, annotations
are not used to identify and select objects. The metadata
in an annotation can be small or large, structured or unstructured, and can
include characters not permitted by labels.

Annotations, like labels, are key/value maps:
-->
<h2 id="为对象附加元数据">为对象附加元数据</h2>
<p>你可以使用标签或注解将元数据附加到 Kubernetes 对象。
标签可以用来选择对象和查找满足某些条件的对象集合。 相反，注解不用于标识和选择对象。
注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。</p>
<p>注解和标签一样，是键/值对:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#b44">&#34;metadata&#34;</span><span style="">:</span> {
  <span style="color:#008000;font-weight:bold">&#34;annotations&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;key1&#34;</span> : <span style="color:#b44">&#34;value1&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;key2&#34;</span> : <span style="color:#b44">&#34;value2&#34;</span>
  }
}
</code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The keys and the values in the map must be strings. In other words, you cannot use
numeric, boolean, list or other types for either the keys or the values.
-->
<p>Map 中的键和值必须是字符串。
换句话说，你不能使用数字、布尔值、列表或其他类型的键或值。
</div>
<!--
Here are some examples of information that could be recorded in annotations:
-->
<p>以下是一些例子，用来说明哪些信息可以使用注解来记录:</p>
<!--
* Fields managed by a declarative configuration layer. Attaching these fields
  as annotations distinguishes them from default values set by clients or
  servers, and from auto-generated fields and fields set by
  auto-sizing or auto-scaling systems.

* Build, release, or image information like timestamps, release IDs, git branch,
  PR numbers, image hashes, and registry address.

* Pointers to logging, monitoring, analytics, or audit repositories.
-->
<ul>
<li>由声明性配置所管理的字段。
将这些字段附加为注解，能够将它们与客户端或服务端设置的默认值、
自动生成的字段以及通过自动调整大小或自动伸缩系统设置的字段区分开来。</li>
<li>构建、发布或镜像信息（如时间戳、发布 ID、Git 分支、PR 数量、镜像哈希、仓库地址）。</li>
<li>指向日志记录、监控、分析或审计仓库的指针。</li>
</ul>
<!--
* Client library or tool information that can be used for debugging purposes:
  for example, name, version, and build information.

* User or tool/system provenance information, such as URLs of related objects
  from other ecosystem components.

* Lightweight rollout tool metadata: for example, config or checkpoints.

* Phone or pager numbers of persons responsible, or directory entries that
  specify where that information can be found, such as a team web site.

* Directives from the end-user to the implementations to modify behavior or
  engage non-standard features.
-->
<ul>
<li>
<p>可用于调试目的的客户端库或工具信息：例如，名称、版本和构建信息。</p>
</li>
<li>
<p>用户或者工具/系统的来源信息，例如来自其他生态系统组件的相关对象的 URL。</p>
</li>
<li>
<p>轻量级上线工具的元数据信息：例如，配置或检查点。</p>
</li>
<li>
<p>负责人员的电话或呼机号码，或指定在何处可以找到该信息的目录条目，如团队网站。</p>
</li>
<li>
<p>从用户到最终运行的指令，以修改行为或使用非标准功能。</p>
</li>
</ul>
<!--
Instead of using annotations, you could store this type of information in an
external database or directory, but that would make it much harder to produce
shared client libraries and tools for deployment, management, introspection,
and the like.
-->
<p>你可以将这类信息存储在外部数据库或目录中而不使用注解，
但这样做就使得开发人员很难生成用于部署、管理、自检的客户端共享库和工具。</p>
<!--
## Syntax and character set

_Annotations_ are key/value pairs. Valid annotation keys have two segments: an optional prefix and name, separated by a slash (`/`). The name segment is required and must be 63 characters or less, beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (`.`), not longer than 253 characters in total, followed by a slash (`/`).

If the prefix is omitted, the annotation Key is presumed to be private to the user. Automated system components (e.g. `kube-scheduler`, `kube-controller-manager`, `kube-apiserver`, `kubectl`, or other third-party automation) which add annotations to end-user objects must specify a prefix.
-->
<h2 id="语法和字符集">语法和字符集</h2>
<p><em>注解（Annotations）</em> 存储的形式是键/值对。有效的注解键分为两部分：
可选的前缀和名称，以斜杠（<code>/</code>）分隔。
名称段是必需项，并且必须在63个字符以内，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾，
并允许使用破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和字母数字。
前缀是可选的。如果指定，则前缀必须是DNS子域：一系列由点（<code>.</code>）分隔的DNS标签，
总计不超过253个字符，后跟斜杠（<code>/</code>）。
如果省略前缀，则假定注解键对用户是私有的。 由系统组件添加的注解
（例如，<code>kube-scheduler</code>，<code>kube-controller-manager</code>，<code>kube-apiserver</code>，<code>kubectl</code>
或其他第三方组件），必须为终端用户添加注解前缀。</p>
<!--
The `kubernetes.io/` and `k8s.io/` prefixes are reserved for Kubernetes core components.

For example, here's the configuration file for a Pod that has the annotation `imageregistry: https://hub.docker.com/` :
-->
<p><code>kubernetes.io/</code> 和 <code>k8s.io/</code> 前缀是为Kubernetes核心组件保留的。</p>
<p>例如，下面是一个 Pod 的配置文件，其注解中包含 <code>imageregistry: https://hub.docker.com/</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>annotations-demo<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">imageregistry</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;https://hub.docker.com/&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx:1.7.9<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span></code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
* Learn more about [Labels and Selectors](/docs/concepts/overview/working-with-objects/labels/).
-->
<ul>
<li>进一步了解<a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签和选择算符</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-13ce5627ef1dc8cbb4530ed231cb7d38">7 - Finalizers</h1>
    
	<!-- overview -->
<!--
---
title: Finalizer
id: finalizer
date: 2021-07-07
full_link: /zh/docs/concepts/overview/working-with-objects/finalizers/
short_description: >
  A namespaced key that tells Kubernetes to wait until specific conditions are met
  before it fully deletes an object marked for deletion.
aka: 
tags:
- fundamental
- operation
-->
<!--
Finalizers are namespaced keys that tell Kubernetes to wait until specific
conditions are met before it fully deletes resources marked for deletion.
Finalizers alert <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controllers'>controllers</a>
to clean up resources the deleted object owned.
-->
<p>Finalizer 是带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后，
再完全删除被标记为删除的资源。
Finalizer 提醒<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>清理被删除的对象拥有的资源。</p>
<!--
When you tell Kubernetes to delete an object that has finalizers specified for
it, the Kubernetes API marks the object for deletion by populating `.metadata.deletionTimestamp`,
and returns a `202` status code (HTTP "Accepted"). The target object remains in a terminating state while the
control plane, or other components, take the actions defined by the finalizers.
After these actions are complete, the controller removes the relevant finalizers
from the target object. When the `metadata.finalizers` field is empty,
Kubernetes considers the deletion complete.
-->
<p>当你告诉 Kubernetes 删除一个指定了 Finalizer 的对象时，
Kubernetes API 通过填充 <code>.metadata.deletionTimestamp</code> 来标记要删除的对象，
并返回<code>202</code>状态码 (HTTP &quot;已接受&quot;) 使其进入只读状态。
此时控制平面或其他组件会采取 Finalizer 所定义的行动，
而目标对象仍然处于终止中（Terminating）的状态。
这些行动完成后，控制器会删除目标对象相关的 Finalizer。
当 <code>metadata.finalizers</code> 字段为空时，Kubernetes 认为删除已完成。</p>
<!--
You can use finalizers to control <a class='glossary-tooltip' title='Kubernetes 用于清理集群资源的各种机制的统称。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/garbage-collection/' target='_blank' aria-label='garbage collection'>garbage collection</a>
of resources. For example, you can define a finalizer to clean up related resources or
infrastructure before the controller deletes the target resource.
-->
<p>你可以使用 Finalizer 控制资源的<a class='glossary-tooltip' title='Kubernetes 用于清理集群资源的各种机制的统称。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/garbage-collection/' target='_blank' aria-label='垃圾收集'>垃圾收集</a>。
例如，你可以定义一个 Finalizer，在删除目标资源前清理相关资源或基础设施。</p>
<!--
You can use finalizers to control <a class='glossary-tooltip' title='Kubernetes 用于清理集群资源的各种机制的统称。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/garbage-collection/' target='_blank' aria-label='garbage collection'>garbage collection</a>
of resources by alerting <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controllers'>controllers</a> to perform specific cleanup tasks before
deleting the target resource. 
-->
<p>你可以通过使用 Finalizers 提醒<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>
在删除目标资源前执行特定的清理任务，
来控制资源的<a class='glossary-tooltip' title='Kubernetes 用于清理集群资源的各种机制的统称。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/garbage-collection/' target='_blank' aria-label='垃圾收集'>垃圾收集</a>。</p>
<!--
Finalizers don't usually specify the code to execute. Instead, they are
typically lists of keys on a specific resource similar to annotations.
Kubernetes specifies some finalizers automatically, but you can also specify
your own.
-->
<p>Finalizers 通常不指定要执行的代码。
相反，它们通常是特定资源上的键的列表，类似于注解。
Kubernetes 自动指定了一些 Finalizers，但你也可以指定你自己的。</p>
<!--
## How finalizers work

When you create a resource using a manifest file, you can specify finalizers in
the `metadata.finalizers` field. When you attempt to delete the resource, the
API server handling the delete request notices the values in the `finalizers` field
and does the following: 

  * Modifies the object to add a `metadata.deletionTimestamp` field with the
    time you started the deletion.
  * Prevents the object from being removed until its `metadata.finalizers` field is empty.
  * Returns a `202` status code (HTTP "Accepted")
-->
<h2 id="how-finalizers-work">Finalizers 如何工作  </h2>
<p>当你使用清单文件创建资源时，你可以在 <code>metadata.finalizers</code> 字段指定 Finalizers。
当你试图删除该资源时，处理删除请求的 API 服务器会注意到 <code>finalizers</code> 字段中的值，
并进行以下操作：</p>
<ul>
<li>修改对象，将你开始执行删除的时间添加到 <code>metadata.deletionTimestamp</code> 字段。</li>
<li>禁止对象被删除，直到其 <code>metadata.finalizers</code> 字段为空。</li>
<li>返回 <code>202</code> 状态码（HTTP &quot;Accepted&quot;）。</li>
</ul>
<!--
The controller managing that finalizer notices the update to the object setting the
`metadata.deletionTimestamp`, indicating deletion of the object has been requested.
The controller then attempts to satisfy the requirements of the finalizers
specified for that resource. Each time a finalizer condition is satisfied, the
controller removes that key from the resource's `finalizers` field. When the
`finalizers` field is emptied, an object with a `deletionTimestamp` field set
is automatically deleted. You can also use finalizers to prevent deletion of unmanaged resources.
-->
<p>管理 finalizer 的控制器注意到对象上发生的更新操作，对象的 <code>metadata.deletionTimestamp</code>
被设置，意味着已经请求删除该对象。然后，控制器会试图满足资源的 Finalizers 的条件。
每当一个 Finalizer 的条件被满足时，控制器就会从资源的 <code>finalizers</code> 字段中删除该键。
当 <code>finalizers</code> 字段为空时，<code>deletionTimestamp</code> 字段被设置的对象会被自动删除。
你也可以使用 Finalizers 来阻止删除未被管理的资源。</p>
<!--
A common example of a finalizer is `kubernetes.io/pv-protection`, which prevents
accidental deletion of `PersistentVolume` objects. When a `PersistentVolume`
object is in use by a Pod, Kubernetes adds the `pv-protection` finalizer. If you
try to delete the `PersistentVolume`, it enters a `Terminating` status, but the
controller can't delete it because the finalizer exists. When the Pod stops
using the `PersistentVolume`, Kubernetes clears the `pv-protection` finalizer,
and the controller deletes the volume.
-->
<p>一个常见的 Finalizer 的例子是 <code>kubernetes.io/pv-protection</code>，
它用来防止意外删除 <code>PersistentVolume</code> 对象。
当一个 <code>PersistentVolume</code> 对象被 Pod 使用时，
Kubernetes 会添加 <code>pv-protection</code> Finalizer。
如果你试图删除 <code>PersistentVolume</code>，它将进入 <code>Terminating</code> 状态，
但是控制器因为该 Finalizer 存在而无法删除该资源。
当 Pod 停止使用 <code>PersistentVolume</code> 时，
Kubernetes 清除 <code>pv-protection</code> Finalizer，控制器就会删除该卷。</p>
<!--
## Owner references, labels, and finalizers {#owners-labels-finalizers}

Like <a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='labels'>labels</a>,
[owner references](/concepts/overview/working-with-objects/owners-dependents/)
describe the relationships between objects in Kubernetes, but are used for a
different purpose. When a
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a> manages objects
like Pods, it uses labels to track changes to groups of related objects. For
example, when a <a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Job'>Job</a> creates one or
more Pods, the Job controller applies labels to those pods and tracks changes to
any Pods in the cluster with the same label.
-->
<h2 id="owners-labels-finalizers">属主引用、标签和 Finalizers</h2>
<p>与<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>类似，
<a href="/zh/concepts/overview/working-with-objects/owners-dependents/">属主引用</a>
描述了 Kubernetes 中对象之间的关系，但它们作用不同。
当一个<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>
管理类似于 Pod 的对象时，它使用标签来跟踪相关对象组的变化。
例如，当 <a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Job'>Job</a> 创建一个或多个 Pod 时，
Job 控制器会给这些 Pod 应用上标签，并跟踪集群中的具有相同标签的 Pod 的变化。</p>
<!--
The Job controller also adds *owner references* to those Pods, pointing at the
Job that created the Pods. If you delete the Job while these Pods are running,
Kubernetes uses the owner references (not labels) to determine which Pods in the
cluster need cleanup.

Kubernetes also processes finalizers when it identifies owner references on a
resource targeted for deletion. 

In some situations, finalizers can block the deletion of dependent objects,
which can cause the targeted owner object to remain for
longer than expected without being fully deleted. In these situations, you
should check finalizers and owner references on the target owner and dependent
objects to troubleshoot the cause. 
-->
<p>Job 控制器还为这些 Pod 添加了<em>属主引用</em>，指向创建 Pod 的 Job。
如果你在这些 Pod 运行的时候删除了 Job，
Kubernetes 会使用属主引用（而不是标签）来确定集群中哪些 Pod 需要清理。</p>
<p>当 Kubernetes 识别到要删除的资源上的属主引用时，它也会处理 Finalizers。</p>
<p>在某些情况下，Finalizers 会阻止依赖对象的删除，
这可能导致目标属主对象被保留的时间比预期的长，而没有被完全删除。
在这些情况下，你应该检查目标属主和附属对象上的 Finalizers 和属主引用，来排查原因。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
In cases where objects are stuck in a deleting state, avoid manually
removing finalizers to allow deletion to continue. Finalizers are usually added
to resources for a reason, so forcefully removing them can lead to issues in
your cluster. This should only be done when the purpose of the finalizer is
understood and is accomplished in another way (for example, manually cleaning
up some dependent object).

-->
<p>在对象卡在删除状态的情况下，要避免手动移除 Finalizers，以允许继续删除操作。
Finalizers 通常因为特殊原因被添加到资源上，所以强行删除它们会导致集群出现问题。
只有了解 finalizer 的用途时才能这样做，并且应该通过一些其他方式来完成
（例如，手动清除其余的依赖对象）。
</div>
<h2 id="what-s-next">What's next</h2>
<!--
* Read [Using Finalizers to Control Deletion](/blog/2021/05/14/using-finalizers-to-control-deletion/)
  on the Kubernetes blog.
-->
<ul>
<li>在 Kubernetes 博客上阅读<a href="/blog/2021/05/14/using-finalizers-to-control-deletion/">使用 Finalizers 控制删除</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-046c03090d47bc4b89b818dc645c3865">8 - 字段选择器</h1>
    
	<!--
title: Field Selectors
weight: 60
-->
<!--
_Field selectors_ let you [select Kubernetes resources](/docs/concepts/overview/working-with-objects/kubernetes-objects) based on the value of one or more resource fields. Here are some example field selector queries:
-->
<p>“字段选择器（Field selectors）”允许你根据一个或多个资源字段的值
<a href="/zh/docs/concepts/overview/working-with-objects/kubernetes-objects">筛选 Kubernetes 资源</a>。
下面是一些使用字段选择器查询的例子：</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<!--
This `kubectl` command selects all Pods for which the value of the [`status.phase`](/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase) field is `Running`:
-->
<p>下面这个 <code>kubectl</code> 命令将筛选出 <a href="/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase"><code>status.phase</code></a>
字段值为 <code>Running</code> 的所有 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --field-selector status.phase<span style="color:#666">=</span>Running
</code></pre></div><!--
Field selectors are essentially resource *filters*. By default, no selectors/filters are applied, meaning that all resources of the specified type are selected. This makes the following `kubectl` queries equivalent:
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <p>字段选择器本质上是资源<em>过滤器（Filters）</em>。默认情况下，字段选择器/过滤器是未被应用的，
这意味着指定类型的所有资源都会被筛选出来。
这使得以下的两个 <code>kubectl</code> 查询是等价的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods
kubectl get pods --field-selector <span style="color:#b44">&#34;&#34;</span>
</code></pre></div>
</div>
<!--
## Supported fields

Supported field selectors vary by Kubernetes resource type. All resource types support the `metadata.name` and `metadata.namespace` fields. Using unsupported field selectors produces an error. For example:
-->
<h2 id="supported-fields">支持的字段 </h2>
<p>不同的 Kubernetes 资源类型支持不同的字段选择器。
所有资源类型都支持 <code>metadata.name</code> 和 <code>metadata.namespace</code> 字段。
使用不被支持的字段选择器会产生错误。例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get ingress --field-selector foo.bar<span style="color:#666">=</span>baz
</code></pre></div><pre><code>Error from server (BadRequest): Unable to find &quot;ingresses&quot; that match label selector &quot;&quot;, field selector &quot;foo.bar=baz&quot;: &quot;foo.bar&quot; is not a known field selector: only &quot;metadata.name&quot;, &quot;metadata.namespace&quot;
</code></pre><!--
## Supported operators

You can use the `=`, `==`, and `!=` operators with field selectors (`=` and `==` mean the same thing). This `kubectl` command, for example, selects all Kubernetes Services that aren't in the `default` namespace:
-->
<h2 id="supported-operators">支持的操作符  </h2>
<p>你可在字段选择器中使用 <code>=</code>、<code>==</code>和 <code>!=</code> （<code>=</code> 和 <code>==</code> 的意义是相同的）操作符。
例如，下面这个 <code>kubectl</code> 命令将筛选所有不属于 <code>default</code> 命名空间的 Kubernetes 服务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style="color:#666">=</span>default
</code></pre></div><!--
## Chained selectors

As with [label](/docs/concepts/overview/working-with-objects/labels) and other selectors, field selectors can be chained together as a comma-separated list. This `kubectl` command selects all Pods for which the `status.phase` does not equal `Running` and the `spec.restartPolicy` field equals `Always`:
-->
<h2 id="chained-selectors">链式选择器  </h2>
<p>同<a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签</a>和其他选择器一样，
字段选择器可以通过使用逗号分隔的列表组成一个选择链。
下面这个 <code>kubectl</code> 命令将筛选 <code>status.phase</code> 字段不等于 <code>Running</code> 同时
<code>spec.restartPolicy</code> 字段等于 <code>Always</code> 的所有 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --field-selector<span style="color:#666">=</span>status.phase!<span style="color:#666">=</span>Running,spec.restartPolicy<span style="color:#666">=</span>Always
</code></pre></div><!--
## Multiple resource types

You can use field selectors across multiple resource types. This `kubectl` command selects all Statefulsets and Services that are not in the `default` namespace:
-->
<h2 id="multiple-resource-types">多种资源类型  </h2>
<p>你能够跨多种资源类型来使用字段选择器。
下面这个 <code>kubectl</code> 命令将筛选出所有不在 <code>default</code> 命名空间中的 StatefulSet 和 Service：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style="color:#666">=</span>default
</code></pre></div>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-efaa7a58910b58892dafd50e3b43c93c">9 - 属主与附属</h1>
    
	<!-- 
title: Owners and Dependents
content_type: concept
weight: 60
-->
<!-- overview -->
<!-- 
In Kubernetes, some objects are *owners* of other objects. For example, a
<a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSet'>ReplicaSet</a> is the owner of a set of Pods. These owned objects are *dependents*
of their owner. 
-->
<p>在 Kubernetes 中，一些对象是其他对象的<em>属主（Owner）</em>。
例如，<a class='glossary-tooltip' title='ReplicaSet 是下一代副本控制器。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/replicaset/' target='_blank' aria-label='ReplicaSet'>ReplicaSet</a> 是一组 Pod 的属主。
具有属主的对象是属主的<em>附属（Dependent）</em> 。</p>
<!--
Ownership is different from the [labels and selectors](/docs/concepts/overview/working-with-objects/labels/)
mechanism that some resources also use. For example, consider a Service that 
creates `EndpointSlice` objects. The Service uses labels to allow the control plane to
determine which `EndpointSlice` objects are used for that Service. In addition
to the labels, each `EndpointSlice` that is managed on behalf of a Service has
an owner reference. Owner references help different parts of Kubernetes avoid
interfering with objects they don’t control. 
-->
<p>属主关系不同于一些资源使用的<a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签和选择算符</a>机制。
例如，有一个创建 <code>EndpointSlice</code> 对象的 Service，
该 Service 使用标签来让控制平面确定，哪些 <code>EndpointSlice</code> 对象属于该 Service。
除开标签，每个代表 Service 所管理的 <code>EndpointSlice</code> 都有一个属主引用。
属主引用避免 Kubernetes 的不同部分干扰到不受它们控制的对象。</p>
<!--
## Owner references in object specifications

Dependent objects have a `metadata.ownerReferences` field that references their
owner object. A valid owner reference consists of the object name and a UID
within the same namespace as the dependent object. Kubernetes sets the value of
this field automatically for objects that are dependents of other objects like
ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers.
You can also configure these relationships manually by changing the value of
this field. However, you usually don't need to and can allow Kubernetes to
automatically manage the relationships.
-->
<h2 id="owner-references-in-object-specifications">对象规约中的属主引用  </h2>
<p>附属对象有一个 <code>metadata.ownerReferences</code> 字段，用于引用其属主对象。
一个有效的属主引用，包含与附属对象同在一个命名空间下的对象名称和一个 UID。
Kubernetes 自动为一些对象的附属资源设置属主引用的值，
这些对象包含 ReplicaSet、DaemonSet、Deployment、Job、CronJob、ReplicationController 等。
你也可以通过改变这个字段的值，来手动配置这些关系。
然而，你通常不需要这么做，你可以让 Kubernetes 自动管理附属关系。</p>
<!--
Dependent objects also have an `ownerReferences.blockOwnerDeletion` field that
takes a boolean value and controls whether specific dependents can block garbage
collection from deleting their owner object. Kubernetes automatically sets this
field to `true` if a <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a> 
(for example, the Deployment controller) sets the value of the
`metadata.ownerReferences` field. You can also set the value of the
`blockOwnerDeletion` field manually to control which dependents block garbage
collection.

A Kubernetes admission controller controls user access to change this field for
dependent resources, based on the delete permissions of the owner. This control
prevents unauthorized users from delaying owner object deletion.
-->
<p>附属对象还有一个 <code>ownerReferences.blockOwnerDeletion</code> 字段，该字段使用布尔值，
用于控制特定的附属对象是否可以阻止垃圾收集删除其属主对象。
如果<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>（例如 Deployment 控制器）
设置了 <code>metadata.ownerReferences</code> 字段的值，Kubernetes 会自动设置
<code>blockOwnerDeletion</code> 的值为 <code>true</code>。
你也可以手动设置 <code>blockOwnerDeletion</code> 字段的值，以控制哪些附属对象会阻止垃圾收集。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Cross-namespace owner references are disallowed by design.
Namespaced dependents can specify cluster-scoped or namespaced owners.
A namespaced owner **must** exist in the same namespace as the dependent.
If it does not, the owner reference is treated as absent, and the dependent
is subject to deletion once all owners are verified absent.

Cluster-scoped dependents can only specify cluster-scoped owners.
In v1.20+, if a cluster-scoped dependent specifies a namespaced kind as an owner,
it is treated as having an unresolvable owner reference, and is not able to be garbage collected.

In v1.20+, if the garbage collector detects an invalid cross-namespace `ownerReference`,
or a cluster-scoped dependent with an `ownerReference` referencing a namespaced kind, a warning Event 
with a reason of `OwnerRefInvalidNamespace` and an `involvedObject` of the invalid dependent is reported.
You can check for that kind of Event by running
`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`.
-->
<p>根据设计，kubernetes 不允许跨名字空间指定属主。
名字空间范围的附属可以指定集群范围的或者名字空间范围的属主。
名字空间范围的属主<strong>必须</strong>和该附属处于相同的名字空间。
如果名字空间范围的属主和附属不在相同的名字空间，那么该属主引用就会被认为是缺失的，
并且当附属的所有属主引用都被确认不再存在之后，该附属就会被删除。</p>
<p>集群范围的附属只能指定集群范围的属主。
在 v1.20+ 版本，如果一个集群范围的附属指定了一个名字空间范围类型的属主，
那么该附属就会被认为是拥有一个不可解析的属主引用，并且它不能够被垃圾回收。</p>
<p>在 v1.20+ 版本，如果垃圾收集器检测到无效的跨名字空间的属主引用，
或者一个集群范围的附属指定了一个名字空间范围类型的属主，
那么它就会报告一个警告事件。该事件的原因是 <code>OwnerRefInvalidNamespace</code>，
<code>involvedObject</code> 属性中包含无效的附属。
你可以运行 <code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>
来获取该类型的事件。</p>

</div>
<!--
## Ownership and finalizers

When you tell Kubernetes to delete a resource, the API server allows the
managing controller to process any [finalizer rules](/docs/concepts/overview/working-with-objects/finalizers/)
for the resource. <a class='glossary-tooltip' title='一个带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/finalizers/' target='_blank' aria-label='Finalizers'>Finalizers</a>
prevent accidental deletion of resources your cluster may still need to function
correctly. For example, if you try to delete a `PersistentVolume` that is still
in use by a Pod, the deletion does not happen immediately because the
`PersistentVolume` has the `kubernetes.io/pv-protection` finalizer on it.
Instead, the volume remains in the `Terminating` status until Kubernetes clears
the finalizer, which only happens after the `PersistentVolume` is no longer
bound to a Pod. 
-->
<h2 id="ownership-and-finalizers">属主关系与 Finalizer  </h2>
<p>当你告诉 Kubernetes 删除一个资源，API 服务器允许管理控制器处理该资源的任何
<a href="/zh/docs/concepts/overview/working-with-objects/finalizers/">Finalizer 规则</a>。
<a class='glossary-tooltip' title='一个带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/finalizers/' target='_blank' aria-label='Finalizer'>Finalizer</a>
防止意外删除你的集群所依赖的、用于正常运作的资源。
例如，如果你试图删除一个仍被 Pod 使用的 <code>PersistentVolume</code>，该资源不会被立即删除，
因为 <code>PersistentVolume</code> 有 <code>kubernetes.io/pv-protection</code> Finalizer。
相反，它将进入 <code>Terminating</code> 状态，直到 Kubernetes 清除这个 Finalizer，
而这种情况只会发生在 <code>PersistentVolume</code> 不再被挂载到 Pod 上时。</p>
<!--
Kubernetes also adds finalizers to an owner resource when you use either
[foreground or orphan cascading deletion](/docs/concepts/architecture/garbage-collection/#cascading-deletion).
In foreground deletion, it adds the `foreground` finalizer so that the
controller must delete dependent resources that also have
`ownerReferences.blockOwnerDeletion=true` before it deletes the owner. If you
specify an orphan deletion policy, Kubernetes adds the `orphan` finalizer so
that the controller ignores dependent resources after it deletes the owner
object. 
-->
<p>当你使用<a href="/zh/docs/concepts/architecture/garbage-collection/#cascading-deletion">前台或孤立级联删除</a>时，
Kubernetes 也会向属主资源添加 Finalizer。
在前台删除中，会添加 <code>foreground</code> Finalizer，这样控制器必须在删除了拥有
<code>ownerReferences.blockOwnerDeletion=true</code> 的附属资源后，才能删除属主对象。
如果你指定了孤立删除策略，Kubernetes 会添加 <code>orphan</code> Finalizer，
这样控制器在删除属主对象后，会忽略附属资源。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* Learn more about [Kubernetes finalizers](/docs/concepts/overview/working-with-objects/finalizers/).
* Learn about [garbage collection](/docs/concepts/architecture/garbage-collection).
* Read the API reference for [object metadata](/docs/reference/kubernetes-api/common-definitions/object-meta/#System).
-->
<ul>
<li>了解更多关于 <a href="/zh/docs/concepts/overview/working-with-objects/finalizers/">Kubernetes Finalizer</a>。</li>
<li>了解关于<a href="/zh/docs/concepts/architecture/garbage-collection">垃圾收集</a>。</li>
<li>阅读<a href="/docs/reference/kubernetes-api/common-definitions/object-meta/#System">对象元数据</a>的 API 参考文档。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5dd62c6a4a481b4cf1ac50f6799eb581">10 - 推荐使用的标签</h1>
    
	<!--
---
title: Recommended Labels
content_type: concept
---
-->
<!-- overview -->
<!--
You can visualize and manage Kubernetes objects with more tools than kubectl and
the dashboard. A common set of labels allows tools to work interoperably, describing
objects in a common manner that all tools can understand.
-->
<p>除了 kubectl 和 dashboard 之外，您可以使用其他工具来可视化和管理 Kubernetes 对象。一组通用的标签可以让多个工具之间相互操作，用所有工具都能理解的通用方式描述对象。</p>
<!--
In addition to supporting tooling, the recommended labels describe applications
in a way that can be queried.
-->
<p>除了支持工具外，推荐的标签还以一种可以查询的方式描述了应用程序。</p>
<!-- body -->
<!--
The metadata is organized around the concept of an _application_. Kubernetes is not
a platform as a service (PaaS) and doesn't have or enforce a formal notion of an application.
Instead, applications are informal and described with metadata. The definition of
what an application contains is loose.
-->
<p>元数据围绕 <em>应用（application）</em> 的概念进行组织。Kubernetes 不是
平台即服务（PaaS），没有或强制执行正式的应用程序概念。
相反，应用程序是非正式的，并使用元数据进行描述。应用程序包含的定义是松散的。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
These are recommended labels. They make it easier to manage applications
but aren't required for any core tooling.
-->
<p>这些是推荐的标签。它们使管理应用程序变得更容易但不是任何核心工具所必需的。
</div>
<!--
Shared labels and annotations share a common prefix: `app.kubernetes.io`. Labels
without a prefix are private to users. The shared prefix ensures that shared labels
do not interfere with custom user labels.
-->
<p>共享标签和注解都使用同一个前缀：<code>app.kubernetes.io</code>。没有前缀的标签是用户私有的。共享前缀可以确保共享标签不会干扰用户自定义的标签。</p>
<!--
## Labels

In order to take full advantage of using these labels, they should be applied
on every resource object.
-->
<h2 id="标签">标签</h2>
<p>为了充分利用这些标签，应该在每个资源对象上都使用它们。</p>
<!--
| Key                                 | Description           | Example  | Type |
| ----------------------------------- | --------------------- | -------- | ---- |
| `app.kubernetes.io/name`            | The name of the application | `mysql` | string |
| `app.kubernetes.io/instance`        | A unique name identifying the instance of an application | `mysql-abcxzy` | string |
| `app.kubernetes.io/version`         | The current version of the application (e.g., a semantic version, revision hash, etc.) | `5.7.21` | string |
| `app.kubernetes.io/component`       | The component within the architecture | `database` | string |
| `app.kubernetes.io/part-of`         | The name of a higher level application this one is part of | `wordpress` | string |
| `app.kubernetes.io/managed-by`      | The tool being used to manage the operation of an application | `helm` | string |
| `app.kubernetes.io/created-by`      | The controller/user who created this resource | `controller-manager` | string |
-->
<table>
<thead>
<tr>
<th>键</th>
<th>描述</th>
<th>示例</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>app.kubernetes.io/name</code></td>
<td>应用程序的名称</td>
<td><code>mysql</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/instance</code></td>
<td>用于唯一确定应用实例的名称</td>
<td><code>mysql-abcxzy</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/version</code></td>
<td>应用程序的当前版本（例如，语义版本，修订版哈希等）</td>
<td><code>5.7.21</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/component</code></td>
<td>架构中的组件</td>
<td><code>database</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/part-of</code></td>
<td>此级别的更高级别应用程序的名称</td>
<td><code>wordpress</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/managed-by</code></td>
<td>用于管理应用程序的工具</td>
<td><code>helm</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>app.kubernetes.io/created-by</code></td>
<td>创建该资源的控制器或者用户</td>
<td><code>controller-manager</code></td>
<td>字符串</td>
</tr>
</tbody>
</table>
<!--
To illustrate these labels in action, consider the following <a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSet'>StatefulSet</a> object:
-->
<p>为说明这些标签的实际使用情况，请看下面的 <a class='glossary-tooltip' title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/statefulset/' target='_blank' aria-label='StatefulSet'>StatefulSet</a> 对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#080;font-style:italic"># 这是一段节选</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5.7.21&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>helm<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/created-by</span>:<span style="color:#bbb"> </span>controller-manager<span style="color:#bbb">
</span></code></pre></div><!--
## Applications And Instances Of Applications

An application can be installed one or more times into a Kubernetes cluster and,
in some cases, the same namespace. For example, WordPress can be installed more
than once where different websites are different installations of WordPress.

The name of an application and the instance name are recorded separately. For
example, WordPress has a `app.kubernetes.io/name` of `wordpress` while it has
an instance name, represented as `app.kubernetes.io/instance` with a value of
`wordpress-abcxzy`. This enables the application and instance of the application
to be identifiable. Every instance of an application must have a unique name.
-->
<h2 id="应用和应用实例">应用和应用实例</h2>
<p>应用可以在 Kubernetes 集群中安装一次或多次。在某些情况下，可以安装在同一命名空间中。例如，可以不止一次地为不同的站点安装不同的 WordPress。</p>
<p>应用的名称和实例的名称是分别记录的。例如，WordPress 应用的
<code>app.kubernetes.io/name</code> 为 <code>wordpress</code>，而其实例名称
<code>app.kubernetes.io/instance</code> 为 <code>wordpress-abcxzy</code>。
这使得应用和应用的实例均可被识别，应用的每个实例都必须具有唯一的名称。</p>
<!--
## Examples
-->
<h2 id="示例">示例</h2>
<!--
To illustrate different ways to use these labels the following examples have varying complexity.
-->
<p>为了说明使用这些标签的不同方式，以下示例具有不同的复杂性。</p>
<!--
### A Simple Stateless Service
-->
<h3 id="一个简单的无状态服务">一个简单的无状态服务</h3>
<!--
Consider the case for a simple stateless service deployed using `Deployment` and `Service` objects. The following two snippets represent how the labels could be used in their simplest form.
-->
<p>考虑使用 <code>Deployment</code> 和 <code>Service</code> 对象部署的简单无状态服务的情况。以下两个代码段表示如何以最简单的形式使用标签。</p>
<!--
The `Deployment` is used to oversee the pods running the application itself.
-->
<p>下面的 <code>Deployment</code> 用于监督运行应用本身的 pods。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>myservice<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>myservice-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
The `Service` is used to expose the application.
-->
<p>下面的 <code>Service</code> 用于暴露应用。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>myservice<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>myservice-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
### Web Application With A Database
-->
<h3 id="带有一个数据库的-web-应用程序">带有一个数据库的 Web 应用程序</h3>
<!--
Consider a slightly more complicated application: a web application (WordPress)
using a database (MySQL), installed using Helm. The following snippets illustrate
the start of objects used to deploy this application.

The start to the following `Deployment` is used for WordPress:
-->
<p>考虑一个稍微复杂的应用：一个使用 Helm 安装的 Web 应用（WordPress），其中
使用了数据库（MySQL）。以下代码片段说明用于部署此应用程序的对象的开始。</p>
<p>以下 <code>Deployment</code> 的开头用于 WordPress：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>wordpress-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;4.9.4&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>helm<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
The `Service` is used to expose WordPress:
-->
<p>这个 <code>Service</code> 用于暴露 WordPress：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>wordpress-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;4.9.4&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>helm<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>server<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
MySQL is exposed as a `StatefulSet` with metadata for both it and the larger application it belongs to:
-->
<p>MySQL 作为一个 <code>StatefulSet</code> 暴露，包含它和它所属的较大应用程序的元数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>StatefulSet<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5.7.21&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>helm<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
The `Service` is used to expose MySQL as part of WordPress:
-->
<p><code>Service</code> 用于将 MySQL 作为 WordPress 的一部分暴露：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/name</span>:<span style="color:#bbb"> </span>mysql<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/instance</span>:<span style="color:#bbb"> </span>mysql-abcxzy<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/version</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;5.7.21&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/managed-by</span>:<span style="color:#bbb"> </span>helm<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/component</span>:<span style="color:#bbb"> </span>database<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app.kubernetes.io/part-of</span>:<span style="color:#bbb"> </span>wordpress<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span><span style="color:#bbb">
</span></code></pre></div><!--
With the MySQL `StatefulSet` and `Service` you'll notice information about both MySQL and Wordpress, the broader application, are included.
-->
<p>使用 MySQL <code>StatefulSet</code> 和 <code>Service</code>，您会注意到有关 MySQL 和 Wordpress 的信息，包括更广泛的应用程序。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
