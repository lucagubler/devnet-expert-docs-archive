<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/concepts/security/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/concepts/security/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/concepts/security/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/concepts/security/">
<link rel="alternate" hreflang="pt-br" href="http://localhost:1313/pt-br/docs/concepts/security/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/concepts/security/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/concepts/security/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/concepts/security/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>安全 | Kubernetes</title><meta property="og:title" content="安全" />
<meta property="og:description" content="确保云原生工作负载安全的一组概念。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/concepts/security/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="安全">
<meta itemprop="description" content="确保云原生工作负载安全的一组概念。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="安全"/>
<meta name="twitter:description" content="确保云原生工作负载安全的一组概念。"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="确保云原生工作负载安全的一组概念。">
<meta property="og:description" content="确保云原生工作负载安全的一组概念。">
<meta name="twitter:description" content="确保云原生工作负载安全的一组概念。">
<meta property="og:url" content="http://localhost:1313/zh/docs/concepts/security/">
<meta property="og:title" content="安全">
<meta name="twitter:title" content="安全">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/concepts/security/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/concepts/security/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/concepts/security/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/concepts/security/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/concepts/security/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/concepts/security/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/concepts/security/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/concepts/security/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/concepts/security/">Français</a>
	
	<a class="dropdown-item" href="/pt-br/docs/concepts/security/">Português</a>
	
	<a class="dropdown-item" href="/es/docs/concepts/security/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/concepts/security/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/concepts/security/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">安全</h1>
<div class="lead">确保云原生工作负载安全的一组概念。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-04eeb110d75afc8acb2cf7a3db743985">云原生安全概述</a></li>


    
  
    
    
	
<li>2: <a href="#pg-1fb24c1dd155f43849da490a74c4b8c5">Pod 安全性标准</a></li>


    
  
    
    
	
<li>3: <a href="#pg-bc9934fccfeaf880eec6ea79025c0381">Pod 安全性准入</a></li>


    
  
    
    
	
<li>4: <a href="#pg-4d77d1ae4c06aa14f54b385191627881">Kubernetes API 访问控制</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-04eeb110d75afc8acb2cf7a3db743985">1 - 云原生安全概述</h1>
    <div class="lead">在云原生安全的背景下思考 Kubernetes 安全模型。</div>
	<!-- overview -->
<!--
This overview defines a model for thinking about Kubernetes security in the context of Cloud Native security.
-->
<p>本概述定义了一个模型，用于在 Cloud Native 安全性上下文中考虑 Kubernetes 安全性。</p>
<!--
This container security model provides suggestions, not proven information security policies.
-->
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> 此容器安全模型只提供建议，而不是经过验证的信息安全策略。
</div>


<!-- body -->
<!--
## The 4C's of Cloud Native security

You can think about security in layers. The 4C's of Cloud Native security are Cloud,
Clusters, Containers, and Code.
-->
<h2 id="云原生安全的-4-个-c">云原生安全的 4 个 C</h2>
<p>你可以分层去考虑安全性，云原生安全的 4 个 C 分别是云（Cloud）、集群（Cluster）、容器（Container）和代码（Code）。</p>
<!--
This layered approach augments the [defense in depth](https://en.wikipedia.org/wiki/Defense_in_depth_(computing))
computing approach to security, which is widely regarded as a best practice for securing
software systems.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 这种分层方法增强了<a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">深度防护方法</a>在安全性方面的
防御能力，该方法被广泛认为是保护软件系统的最佳实践。
</div>

<figure>
    <img src="/images/docs/4c.png"/> <figcaption>
            <h4>云原生安全的 4C</h4>
        </figcaption>
</figure>

<!--
Each layer of the Cloud Native security model builds upon the next outermost layer.
The Code layer benefits from strong base (Cloud, Cluster, Container) security layers.
You cannot safeguard against poor security standards in the base layers by addressing
security at the Code level.
-->
<p>云原生安全模型的每一层都是基于下一个最外层，代码层受益于强大的基础安全层（云、集群、容器）。你无法通过在代码层解决安全问题来为基础层中糟糕的安全标准提供保护。</p>
<h2 id="云">云</h2>
<!--
In many ways, the Cloud (or co-located servers, or the corporate datacenter) is the
[trusted computing base](https://en.wikipedia.org/wiki/Trusted_computing_base)
of a Kubernetes cluster. If the Cloud layer is vulnerable (or
configured in a vulnerable way) then there is no guarantee that the components built
on top of this base are secure. Each cloud provider makes security recommendations
for running workloads securely in their environment.
-->
<p>在许多方面，云（或者位于同一位置的服务器，或者是公司数据中心）是 Kubernetes 集群中的
<a href="https://en.wikipedia.org/wiki/Trusted_computing_base">可信计算基</a>。
如果云层容易受到攻击（或者被配置成了易受攻击的方式），就不能保证在此基础之上构建的组件是安全的。
每个云提供商都会提出安全建议，以在其环境中安全地运行工作负载。</p>
<!--
### Cloud provider security

If you are running a Kubernetes cluster on your own hardware or a different cloud provider,
consult your documentation for security best practices.
Here are links to some of the popular cloud providers' security documentation:
-->
<h3 id="云提供商安全性">云提供商安全性</h3>
<p>如果您是在您自己的硬件或者其他不同的云提供商上运行 Kubernetes 集群，
请查阅相关文档来获取最好的安全实践。</p>
<p>下面是一些比较流行的云提供商的安全性文档链接：</p>





<table><caption style="display: none;">云提供商安全</caption>
<thead>
<tr>
<th>IaaS 提供商</th>
<th>链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alibaba Cloud</td>
<td><a href="https://www.alibabacloud.com/trust-center">https://www.alibabacloud.com/trust-center</a></td>
</tr>
<tr>
<td>Amazon Web Services</td>
<td><a href="https://aws.amazon.com/security/">https://aws.amazon.com/security/</a></td>
</tr>
<tr>
<td>Google Cloud Platform</td>
<td><a href="https://cloud.google.com/security/">https://cloud.google.com/security/</a></td>
</tr>
<tr>
<td>IBM Cloud</td>
<td><a href="https://www.ibm.com/cloud/security">https://www.ibm.com/cloud/security</a></td>
</tr>
<tr>
<td>Microsoft Azure</td>
<td><a href="https://docs.microsoft.com/en-us/azure/security/azure-security">https://docs.microsoft.com/en-us/azure/security/azure-security</a></td>
</tr>
<tr>
<td>Oracle Cloud Infrastructure</td>
<td><a href="https://www.oracle.com/security/">https://www.oracle.com/security/</a></td>
</tr>
<tr>
<td>VMWare VSphere</td>
<td><a href="https://www.vmware.com/security/hardening-guides.html">https://www.vmware.com/security/hardening-guides.html</a></td>
</tr>
</tbody>
</table>

<!--
### Infrastructure security {#infrastructure-security}

Suggestions for securing your infrastructure in a Kubernetes cluster:






<table><caption style="display: none;">Infrastructure security</caption>
<thead>
<tr>
<th>Area of Concern for Kubernetes Infrastructure</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Network access to API Server (Control plane)</td>
<td>All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.</td>
</tr>
<tr>
<td>Network access to Nodes (nodes)</td>
<td>Nodes should be configured to <em>only</em> accept connections (via network access control lists) from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.</td>
</tr>
<tr>
<td>Kubernetes access to Cloud Provider API</td>
<td>Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">principle of least privilege</a> for the resources it needs to administer. The <a href="https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles">Kops documentation</a> provides information about IAM policies and roles.</td>
</tr>
<tr>
<td>Access to etcd</td>
<td>Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the <a href="https://github.com/etcd-io/etcd/tree/master/Documentation">etcd documentation</a>.</td>
</tr>
<tr>
<td>etcd Encryption</td>
<td>Wherever possible it's a good practice to encrypt all drives at rest, and since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.</td>
</tr>
</tbody>
</table>

-->
<h3 id="infrastructure-security">基础设施安全</h3>
<p>关于在 Kubernetes 集群中保护你的基础设施的建议：</p>





<table><caption style="display: none;">基础设施安全</caption>
<thead>
<tr>
<th>Kubetnetes 基础架构关注领域</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过网络访问 API 服务（控制平面）</td>
<td>所有对 Kubernetes 控制平面的访问不允许在 Internet 上公开，同时应由网络访问控制列表控制，该列表包含管理集群所需的 IP 地址集。</td>
</tr>
<tr>
<td>通过网络访问 Node（节点）</td>
<td>节点应配置为 <em>仅能</em> 从控制平面上通过指定端口来接受（通过网络访问控制列表）连接，以及接受 NodePort 和 LoadBalancer 类型的 Kubernetes 服务连接。如果可能的话，这些节点不应完全暴露在公共互联网上。</td>
</tr>
<tr>
<td>Kubernetes 访问云提供商的 API</td>
<td>每个云提供商都需要向 Kubernetes 控制平面和节点授予不同的权限集。为集群提供云提供商访问权限时，最好遵循对需要管理的资源的<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小特权原则</a>。<a href="https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles">Kops 文档</a>提供有关 IAM 策略和角色的信息。</td>
</tr>
<tr>
<td>访问 etcd</td>
<td>对 etcd（Kubernetes 的数据存储）的访问应仅限于控制平面。根据配置情况，你应该尝试通过 TLS 来使用 etcd。更多信息可以在 <a href="https://github.com/etcd-io/etcd/tree/master/Documentation">etcd 文档</a>中找到。</td>
</tr>
<tr>
<td>etcd 加密</td>
<td>在所有可能的情况下，最好对所有驱动器进行静态数据加密，并且由于 etcd 拥有整个集群的状态（包括机密信息），因此其磁盘更应该进行静态数据加密。</td>
</tr>
</tbody>
</table>

<!--
## Cluster

There are two areas of concern for securing Kubernetes:

* Securing the cluster components that are configurable
* Securing the applications which run in the cluster
-->
<h2 id="集群">集群</h2>
<p>保护 Kubernetes 有两个方面需要注意：</p>
<ul>
<li>保护可配置的集群组件</li>
<li>保护在集群中运行的应用程序</li>
</ul>
<!--
### Components of the Cluster {#cluster-components}

If you want to protect your cluster from accidental or malicious access and adopt
good information practices, read and follow the advice about
[securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/).
-->
<h3 id="cluster-components">集群组件</h3>
<p>如果想要保护集群免受意外或恶意的访问，采取良好的信息管理实践，请阅读并遵循有关<a href="/zh/docs/tasks/administer-cluster/securing-a-cluster/">保护集群</a>的建议。</p>
<!--
### Components in the cluster (your application) {#cluster-applications}

Depending on the attack surface of your application, you may want to focus on specific
aspects of security. For example: If you are running a service (Service A) that is critical
in a chain of other resources and a separate workload (Service B) which is
vulnerable to a resource exhaustion attack, then the risk of compromising Service A
is high if you do not limit the resources of Service B. The following table lists
areas of security concerns and recommendations for securing workloads running in Kubernetes:

Area of Concern for Workload Security | Recommendation |
------------------------------ | --------------------- |
RBAC Authorization (Access to the Kubernetes API) | https://kubernetes.io/docs/reference/access-authn-authz/rbac/
Authentication | https://kubernetes.io/docs/concepts/security/controlling-access/
Application secrets management (and encrypting them in etcd at rest) | https://kubernetes.io/docs/concepts/configuration/secret/ <br> https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
Ensuring that pods meet defined Pod Security Standards | https://kubernetes.io/docs/concepts/security/pod-security-standards/#policy-instantiation
Quality of Service (and Cluster resource management) | https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/
Network Policies | https://kubernetes.io/docs/concepts/services-networking/network-policies/
TLS for Kubernetes Ingress | https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
-->
<h3 id="cluster-applications">集群中的组件（您的应用）</h3>
<p>根据您的应用程序的受攻击面，您可能需要关注安全性的特定面，比如：
如果您正在运行中的一个服务（A 服务）在其他资源链中很重要，并且所运行的另一工作负载（服务 B）
容易受到资源枯竭的攻击，则如果你不限制服务 B 的资源的话，损害服务 A 的风险就会很高。
下表列出了安全性关注的领域和建议，用以保护 Kubernetes 中运行的工作负载：</p>
<table>
<thead>
<tr>
<th>工作负载安全性关注领域</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>RBAC 授权(访问 Kubernetes API)</td>
<td><a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/">https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/</a></td>
</tr>
<tr>
<td>认证方式</td>
<td><a href="https://kubernetes.io/zh/docs/concepts/security/controlling-access/">https://kubernetes.io/zh/docs/concepts/security/controlling-access/</a></td>
</tr>
<tr>
<td>应用程序 Secret 管理 (并在 etcd 中对其进行静态数据加密)</td>
<td><a href="https://kubernetes.io/zh/docs/concepts/configuration/secret/">https://kubernetes.io/zh/docs/concepts/configuration/secret/</a> <br> <a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/">https://kubernetes.io/zh/docs/tasks/administer-cluster/encrypt-data/</a></td>
</tr>
<tr>
<td>确保 Pod 符合定义的 Pod 安全标准</td>
<td><a href="https://kubernetes.io/zh/docs/concepts/security/pod-security-standards/#policy-instantiation">https://kubernetes.io/zh/docs/concepts/security/pod-security-standards/#policy-instantiation</a></td>
</tr>
<tr>
<td>服务质量（和集群资源管理）</td>
<td><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/quality-service-pod/">https://kubernetes.io/zh/docs/tasks/configure-pod-container/quality-service-pod/</a></td>
</tr>
<tr>
<td>网络策略</td>
<td><a href="https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/">https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/</a></td>
</tr>
<tr>
<td>Kubernetes Ingress 的 TLS 支持</td>
<td><a href="https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#tls">https://kubernetes.io/zh/docs/concepts/services-networking/ingress/#tls</a></td>
</tr>
</tbody>
</table>
<!--
## Container

Container security is outside the scope of this guide. Here are general recommendations and
links to explore this topic:

Area of Concern for Containers | Recommendation |
------------------------------ | -------------- |
Container Vulnerability Scanning and OS Dependency Security | As part of an image build step, you should scan your containers for known vulnerabilities.
Image Signing and Enforcement | Sign container images to maintain a system of trust for the content of your containers.
Disallow privileged users | When constructing containers, consult your documentation for how to create users inside of the containers that have the least level of operating system privilege necessary in order to carry out the goal of the container.
Use container runtime with stronger isolation | Select [container runtime classes](/docs/concepts/containers/runtime-class/) that provide stronger isolation
-->
<h2 id="容器">容器</h2>
<p>容器安全性不在本指南的探讨范围内。下面是一些探索此主题的建议和连接：</p>
<table>
<thead>
<tr>
<th>容器关注领域</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器漏洞扫描和操作系统依赖安全性</td>
<td>作为镜像构建的一部分，您应该扫描您的容器里的已知漏洞。</td>
</tr>
<tr>
<td>镜像签名和执行</td>
<td>对容器镜像进行签名，以维护对容器内容的信任。</td>
</tr>
<tr>
<td>禁止特权用户</td>
<td>构建容器时，请查阅文档以了解如何在具有最低操作系统特权级别的容器内部创建用户，以实现容器的目标。</td>
</tr>
<tr>
<td>使用带有较强隔离能力的容器运行时</td>
<td>选择提供较强隔离能力的<a href="/zh/docs/concepts/containers/runtime-class/">容器运行时类</a>。</td>
</tr>
</tbody>
</table>
<!--
## Code

Application code is one of the primary attack surfaces over which you have the most control.
While securing application code is outside of the Kubernetes security topic, here
are recommendations to protect application code:
-->
<h2 id="代码">代码</h2>
<p>应用程序代码是您最能够控制的主要攻击面之一，虽然保护应用程序代码不在 Kubernetes 安全主题范围内，但以下是保护应用程序代码的建议：</p>
<!--
### Code security






<table><caption style="display: none;">Code security</caption>
<thead>
<tr>
<th>Area of Concern for Code</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access over TLS only</td>
<td>If your code needs to communicate by TCP, perform a TLS handshake with the client ahead of time. With the exception of a few cases, encrypt everything in transit. Going one step further, it's a good idea to encrypt network traffic between services. This can be done through a process known as mutual TLS authentication or <a href="https://en.wikipedia.org/wiki/Mutual_authentication">mTLS</a> which performs a two sided verification of communication between two certificate holding services.</td>
</tr>
<tr>
<td>Limiting port ranges of communication</td>
<td>This recommendation may be a bit self-explanatory, but wherever possible you should only expose the ports on your service that are absolutely essential for communication or metric gathering.</td>
</tr>
<tr>
<td>3rd Party Dependency Security</td>
<td>It is a good practice to regularly scan your application's third party libraries for known security vulnerabilities. Each programming language has a tool for performing this check automatically.</td>
</tr>
<tr>
<td>Static Code Analysis</td>
<td>Most languages provide a way for a snippet of code to be analyzed for any potentially unsafe coding practices. Whenever possible you should perform checks using automated tooling that can scan codebases for common security errors. Some of the tools can be found at: <a href="https://owasp.org/www-community/Source_Code_Analysis_Tools">https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td>
</tr>
<tr>
<td>Dynamic probing attacks</td>
<td>There are a few automated tools that you can run against your service to try some of the well known service attacks. These include SQL injection, CSRF, and XSS. One of the most popular dynamic analysis tools is the <a href="https://owasp.org/www-project-zap/">OWASP Zed Attack proxy</a> tool.</td>
</tr>
</tbody>
</table>

-->
<h3 id="代码安全性">代码安全性</h3>





<table><caption style="display: none;">代码安全</caption>
<thead>
<tr>
<th>代码关注领域</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td>仅通过 TLS 访问</td>
<td>如果您的代码需要通过 TCP 通信，请提前与客户端执行 TLS 握手。除少数情况外，请加密传输中的所有内容。更进一步，加密服务之间的网络流量是一个好主意。这可以通过被称为双向 TLS 或 <a href="https://en.wikipedia.org/wiki/Mutual_authentication">mTLS</a> 的过程来完成，该过程对两个证书持有服务之间的通信执行双向验证。</td>
</tr>
<tr>
<td>限制通信端口范围</td>
<td>此建议可能有点不言自明，但是在任何可能的情况下，你都只应公开服务上对于通信或度量收集绝对必要的端口。</td>
</tr>
<tr>
<td>第三方依赖性安全</td>
<td>最好定期扫描应用程序的第三方库以了解已知的安全漏洞。每种编程语言都有一个自动执行此检查的工具。</td>
</tr>
<tr>
<td>静态代码分析</td>
<td>大多数语言都提供给了一种方法，来分析代码段中是否存在潜在的不安全的编码实践。只要有可能，你都应该使用自动工具执行检查，该工具可以扫描代码库以查找常见的安全错误，一些工具可以在以下连接中找到：https://owasp.org/www-community/Source_Code_Analysis_Tools</td>
</tr>
<tr>
<td>动态探测攻击</td>
<td>您可以对服务运行一些自动化工具，来尝试一些众所周知的服务攻击。这些攻击包括 SQL 注入、CSRF 和 XSS。<a href="https://owasp.org/www-project-zap/">OWASP Zed Attack</a> 代理工具是最受欢迎的动态分析工具之一。</td>
</tr>
</tbody>
</table>

<h2 id="what-s-next">What's next</h2>
<!--
Learn about related Kubernetes security topics:

* [Pod security standards](/docs/concepts/security/pod-security-standards/)
* [Network policies for Pods](/docs/concepts/services-networking/network-policies/)
* [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access)
* [Securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/)
* [Data encryption in transit](/docs/tasks/tls/managing-tls-in-a-cluster/) for the control plane
* [Data encryption at rest](/docs/tasks/administer-cluster/encrypt-data/)
* [Secrets in Kubernetes](/docs/concepts/configuration/secret/)
* [Runtime class](/docs/concepts/containers/runtime-class)
-->
<p>学习了解相关的 Kubernetes 安全主题：</p>
<ul>
<li><a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全标准</a></li>
<li><a href="/zh/docs/concepts/services-networking/network-policies/">Pod 的网络策略</a></li>
<li><a href="/zh/docs/concepts/security/controlling-access/">控制对 Kubernetes API 的访问</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/securing-a-cluster/">保护您的集群</a></li>
<li>为控制面<a href="/zh/docs/tasks/tls/managing-tls-in-a-cluster/">加密通信中的数据</a></li>
<li><a href="/zh/docs/tasks/administer-cluster/encrypt-data/">加密静止状态的数据</a></li>
<li><a href="/zh/docs/concepts/configuration/secret/">Kubernetes 中的 Secret</a></li>
<li><a href="/zh/docs/concepts/containers/runtime-class">运行时类</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1fb24c1dd155f43849da490a74c4b8c5">2 - Pod 安全性标准</h1>
    
	<!--
reviewers:
- tallclair
title: Pod Security Standards
content_type: concept
weight: 10
-->
<!-- overview -->
<!--
The Pod Security Standards define three different _policies_ to broadly cover the security
spectrum. These policies are _cumulative_ and range from highly-permissive to highly-restrictive.
This guide outlines the requirements of each policy.

| Profile | Description |
| ------ | ----------- |
| <strong style="white-space: nowrap">Privileged</strong> | Unrestricted policy, providing the widest possible level of permissions. This policy allows for known privilege escalations. |
| <strong style="white-space: nowrap">Baseline</strong> | Minimally restrictive policy which prevents known privilege escalations. Allows the default (minimally specified) Pod configuration. |
| <strong style="white-space: nowrap">Restricted</strong> | Heavily restricted policy, following current Pod hardening best practices. |
-->
<p>Pod 安全性标准定义了三种不同的 <em>策略（Policy）</em>，以广泛覆盖安全应用场景。
这些策略是 <em>渐进式的（Cumulative）</em>，安全级别从高度宽松至高度受限。
本指南概述了每个策略的要求。</p>
<table>
<thead>
<tr>
<th>Profile</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong style="white-space: nowrap">Privileged</strong></td>
<td>不受限制的策略，提供最大可能范围的权限许可。此策略允许已知的特权提升。</td>
</tr>
<tr>
<td><strong style="white-space: nowrap">Baseline</strong></td>
<td>限制性最弱的策略，禁止已知的策略提升。允许使用默认的（规定最少）Pod 配置。</td>
</tr>
<tr>
<td><strong style="white-space: nowrap">Restricted</strong></td>
<td>限制性非常强的策略，遵循当前的保护 Pod 的最佳实践。</td>
</tr>
</tbody>
</table>
<!-- body -->
<!--
## Profile Details

### Privileged
-->
<h2 id="profile-details">Profile 细节   </h2>
<h3 id="privileged">Privileged</h3>
<!--
**The _Privileged_ policy is purposely-open, and entirely unrestricted.** This type of policy is
typically aimed at system- and infrastructure-level workloads managed by privileged, trusted users.

The privileged policy is defined by an absence of restrictions. For allow-by-default enforcement
mechanisms (such as gatekeeper), the privileged profile may be an absence of applied constraints
rather than an instantiated policy. In contrast, for a deny-by-default mechanism (such as Pod
Security Policy) the privileged policy should enable all controls (disable all restrictions).
-->
<p><strong><em>Privileged</em> 策略是有目的地开放且完全无限制的策略。</strong>
此类策略通常针对由特权较高、受信任的用户所管理的系统级或基础设施级负载。</p>
<p>Privileged 策略定义中限制较少。对于默认允许（Allow-by-default）实施机制（例如 gatekeeper），
Privileged 框架可能意味着不应用任何约束而不是实施某策略实例。
与此不同，对于默认拒绝（Deny-by-default）实施机制（如 Pod 安全策略）而言，
Privileged 策略应该默认允许所有控制（即，禁止所有限制）。</p>
<h3 id="baseline">Baseline</h3>
<!--
**The _Baseline_ policy is aimed at ease of adoption for common containerized workloads while
preventing known privilege escalations.** This policy is targeted at application operators and
developers of non-critical applications. The following listed controls should be
enforced/disallowed:
-->
<p><strong><em>Baseline</em> 策略的目标是便于常见的容器化应用采用，同时禁止已知的特权提升。</strong>
此策略针对的是应用运维人员和非关键性应用的开发人员。
下面列举的控制应该被实施（禁止）：</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
In this table, wildcards (`*`) indicate all elements in a list. For example,
`spec.containers[*].securityContext` refers to the Security Context object for _all defined
containers_. If any of the listed containers fails to meet the requirements, the entire pod will
fail validation.
-->
<p>在下述表格中，通配符（<code>*</code>）意味着一个列表中的所有元素。
例如 <code>spec.containers[*].securityContext</code> 表示 <em>所定义的所有容器</em> 的安全性上下文对象。
如果所列出的任一容器不能满足要求，整个 Pod 将无法通过校验。
</div>
<table>
	<!-- caption style="display:none">Baseline policy specification</caption -->
	<caption style="display:none">Baseline 策略规范</caption>
	<tbody>
		<tr>
			<td>控制（Control）</td>
			<td>策略（Policy）</td>
		</tr>
    <tr>
			<!-- <td style="white-space: nowrap">HostProcess</td> -->
      <td style="white-space: nowrap">HostProcess</td>
      <!-- <td>
				<p>Windows pods offer the ability to run <a href="/docs/tasks/configure-pod-container/create-hostprocess-pod">HostProcess containers</a> which enables privileged access to the Windows node. Privileged access to the host is disallowed in the baseline policy. HostProcess pods are an <strong>alpha</strong> feature as of Kubernetes <strong>v1.22</strong>.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.containers[*].securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.initContainers[*].securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.windowsOptions.hostProcess</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>false</code></li>
				</ul>
			</td> -->
			<td>
				<p>Windows Pod 提供了运行
         <a href="/zh/docs/tasks/configure-pod-container/create-hostprocess-pod">HostProcess 容器</a> 的能力，
         这使得对 Windows 节点的特权访问成为可能。 
         基线策略中对宿主的特权访问是被禁止的。 
         HostProcess Pod 是 Kubernetes <strong>v1.22</strong> 版本的
          <strong>alpha</strong> 特性。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.containers[*].securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.initContainers[*].securityContext.windowsOptions.hostProcess</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.windowsOptions.hostProcess</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>false</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">Host Namespaces</td> -->
			<td style="white-space: nowrap">宿主名字空间</td>
			<!-- 
      <td>
				<p>Sharing the host namespaces must be disallowed.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.hostNetwork</code></li>
					<li><code>spec.hostPID</code></li>
					<li><code>spec.hostIPC</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>false</code></li>
				</ul>
			</td>
      -->
			<td>
        <p>必须禁止共享宿主名字空间。</p>
        <p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.hostNetwork</code></li>
					<li><code>spec.hostPID</code></li>
					<li><code>spec.hostIPC</code></li>
				</ul>
        <p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>false</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">Privileged Containers</td> -->
			<td style="white-space: nowrap">特权容器</td>
			<!-- <td>
				<p>Privileged Pods disable most security mechanisms and must be disallowed.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.privileged</code></li>
					<li><code>spec.initContainers[*].securityContext.privileged</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.privileged</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>false</code></li>
				</ul>
			</td> -->
			<td>
        <p>特权 Pod 关闭了大多数安全性机制，必须被禁止。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.privileged</code></li>
					<li><code>spec.initContainers[*].securityContext.privileged</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.privileged</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>false</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">Capabilities</td> -->
			<td style="white-space: nowrap">权能</td>
			<!-- <td>
				<p>Adding additional capabilities beyond those listed below must be disallowed.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>AUDIT_WRITE</code></li>
					<li><code>CHOWN</code></li>
					<li><code>DAC_OVERRIDE</code></li>
					<li><code>FOWNER</code></li>
					<li><code>FSETID</code></li>
					<li><code>KILL</code></li>
					<li><code>MKNOD</code></li>
					<li><code>NET_BIND_SERVICE</code></li>
					<li><code>SETFCAP</code></li>
					<li><code>SETGID</code></li>
					<li><code>SETPCAP</code></li>
					<li><code>SETUID</code></li>
					<li><code>SYS_CHROOT</code></li>
				</ul>
			</td> -->
			<td>
        <p>必须禁止添加除下列字段之外的权能。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>AUDIT_WRITE</code></li>
					<li><code>CHOWN</code></li>
					<li><code>DAC_OVERRIDE</code></li>
					<li><code>FOWNER</code></li>
					<li><code>FSETID</code></li>
					<li><code>KILL</code></li>
					<li><code>MKNOD</code></li>
					<li><code>NET_BIND_SERVICE</code></li>
					<li><code>SETFCAP</code></li>
					<li><code>SETGID</code></li>
					<li><code>SETPCAP</code></li>
					<li><code>SETUID</code></li>
					<li><code>SYS_CHROOT</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">HostPath Volumes</td>-->
			<td style="white-space: nowrap">HostPath 卷</td>
			<!-- <td>
				<p>HostPath volumes must be forbidden.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.volumes[*].hostPath</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
				</ul>
			</td> -->
			<td>
        <p>必须禁止 HostPath 卷。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.volumes[*].hostPath</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">Host Ports</td> -->
			<td style="white-space: nowrap">宿主端口</td>
			<!-- <td>
				<p>HostPorts should be disallowed, or at minimum restricted to a known list.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].ports[*].hostPort</code></li>
					<li><code>spec.initContainers[*].ports[*].hostPort</code></li>
					<li><code>spec.ephemeralContainers[*].ports[*].hostPort</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li>Known list</li>
					<li><code>0</code></li>
				</ul>
			</td>-->
			<td>
        <p>应禁止使用宿主端口，或者至少限定为已知列表。</p>
        <p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].ports[*].hostPort</code></li>
					<li><code>spec.initContainers[*].ports[*].hostPort</code></li>
					<li><code>spec.ephemeralContainers[*].ports[*].hostPort</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li>已知列表</li>
					<li><code>0</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">AppArmor</td> -->
			<td style="white-space: nowrap">AppArmor</td>
			<!-- <td>
				<p>On supported hosts, the <code>runtime/default</code> AppArmor profile is applied by default. The baseline policy should prevent overriding or disabling the default AppArmor profile, or restrict overrides to an allowed set of profiles.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>metadata.annotations["container.apparmor.security.beta.kubernetes.io/*"]</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>runtime/default</code></li>
					<li><code>localhost/*</code></li>
				</ul>
			</td> -->
			<td>
        <p>在受支持的主机上，默认使用 <code>runtime/default</code> AppArmor Profile。
				基线策略应避免覆盖或者禁用默认策略，以及限制覆盖一些 Profile 集合的权限。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>metadata.annotations["container.apparmor.security.beta.kubernetes.io/*"]</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>runtime/default</code></li>
					<li><code>localhost/*</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">SELinux</td> -->
			<td style="white-space: nowrap">SELinux</td>
			<!-- <td>
				<p>Setting the SELinux type is restricted, and setting a custom SELinux user or role option is forbidden.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.type</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/""</li>
					<li><code>container_t</code></li>
					<li><code>container_init_t</code></li>
					<li><code>container_kvm_t</code></li>
				</ul>
				<hr />
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.role</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/""</li>
				</ul>
			</td>-->
			<td>
        <p>设置 SELinux 类型的操作是被限制的，设置自定义的 SELinux 用户或角色选项是被禁止的。</p>
        <p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.type</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/""</li>
					<li><code>container_t</code></li>
					<li><code>container_init_t</code></li>
					<li><code>container_kvm_t</code></li>
				</ul>
				<hr />
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.user</code></li>
					<li><code>spec.securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.containers[*].securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.initContainers[*].securityContext.seLinuxOptions.role</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seLinuxOptions.role</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/""</li>
				</ul>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap"><code>/proc</code> Mount Type</td> -->
			<td style="white-space: nowrap"><code>/proc</code> 挂载类型</td>
			<!-- <td>
				<p>The default <code>/proc</code> masks are set up to reduce attack surface, and should be required.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.procMount</code></li>
					<li><code>spec.initContainers[*].securityContext.procMount</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.procMount</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>Default</code></li>
				</ul>
			</td> -->
			<td>
        <p>要求使用默认的 <code>/proc</code> 掩码以减小攻击面。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.procMount</code></li>
					<li><code>spec.initContainers[*].securityContext.procMount</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.procMount</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>Default</code></li>
				</ul>
			</td>
		</tr>
    <tr>
  			<td>Seccomp</td>
  			<!-- <td>
  				<p>Seccomp profile must not be explicitly set to <code>Unconfined</code>.</p>
  				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.seccompProfile.type</code></li>
					<li><code>spec.containers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>RuntimeDefault</code></li>
					<li><code>Localhost</code></li>
				</ul>
  			</td> -->
        <td>
  				<p>Seccomp Profile 禁止被显式设置为 <code>Unconfined</code>。</p>
  				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.seccompProfile.type</code></li>
					<li><code>spec.containers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>RuntimeDefault</code></li>
					<li><code>Localhost</code></li>
				</ul>
  			</td>
  		</tr>
		<tr>
			<td>Sysctls</td>
			<!-- <td>
				<p>Sysctls can disable security mechanisms or affect all containers on a host, and should be disallowed except for an allowed "safe" subset. A sysctl is considered safe if it is namespaced in the container or the Pod, and it is isolated from other Pods or processes on the same Node.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.sysctls[*].name</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>kernel.shm_rmid_forced</code></li>
					<li><code>net.ipv4.ip_local_port_range</code></li>
					<li><code>net.ipv4.ip_unprivileged_port_start</code></li>
					<li><code>net.ipv4.tcp_syncookies</code></li>
					<li><code>net.ipv4.ping_group_range</code></li>
				</ul>
			</td> -->
			<td>
        <p>Sysctls 可以禁用安全机制或影响宿主上所有容器，因此除了若干“安全”的子集之外，应该被禁止。
				如果某 sysctl 是受容器或 Pod 的名字空间限制，且与节点上其他 Pod 或进程相隔离，可认为是安全的。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.sysctls[*].name</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>kernel.shm_rmid_forced</code></li>
					<li><code>net.ipv4.ip_local_port_range</code></li>
					<li><code>net.ipv4.ip_unprivileged_port_start</code></li>
					<li><code>net.ipv4.tcp_syncookies</code></li>
					<li><code>net.ipv4.ping_group_range</code></li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>
<h3 id="restricted">Restricted</h3>
<!--
**The _Restricted_ policy is aimed at enforcing current Pod hardening best practices, at the
expense of some compatibility.** It is targeted at operators and developers of security-critical
applications, as well as lower-trust users. The following listed controls should be
enforced/disallowed:

In this table, wildcards (`*`) indicate all elements in a list. For example, 
`spec.containers[*].securityContext` refers to the Security Context object for _all defined
containers_. If any of the listed containers fails to meet the requirements, the entire pod will
fail validation.
-->
<p><strong><em>Restricted</em> 策略旨在实施当前保护 Pod 的最佳实践，尽管这样作可能会牺牲一些兼容性。</strong>
该类策略主要针对运维人员和安全性很重要的应用的开发人员，以及不太被信任的用户。
下面列举的控制需要被实施（禁止）：</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 在下述表格中，通配符（<code>*</code>）意味着一个列表中的所有元素。
例如 <code>spec.containers[*].securityContext</code> 表示 <em>所定义的所有容器</em> 的安全性上下文对象。
如果所列出的任一容器不能满足要求，整个 Pod 将无法通过校验。
</div>
<table>
	<!-- caption style="display:none">Restricted policy specification</caption -->
	<caption style="display:none">Restricted 策略规范</caption>
	<tbody>
		<tr>
			<!-- td><strong>Control</strong></td -->
			<td width="30%"><strong>控制（Control）</strong></td>
			<!-- td><strong>Policy</strong></td -->
			<td><strong>策略（Policy）</strong></td>
		</tr>
		<tr>
			<!-- <td colspan="2"><em>Everything from the baseline profile.</em></td> -->
			<td colspan="2"><em>基线策略的所有要求。</em></td>
		</tr>
		<tr>
      <!-- <td style="white-space: nowrap">Volume Types</td>
			<td>
				<p>In addition to restricting HostPath volumes, the restricted policy limits usage of non-core volume types to those defined through PersistentVolumes.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.volumes[*]</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				Every item in the <code>spec.volumes[*]</code> list must set one of the following fields to a non-null value:
				<ul>
					<li><code>spec.volumes[*].configMap</code></li>
					<li><code>spec.volumes[*].csi</code></li>
					<li><code>spec.volumes[*].downwardAPI</code></li>
					<li><code>spec.volumes[*].emptyDir</code></li>
					<li><code>spec.volumes[*].ephemeral</code></li>
					<li><code>spec.volumes[*].persistentVolumeClaim</code></li>
					<li><code>spec.volumes[*].projected</code></li>
					<li><code>spec.volumes[*].secret</code></li>
				</ul>
			</td> -->
			<td>卷类型</td>
			<td>
        <p>除了限制 HostPath 卷之外，此类策略还限制可以通过 PersistentVolumes 定义的非核心卷类型。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.volumes[*]</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<code>spec.volumes[*]</code> 列表中的每个条目必须将下面字段之一设置为非空值：
				<ul>
					<li><code>spec.volumes[*].configMap</code></li>
					<li><code>spec.volumes[*].csi</code></li>
					<li><code>spec.volumes[*].downwardAPI</code></li>
					<li><code>spec.volumes[*].emptyDir</code></li>
					<li><code>spec.volumes[*].ephemeral</code></li>
					<li><code>spec.volumes[*].persistentVolumeClaim</code></li>
					<li><code>spec.volumes[*].projected</code></li>
					<li><code>spec.volumes[*].secret</code></li>
				</ul>
			</td>
		</tr>
		<tr>
      <!-- <td style="white-space: nowrap">Privilege Escalation (v1.8+)</td>
			<td>
				<p>Privilege escalation (such as via set-user-ID or set-group-ID file mode) should not be allowed.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.allowPrivilegeEscalation</code></li>
					<li><code>spec.initContainers[*].securityContext.allowPrivilegeEscalation</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li><code>false</code></li>
				</ul>
			</td> -->
			<td style="white-space: nowrap">特权提升（v1.8+）</td>
			<td>
        <p>禁止（通过 SetUID 或 SetGID 文件模式）获得特权提升。</p>
				<br>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.allowPrivilegeEscalation</code></li>
					<li><code>spec.initContainers[*].securityContext.allowPrivilegeEscalation</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li><code>false</code></li>
				</ul>
			</td>
		</tr>
		<tr>
      <!-- <td style="white-space: nowrap">Running as Non-root</td> -->
			<td style="white-space: nowrap">以非 root 账号运行 </td>
      <!-- <td>
				<p>Containers must be required to run as non-root users.</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.runAsNonRoot</code></li>
					<li><code>spec.containers[*].securityContext.runAsNonRoot</code></li>
					<li><code>spec.initContainers[*].securityContext.runAsNonRoot</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.runAsNonRoot</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li><code>true</code></li>
				</ul>
				<small>
					The container fields may be undefined/<code>nil</code> if the pod-level
					<code>spec.securityContext.runAsNonRoot</code> is set to <code>true</code>.
				</small>
			</td> -->
			<td>
        <p>必须要求容器以非 root 用户运行。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.runAsNonRoot</code></li>
					<li><code>spec.containers[*].securityContext.runAsNonRoot</code></li>
					<li><code>spec.initContainers[*].securityContext.runAsNonRoot</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.runAsNonRoot</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li><code>true</code></li>
				</ul>
				<small>
					如果 Pod 级别 <code>spec.securityContext.runAsNonRoot</code> 设置为 
          <code>true</code>，则允许容器组的安全上下文字段设置为 未定义/<code>nil</code>。
				</small>
			</td>
		</tr>
		<tr>
			<!-- <td style="white-space: nowrap">Running as Non-root user (v1.23+)</td> -->
			<td style="white-space: nowrap">非 root 用户（v1.23+）</td>
			<td>
				<!--
				<p>Containers must not set <tt>runAsUser</tt> to 0</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.runAsUser</code></li>
					<li><code>spec.containers[*].securityContext.runAsUser</code></li>
					<li><code>spec.initContainers[*].securityContext.runAsUser</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.runAsUser</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>any non-zero value</li>
					<li><code>undefined/null</code></li>
				</ul>
			</td> -->
				<p>Containers 不可以将 <tt>runAsUser</tt> 设置为 0</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.runAsUser</code></li>
					<li><code>spec.containers[*].securityContext.runAsUser</code></li>
					<li><code>spec.initContainers[*].securityContext.runAsUser</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.runAsUser</code></li>
				</ul>
				<p><strong>允许的字段</strong></p>
				<ul>
					<li>any non-zero value</li>
					<li><code>未定义/空值</code></li>
				</ul>
			</td>
		</tr>
		<tr>
			<td style="white-space: nowrap">Seccomp (v1.19+)</td>
			<td>
				<!-- <td>
  				<p>Seccomp profile must be explicitly set to one of the allowed values. Both the <code>Unconfined</code> profile and the <em>absence</em> of a profile are prohibited.</p>
  				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.securityContext.seccompProfile.type</code></li>
					<li><code>spec.containers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li><code>RuntimeDefault</code></li>
					<li><code>Localhost</code></li>
				</ul>
				<small>
					The container fields may be undefined/<code>nil</code> if the pod-level
					<code>spec.securityContext.seccompProfile.type</code> field is set appropriately.
					Conversely, the pod-level field may be undefined/<code>nil</code> if _all_ container-
					level fields are set.
				</small>
  			</td> -->
        <p>Seccomp Profile 必须被显式设置成一个允许的值。禁止使用 <code>Unconfined</code> 
        Profile 或者指定 <em>不存在的</em> Profile。</p>
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.securityContext.seccompProfile.type</code></li>
					<li><code>spec.containers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li><code>RuntimeDefault</code></li>
					<li><code>Localhost</code></li>
				</ul>
				<small>
					如果 Pod 级别的 <code>spec.securityContext.seccompProfile.type</code> 
          已设置得当，容器级别的安全上下文字段可以为 未定义/<code>nil</code>。
          反过来说，如果 _所有的_ 容器级别的安全上下文字段已设置，则 Pod 级别的字段可为 未定义/<code>nil</code>。 
				</small>
			</td>
		</tr>
    <tr>
			<!-- <td style="white-space: nowrap">Capabilities (v1.22+)</td> -->
      <td style="white-space: nowrap">权能（v1.22+）</td>
      <!-- <td>
				<p>
					Containers must drop <code>ALL</code> capabilities, and are only permitted to add back
					the <code>NET_BIND_SERVICE</code> capability.
				</p>
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.drop</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.drop</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.drop</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Any list of capabilities that includes <code>ALL</code></li>
				</ul>
				<hr />
				<p><strong>Restricted Fields</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li>
				</ul>
				<p><strong>Allowed Values</strong></p>
				<ul>
					<li>Undefined/nil</li>
					<li><code>NET_BIND_SERVICE</code></li>
				</ul>
			</td> -->
			<td>
        <p>
					容器组必须弃用 <code>ALL</code> 权能，并且只允许添加 <code>NET_BIND_SERVICE</code> 权能。
				</p>
        <p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.drop</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.drop</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.drop</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>包含 <code>ALL</code> 的任何一种权能列表。</li>
				</ul>
				<hr />
				<p><strong>限制的字段</strong></p>
				<ul>
					<li><code>spec.containers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.initContainers[*].securityContext.capabilities.add</code></li>
					<li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li>
				</ul>
				<p><strong>允许的值</strong></p>
				<ul>
					<li>未定义/nil</li>
					<li><code>NET_BIND_SERVICE</code></li>
				</ul>
			</td>
		</tr>
	</tbody>
</table>
<!--
## Policy Instantiation

Decoupling policy definition from policy instantiation allows for a common understanding and
consistent language of policies across clusters, independent of the underlying enforcement
mechanism.

As mechanisms mature, they will be defined below on a per-policy basis. The methods of enforcement
of individual policies are not defined here.
-->
<h2 id="policy-instantiation">策略实例化  </h2>
<p>将策略定义从策略实例中解耦出来有助于形成跨集群的策略理解和语言陈述，
以免绑定到特定的下层实施机制。</p>
<p>随着相关机制的成熟，这些机制会按策略分别定义在下面。特定策略的实施方法不在这里定义。</p>
<p><a href="/zh/docs/concepts/security/pod-security-admission/"><strong>Pod 安全性准入控制器</strong></a></p>
<ul>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-privileged.yaml" download="security/podsecurity-privileged.yaml">Privileged 名字空间</a>
</li>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-baseline.yaml" download="security/podsecurity-baseline.yaml">Baseline 名字空间</a>
</li>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/security/podsecurity-restricted.yaml" download="security/podsecurity-restricted.yaml">Restricted 名字空间</a>
</li>
</ul>
<p><a href="/zh/docs/concepts/security/pod-security-policy/"><strong>PodSecurityPolicy</strong></a> （已弃用）</p>
<ul>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/privileged-psp.yaml" download="policy/privileged-psp.yaml">Privileged</a>
</li>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/baseline-psp.yaml" download="policy/baseline-psp.yaml">Baseline</a>
</li>
<li>






<a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/restricted-psp.yaml" download="policy/restricted-psp.yaml">Restricted</a>
</li>
</ul>
<!--
## FAQ

### Why isn't there a profile between privileged and baseline?
-->
<h2 id="faq">常见问题   </h2>
<h3 id="为什么不存在介于-privileged-和-baseline-之间的策略类型">为什么不存在介于 Privileged 和 Baseline 之间的策略类型</h3>
<!--
The three profiles defined here have a clear linear progression from most secure (restricted) to least
secure (privileged), and cover a broad set of workloads. Privileges required above the baseline
policy are typically very application specific, so we do not offer a standard profile in this
niche. This is not to say that the privileged profile should always be used in this case, but that
policies in this space need to be defined on a case-by-case basis.

SIG Auth may reconsider this position in the future, should a clear need for other profiles arise.
-->
<p>这里定义的三种策略框架有一个明晰的线性递进关系，从最安全（Restricted）到最不安全，
并且覆盖了很大范围的工作负载。特权要求超出 Baseline 策略者通常是特定于应用的需求，
所以我们没有在这个范围内提供标准框架。
这并不意味着在这样的情形下仍然只能使用 Privileged 框架，只是说处于这个范围的
策略需要因地制宜地定义。</p>
<p>SIG Auth 可能会在将来考虑这个范围的框架，前提是有对其他框架的需求。</p>
<!--
### What's the difference between a security policy and a security context?

[Security Contexts](/docs/tasks/configure-pod-container/security-context/) configure Pods and
Containers at runtime. Security contexts are defined as part of the Pod and container specifications
in the Pod manifest, and represent parameters to the container runtime.
-->
<h3 id="安全策略与安全上下文的区别是什么">安全策略与安全上下文的区别是什么？</h3>
<p><a href="/zh/docs/tasks/configure-pod-container/security-context/">安全上下文</a>在运行时配置 Pod
和容器。安全上下文是在 Pod 清单中作为 Pod 和容器规约的一部分来定义的，所代表的是
传递给容器运行时的参数。</p>
<!--
Security profiles are control plane mechanisms to enforce specific settings in the Security Context,
as well as other related parameters outside the Security Context. As of July 2021, 
[Pod Security Policies](/docs/concepts/security/pod-security-policy/) are deprecated in favor of the
built-in [Pod Security Admission Controller](/docs/concepts/security/pod-security-admission/). 

Other alternatives for enforcing security profiles are being developed in the Kubernetes
ecosystem, such as: 
- [OPA Gatekeeper](https://github.com/open-policy-agent/gatekeeper).
- [Kubewarden](https://github.com/kubewarden).
- [Kyverno](https://kyverno.io/policies/pod-security/).
-->
<p>安全策略则是控制面用来对安全上下文以及安全性上下文之外的参数实施某种设置的机制。
在 2020 年 7 月，
<a href="/zh/docs/concepts/security/pod-security-policy/">Pod 安全性策略</a>已被废弃，
取而代之的是内置的 <a href="/zh/docs/concepts/security/pod-security-admission/">Pod 安全性准入控制器</a>。</p>
<p>Kubernetes 生态系统中还在开发一些其他的替代方案，例如</p>
<ul>
<li><a href="https://github.com/open-policy-agent/gatekeeper">OPA Gatekeeper</a>。</li>
<li><a href="https://github.com/kubewarden">Kubewarden</a>。</li>
<li><a href="https://kyverno.io/policies/pod-security/">Kyverno</a>。</li>
</ul>
<!--
### What profiles should I apply to my Windows Pods?

Windows in Kubernetes has some limitations and differentiators from standard Linux-based
workloads. Specifically, the Pod SecurityContext fields [have no effect on
Windows](/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext). As
such, no standardized Pod Security profiles currently exists.
-->
<h3 id="我应该为我的-windows-pod-实施哪种框架">我应该为我的 Windows Pod 实施哪种框架？</h3>
<p>Kubernetes 中的 Windows 负载与标准的基于 Linux 的负载相比有一些局限性和区别。
尤其是 Pod SecurityContext 字段
<a href="/zh/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext">对 Windows 不起作用</a>。
因此，目前没有对应的标准 Pod 安全性框架。</p>
<!-- 
If you apply the restricted profile for a Windows pod, this **may** have an impact on the pod
at runtime. The restricted profile requires enforcing Linux-specific restrictions (such as seccomp
profile, and disallowing privilege escalation). If the kubelet and / or its container runtime ignore
these Linux-specific values, then the Windows pod should still work normally within the restricted
profile. However, the lack of enforcement means that there is no additional restriction, for Pods
that use Windows containers, compared to the baseline profile.

The use of the HostProcess flag to create a HostProcess pod should only be done in alignment with the privileged policy. Creation of a Windows HostProcess pod is blocked under the baseline and restricted policies, so any HostProcess pod should be considered privileged.
-->
<p>如果你为一个 Windows Pod 应用了 Restricted 策略，<strong>可能会</strong> 对该 Pod 的运行时产生影响。
Restricted 策略需要强制执行 Linux 特有的限制（如 seccomp Profile，并且禁止特权提升）。
如果 kubelet 和/或其容器运行时忽略了 Linux 特有的值，那么应该不影响 Windows Pod 正常工作。
然而，对于使用 Windows 容器的 Pod 来说，缺乏强制执行意味着相比于 Restricted 策略，没有任何额外的限制。</p>
<p>你应该只在 Privileged 策略下使用 HostProcess 标志来创建 HostProcess Pod。
在 Baseline 和 Restricted 策略下，创建 Windows HostProcess Pod 是被禁止的，
因此任何 HostProcess Pod 都应该被认为是有特权的。</p>
<!--
### What about sandboxed Pods?

There is not currently an API standard that controls whether a Pod is considered sandboxed or
not. Sandbox Pods may be identified by the use of a sandboxed runtime (such as gVisor or Kata
Containers), but there is no standard definition of what a sandboxed runtime is.

The protections necessary for sandboxed workloads can differ from others. For example, the need to
restrict privileged permissions is lessened when the workload is isolated from the underlying
kernel. This allows for workloads requiring heightened permissions to still be isolated.

Additionally, the protection of sandboxed workloads is highly dependent on the method of
sandboxing. As such, no single recommended policy is recommended for all sandboxed workloads.
-->
<h3 id="沙箱-sandboxed-pod-怎么处理">沙箱（Sandboxed） Pod 怎么处理？</h3>
<p>现在还没有 API 标准来控制 Pod 是否被视作沙箱化 Pod。
沙箱 Pod 可以通过其是否使用沙箱化运行时（如 gVisor 或 Kata Container）来辨别，不过
目前还没有关于什么是沙箱化运行时的标准定义。</p>
<p>沙箱化负载所需要的保护可能彼此各不相同。例如，当负载与下层内核直接隔离开来时，
限制特权化操作的许可就不那么重要。这使得那些需要更多许可权限的负载仍能被有效隔离。</p>
<p>此外，沙箱化负载的保护高度依赖于沙箱化的实现方法。
因此，现在还没有针对所有沙箱化负载的建议策略。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-bc9934fccfeaf880eec6ea79025c0381">3 - Pod 安全性准入</h1>
    <div class="lead">对 Pod 安全性准入控制器的概述，Pod 安全性准入控制器可以实施 Pod 安全性标准。</div>
	<!--
reviewers:
- tallclair
- liggitt
title: Pod Security Admission
description: >
  An overview of the Pod Security Admission Controller, which can enforce the Pod Security
  Standards.
content_type: concept
weight: 20
min-kubernetes-server-version: v1.22
-->
<!-- overview -->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code>
</div>


<!--
The Kubernetes [Pod Security Standards](/docs/concepts/security/pod-security-standards/) define
different isolation levels for Pods. These standards let you define how you want to restrict the
behavior of pods in a clear, consistent fashion.
-->
<p>Kubernetes <a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全性标准（Security Standards）</a>
为 Pod 定义不同的隔离级别。这些标准能够让你以一种清晰、一致的方式定义如何限制 Pod 行为。</p>
<!--
As a Beta feature, Kubernetes offers a built-in _Pod Security_ <a class='glossary-tooltip' title='在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/access-authn-authz/admission-controllers/' target='_blank' aria-label='admission controller'>admission controller</a>, the successor
to [PodSecurityPolicies](/docs/concepts/security/pod-security-policy/). Pod security restrictions
are applied at the <a class='glossary-tooltip' title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='namespace'>namespace</a> level when pods
are created.
-->
<p>作为一项 Beta 功能特性，Kubernetes 提供一种内置的 <em>Pod 安全性</em>
<a class='glossary-tooltip' title='在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/access-authn-authz/admission-controllers/' target='_blank' aria-label='准入控制器'>准入控制器</a>，
作为 <a href="/zh/docs/concepts/security/pod-security-policy/">PodSecurityPolicies</a>
特性的后继演化版本。Pod 安全性限制是在 Pod 被创建时在
<a class='glossary-tooltip' title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/namespaces/' target='_blank' aria-label='名字空间'>名字空间</a>层面实施的。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The PodSecurityPolicy API is deprecated and will be 
[removed](/docs/reference/using-api/deprecation-guide/#v1-25) from Kubernetes in v1.25.
-->
<p>PodSecurityPolicy API 已经被废弃，会在 Kubernetes v1.25 发行版中
<a href="/zh/docs/reference/using-api/deprecation-guide/#v1-25">移除</a>。
</div>
<!-- body -->
<!--
## Enabling the `PodSecurity` admission plugin

In v1.23, the `PodSecurity` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
is a Beta feature and is enabled by default.

In v1.22, the `PodSecurity` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
is an Alpha feature and must be enabled in `kube-apiserver` in order to use the built-in admission plugin.
-->
<h2 id="enabling-the-podsecurity-admission-plugin">启用 <code>PodSecurity</code> 准入插件  </h2>
<p>在 v1.23 中，<code>PodSecurity</code> <a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>
是一项 Beta 功能特性，默认被启用。</p>
<p>在 v1.22 中，<code>PodSecurity</code> <a href="/zh/docs/reference/command-line-tools-reference/feature-gates/">特性门控</a>
是一项 Alpha 功能特性，必须在 <code>kube-apiserver</code> 上启用才能使用内置的准入插件。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">--feature-gates<span style="color:#666">=</span><span style="color:#b44">&#34;...,PodSecurity=true&#34;</span>
</code></pre></div><!--
## Alternative: installing the `PodSecurity` admission webhook {#webhook}

For environments where the built-in `PodSecurity` admission plugin cannot be used,
either because the cluster is older than v1.22, or the `PodSecurity` feature cannot be enabled,
the `PodSecurity` admission logic is also available as a Beta [validating admission webhook](https://git.k8s.io/pod-security-admission/webhook).
-->
<h2 id="webhook">替代方案：安装 <code>PodSecurity</code> 准入 Webhook  </h2>
<p>对于无法应用内置 <code>PodSecurity</code> 准入插件的环境，无论是因为集群版本低于 v1.22，
或者 <code>PodSecurity</code> 特性无法被启用，都可以使用 Beta 版本的
<a href="https://git.k8s.io/pod-security-admission/webhook">验证性准入 Webhook</a>。
来使用 <code>PodSecurity</code> 准入逻辑。</p>
<!--
A pre-built container image, certificate generation scripts, and example manifests
are available at [https://git.k8s.io/pod-security-admission/webhook](https://git.k8s.io/pod-security-admission/webhook).

To install:
-->
<p>在 <a href="https://git.k8s.io/pod-security-admission/webhook">https://git.k8s.io/pod-security-admission/webhook</a>
上可以找到一个预先构建的容器镜像、证书生成脚本以及一些示例性质的清单。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">git clone git@github.com:kubernetes/pod-security-admission.git
<span style="color:#a2f">cd</span> pod-security-admission/webhook
make certs
kubectl apply -k .
</code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
The generated certificate is valid for 2 years. Before it expires,
regenerate the certificate or remove the webhook in favor of the built-in admission plugin.
-->
<p>所生成的证书合法期限为 2 年。在证书过期之前，
需要重新生成证书或者去掉 Webhook 以使用内置的准入查件。
</div>
<!--
## Pod Security levels
-->
<h2 id="pod-security-levels">Pod 安全性级别  </h2>
<!--
Pod Security admission places requirements on a Pod's [Security
Context](/docs/tasks/configure-pod-container/security-context/) and other related fields according
to the three levels defined by the [Pod Security
Standards](/docs/concepts/security/pod-security-standards): `privileged`, `baseline`, and
`restricted`. Refer to the [Pod Security Standards](/docs/concepts/security/pod-security-standards)
page for an in-depth look at those requirements.
-->
<p>Pod 安全性准入插件对 Pod 的<a href="/zh/docs/tasks/configure-pod-container/security-context/">安全性上下文</a>
有一定的要求，并且依据 <a href="/zh/docs/concepts/security/pod-security-standards">Pod 安全性标准</a>
所定义的三个级别（<code>privileged</code>、<code>baseline</code> 和 <code>restricted</code>）对其他字段也有要求。
关于这些需求的更进一步讨论，请参阅
<a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全性标准</a>页面。</p>
<!--
## Pod Security Admission labels for namespaces

Once the feature is enabled or the webhook is installed, you can configure namespaces to define the admission
control mode you want to use for pod security in each namespace. Kubernetes defines a set of 
<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='labels'>labels</a> that you can set to define which of the 
predefined Pod Security Standard levels you want to use for a namespace. The label you select
defines what action the <a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='control plane'>control plane</a>
takes if a potential violation is detected:
-->
<h2 id="为名字空间设置-pod-安全性准入控制标签">为名字空间设置 Pod 安全性准入控制标签</h2>
<p>一旦特性被启用或者安装了 Webhook，你可以配置名字空间以定义每个名字空间中
Pod 安全性准入控制模式。
Kubernetes 定义了一组<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>，
你可以设置这些标签来定义某个名字空间上要使用的预定义的 Pod 安全性标准级别。
你所选择的标签定义了检测到潜在违例时，<a class='glossary-tooltip' title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-control-plane' target='_blank' aria-label='控制面'>控制面</a>
要采取什么样的动作。</p>
<!--





<table><caption style="display: none;">Pod Security Admission modes</caption>
<thead>
<tr>
<th style="text-align:left">Mode</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>enforce</strong></td>
<td style="text-align:left">Policy violations will cause the pod to be rejected.</td>
</tr>
<tr>
<td style="text-align:left"><strong>audit</strong></td>
<td style="text-align:left">Policy violations will trigger the addition of an audit annotation to the event recorded in the <a href="/docs/tasks/debug-application-cluster/audit/">audit log</a>, but are otherwise allowed.</td>
</tr>
<tr>
<td style="text-align:left"><strong>warn</strong></td>
<td style="text-align:left">Policy violations will trigger a user-facing warning, but are otherwise allowed.</td>
</tr>
</tbody>
</table>

-->





<table><caption style="display: none;">Pod 安全准入模式</caption>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>enforce</strong></td>
<td style="text-align:left">策略违例会导致 Pod 被拒绝</td>
</tr>
<tr>
<td style="text-align:left"><strong>audit</strong></td>
<td style="text-align:left">策略违例会触发<a href="/zh/docs/tasks/debug-application-cluster/audit/">审计日志</a>中记录新事件时添加审计注解；但是 Pod 仍是被接受的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>warn</strong></td>
<td style="text-align:left">策略违例会触发用户可见的警告信息，但是 Pod 仍是被接受的。</td>
</tr>
</tbody>
</table>

<!--
A namespace can configure any or all modes, or even set a different level for different modes.

For each mode, there are two labels that determine the policy used:
-->
<p>名字空间可以配置任何一种或者所有模式，或者甚至为不同的模式设置不同的级别。</p>
<p>对于每种模式，决定所使用策略的标签有两个：</p>
<!--
# The per-mode level label indicates which policy level to apply for the mode.
#
# MODE must be one of `enforce`, `audit`, or `warn`.
# LEVEL must be one of `privileged`, `baseline`, or `restricted`.
pod-security.kubernetes.io/<MODE>: <LEVEL>

# Optional: per-mode version label that can be used to pin the policy to the
# version that shipped with a given Kubernetes minor version (for example v1.23).
#
# MODE must be one of `enforce`, `audit`, or `warn`.
# VERSION must be a valid Kubernetes minor version, or `latest`.
pod-security.kubernetes.io/<MODE>-version: <VERSION>
-->
<pre><code># 针对模式的级别标签用来标示针对该模式所应用的策略级别
#
# MODE 必须是 `enforce`、`audit` 或 `warn` 之一
# LEVEL 必须是 `privileged`、baseline` 或 `restricted` 之一
pod-security.kubernetes.io/&lt;MODE&gt;: &lt;LEVEL&gt;

# 可选：针对每个模式版本的版本标签可以将策略锁定到
# 给定 Kubernetes 小版本号所附带的版本（例如 v1.23）
#
# MODE 必须是 `enforce`、`audit` 或 `warn` 之一
# VERSION 必须是一个合法的 Kubernetes 小版本号或者 `latest`
pod-security.kubernetes.io/&lt;MODE&gt;-version: &lt;VERSION&gt;
</code></pre><!--
Check out [Enforce Pod Security Standards with Namespace Labels](/docs/tasks/configure-pod-container/enforce-standards-namespace-labels) to see example usage.
-->
<p>关于用法示例，可参阅
<a href="/zh/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/">使用名字空间标签来强制实施 Pod 安全标准</a>。</p>
<!--
## Workload resources and Pod templates

Pods are often created indirectly, by creating a [workload
object](/docs/concepts/workloads/controllers/) such as a <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployment'>Deployment</a> or <a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Job'>Job</a>. The workload object defines a
_Pod template_ and a <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a> for the
workload resource creates Pods based on that template. To help catch violations early, both the
audit and warning modes are applied to the workload resources. However, enforce mode is **not**
applied to workload resources, only to the resulting pod objects.
-->
<h2 id="workload-resources-and-pod-templates">负载资源和 Pod 模板   </h2>
<p>Pod 通常是通过创建 <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployment'>Deployment</a> 或
<a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Job'>Job</a> 这类<a href="/zh/docs/concepts/workloads/controllers/">工作负载对象</a>
来间接创建的。工作负载对象为工作负载资源定义一个 <em>Pod 模板</em> 和一个对应的
负责基于该模板来创建 Pod 的<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>。
为了尽早地捕获违例状况，<code>audit</code> 和 <code>warn</code> 模式都应用到负载资源。
不过，<code>enforce</code> 模式并 <strong>不</strong> 应用到工作负载资源，仅应用到所生成的 Pod 对象上。</p>
<!--
## Exemptions

You can define _exemptions_ from pod security enforcement in order to allow the creation of pods that
would have otherwise been prohibited due to the policy associated with a given namespace.
Exemptions can be statically configured in the
[Admission Controller configuration](/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller).
-->
<h2 id="exemptions">豁免  </h2>
<p>你可以为 Pod 安全性的实施设置 <em>豁免（Exemptions）</em> 规则，
从而允许创建一些本来会被与给定名字空间相关的策略所禁止的 Pod。
豁免规则可以在<a href="/zh/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller">准入控制器配置</a>
中静态配置。</p>
<!--
Exemptions must be explicitly enumerated. Requests meeting exemption criteria are _ignored_ by the
Admission Controller (all `enforce`, `audit` and `warn` behaviors are skipped). Exemption dimensions include:
-->
<p>豁免规则可以显式枚举。满足豁免标准的请求会被准入控制器 <em>忽略</em>
（所有 <code>enforce</code>、<code>audit</code> 和 <code>warn</code> 行为都会被略过）。
豁免的维度包括：</p>
<!--
- **Usernames:** requests from users with an exempt authenticated (or impersonated) username are
  ignored.
- **RuntimeClassNames:** pods and [workload resources](#workload-resources-and-pod-templates) specifying an exempt runtime class name are
  ignored.
- **Namespaces:** pods and [workload resources](#workload-resources-and-pod-templates) in an exempt namespace are ignored.
-->
<ul>
<li><strong>Username：</strong> 来自用户名已被豁免的、已认证的（或伪装的）的用户的请求会被忽略。</li>
<li><strong>RuntimeClassName：</strong> 指定了已豁免的运行时类名称的 Pod
和<a href="#workload-resources-and-pod-templates">负载资源</a>会被忽略。</li>
<li><strong>Namespace：</strong> 位于被豁免的名字空间中的 Pod 和<a href="#workload-resources-and-pod-templates">负载资源</a>
会被忽略。</li>
</ul>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!--
Most pods are created by a controller in response to a [workload
resource](#workload-resources-and-pod-templates), meaning that exempting an end user will only
exempt them from enforcement when creating pods directly, but not when creating a workload resource.
Controller service accounts (such as `system:serviceaccount:kube-system:replicaset-controller`)
should generally not be exempted, as doing so would implicitly exempt any user that can create the
corresponding workload resource.
-->
<p>大多数 Pod 是作为对<a href="#workload-resources-and-pod-templates">工作负载资源</a>的响应，
由控制器所创建的，这意味着为某最终用户提供豁免时，只会当该用户直接创建 Pod
时对其实施安全策略的豁免。用户创建工作负载资源时不会被豁免。
控制器服务账号（例如：<code>system:serviceaccount:kube-system:replicaset-controller</code>）
通常不应该被豁免，因为豁免这类服务账号隐含着对所有能够创建对应工作负载资源的用户豁免。
</div>

<!--
Updates to the following pod fields are exempt from policy checks, meaning that if a pod update
request only changes these fields, it will not be denied even if the pod is in violation of the
current policy level:
-->
<p>策略检查时会对以下 Pod 字段的更新操作予以豁免，这意味着如果 Pod
更新请求仅改变这些字段时，即使 Pod 违反了当前的策略级别，请求也不会被拒绝。</p>
<!--
- Any metadata updates **except** changes to the seccomp or AppArmor annotations:
  - `seccomp.security.alpha.kubernetes.io/pod` (deprecated)
  - `container.seccomp.security.alpha.kubernetes.io/*` (deprecated)
  - `container.apparmor.security.beta.kubernetes.io/*`
- Valid updates to `.spec.activeDeadlineSeconds`
- Valid updates to `.spec.tolerations`
-->
<ul>
<li>除了对 seccomp 或 AppArmor 注解之外的所有 meatadata 更新操作：
<ul>
<li><code>seccomp.security.alpha.kubernetes.io/pod</code> （已弃用）</li>
<li><code>container.seccomp.security.alpha.kubernetes.io/*</code> （已弃用）</li>
<li><code>container.apparmor.security.beta.kubernetes.io/*</code></li>
</ul>
</li>
<li>对 <code>.spec.activeDeadlineSeconds</code> 的合法更新</li>
<li>对 <code>.spec.tolerations</code> 的合法更新</li>
</ul>
<h2 id="what-s-next">What's next</h2>
<!--
- [Pod Security Standards](/docs/concepts/security/pod-security-standards)
- [Enforcing Pod Security Standards](/docs/setup/best-practices/enforcing-pod-security-standards)
- [Enforce Pod Security Standards by Configuring the Built-in Admission Controller](/docs/tasks/configure-pod-container/enforce-standards-admission-controller)
- [Enforce Pod Security Standards with Namespace Labels](/docs/tasks/configure-pod-container/enforce-standards-namespace-labels)
- [Migrate from PodSecurityPolicy to the Built-In PodSecurity Admission Controller](/docs/tasks/configure-pod-container/migrate-from-psp)
-->
<ul>
<li><a href="/zh/docs/concepts/security/pod-security-standards/">Pod 安全性标准</a></li>
<li><a href="/zh/docs/setup/best-practices/enforcing-pod-security-standards/">强制实施 Pod 安全性标准</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/enforce-standards-admission-controller/">通过配置内置的准入控制器强制实施 Pod 安全性标准</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/">使用名字空间标签来实施 Pod 安全性标准</a></li>
<li><a href="/zh/docs/tasks/configure-pod-container/migrate-from-psp/">从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-4d77d1ae4c06aa14f54b385191627881">4 - Kubernetes API 访问控制</h1>
    
	<!--
---
reviewers:
- erictune
- lavalamp
title: Controlling Access to the Kubernetes API
content_type: concept
---
-->
<!-- overview -->
<!--
This page provides an overview of controlling access to the Kubernetes API.
-->
<p>本页面概述了对 Kubernetes API 的访问控制。</p>
<!-- body -->
<!--
Users access the [Kubernetes API](/docs/concepts/overview/kubernetes-api/) using `kubectl`,
client libraries, or by making REST requests.  Both human users and
[Kubernetes service accounts](/docs/tasks/configure-pod-container/configure-service-account/) can be
authorized for API access.
When a request reaches the API, it goes through several stages, illustrated in the
following diagram:
-->
<p>用户使用 <code>kubectl</code>、客户端库或构造 REST 请求来访问 <a href="/zh/docs/concepts/overview/kubernetes-api/">Kubernetes API</a>。
人类用户和 <a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">Kubernetes 服务账户</a>都可以被鉴权访问 API。
当请求到达 API 时，它会经历多个阶段，如下图所示：</p>
<p><img src="/images/docs/admin/access-control-overview.svg" alt="Kubernetes API 请求处理步骤示意图"></p>
<!-- ## Transport security -->
<h2 id="transport-security">传输安全</h2>
<!--
In a typical Kubernetes cluster, the API serves on port 443, protected by TLS.
The API server presents a certificate. This certificate may be signed using
a private certificate authority (CA), or based on a public key infrastructure linked
to a generally recognized CA.
-->
<p>在典型的 Kubernetes 集群中，API 服务器在 443 端口上提供服务，受 TLS 保护。
API 服务器出示证书。
该证书可以使用私有证书颁发机构（CA）签名，也可以基于链接到公认的 CA 的公钥基础架构签名。</p>
<!--
If your cluster uses a private certificate authority, you need a copy of that CA
certificate configured into your `~/.kube/config` on the client, so that you can
trust the connection and be confident it was not intercepted.

Your client can present a TLS client certificate at this stage.
-->
<p>如果你的集群使用私有证书颁发机构，你需要在客户端的 <code>~/.kube/config</code> 文件中提供该 CA 证书的副本，
以便你可以信任该连接并确认该连接没有被拦截。</p>
<p>你的客户端可以在此阶段出示 TLS 客户端证书。</p>
<!-- ## Authentication -->
<h2 id="authentication">认证</h2>
<!--
Once TLS is established, the HTTP request moves to the Authentication step.
This is shown as step **1** in the diagram.
The cluster creation script or cluster admin configures the API server to run
one or more Authenticator modules.
Authenticators are described in more detail in
[Authentication](/docs/reference/access-authn-authz/authentication/).
-->
<p>如上图步骤 <strong>1</strong> 所示，建立 TLS 后， HTTP 请求将进入认证（Authentication）步骤。
集群创建脚本或者集群管理员配置 API 服务器，使之运行一个或多个身份认证组件。
身份认证组件在<a href="/zh/docs/reference/access-authn-authz/authentication/">认证</a>节中有更详细的描述。</p>
<!--
The input to the authentication step is the entire HTTP request; however, it typically
examines the headers and/or client certificate.

Authentication modules include client certificates, password, and plain tokens,
bootstrap tokens, and JSON Web Tokens (used for service accounts).

Multiple authentication modules can be specified, in which case each one is tried in sequence,
until one of them succeeds.
-->
<p>认证步骤的输入整个 HTTP 请求；但是，通常组件只检查头部或/和客户端证书。</p>
<p>认证模块包含客户端证书、密码、普通令牌、引导令牌和 JSON Web 令牌（JWT，用于服务账户）。</p>
<p>可以指定多个认证模块，在这种情况下，服务器依次尝试每个验证模块，直到其中一个成功。</p>
<!--
If the request cannot be authenticated, it is rejected with HTTP status code 401.
Otherwise, the user is authenticated as a specific `username`, and the user name
is available to subsequent steps to use in their decisions.  Some authenticators
also provide the group memberships of the user, while other authenticators
do not.

While Kubernetes uses usernames for access control decisions and in request logging,
it does not have a `User` object nor does it store usernames or other information about
users in its API.
-->
<p>如果请求认证不通过，服务器将以 HTTP 状态码 401 拒绝该请求。
反之，该用户被认证为特定的 <code>username</code>，并且该用户名可用于后续步骤以在其决策中使用。
部分验证器还提供用户的组成员身份，其他则不提供。</p>
<!-- ## Authorization -->
<h2 id="authorization">鉴权</h2>
<!--
After the request is authenticated as coming from a specific user, the request must be authorized. This is shown as step **2** in the diagram.

A request must include the username of the requester, the requested action, and the object affected by the action. The request is authorized if an existing policy declares that the user has permissions to complete the requested action.

For example, if Bob has the policy below, then he can read pods only in the namespace `projectCaribou`:
-->
<p>如上图的步骤 <strong>2</strong> 所示，将请求验证为来自特定的用户后，请求必须被鉴权。</p>
<p>请求必须包含请求者的用户名、请求的行为以及受该操作影响的对象。
如果现有策略声明用户有权完成请求的操作，那么该请求被鉴权通过。</p>
<p>例如，如果 Bob 有以下策略，那么他只能在 <code>projectCaribou</code> 名称空间中读取 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;Policy&#34;</span>,
    <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;user&#34;</span>: <span style="color:#b44">&#34;bob&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;projectCaribou&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>,
        <span style="color:#008000;font-weight:bold">&#34;readonly&#34;</span>: <span style="color:#a2f;font-weight:bold">true</span>
    }
}
</code></pre></div><!--
If Bob makes the following request, the request is authorized because he is allowed to read objects in the `projectCaribou` namespace:
-->
<p>如果 Bob 执行以下请求，那么请求会被鉴权，因为允许他读取 <code>projectCaribou</code> 名称空间中的对象。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;apiVersion&#34;</span>: <span style="color:#b44">&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;SubjectAccessReview&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;spec&#34;</span>: {
    <span style="color:#008000;font-weight:bold">&#34;resourceAttributes&#34;</span>: {
      <span style="color:#008000;font-weight:bold">&#34;namespace&#34;</span>: <span style="color:#b44">&#34;projectCaribou&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;verb&#34;</span>: <span style="color:#b44">&#34;get&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;group&#34;</span>: <span style="color:#b44">&#34;unicorn.example.org&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;resource&#34;</span>: <span style="color:#b44">&#34;pods&#34;</span>
    }
  }
}
</code></pre></div><!--
If Bob makes a request to write (`create` or `update`) to the objects in the `projectCaribou` namespace, his authorization is denied.
If Bob makes a request to read (`get`) objects in a different namespace such as `projectFish`, then his authorization is denied.

Kubernetes authorization requires that you use common REST attributes to interact with existing organization-wide or cloud-provider-wide access control systems.
It is important to use REST formatting because these control systems might interact with other APIs besides the Kubernetes API.
-->
<p>如果 Bob 在 <code>projectCaribou</code> 名字空间中请求写（<code>create</code> 或 <code>update</code>）对象，其鉴权请求将被拒绝。
如果 Bob 在诸如 <code>projectFish</code> 这类其它名字空间中请求读取（<code>get</code>）对象，其鉴权也会被拒绝。</p>
<p>Kubernetes 鉴权要求使用公共 REST 属性与现有的组织范围或云提供商范围的访问控制系统进行交互。
使用 REST 格式很重要，因为这些控制系统可能会与 Kubernetes API 之外的 API 交互。</p>
<!--
Kubernetes supports multiple authorization modules, such as ABAC mode, RBAC Mode, and Webhook mode.
When an administrator creates a cluster, they configure the authorization modules that should be used in the API server.
If more than one authorization modules are configured, Kubernetes checks each module,
and if any module authorizes the request, then the request can proceed.
If all of the modules deny the request, then the request is denied (HTTP status code 403).

To learn more about Kubernetes authorization, including details about creating policies using the supported authorization modules,
see [Authorization](/docs/reference/access-authn-authz/authorization/).
-->
<p>Kubernetes 支持多种鉴权模块，例如 ABAC 模式、RBAC 模式和 Webhook 模式等。
管理员创建集群时，他们配置应在 API 服务器中使用的鉴权模块。
如果配置了多个鉴权模块，则 Kubernetes 会检查每个模块，任意一个模块鉴权该请求，请求即可继续；
如果所有模块拒绝了该请求，请求将会被拒绝（HTTP 状态码 403）。</p>
<p>要了解更多有关 Kubernetes 鉴权的更多信息，包括有关使用支持鉴权模块创建策略的详细信息，
请参阅<a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权</a>。</p>
<!-- ## Admission control -->
<h2 id="admission-control">准入控制</h2>
<!--
Admission Control modules are software modules that can modify or reject requests.
In addition to the attributes available to Authorization modules, Admission
Control modules can access the contents of the object that is being created or modified.

Admission controllers act on requests that create, modify, delete, or connect to (proxy) an object.
Admission controllers do not act on requests that merely read objects.
When multiple admission controllers are configured, they are called in order.
-->
<p>准入控制模块是可以修改或拒绝请求的软件模块。
除鉴权模块可用的属性外，准入控制模块还可以访问正在创建或修改的对象的内容。</p>
<p>准入控制器对创建、修改、删除或（通过代理）连接对象的请求进行操作。
准入控制器不会对仅读取对象的请求起作用。
有多个准入控制器被配置时，服务器将依次调用它们。</p>
<!--
This is shown as step **3** in the diagram.

Unlike Authentication and Authorization modules, if any admission controller module
rejects, then the request is immediately rejected.

In addition to rejecting objects, admission controllers can also set complex defaults for
fields.

The available Admission Control modules are described in [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/).

Once a request passes all admission controllers, it is validated using the validation routines
for the corresponding API object, and then written to the object store (shown as step **4**).
-->
<p>这一操作如上图的步骤 <strong>3</strong> 所示。</p>
<p>与身份认证和鉴权模块不同，如果任何准入控制器模块拒绝某请求，则该请求将立即被拒绝。</p>
<p>除了拒绝对象之外，准入控制器还可以为字段设置复杂的默认值。</p>
<p>可用的准入控制模块在<a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>中进行了描述。</p>
<p>请求通过所有准入控制器后，将使用检验例程检查对应的 API 对象，然后将其写入对象存储（如步骤 <strong>4</strong> 所示）。</p>
<!--
## Auditing

Kubernetes auditing provides a security-relevant, chronological set of records documenting the sequence of actions in a cluster.
The cluster audits the activities generated by users, by applications that use the Kubernetes API, and by the control plane itself.

For more information, see [Auditing](/docs/tasks/debug-application-cluster/audit/).
-->
<h2 id="auditing">审计</h2>
<p>Kubernetes 审计提供了一套与安全相关的、按时间顺序排列的记录，其中记录了集群中的操作序列。
集群对用户、使用 Kubernetes API 的应用程序以及控制平面本身产生的活动进行审计。</p>
<p>更多信息请参考 <a href="/zh/docs/tasks/debug-application-cluster/audit/">审计</a>.</p>
<!-- ## API server ports and IPs -->
<h2 id="api-server-ports-and-ips">API 服务器端口和 IP</h2>
<!--
The previous discussion applies to requests sent to the secure port of the API server
(the typical case).  The API server can actually serve on 2 ports:

By default, the Kubernetes API server serves HTTP on 2 ports:
-->
<p>前面的讨论适用于发送到 API 服务器的安全端口的请求（典型情况）。 API 服务器实际上可以在 2 个端口上提供服务：</p>
<p>默认情况下，Kubernetes API 服务器在 2 个端口上提供 HTTP 服务：</p>
<!--
  1. `localhost` port:

      - is intended for testing and bootstrap, and for other components of the master node
        (scheduler, controller-manager) to talk to the API
      - no TLS
      - default is port 8080
      - default IP is localhost, change with `--insecure-bind-address` flag.
      - request **bypasses** authentication and authorization modules.
      - request handled by admission control module(s).
      - protected by need to have host access

  2. “Secure port”:

      - use whenever possible
      - uses TLS.  Set cert with `--tls-cert-file` and key with `--tls-private-key-file` flag.
      - default is port 6443, change with `--secure-port` flag.
      - default IP is first non-localhost network interface, change with `--bind-address` flag.
      - request handled by authentication and authorization modules.
      - request handled by admission control module(s).
      - authentication and authorization modules run.
 -->
<ol>
<li>
<p><code>localhost</code> 端口:</p>
<ul>
<li>用于测试和引导，以及主控节点上的其他组件（调度器，控制器管理器）与 API 通信</li>
<li>没有 TLS</li>
<li>默认为端口 8080</li>
<li>默认 IP 为 localhost，使用 <code>--insecure-bind-address</code> 进行更改</li>
<li>请求 <strong>绕过</strong> 身份认证和鉴权模块</li>
<li>由准入控制模块处理的请求</li>
<li>受需要访问主机的保护</li>
</ul>
</li>
<li>
<p>“安全端口”：</p>
<ul>
<li>尽可能使用</li>
<li>使用 TLS。 用 <code>--tls-cert-file</code> 设置证书，用 <code>--tls-private-key-file</code> 设置密钥</li>
<li>默认端口 6443，使用 <code>--secure-port</code> 更改</li>
<li>默认 IP 是第一个非本地网络接口，使用 <code>--bind-address</code> 更改</li>
<li>请求须经身份认证和鉴权组件处理</li>
<li>请求须经准入控制模块处理</li>
<li>身份认证和鉴权模块运行</li>
</ul>
</li>
</ol>
<h2 id="what-s-next">What's next</h2>
<!--
Read more documentation on authentication, authorization and API access control:

- [Authenticating](/docs/reference/access-authn-authz/authentication/)
   - [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/)
- [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/)
   - [Dynamic Admission Control](/docs/reference/access-authn-authz/extensible-admission-controllers/)
- [Authorization](/docs/reference/access-authn-authz/authorization/)
   - [Role Based Access Control](/docs/reference/access-authn-authz/rbac/)
   - [Attribute Based Access Control](/docs/reference/access-authn-authz/abac/)
   - [Node Authorization](/docs/reference/access-authn-authz/node/)
   - [Webhook Authorization](/docs/reference/access-authn-authz/webhook/)
- [Certificate Signing Requests](/docs/reference/access-authn-authz/certificate-signing-requests/)
   - including [CSR approval](/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection)
     and [certificate signing](/docs/reference/access-authn-authz/certificate-signing-requests/#signing)
- Service accounts
  - [Developer guide](/docs/tasks/configure-pod-container/configure-service-account/)
  - [Administration](/docs/reference/access-authn-authz/service-accounts-admin/)

You can learn about:
- how Pods can use
  [Secrets](/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials)
  to obtain API credentials.
-->
<p>阅读更多有关身份认证、鉴权和 API 访问控制的文档：</p>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/authentication/">认证</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/bootstrap-tokens/">使用 Bootstrap 令牌进行身份认证</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/admission-controllers/">准入控制器</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/extensible-admission-controllers/">动态准入控制</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/authorization/">鉴权</a>
<ul>
<li><a href="/zh/docs/reference/access-authn-authz/rbac/">基于角色的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/abac/">基于属性的访问控制</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/node/">节点鉴权</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/webhook/">Webhook 鉴权</a></li>
</ul>
</li>
<li><a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a>
<ul>
<li>包括 <a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection">CSR 认证</a>
和<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signing">证书签名</a></li>
</ul>
</li>
<li>服务账户
<ul>
<li><a href="/zh/docs/tasks/configure-pod-container/configure-service-account/">开发者指导</a></li>
<li><a href="/zh/docs/reference/access-authn-authz/service-accounts-admin/">管理</a></li>
</ul>
</li>
</ul>
<p>你可以了解</p>
<ul>
<li>Pod 如何使用
<a href="/zh/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials">Secrets</a>
获取 API 凭证.</li>
</ul>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
