<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/tasks/job/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/tasks/job/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/tasks/job/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/tasks/job/">
<link rel="alternate" hreflang="de" href="http://localhost:1313/de/docs/tasks/job/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/tasks/job/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/tasks/job/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>运行 Jobs | Kubernetes</title><meta property="og:title" content="运行 Jobs" />
<meta property="og:description" content="使用并行处理运行 Jobs。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/job/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="运行 Jobs">
<meta itemprop="description" content="使用并行处理运行 Jobs。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="运行 Jobs"/>
<meta name="twitter:description" content="使用并行处理运行 Jobs。"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="使用并行处理运行 Jobs。">
<meta property="og:description" content="使用并行处理运行 Jobs。">
<meta name="twitter:description" content="使用并行处理运行 Jobs。">
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/job/">
<meta property="og:title" content="运行 Jobs">
<meta name="twitter:title" content="运行 Jobs">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tasks/job/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/tasks/job/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/job/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tasks/job/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tasks/job/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tasks/job/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tasks/job/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/tasks/job/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/tasks/job/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/tasks/job/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/tasks/job/">Español</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tasks/job/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">运行 Jobs</h1>
<div class="lead">使用并行处理运行 Jobs。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-964bdff888520740e5e221695245678d">使用 CronJob 运行自动化任务</a></li>


    
  
    
    
	
<li>2: <a href="#pg-1058efa4d70f13c015e6a2094ff85068">使用工作队列进行粗粒度并行处理</a></li>


    
  
    
    
	
<li>3: <a href="#pg-457c9dd93aed2b05615ed28dc38075d3">使用工作队列进行精细的并行处理</a></li>


    
  
    
    
	
<li>4: <a href="#pg-9e63850014876afaebd1561f70bb8f6b">使用索引作业完成静态工作分配下的并行处理</a></li>


    
  
    
    
	
<li>5: <a href="#pg-da7c2b067953d239eb4457e8978ad8f6">使用展开的方式进行并行处理</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-964bdff888520740e5e221695245678d">1 - 使用 CronJob 运行自动化任务</h1>
    
	<!--
title: Running Automated Tasks with a CronJob
reviewers:
- chenopis
content_type: task
weight: 10
min-kubernetes-server-version: v1.21
-->
<!-- overview -->
<!--

CronJobs was promoted to general availability in Kubernetes v1.21. If you are using an older version of
Kubernetes, please refer to the documentation for the version of Kubernetes that you are using,
so that you see accurate information. Older Kubernetes versions do not support the `batch/v1` CronJob API.

You can use [CronJobs](/docs/concepts/workloads/controllers/cron-jobs) to run jobs on a time-based schedule.
These automated jobs run like [Cron](https://en.wikipedia.org/wiki/Cron) tasks on a Linux or UNIX system.

Cron jobs are useful for creating periodic and recurring tasks, like running backups or sending emails.
Cron jobs can also schedule individual tasks for a specific time, such as if you want to schedule a job for a low activity period.
-->
<p>在Kubernetes v1.21 版本中，CronJob 被提升为通用版本。如果你使用的是旧版本的 Kubernetes，请参考你正在使用的 Kubernetes 版本的文档，这样你就能看到准确的信息。旧的 Kubernetes 版本不支持<code>batch/v1</code> CronJob API。</p>
<p>你可以利用 <a href="/zh/docs/concepts/workloads/controllers/cron-jobs">CronJobs</a> 执行基于时间调度的任务。这些自动化任务和 Linux 或者 Unix 系统的 <a href="https://en.wikipedia.org/wiki/Cron">Cron</a> 任务类似。</p>
<p>CronJobs 在创建周期性以及重复性的任务时很有帮助，例如执行备份操作或者发送邮件。CronJobs 也可以在特定时间调度单个任务，例如你想调度低活跃周期的任务。</p>
<!--
Cron jobs have limitations and idiosyncrasies.
For example, in certain circumstances, a single cron job can create multiple jobs.
Therefore, jobs should be idempotent.
For more limitations, see [CronJobs](/docs/concepts/workloads/controllers/cron-jobs).
-->
<p>CronJobs 有一些限制和特点。
例如，在特定状况下，同一个 CronJob 可以创建多个任务。
因此，任务应该是幂等的。</p>
<p>查看更多限制，请参考 <a href="/zh/docs/concepts/workloads/controllers/cron-jobs">CronJobs</a>。</p>
<h2 id="before-you-begin">Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version v1.21.
 To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<!-- steps -->
<!--
## Creating a Cron Job

Cron jobs require a config file.
This example cron job config `.spec` file prints the current time and a hello message every minute:
-->
<h2 id="创建-cronjob">创建 CronJob</h2>
<p>CronJob 需要一个配置文件。
本例中 CronJob 的<code>.spec</code> 配置文件每分钟打印出当前时间和一个问好信息：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/cronjob.yaml" download="application/job/cronjob.yaml"><code>application/job/cronjob.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-cronjob-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>CronJob<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">schedule</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;* * * * *&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">jobTemplate</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>busybox:1.28<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">imagePullPolicy</span>:<span style="color:#bbb"> </span>IfNotPresent<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- /bin/sh<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- -c<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- date; echo Hello from the Kubernetes cluster<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>OnFailure<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Run the example cron job by downloading the example file and then running this command:
-->
<p>想要运行示例的 CronJob，可以下载示例文件并执行命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</code></pre></div><pre><code>cronjob.batch/hello created
</code></pre><!--
After creating the cron job, get its status using this command:
-->
<p>创建好 CronJob 后，使用下面的命令来获取其状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get cronjob hello
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><!--
As you can see from the results of the command, the cron job has not scheduled or run any jobs yet.
Watch for the job to be created in around one minute:
-->
<p>就像你从命令返回结果看到的那样，CronJob 还没有调度或执行任何任务。大约需要一分钟任务才能创建好。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get <span style="color:#a2f">jobs</span> --watch
</code></pre></div><pre><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><!--
Now you've seen one running job scheduled by the "hello" cron job.
You can stop watching the job and view the cron job again to see that it scheduled the job:
-->
<p>现在你已经看到了一个运行中的任务被 “hello” CronJob 调度。
你可以停止监视这个任务，然后再次查看 CronJob 就能看到它调度任务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get cronjob hello
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><!--
You should see that the cron job `hello` successfully scheduled a job at the time specified in `LAST SCHEDULE`. There are currently 0 active jobs, meaning that the job has completed or failed.

Now, find the pods that the last scheduled job created and view the standard output of one of the pods.
-->
<p>你应该能看到 <code>hello</code> CronJob 在 <code>LAST SCHEDULE</code> 声明的时间点成功的调度了一次任务。
有 0 个活跃的任务意味着任务执行完毕或者执行失败。</p>
<p>现在，找到最后一次调度任务创建的 Pod 并查看一个 Pod 的标准输出。</p>
<!--
The job name and pod name are different.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Job 名称和 Pod 名称不同。
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 在你的系统上将 &#34;hello-4111706356&#34; 替换为 Job 名称</span>
<span style="color:#b8860b">pods</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl get pods --selector<span style="color:#666">=</span>job-name<span style="color:#666">=</span>hello-4111706356 --output<span style="color:#666">=</span><span style="color:#b8860b">jsonpath</span><span style="color:#666">={</span>.items..metadata.name<span style="color:#666">}</span><span style="color:#a2f;font-weight:bold">)</span>
</code></pre></div><!--
Show pod log:
-->
<p>查看 Pod 日志：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs <span style="color:#b8860b">$pods</span>
</code></pre></div><!--
The output is similar to this:
-->
<p>输出与此类似：</p>
<pre><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><!--
## Deleting a Cron Job

When you don't need a cron job any more, delete it with `kubectl delete cronjob <cronjob name>`：
-->
<h2 id="删除-cronjob">删除 CronJob</h2>
<p>当你不再需要 CronJob 时，可以用 <code>kubectl delete cronjob &lt;cronjob name&gt;</code> 删掉它：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete cronjob hello
</code></pre></div><!--
Deleting the cron job removes all the jobs and pods it created and stops it from creating additional jobs.
You can read more about removing jobs in [garbage collection](/docs/concepts/workloads/controllers/garbage-collection/).
-->
<p>删除 CronJob 会清除它创建的所有任务和 Pod，并阻止它创建额外的任务。你可以查阅
<a href="/zh/docs/concepts/workloads/controllers/garbage-collection/">垃圾收集</a>。</p>
<!--
## Writing a Cron Job Spec

As with all other Kubernetes configs, a cron job needs `apiVersion`, `kind`, and `metadata` fields. For general
information about working with config files, see [deploying applications](/docs/tasks/run-application/run-stateless-application-deployment/),
and [using kubectl to manage resources](/docs/concepts/overview/working-with-objects/object-management/) documents.

A cron job config also needs a [`.spec` section](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status).
-->
<h2 id="编写-cronjob-声明信息">编写 CronJob 声明信息</h2>
<p>像 Kubernetes 的其他配置一样，CronJob 需要 <code>apiVersion</code>、<code>kind</code>、和 <code>metadata</code> 域。
配置文件的一般信息，请参考
<a href="/zh/docs/tasks/run-application/run-stateless-application-deployment/">部署应用</a> 和
<a href="/zh/docs/concepts/overview/working-with-objects/object-management/">使用 kubectl 管理资源</a>.</p>
<p>CronJob 配置也需要包括
<a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status"><code>.spec</code></a>.</p>
<!--
All modifications to a cron job, especially its `.spec`, are applied only to the following runs.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 对 CronJob 的所有改动，特别是它的 <code>.spec</code>，只会影响将来的运行实例。
</div>
<!--
### Schedule

The `.spec.schedule` is a required field of the `.spec`.
It takes a [Cron](https://en.wikipedia.org/wiki/Cron) format string, such as `0 * * * *` or `@hourly`, as schedule time of its jobs to be created and executed.
-->
<h3 id="时间安排">时间安排</h3>
<p><code>.spec.schedule</code> 是 <code>.spec</code> 需要的域。它使用了 <a href="https://en.wikipedia.org/wiki/Cron">Cron</a>
格式串，例如 <code>0 * * * *</code> or <code>@hourly</code> ，作为它的任务被创建和执行的调度时间。</p>
<!--
The format also includes extended "Vixie cron" step values. As explained in the [FreeBSD manual](https://www.freebsd.org/cgi/man.cgi?crontab%285%29):
-->
<p>该格式也包含了扩展的 &quot;Vixie cron&quot; 步长值。
<a href="https://www.freebsd.org/cgi/man.cgi?crontab%285%29">FreeBSD 手册</a>中解释如下:</p>
<!--
> Step values can be	used in	conjunction with ranges.  Following a range
> with `/<number>` specifies skips	of the number's	value through the
> range.  For example, `0-23/2` can be used in the	hours field to specify
> command execution every other hour	(the alternative in the	V7 standard is
> `0,2,4,6,8,10,12,14,16,18,20,22`).  Steps are also permitted after an
> asterisk, so if you want to say "every two hours", just use `*/2`.
-->
<blockquote>
<p>步长可被用于范围组合。范围后面带有 <code>/&lt;数字&gt;</code> 可以声明范围内的步幅数值。
例如，<code>0-23/2</code> 可被用在小时域来声明命令在其他数值的小时数执行
（ V7 标准中对应的方法是<code>0,2,4,6,8,10,12,14,16,18,20,22</code>）。
步长也可以放在通配符后面，因此如果你想表达 &quot;每两小时&quot;，就用 <code>*/2</code> 。</p>
</blockquote>
<!--
A question mark (`?`) in the schedule has the same meaning as an asterisk `*`, that is, it stands for any of available value for a given field.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 调度中的问号 (<code>?</code>) 和星号  <code>*</code> 含义相同，表示给定域的任何可用值。
</div>
<!--
### Job Template

The `.spec.jobTemplate` is the template for the job, and it is required.
It has exactly the same schema as a [Job](/docs/concepts/workloads/controllers/job/), 
except that it is nested and does not have an `apiVersion` or `kind`.
For information about writing a job `.spec`, see
[Writing a Job Spec](/docs/concepts/workloads/controllers/job/#writing-a-job-spec).
-->
<h3 id="任务模版">任务模版</h3>
<p><code>.spec.jobTemplate</code>是任务的模版，它是必须的。它和
<a href="/zh/docs/concepts/workloads/controllers/job/">Job</a>的语法完全一样，
除了它是嵌套的没有 <code>apiVersion</code> 和 <code>kind</code>。
编写任务的 <code>.spec</code> ，请参考
<a href="/zh/docs/concepts/workloads/controllers/job/#writing-a-job-spec">编写 Job 的Spec</a>。</p>
<!--
### Starting Deadline

The `.spec.startingDeadlineSeconds` field is optional.
It stands for the deadline in seconds for starting the job if it misses its scheduled time for any reason.
After the deadline, the cron job does not start the job.
Jobs that do not meet their deadline in this way count as failed jobs.
If this field is not specified, the jobs have no deadline.
-->
<h3 id="starting-deadline">开始的最后期限  </h3>
<p><code>.spec.startingDeadlineSeconds</code> 域是可选的。
它表示任务如果由于某种原因错过了调度时间，开始该任务的截止时间的秒数。过了截止时间，CronJob 就不会开始任务。
不满足这种最后期限的任务会被统计为失败任务。如果该域没有声明，那任务就没有最后期限。</p>
<!--
If the `.spec.startingDeadlineSeconds` field is set (not null), the CronJob
controller measures the time between when a job is expected to be created and
now. If the difference is higher than that limit, it will skip this execution.

For example, if it is set to `200`, it allows a job to be created for up to 200
seconds after the actual schedule.
-->
<p>如果<code>.spec.startingDeadlineSeconds</code>字段被设置(非空)，CronJob 控制器会计算从预期创建 Job 到当前时间的时间差。
如果时间差大于该限制，则跳过此次执行。</p>
<p>例如，如果将其设置为 <code>200</code>，则 Job 控制器允许在实际调度之后最多 200 秒内创建 Job。</p>
<!--
### Concurrency Policy

The `.spec.concurrencyPolicy` field is also optional.
It specifies how to treat concurrent executions of a job that is created by this cron job.
the spec may specify only one of the following concurrency policies:

* `Allow` (default): The cron job allows concurrently running jobs
* `Forbid`: The cron job does not allow concurrent runs; if it is time for a new job run and the previous job run hasn't finished yet, the cron job skips the new job run
* `Replace`: If it is time for a new job run and the previous job run hasn't finished yet, the cron job replaces the currently running job run with a new job run

Note that concurrency policy only applies to the jobs created by the same cron job.
If there are multiple cron jobs, their respective jobs are always allowed to run concurrently.
-->
<h3 id="并发性规则">并发性规则</h3>
<p><code>.spec.concurrencyPolicy</code> 也是可选的。它声明了 CronJob 创建的任务执行时发生重叠如何处理。
spec 仅能声明下列规则中的一种：</p>
<ul>
<li><code>Allow</code> (默认)：CronJob 允许并发任务执行。</li>
<li><code>Forbid</code>： CronJob 不允许并发任务执行；如果新任务的执行时间到了而老任务没有执行完，CronJob 会忽略新任务的执行。</li>
<li><code>Replace</code>：如果新任务的执行时间到了而老任务没有执行完，CronJob 会用新任务替换当前正在运行的任务。</li>
</ul>
<p>请注意，并发性规则仅适用于相同 CronJob 创建的任务。如果有多个 CronJob，它们相应的任务总是允许并发执行的。</p>
<!--
### Suspend

The `.spec.suspend` field is also optional.
If it is set to `true`, all subsequent executions are suspended.
This setting does not apply to already started executions.
Defaults to false.
-->
<h3 id="挂起">挂起</h3>
<p><code>.spec.suspend</code>域也是可选的。如果设置为 <code>true</code> ，后续发生的执行都会挂起。
这个设置对已经开始的执行不起作用。默认是关闭的。</p>
<!--
Executions that are suspended during their scheduled time count as missed jobs.
When `.spec.suspend` changes from `true` to `false` on an existing cron job without a [starting deadline](#starting-deadline), the missed jobs are scheduled immediately.
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> 在调度时间内挂起的执行都会被统计为错过的任务。当 <code>.spec.suspend</code> 从 <code>true</code> 改为 <code>false</code> 时，
且没有 <a href="#starting-deadline">开始的最后期限</a>，错过的任务会被立即调度。
</div>

<!--
### Jobs History Limits

The `.spec.successfulJobsHistoryLimit` and `.spec.failedJobsHistoryLimit` fields are optional.
These fields specify how many completed and failed jobs should be kept.
By default, they are set to 3 and 1 respectively.  Setting a limit to `0` corresponds to keeping none of the corresponding kind of jobs after they finish.
-->
<h3 id="任务历史限制">任务历史限制</h3>
<p><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>是可选的。
这两个字段指定应保留多少已完成和失败的任务。
默认设置为3和1。限制设置为 <code>0</code> 代表相应类型的任务完成后不会保留。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1058efa4d70f13c015e6a2094ff85068">2 - 使用工作队列进行粗粒度并行处理</h1>
    
	<!--
---
title: Coarse Parallel Processing Using a Work Queue
min-kubernetes-server-version: v1.8
content_type: task
weight: 20
---
-->
<!-- overview -->
<!--
In this example, we will run a Kubernetes Job with multiple parallel
worker processes.

In this example, as each pod is created, it picks up one unit of work
from a task queue, completes it, deletes it from the queue, and exits.

Here is an overview of the steps in this example:

1. **Start a message queue service.**  In this example, we use RabbitMQ, but you could use another
  one.  In practice you would set up a message queue service once and reuse it for many jobs.
1. **Create a queue, and fill it with messages.**  Each message represents one task to be done.  In
   this example, a message is an integer that we will do a lengthy computation on.
1. **Start a Job that works on tasks from the queue**.  The Job starts several pods.  Each pod takes
  one task from the message queue, processes it, and repeats until the end of the queue is reached.
-->
<p>本例中，我们会运行包含多个并行工作进程的 Kubernetes Job。</p>
<p>本例中，每个 Pod 一旦被创建，会立即从任务队列中取走一个工作单元并完成它，然后将工作单元从队列中删除后再退出。</p>
<p>下面是本次示例的主要步骤：</p>
<ol>
<li>
<p><strong>启动一个消息队列服务</strong>  本例中，我们使用 RabbitMQ，你也可以用其他的消息队列服务。在实际工作环境中，你可以创建一次消息队列服务然后在多个任务中重复使用。</p>
</li>
<li>
<p><strong>创建一个队列，放上消息数据</strong>  每个消息表示一个要执行的任务。本例中，每个消息是一个整数值。我们将基于这个整数值执行很长的计算操作。</p>
</li>
<li>
<p><strong>启动一个在队列中执行这些任务的 Job</strong>。该 Job 启动多个 Pod。每个 Pod 从消息队列中取走一个任务，处理它，然后重复执行，直到队列的队尾。</p>
</li>
</ol>
<h2 id="before-you-begin">Before you begin</h2>
<!--
Be familiar with the basic,
non-parallel, use of [Job](/docs/concepts/jobs/run-to-completion-finite-workloads/).
-->
<p>要熟悉 Job 基本用法（非并行的），请参考
<a href="/zh/docs/concepts/workloads/controllers/job/">Job</a>。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version v1.8.
 To check the version, enter <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Starting a message queue service

This example uses RabbitMQ, however, you can adapt the example to use another AMQP-type message service.

In practice you could set up a message queue service once in a
cluster and reuse it for many jobs, as well as for long-running services.

Start RabbitMQ as follows:
-->
<h2 id="启动消息队列服务">启动消息队列服务</h2>
<p>本例使用了 RabbitMQ，但你可以更改该示例，使用其他 AMQP 类型的消息服务。</p>
<p>在实际工作中，在集群中一次性部署某个消息队列服务，之后在很多 Job 中复用，包括需要长期运行的服务。</p>
<p>按下面的方法启动 RabbitMQ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-service.yaml
</code></pre></div><pre><code>service &quot;rabbitmq-service&quot; created
</code></pre><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.3/examples/celery-rabbitmq/rabbitmq-controller.yaml
</code></pre></div><pre><code>replicationcontroller &quot;rabbitmq-controller&quot; created
</code></pre><!--
We will only use the rabbitmq part from the [celery-rabbitmq example](https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/celery-rabbitmq).
-->
<p>我们仅用到 <a href="https://github.com/kubernetes/kubernetes/tree/release-1.3/examples/celery-rabbitmq">celery-rabbitmq 示例</a> 中描述的部分功能。</p>
<!--
## Testing the message queue service

Now, we can experiment with accessing the message queue.  We will
create a temporary interactive pod, install some tools on it,
and experiment with queues.

First create a temporary interactive Pod.
-->
<h2 id="测试消息队列服务">测试消息队列服务</h2>
<p>现在，我们可以试着访问消息队列。我们将会创建一个临时的可交互的 Pod，在它上面安装一些工具，然后用队列做实验。</p>
<p>首先创建一个临时的可交互的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 创建一个临时的可交互的 Pod</span>
kubectl run -i --tty temp --image ubuntu:14.04
</code></pre></div><pre><code>Waiting for pod default/temp-loe07 to be running, status is Pending, pod ready: false
... [ previous line repeats several times .. hit return when it stops ] ...
</code></pre><!--
Note that your pod name and command prompt will be different.

Next install the `amqp-tools` so we can work with message queues.
-->
<p>请注意你的 Pod 名称和命令提示符将会不同。</p>
<p>接下来安装 <code>amqp-tools</code> ，这样我们就能用消息队列了。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 安装一些工具</span>
root@temp-loe07:/# apt-get update
.... <span style="color:#666">[</span> lots of output <span style="color:#666">]</span> ....
root@temp-loe07:/# apt-get install -y curl ca-certificates amqp-tools python dnsutils
.... <span style="color:#666">[</span> lots of output <span style="color:#666">]</span> ....
</code></pre></div><!--
Later, we will make a docker image that includes these packages.

Next, we will check that we can discover the rabbitmq service:
-->
<p>后续，我们将制作一个包含这些包的 Docker 镜像。</p>
<p>接着，我们将要验证我们发现 RabbitMQ 服务：</p>
<!--
# Note the rabbitmq-service has a DNS name, provided by Kubernetes:
-->
<pre><code># 请注意 rabbitmq-service 有Kubernetes 提供的 DNS 名称，

root@temp-loe07:/# nslookup rabbitmq-service
Server:        10.0.0.10
Address:    10.0.0.10#53

Name:    rabbitmq-service.default.svc.cluster.local
Address: 10.0.147.152

# 你的 IP 地址会不同
</code></pre><!--
If Kube-DNS is not setup correctly, the previous step may not work for you.
You can also find the service IP in an env var:
-->
<p>如果 Kube-DNS 没有正确安装，上一步可能会出错。
你也可以在环境变量中找到服务 IP。</p>
<!--
# Your address will vary.
-->
<pre><code># env | grep RABBIT | grep HOST
RABBITMQ_SERVICE_SERVICE_HOST=10.0.147.152

# 你的 IP 地址会有所不同
</code></pre><!--
Next we will verify we can create a queue, and publish and consume messages.
-->
<p>接着我们将要确认可以创建队列，并能发布消息和消费消息。</p>
<!--
# In the next line, rabbitmq-service is the hostname where the rabbitmq-service
# can be reached.  5672 is the standard port for rabbitmq.

# If you could not resolve "rabbitmq-service" in the previous step,
# then use this command instead:
# root@temp-loe07:/# BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672
# Now create a queue:
# and publish a message to it:
# and get it back.
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 下一行，rabbitmq-service 是访问 rabbitmq-service 的主机名。5672是 rabbitmq 的标准端口。</span>

root@temp-loe07:/# <span style="color:#a2f">export</span> <span style="color:#b8860b">BROKER_URL</span><span style="color:#666">=</span>amqp://guest:guest@rabbitmq-service:5672

<span style="color:#080;font-style:italic"># 如果上一步中你不能解析 &#34;rabbitmq-service&#34;，可以用下面的命令替换：</span>
<span style="color:#080;font-style:italic"># root@temp-loe07:/# BROKER_URL=amqp://guest:guest@$RABBITMQ_SERVICE_SERVICE_HOST:5672</span>

<span style="color:#080;font-style:italic"># 现在创建队列：</span>

root@temp-loe07:/# /usr/bin/amqp-declare-queue --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q foo -d foo

<span style="color:#080;font-style:italic"># 向它推送一条消息:</span>

root@temp-loe07:/# /usr/bin/amqp-publish --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -r foo -p -b Hello

<span style="color:#080;font-style:italic"># 然后取回它.</span>

root@temp-loe07:/# /usr/bin/amqp-consume --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q foo -c <span style="color:#666">1</span> cat <span style="color:#666">&amp;&amp;</span> <span style="color:#a2f">echo</span>
Hello
root@temp-loe07:/#
</code></pre></div><!--
In the last command, the `amqp-consume` tool takes one message (`-c 1`)
from the queue, and passes that message to the standard input of an arbitrary command.  In this case, the program `cat` prints out the characters read from standard input, and the echo adds a carriage
return so the example is readable.
-->
<p>最后一个命令中， <code>amqp-consume</code> 工具从队列中取走了一个消息，并把该消息传递给了随机命令的标准输出。
在这种情况下，<code>cat</code> 会打印它从标准输入中读取的字符，echo 会添加回车符以便示例可读。</p>
<!--
## Filling the Queue with tasks

Now let's fill the queue with some "tasks".  In our example, our tasks are strings to be
printed.

In a practice, the content of the messages might be:

- names of files to that need to be processed
- extra flags to the program
- ranges of keys in a database table
- configuration parameters to a simulation
- frame numbers of a scene to be rendered
-->
<h2 id="为队列增加任务">为队列增加任务</h2>
<p>现在让我们给队列增加一些任务。在我们的示例中，任务是多个待打印的字符串。</p>
<p>实践中，消息的内容可以是：</p>
<ul>
<li>待处理的文件名</li>
<li>程序额外的参数</li>
<li>数据库表的关键字范围</li>
<li>模拟任务的配置参数</li>
<li>待渲染的场景的帧序列号</li>
</ul>
<!--
In practice, if there is large data that is needed in a read-only mode by all pods
of the Job, you will typically put that in a shared file system like NFS and mount
that readonly on all the pods, or the program in the pod will natively read data from
a cluster file system like HDFS.

For our example, we will create the queue and fill it using the amqp command line tools.
In practice, you might write a program to fill the queue using an amqp client library.
-->
<p>本例中，如果有大量的数据需要被 Job 的所有 Pod 读取，典型的做法是把它们放在一个共享文件系统中，如NFS，并以只读的方式挂载到所有 Pod，或者 Pod 中的程序从类似 HDFS 的集群文件系统中读取。</p>
<p>例如，我们创建队列并使用 amqp 命令行工具向队列中填充消息。实践中，你可以写个程序来利用 amqp 客户端库来填充这些队列。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">/usr/bin/amqp-declare-queue --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -q job1  -d job1

<span style="color:#a2f;font-weight:bold">for</span> f in apple banana cherry date fig grape lemon melon 
<span style="color:#a2f;font-weight:bold">do</span>
  /usr/bin/amqp-publish --url<span style="color:#666">=</span><span style="color:#b8860b">$BROKER_URL</span> -r job1 -p -b <span style="color:#b8860b">$f</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!--
So, we filled the queue with 8 messages.

## Create an Image

Now we are ready to create an image that we will run as a job.

We will use the `amqp-consume` utility to read the message
from the queue and run our actual program.  Here is a very simple
example program:
-->
<p>这样，我们给队列中填充了8个消息。</p>
<h2 id="创建镜像">创建镜像</h2>
<p>现在我们可以创建一个做为 Job 来运行的镜像。</p>
<p>我们将用 <code>amqp-consume</code> 来从队列中读取消息并实际运行我们的程序。这里给出一个非常简单的示例程序：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/rabbitmq/worker.py" download="application/job/rabbitmq/worker.py"><code>application/job/rabbitmq/worker.py</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-rabbitmq-worker-py')" title="Copy application/job/rabbitmq/worker.py to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-rabbitmq-worker-py">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">#!/usr/bin/env python</span>

<span style="color:#080;font-style:italic"># Just prints standard out and sleeps for 10 seconds.</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">sys</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">time</span>
<span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Processing &#34;</span> <span style="color:#666">+</span> sys<span style="color:#666">.</span>stdin<span style="color:#666">.</span>readlines()[<span style="color:#666">0</span>])
time<span style="color:#666">.</span>sleep(<span style="color:#666">10</span>)
</code></pre></div>
    </div>
</div>


<!--
Now, build an image.  If you are working in the source
tree, then change directory to `examples/job/work-queue-1`.
Otherwise, make a temporary directory, change to it,
download the [Dockerfile](/examples/application/job/rabbitmq/Dockerfile),
and [worker.py](/examples/application/job/rabbitmq/worker.py).  In either case,
build the image with this command:
-->
<p>现在，编译镜像。如果你在用源代码树，那么切换到目录 <code>examples/job/work-queue-1</code>。
否则的话，创建一个临时目录，切换到这个目录。下载
<a href="/examples/application/job/rabbitmq/Dockerfile">Dockerfile</a>，和
<a href="/examples/application/job/rabbitmq/worker.py">worker.py</a>。
无论哪种情况，都可以用下面的命令编译镜像</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker build -t job-wq-1 .
</code></pre></div><!--
For the [Docker Hub](https://hub.docker.com/), tag your app image with
your username and push to the Hub with the below commands. Replace
`<username>` with your Hub username.
-->
<p>对于 <a href="https://hub.docker.com/">Docker Hub</a>, 给你的应用镜像打上标签，
标签为你的用户名，然后用下面的命令推送到 Hub。用你的 Hub 用户名替换 <code>&lt;username&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker tag job-wq-1 &lt;username&gt;/job-wq-1
docker push &lt;username&gt;/job-wq-1
</code></pre></div><!--
If you are using [Google Container
Registry](https://cloud.google.com/tools/container-registry/), tag
your app image with your project ID, and push to GCR. Replace
`<project>` with your project ID.
-->
<p>如果你在用<a href="https://cloud.google.com/tools/container-registry/">谷歌容器仓库</a>，
用你的项目 ID 作为标签打到你的应用镜像上，然后推送到 GCR。
用你的项目 ID 替换 <code>&lt;project&gt;</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker tag job-wq-1 gcr.io/&lt;project&gt;/job-wq-1
gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-1
</code></pre></div><!--
## Defining a Job

Here is a job definition.  You'll need to make a copy of the Job and edit the
image to match the name you used, and call it `./job.yaml`.
-->
<h2 id="定义-job">定义 Job</h2>
<p>这里给出一个 Job 定义 yaml文件。你需要拷贝一份并编辑镜像以匹配你使用的名称，保存为 <code>./job.yaml</code>。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/rabbitmq/job.yaml" download="application/job/rabbitmq/job.yaml"><code>application/job/rabbitmq/job.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-rabbitmq-job-yaml')" title="Copy application/job/rabbitmq/job.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-rabbitmq-job-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>job-wq-1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">completions</span>:<span style="color:#bbb"> </span><span style="color:#666">8</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">parallelism</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>job-wq-1<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>c<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>gcr.io/&lt;project&gt;/job-wq-1<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">env</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>BROKER_URL<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span>amqp://guest:guest@rabbitmq-service:5672<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>QUEUE<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">value</span>:<span style="color:#bbb"> </span>job1<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>OnFailure<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
In this example, each pod works on one item from the queue and then exits.
So, the completion count of the Job corresponds to the number of work items
done.  So we set, `.spec.completions: 8` for the example, since we put 8 items in the queue.

## Running the Job

So, now run the Job:
-->
<p>本例中，每个 Pod 使用队列中的一个消息然后退出。这样，Job 的完成计数就代表了完成的工作项的数量。本例中我们设置 <code>.spec.completions: 8</code>，因为我们放了8项内容在队列中。</p>
<h2 id="运行-job">运行 Job</h2>
<p>现在我们运行 Job：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./job.yaml
</code></pre></div><!--
Now wait a bit, then check on the job.
-->
<p>稍等片刻，然后检查 Job。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe jobs/job-wq-1
</code></pre></div><pre><code>Name:             job-wq-1
Namespace:        default
Selector:         controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-1
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      8
Start Time:       Wed, 06 Sep 2017 16:42:02 +0800
Pods Statuses:    0 Running / 8 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=41d75705-92df-11e7-b85e-fa163ee3c11f
                job-name=job-wq-1
  Containers:
   c:
    Image:      gcr.io/causal-jigsaw-637/job-wq-1
    Port:
    Environment:
      BROKER_URL:       amqp://guest:guest@rabbitmq-service:5672
      QUEUE:            job1
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen  LastSeen   Count    From    SubobjectPath    Type      Reason              Message
  ─────────  ────────   ─────    ────    ─────────────    ──────    ──────              ───────
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-hcobb
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-weytj
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-qaam5
  27s        27s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-b67sr
  26s        26s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-xe5hj
  15s        15s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-w2zqe
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-d6ppa
  14s        14s        1        {job }                   Normal    SuccessfulCreate    Created pod: job-wq-1-p17e0
</code></pre><!--
All our pods succeeded.  Yay.
-->
<p>我们所有的 Pod 都成功了。耶！</p>
<!-- discussion -->
<!--
## Alternatives

This approach has the advantage that you
do not need to modify your "worker" program to be aware that there is a work queue.

It does require that you run a message queue service.
If running a queue service is inconvenient, you may
want to consider one of the other [job patterns](/docs/concepts/jobs/run-to-completion-finite-workloads/#job-patterns).
-->
<h2 id="替代方案">替代方案</h2>
<p>本文所讲述的处理方法的好处是你不需要修改你的 &quot;worker&quot; 程序使其知道工作队列的存在。</p>
<p>本文所描述的方法需要你运行一个消息队列服务。如果不方便运行消息队列服务，你也许会考虑另外一种
<a href="/zh/docs/concepts/workloads/controllers/job/#job-patterns">任务模式</a>。</p>
<!--
This approach creates a pod for every work item.  If your work items only take a few seconds,
though, creating a Pod for every work item may add a lot of overhead.  Consider another
[example](/docs/tasks/job/fine-parallel-processing-work-queue/), that executes multiple work items per Pod.

In this example, we used use the `amqp-consume` utility to read the message
from the queue and run our actual program.  This has the advantage that you
do not need to modify your program to be aware of the queue.
A [different example](/docs/tasks/job/fine-parallel-processing-work-queue/), shows how to
communicate with the work queue using a client library.
-->
<p>本文所述的方法为每个工作项创建了一个 Pod。
如果你的工作项仅需数秒钟，为每个工作项创建 Pod会增加很多的常规消耗。
可以考虑另外的方案请参考<a href="/zh/docs/tasks/job/fine-parallel-processing-work-queue/">示例</a>，
这种方案可以实现每个 Pod 执行多个工作项。</p>
<p>示例中，我们使用 <code>amqp-consume</code> 从消息队列读取消息并执行我们真正的程序。
这样的好处是你不需要修改你的程序使其知道队列的存在。
要了解怎样使用客户端库和工作队列通信，请参考
<a href="/zh/docs/tasks/job/fine-parallel-processing-work-queue/">不同的示例</a>。</p>
<!--
## Caveats

If the number of completions is set to less than the number of items in the queue, then
not all items will be processed.

If the number of completions is set to more than the number of items in the queue,
then the Job will not appear to be completed, even though all items in the queue
have been processed.  It will start additional pods which will block waiting
for a message.

There is an unlikely race with this pattern.  If the container is killed in between the time
that the message is acknowledged by the amqp-consume command and the time that the container
exits with success, or if the node crashes before the kubelet is able to post the success of the pod
back to the api-server, then the Job will not appear to be complete, even though all items
in the queue have been processed.
-->
<h2 id="友情提醒">友情提醒</h2>
<p>如果设置的完成数量小于队列中的消息数量，会导致一部分消息项不会被执行。</p>
<p>如果设置的完成数量大于队列中的消息数量，当队列中所有的消息都处理完成后，
Job 也会显示为未完成。Job 将创建 Pod 并阻塞等待消息输入。</p>
<p>当发生下面两种情况时，即使队列中所有的消息都处理完了，Job 也不会显示为完成状态：</p>
<ul>
<li>在 amqp-consume 命令拿到消息和容器成功退出之间的时间段内，执行杀死容器操作；</li>
<li>在 kubelet 向 api-server 传回 Pod 成功运行之前，发生节点崩溃。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-457c9dd93aed2b05615ed28dc38075d3">3 - 使用工作队列进行精细的并行处理</h1>
    
	<!--
title: Fine Parallel Processing Using a Work Queue
content_type: task
weight: 30
min-kubernetes-server-version: v1.8
-->
<!-- overview -->
<!--
In this example, we will run a Kubernetes Job with multiple parallel
worker processes in a given pod.
-->
<p>在这个例子中，我们会运行一个Kubernetes Job，其中的 Pod 会运行多个并行工作进程。</p>
<!--
In this example, as each pod is created, it picks up one unit of work
from a task queue, processes it, and repeats until the end of the queue is reached.

Here is an overview of the steps in this example:
-->
<p>在这个例子中，当每个pod被创建时，它会从一个任务队列中获取一个工作单元，处理它，然后重复，直到到达队列的尾部。</p>
<p>下面是这个示例的步骤概述：</p>
<!--
1. **Start a storage service to hold the work queue.**  In this example, we use Redis to store
  our work items.  In the previous example, we used RabbitMQ.  In this example, we use Redis and
  a custom work-queue client library because AMQP does not provide a good way for clients to
  detect when a finite-length work queue is empty.  In practice you would set up a store such
  as Redis once and reuse it for the work queues of many jobs, and other things.
-->
<ol>
<li><strong>启动存储服务用于保存工作队列。</strong> 在这个例子中，我们使用 Redis 来存储工作项。
在上一个例子中，我们使用了 RabbitMQ。
在这个例子中，由于 AMQP 不能为客户端提供一个良好的方法来检测一个有限长度的工作队列是否为空，
我们使用了 Redis 和一个自定义的工作队列客户端库。
在实践中，你可能会设置一个类似于 Redis 的存储库，并将其同时用于多项任务或其他事务的工作队列。</li>
</ol>
<!--
1. **Create a queue, and fill it with messages.**  Each message represents one task to be done.  In
   this example, a message is an integer that we will do a lengthy computation on.
-->
<ol start="2">
<li><strong>创建一个队列，然后向其中填充消息。</strong> 每个消息表示一个将要被处理的工作任务。
在这个例子中，消息是一个我们将用于进行长度计算的整数。</li>
</ol>
<!--
1. **Start a Job that works on tasks from the queue**.  The Job starts several pods.  Each pod takes
  one task from the message queue, processes it, and repeats until the end of the queue is reached.
-->
<ol start="3">
<li><strong>启动一个 Job 对队列中的任务进行处理</strong>。这个 Job 启动了若干个 Pod 。
每个 Pod 从消息队列中取出一个工作任务，处理它，然后重复，直到到达队列的尾部。</li>
</ol>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version v1.8.
 To check the version, enter <code>kubectl version</code>.
</p>
<!--
Be familiar with the basic,
non-parallel, use of [Job](/docs/concepts/workloads/controllers/job/).
-->
<p>熟悉基本的、非并行的 <a href="/zh/docs/concepts/workloads/controllers/job/">Job</a>。</p>
<!-- steps -->
<!--
## Starting Redis

For this example, for simplicity, we will start a single instance of Redis.
See the [Redis Example](https://github.com/kubernetes/examples/tree/master/guestbook) for an example
of deploying Redis scalably and redundantly.
-->
<h2 id="启动-redis">启动 Redis</h2>
<p>对于这个例子，为了简单起见，我们将启动一个单实例的 Redis。
了解如何部署一个可伸缩、高可用的 Redis 例子，请查看
<a href="https://github.com/kubernetes/examples/tree/master/guestbook">Redis 示例</a></p>
<!--
You could also download the following files directly:
-->
<p>你也可以直接下载如下文件：</p>
<ul>
<li><a href="/examples/application/job/redis/redis-pod.yaml"><code>redis-pod.yaml</code></a></li>
<li><a href="/examples/application/job/redis/redis-service.yaml"><code>redis-service.yaml</code></a></li>
<li><a href="/examples/application/job/redis/Dockerfile"><code>Dockerfile</code></a></li>
<li><a href="/examples/application/job/redis/job.yaml"><code>job.yaml</code></a></li>
<li><a href="/examples/application/job/redis/rediswq.py"><code>rediswq.py</code></a></li>
<li><a href="/examples/application/job/redis/worker.py"><code>worker.py</code></a></li>
</ul>
<!--
## Filling the Queue with tasks

Now let's fill the queue with some "tasks".  In our example, our tasks are strings to be
printed.

Start a temporary interactive pod for running the Redis CLI.
-->
<h2 id="使用任务填充队列">使用任务填充队列</h2>
<p>现在，让我们往队列里添加一些“任务”。在这个例子中，我们的任务是一些将被打印出来的字符串。</p>
<p>启动一个临时的可交互的 pod 用于运行 Redis 命令行界面。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run -i --tty temp --image redis --command <span style="color:#b44">&#34;/bin/sh&#34;</span>
</code></pre></div><pre><code>Waiting for pod default/redis2-c7h78 to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><!--
Now hit enter, start the redis CLI, and create a list with some work items in it.
-->
<p>现在按回车键，启动 redis 命令行界面，然后创建一个存在若干个工作项的列表。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># redis-cli -h redis</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;apple&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">1</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;banana&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">2</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;cherry&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">3</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;date&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">4</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;fig&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">5</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;grape&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">6</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;lemon&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">7</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;melon&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">8</span>
redis:6379&gt; rpush job2 <span style="color:#b44">&#34;orange&#34;</span>
<span style="color:#666">(</span>integer<span style="color:#666">)</span> <span style="color:#666">9</span>
redis:6379&gt; lrange job2 <span style="color:#666">0</span> -1
1<span style="color:#666">)</span> <span style="color:#b44">&#34;apple&#34;</span>
2<span style="color:#666">)</span> <span style="color:#b44">&#34;banana&#34;</span>
3<span style="color:#666">)</span> <span style="color:#b44">&#34;cherry&#34;</span>
4<span style="color:#666">)</span> <span style="color:#b44">&#34;date&#34;</span>
5<span style="color:#666">)</span> <span style="color:#b44">&#34;fig&#34;</span>
6<span style="color:#666">)</span> <span style="color:#b44">&#34;grape&#34;</span>
7<span style="color:#666">)</span> <span style="color:#b44">&#34;lemon&#34;</span>
8<span style="color:#666">)</span> <span style="color:#b44">&#34;melon&#34;</span>
9<span style="color:#666">)</span> <span style="color:#b44">&#34;orange&#34;</span>
</code></pre></div><!--
So, the list with key `job2` will be our work queue.
-->
<p>因此，这个键为 <code>job2</code> 的列表就是我们的工作队列。</p>
<!--
Note: if you do not have Kube DNS setup correctly, you may need to change
the first step of the above block to `redis-cli -h $REDIS_SERVICE_HOST`.
-->
<p>注意：如果你还没有正确地配置 Kube DNS，你可能需要将上面的第一步改为
<code>redis-cli -h $REDIS_SERVICE_HOST</code>。</p>
<!--
## Create an Image

Now we are ready to create an image that we will run.

We will use a python worker program with a redis client to read
the messages from the message queue.

A simple Redis work queue client library is provided,
called rediswq.py ([Download](/examples/application/job/redis/rediswq.py)).
-->
<h2 id="创建镜像">创建镜像</h2>
<p>现在我们已经准备好创建一个我们要运行的镜像</p>
<p>我们会使用一个带有 redis 客户端的 python 工作程序从消息队列中读出消息。</p>
<p>这里提供了一个简单的 Redis 工作队列客户端库，叫 rediswq.py (<a href="/examples/application/job/redis/rediswq.py">下载</a>)。</p>
<!--
The "worker" program in each Pod of the Job uses the work queue
client library to get work.  Here it is:
-->
<p>Job 中每个 Pod 内的 “工作程序” 使用工作队列客户端库获取工作。如下：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/redis/worker.py" download="application/job/redis/worker.py"><code>application/job/redis/worker.py</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-redis-worker-py')" title="Copy application/job/redis/worker.py to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-redis-worker-py">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">#!/usr/bin/env python</span>

<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">time</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">rediswq</span>

host<span style="color:#666">=</span><span style="color:#b44">&#34;redis&#34;</span>
<span style="color:#080;font-style:italic"># Uncomment next two lines if you do not have Kube-DNS working.</span>
<span style="color:#080;font-style:italic"># import os</span>
<span style="color:#080;font-style:italic"># host = os.getenv(&#34;REDIS_SERVICE_HOST&#34;)</span>

q <span style="color:#666">=</span> rediswq<span style="color:#666">.</span>RedisWQ(name<span style="color:#666">=</span><span style="color:#b44">&#34;job2&#34;</span>, host<span style="color:#666">=</span>host)
<span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Worker with sessionID: &#34;</span> <span style="color:#666">+</span>  q<span style="color:#666">.</span>sessionID())
<span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Initial queue state: empty=&#34;</span> <span style="color:#666">+</span> <span style="color:#a2f">str</span>(q<span style="color:#666">.</span>empty()))
<span style="color:#a2f;font-weight:bold">while</span> <span style="color:#a2f;font-weight:bold">not</span> q<span style="color:#666">.</span>empty():
  item <span style="color:#666">=</span> q<span style="color:#666">.</span>lease(lease_secs<span style="color:#666">=</span><span style="color:#666">10</span>, block<span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">True</span>, timeout<span style="color:#666">=</span><span style="color:#666">2</span>)
  <span style="color:#a2f;font-weight:bold">if</span> item <span style="color:#a2f;font-weight:bold">is</span> <span style="color:#a2f;font-weight:bold">not</span> <span style="color:#a2f;font-weight:bold">None</span>:
    itemstr <span style="color:#666">=</span> item<span style="color:#666">.</span>decode(<span style="color:#b44">&#34;utf-8&#34;</span>)
    <span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Working on &#34;</span> <span style="color:#666">+</span> itemstr)
    time<span style="color:#666">.</span>sleep(<span style="color:#666">10</span>) <span style="color:#080;font-style:italic"># Put your actual work here instead of sleep.</span>
    q<span style="color:#666">.</span>complete(item)
  <span style="color:#a2f;font-weight:bold">else</span>:
    <span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Waiting for work&#34;</span>)
<span style="color:#a2f">print</span>(<span style="color:#b44">&#34;Queue empty, exiting&#34;</span>)
</code></pre></div>
    </div>
</div>


<!--
You could download [`worker.py`](/examples/application/job/redis/worker.py), [`rediswq.py`](/examples/application/job/redis/rediswq.py), and [`Dockerfile`](/examples/application/job/redis/Dockerfile)
using above links. Then build the image:
-->
<p>你也可以下载 <a href="/examples/application/job/redis/worker.py"><code>worker.py</code></a>、
<a href="/examples/application/job/redis/rediswq.py"><code>rediswq.py</code></a> 和
<a href="/examples/application/job/redis/Dockerfile"><code>Dockerfile</code></a>。然后构建镜像：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker build -t job-wq-2 .
</code></pre></div><!--
### Push the image

For the [Docker Hub](https://hub.docker.com/), tag your app image with
your username and push to the Hub with the below commands. Replace
`<username>` with your Hub username.
-->
<h3 id="push-镜像">Push 镜像</h3>
<p>对于 <a href="https://hub.docker.com/">Docker Hub</a>，请先用你的用户名给镜像打上标签，
然后使用下面的命令 push 你的镜像到仓库。请将 <code>&lt;username&gt;</code> 替换为你自己的 Hub 用户名。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker tag job-wq-2 &lt;username&gt;/job-wq-2
docker push &lt;username&gt;/job-wq-2
</code></pre></div><!--
You need to push to a public repository or [configure your cluster to be able to access
your private repository](/docs/concepts/containers/images/).
-->
<p>你需要将镜像 push 到一个公共仓库或者
<a href="/zh/docs/concepts/containers/images/">配置集群访问你的私有仓库</a>。</p>
<!--
If you are using [Google Container
Registry](https://cloud.google.com/tools/container-registry/), tag
your app image with your project ID, and push to GCR. Replace
`<project>` with your project ID.
-->
<p>如果你使用的是 <a href="https://cloud.google.com/tools/container-registry/">Google Container Registry</a>，
请先用你的 project ID 给你的镜像打上标签，然后 push 到 GCR 。请将 <code>&lt;project&gt;</code> 替换为你自己的 project ID</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">docker tag job-wq-2 gcr.io/&lt;project&gt;/job-wq-2
gcloud docker -- push gcr.io/&lt;project&gt;/job-wq-2
</code></pre></div><!--
## Defining a Job

Here is the job definition:
-->
<h2 id="定义一个-job">定义一个 Job</h2>
<p>这是 job 定义：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/redis/job.yaml" download="application/job/redis/job.yaml"><code>application/job/redis/job.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-redis-job-yaml')" title="Copy application/job/redis/job.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-redis-job-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>job-wq-2<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">parallelism</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>job-wq-2<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>c<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>gcr.io/myproject/job-wq-2<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>OnFailure<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
Be sure to edit the job template to
change `gcr.io/myproject` to your own path.
-->
<p>请确保将 job 模板中的 <code>gcr.io/myproject</code> 更改为你自己的路径。</p>
<!--
In this example, each pod works on several items from the queue and then exits when there are no more items.
Since the workers themselves detect when the workqueue is empty, and the Job controller does not
know about the workqueue, it relies on the workers to signal when they are done working.
The workers signal that the queue is empty by exiting with success.  So, as soon as any worker
exits with success, the controller knows the work is done, and the Pods will exit soon.
So, we set the completion count of the Job to 1.  The job controller will wait for the other pods to complete
too.
-->
<p>在这个例子中，每个 pod 处理了队列中的多个项目，直到队列中没有项目时便退出。
因为是由工作程序自行检测工作队列是否为空，并且 Job 控制器不知道工作队列的存在，
这依赖于工作程序在完成工作时发出信号。
工作程序以成功退出的形式发出信号表示工作队列已经为空。
所以，只要有任意一个工作程序成功退出，控制器就知道工作已经完成了，所有的 Pod 将很快会退出。
因此，我们将 Job 的完成计数（Completion Count）设置为 1 。
尽管如此，Job 控制器还是会等待其它 Pod 完成。</p>
<!--
## Running the Job

So, now run the Job:
-->
<h2 id="运行-job">运行 Job</h2>
<p>现在运行这个 Job ：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f ./job.yaml
</code></pre></div><!--
Now wait a bit, then check on the job.
-->
<p>稍等片刻，然后检查这个 Job。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe jobs/job-wq-2
</code></pre></div><pre><code>Name:             job-wq-2
Namespace:        default
Selector:         controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
Labels:           controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                  job-name=job-wq-2
Annotations:      &lt;none&gt;
Parallelism:      2
Completions:      &lt;unset&gt;
Start Time:       Mon, 11 Jan 2016 17:07:59 -0800
Pods Statuses:    1 Running / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1c7e4e3-92e1-11e7-b85e-fa163ee3c11f
                job-name=job-wq-2
  Containers:
   c:
    Image:              gcr.io/exampleproject/job-wq-2
    Port:
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  33s          33s         1        {job-controller }                Normal      SuccessfulCreate  Created pod: job-wq-2-lglf8
</code></pre><p>查看日志：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs pods/job-wq-2-7r7b2
</code></pre></div><pre><code>Worker with sessionID: bbd72d0a-9e5c-4dd6-abf6-416cc267991f
Initial queue state: empty=False
Working on banana
Working on date
Working on lemon
</code></pre><!--
As you can see, one of our pods worked on several work units.
-->
<p>你可以看到，其中的一个 pod 处理了若干个工作单元。</p>
<!-- discussion -->
<!--
## Alternatives
-->
<h2 id="替代方案">替代方案</h2>
<!--
If running a queue service or modifying your containers to use a work queue is inconvenient, you may
want to consider one of the other [job patterns](/docs/concepts/jobs/run-to-completion-finite-workloads/#job-patterns).
-->
<p>如果你不方便运行一个队列服务或者修改你的容器用于运行一个工作队列，你可以考虑其它的
<a href="/zh/docs/concepts/workloads/controllers/job/#job-patterns">Job 模式</a>。</p>
<!--
If you have a continuous stream of background processing work to run, then
consider running your background workers with a `ReplicaSet` instead,
and consider running a background processing library such as
[https://github.com/resque/resque](https://github.com/resque/resque).
-->
<p>如果你有持续的后台处理业务，那么可以考虑使用 <code>ReplicaSet</code> 来运行你的后台业务，
和运行一个类似 <a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
的后台处理库。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9e63850014876afaebd1561f70bb8f6b">4 - 使用索引作业完成静态工作分配下的并行处理</h1>
    
	<!-- 
title: Indexed Job for Parallel Processing with Static Work Assignment
content_type: task
min-kubernetes-server-version: v1.21
weight: 30
-->





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>


<!-- overview -->
<!-- 
In this example, you will run a Kubernetes Job that uses multiple parallel
worker processes.
Each worker is a different container running in its own Pod. The Pods have an
_index number_ that the control plane sets automatically, which allows each Pod
to identify which part of the overall task to work on.
-->
<p>在此示例中，你将运行一个使用多个并行工作进程的 Kubernetes Job。
每个 worker 都是在自己的 Pod 中运行的不同容器。
Pod 具有控制平面自动设置的 <em>索引编号（index number）</em>，
这些编号使得每个 Pod 能识别出要处理整个任务的哪个部分。</p>
<!-- 
The pod index is available in the <a class='glossary-tooltip' title='注解是以键值对的形式给资源对象附加随机的无法标识的元数据。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/annotations/' target='_blank' aria-label='annotation'>annotation</a>
`batch.kubernetes.io/job-completion-index` as a string representing its
decimal value. In order for the containerized task process to obtain this index,
you can publish the value of the annotation using the [downward API](/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api)
mechanism.
For convenience, the control plane automatically sets the downward API to
expose the index in the `JOB_COMPLETION_INDEX` environment variable.
-->
<p>Pod 索引在<a class='glossary-tooltip' title='注解是以键值对的形式给资源对象附加随机的无法标识的元数据。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/annotations/' target='_blank' aria-label='注解'>注解</a>
<code>batch.kubernetes.io/job-completion-index</code> 中呈现，具体表示为一个十进制值字符串。
为了让容器化的任务进程获得此索引，你可以使用
<a href="/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api">downward API</a>
机制发布注解的值。为方便起见，
控制平面自动设置 downward API 以在 <code>JOB_COMPLETION_INDEX</code> 环境变量中公开索引。</p>
<!-- 
Here is an overview of the steps in this example:

1. **Define a Job manifest using indexed completion**.
   The downward API allows you to pass the pod index annotation as an
   environment variable or file to the container.
2. **Start an `Indexed` Job based on that manifest**.
-->
<p>以下是此示例中步骤的概述：</p>
<ol>
<li><strong>定义使用带索引完成信息的 Job 清单</strong>。
Downward API 使你可以将 Pod 索引注释作为环境变量或文件传递给容器。</li>
<li><strong>根据该清单启动一个带索引（<code>Indexed</code>）的 Job</strong>。</li>
</ol>
<h2 id="before-you-begin">Before you begin</h2>
<!-- 
You should already be familiar with the basic,
non-parallel, use of [Job](/docs/concepts/workloads/controllers/job/).
-->
<p>你应该已经熟悉 <a href="/zh/docs/concepts/workloads/controllers/job/">Job</a> 的基本的、非并行的用法。</p>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version v1.21.
 To check the version, enter <code>kubectl version</code>.
</p>
<!-- steps -->
<!-- ## Choose an approach -->
<h2 id="选择一种方法">选择一种方法</h2>
<!-- 
To access the work item from the worker program, you have a few options:

1. Read the `JOB_COMPLETION_INDEX` environment variable. The Job
   <a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='controller'>controller</a>
   automatically links this variable to the annotation containing the completion
   index.
1. Read a file that contains the completion index.
1. Assuming that you can't modify the program, you can wrap it with a script
   that reads the index using any of the methods above and converts it into
   something that the program can use as input.
 -->
<p>要从工作程序访问工作项，你有几个选择：</p>
<ol>
<li>读取 <code>JOB_COMPLETION_INDEX</code> 环境变量。Job
<a class='glossary-tooltip' title='控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/architecture/controller/' target='_blank' aria-label='控制器'>控制器</a>
自动将此变量链接到包含完成索引的注解。</li>
<li>读取包含完整索引的文件。</li>
<li>假设你无法修改程序，你可以使用脚本包装它，
该脚本使用上述任意方法读取索引并将其转换为程序可以用作输入的内容。</li>
</ol>
<!-- 
For this example, imagine that you chose option 3 and you want to run the
[rev](https://man7.org/linux/man-pages/man1/rev.1.html) utility. This
program accepts a file as an argument and prints its content reversed.
-->
<p>对于此示例，假设你选择了方法 3 并且想要运行
<a href="https://man7.org/linux/man-pages/man1/rev.1.html">rev</a> 实用程序。
这个程序接受一个文件作为参数并按逆序打印其内容。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">rev data.txt
</code></pre></div><!--  
You'll use the `rev` tool from the
[`busybox`](https://hub.docker.com/_/busybox) container image.
-->
<p>你将使用 <a href="https://hub.docker.com/_/busybox"><code>busybox</code></a> 容器映像中的 <code>rev</code> 工具。</p>
<!-- 
As this is only an example, each Pod only does a tiny piece of work (reversing a short
string). In a real workload you might, for example, create a Job that represents
 the
task of producing 60 seconds of video based on scene data.
Each work item in the video rendering Job would be to render a particular
frame of that video clip. Indexed completion would mean that each Pod in
the Job knows which frame to render and publish, by counting frames from
the start of the clip.
-->
<p>由于这只是一个例子，每个 Pod 只做一小部分工作（反转一个短字符串）。
例如，在实际工作负载中，你可能会创建一个表示基于场景数据制作 60 秒视频的任务的 Job 。
视频渲染 Job 中的每个工作项都将渲染该视频剪辑的特定帧。
索引完成意味着 Job 中的每个 Pod 都知道通过从剪辑开始计算帧数，来确定渲染和发布哪一帧，。</p>
<!-- ## Define an Indexed Job -->
<h2 id="定义索引作业">定义索引作业</h2>
<!-- 
Here is a sample Job manifest that uses `Indexed` completion mode:
-->
<p>这是一个使用 <code>Indexed</code> 完成模式的示例 Job 清单：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/indexed-job.yaml" download="application/job/indexed-job.yaml"><code>application/job/indexed-job.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-indexed-job-yaml')" title="Copy application/job/indexed-job.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-indexed-job-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;indexed-job&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">completions</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">parallelism</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">completionMode</span>:<span style="color:#bbb"> </span>Indexed<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">initContainers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;input&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;docker.io/library/bash&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;bash&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;-c&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- |<span style="color:#b44;font-style:italic">
</span><span style="color:#b44;font-style:italic">          items=(foo bar baz qux xyz)
</span><span style="color:#b44;font-style:italic">          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style="color:#bbb">          
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">volumeMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">mountPath</span>:<span style="color:#bbb"> </span>/input<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>input<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;worker&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;docker.io/library/busybox&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;rev&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;/input/data.txt&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">volumeMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">mountPath</span>:<span style="color:#bbb"> </span>/input<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>input<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">volumes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>input<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">emptyDir</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!-- 
In the example above, you use the builtin `JOB_COMPLETION_INDEX` environment
variable set by the Job controller for all containers. An [init container](/docs/concepts/workloads/pods/init-containers/)
maps the index to a static value and writes it to a file that is shared with the
container running the worker through an [emptyDir volume](/docs/concepts/storage/volumes/#emptydir).
Optionally, you can [define your own environment variable through the downward
API](/docs/tasks/inject-data-application/environment-variable-expose-pod-information/)
to publish the index to containers. You can also choose to load a list of values
from a [ConfigMap as an environment variable or file](/docs/tasks/configure-pod-container/configure-pod-configmap/).
-->
<p>在上面的示例中，你使用 Job 控制器为所有容器设置的内置 <code>JOB_COMPLETION_INDEX</code> 环境变量。
<a href="/zh/docs/concepts/workloads/pods/init-containers/">Init 容器</a>
将索引映射到一个静态值，并将其写入一个文件，该文件通过
<a href="/zh/docs/concepts/storage/volumes/#emptydir">emptyDir 卷</a>
与运行 worker 的容器共享。或者，你可以
<a href="/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/">通过 Downward API 定义自己的环境变量</a>
将索引发布到容器。你还可以选择从
<a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap/">包含 ConfigMap 的环境变量或文件</a>
加载值列表。</p>
<!-- 
Alternatively, you can directly [use the downward API to pass the annotation
value as a volume file](/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields),
like shown in the following example:
-->
<p>或者也可以直接
<a href="/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields">使用 Downward API 将注解值作为卷文件传递</a>，
如下例所示：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/indexed-job-vol.yaml" download="application/job/indexed-job-vol.yaml"><code>application/job/indexed-job-vol.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-indexed-job-vol-yaml')" title="Copy application/job/indexed-job-vol.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-indexed-job-vol-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;indexed-job&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">completions</span>:<span style="color:#bbb"> </span><span style="color:#666">5</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">parallelism</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">completionMode</span>:<span style="color:#bbb"> </span>Indexed<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;worker&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#39;docker.io/library/busybox&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;rev&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#b44">&#34;/input/data.txt&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">volumeMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">mountPath</span>:<span style="color:#bbb"> </span>/input<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>input<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">volumes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>input<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">downwardAPI</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">items</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span>- <span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;data.txt&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">fieldRef</span>:<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">fieldPath</span>:<span style="color:#bbb"> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</code></pre></div>
    </div>
</div>


<!-- ## Running the Job -->
<h2 id="执行-job">执行 Job</h2>
<!-- Now run the Job: -->
<p>现在执行 Job：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 使用第一种方法（依赖于 $JOB_COMPLETION_INDEX）</span>
kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</code></pre></div><!-- 
When you create this Job, the control plane creates a series of Pods, one for each index you specified. The value of `.spec.parallelism` determines how many can run at once whereas `.spec.completions` determines how many Pods the Job creates in total.

Because `.spec.parallelism` is less than `.spec.completions`, the control plane waits for some of the first Pods to complete before starting more of them.

Once you have created the Job, wait a moment then check on progress:
-->
<p>当你创建此 Job 时，控制平面会创建一系列 Pod，每个索引都由你指定。
<code>.spec.parallelism</code> 的值决定了一次可以运行多少个，
而 <code>.spec.completions</code> 决定了 Job 总共创建了多少个 Pod。</p>
<p>因为 <code>.spec.parallelism</code> 小于 <code>.spec.completions</code>，
控制平面在启动更多 Pod 之前，等待部分第一批 Pod 完成。</p>
<p>创建 Job 后，稍等片刻，然后检查进度：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe jobs/indexed-job
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod's lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre><!-- 
In this example, you run the Job with custom values for each index. You can
inspect the output of one of the pods:
-->
<p>在此示例中，你使用每个索引的自定义值运行 Job。
你可以检查其中一个 Pod 的输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs indexed-job-fdhq5 <span style="color:#080;font-style:italic"># 更改它以匹配来自该 Job 的 Pod 的名称</span>
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>xuq
</code></pre>
</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-da7c2b067953d239eb4457e8978ad8f6">5 - 使用展开的方式进行并行处理</h1>
    
	<!--
title: Parallel Processing using Expansions
content_type: task
min-kubernetes-server-version: v1.8
weight: 50
-->
<!-- overview -->
<!--
This task demonstrates running multiple <a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Jobs'>Jobs</a>
based on a common template. You can use this approach to process batches of work in
parallel.

For this example there are only three items: _apple_, _banana_, and _cherry_.
The sample Jobs process each item by printing a string then pausing.

See [using Jobs in real workloads](#using-jobs-in-real-workloads) to learn about how
this pattern fits more realistic use cases.
-->
<p>本任务展示基于一个公共的模板运行多个<a class='glossary-tooltip' title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/job/' target='_blank' aria-label='Jobs'>Jobs</a>。
你可以用这种方法来并行执行批处理任务。</p>
<p>在本任务示例中，只有三个工作条目：<em>apple</em>、<em>banana</em> 和 <em>cherry</em>。
示例任务处理每个条目时打印一个字符串之后结束。</p>
<p>参考<a href="#using-jobs-in-real-workloads">在真实负载中使用 Job</a>了解更适用于真实使用场景的模式。</p>
<h2 id="before-you-begin">Before you begin</h2>
<!--
You should be familiar with the basic,
non-parallel, use of [Job](/docs/concepts/workloads/controllers/job/).
-->
<p>你应先熟悉基本的、非并行的 <a href="/zh/docs/concepts/workloads/controllers/job/">Job</a>
的用法。</p>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>

<!--
For basic templating you need the command-line utility `sed`.

To follow the advanced templating example, you need a working installation of
[Python](https://www.python.org/), and the Jinja2 template
library for Python.

Once you have Python set up, you can install Jinja2 by running:
-->
<p>任务中的基本模板示例要求安装命令行工具 <code>sed</code>。
要使用较高级的模板示例，你需要安装 <a href="https://www.python.org/">Python</a>，
并且要安装 Jinja2 模板库。</p>
<p>一旦 Python 已经安装好，你可以运行下面的命令安装 Jinja2：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">pip install --user jinja2
</code></pre></div><!-- steps -->
<!--
## Create Jobs based on a template
-->
<h2 id="create-jobs-based-on-a-template">基于模板创建 Job </h2>
<!--
First, download the following template of a job to a file called `job-tmpl.yaml`
-->
<p>首先，将以下作业模板下载到名为 <code>job-tmpl.yaml</code> 的文件中。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/job/job-tmpl.yaml" download="application/job/job-tmpl.yaml"><code>application/job/job-tmpl.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('application-job-job-tmpl-yaml')" title="Copy application/job/job-tmpl.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="application-job-job-tmpl-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>batch/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Job<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>process-item-$ITEM<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">jobgroup</span>:<span style="color:#bbb"> </span>jobexample<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>jobexample<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">jobgroup</span>:<span style="color:#bbb"> </span>jobexample<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>c<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>busybox:1.28<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;sh&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;-c&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;echo Processing item $ITEM &amp;&amp; sleep 5&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"> <span style="color:#080;font-style:italic"># 使用 curl 下载 job-tmpl.yaml</span>
curl -L -s -O https://k8s.io/examples/application/job/job-tmpl.yaml
</code></pre></div><!--
The file you downloaded is not yet a valid Kubernetes
<a class='glossary-tooltip' title='一个或多个 Kubernetes API 对象的序列化规范。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-manifest' target='_blank' aria-label='manifest'>manifest</a>.
Instead that template is a YAML representation of a Job object with some placeholders
that need to be filled in before it can be used.  The `$ITEM` syntax is not meaningful to Kubernetes.
-->
<p>你所下载的文件不是一个合法的 Kubernetes <a class='glossary-tooltip' title='一个或多个 Kubernetes API 对象的序列化规范。' data-toggle='tooltip' data-placement='top' href='/zh/docs/reference/glossary/?all=true#term-manifest' target='_blank' aria-label='清单'>清单</a>。
这里的模板只是 Job 对象的 yaml 表示，其中包含一些占位符，在使用它之前需要被填充。
<code>$ITEM</code> 语法对 Kubernetes 没有意义。</p>
<!--
### Create manifests from the template

The following shell snippet uses `sed` to replace the string `$ITEM` with the loop
variable, writing into a temporary directory named `jobs`. Run this now:
-->
<h3 id="基于模板创建清单">基于模板创建清单</h3>
<p>下面的 Shell 代码片段使用 <code>sed</code> 将字符串 <code>$ITEM</code> 替换为循环变量，并将结果
写入到一个名为 <code>jobs</code> 的临时目录。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 展开模板文件到多个文件中，每个文件对应一个要处理的条目</span>
mkdir ./jobs
<span style="color:#a2f;font-weight:bold">for</span> i in apple banana cherry
<span style="color:#a2f;font-weight:bold">do</span>
  cat job-tmpl.yaml | sed <span style="color:#b44">&#34;s/\$ITEM/</span><span style="color:#b8860b">$i</span><span style="color:#b44">/&#34;</span> &gt; ./jobs/job-<span style="color:#b8860b">$i</span>.yaml
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!--
Check if it worked:
-->
<p>检查上述脚本的输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ls jobs/
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>job-apple.yaml
job-banana.yaml
job-cherry.yaml
</code></pre><!--
You could use any type of template language (for example: Jinja2; ERB), or
write a program to generate the Job manifests.
-->
<p>你可以使用任何一种模板语言（例如：Jinja2、ERB），或者编写一个程序来
生成 Job 清单。</p>
<!--
### Create Jobs from the manifests

Next, create all the Jobs with one kubectl command:
-->
<h3 id="基于清单创建-job">基于清单创建 Job</h3>
<p>接下来用一个 kubectl 命令创建所有的 Job：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create -f ./jobs
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>job.batch/process-item-apple created
job.batch/process-item-banana created
job.batch/process-item-cherry created
</code></pre><!--
Now, check on the jobs:
-->
<p>现在检查 Job：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get <span style="color:#a2f">jobs</span> -l <span style="color:#b8860b">jobgroup</span><span style="color:#666">=</span>jobexample
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>NAME                  COMPLETIONS   DURATION   AGE
process-item-apple    1/1           14s        22s
process-item-banana   1/1           12s        21s
process-item-cherry   1/1           12s        20s
</code></pre><!--
Using the `-l` option to kubectl selects only the Jobs that are part
of this group of jobs (there might be other unrelated jobs in the system).

You can check on the Pods as well using the same
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='label selector'>label selector</a>:
-->
<p>使用 kubectl 的 <code>-l</code> 选项可以仅选择属于当前 Job 组的对象
（系统中可能存在其他不相关的 Job）。</p>
<p>你可以使用相同的 <a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签选择算符'>标签选择算符</a>
来过滤 Pods：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l <span style="color:#b8860b">jobgroup</span><span style="color:#666">=</span>jobexample
</code></pre></div><!--
The output is similar to:
-->
<p>输出类似于：</p>
<pre><code>NAME                        READY     STATUS      RESTARTS   AGE
process-item-apple-kixwv    0/1       Completed   0          4m
process-item-banana-wrsf7   0/1       Completed   0          4m
process-item-cherry-dnfu9   0/1       Completed   0          4m
</code></pre><!--
We can use this single command to check on the output of all jobs at once:
-->
<p>我们可以用下面的命令查看所有 Job 的输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl logs -f -l <span style="color:#b8860b">jobgroup</span><span style="color:#666">=</span>jobexample
</code></pre></div><!--
The output should be:
-->
<p>输出类似于：</p>
<pre><code>Processing item apple
Processing item banana
Processing item cherry
</code></pre><!--
### Clean up {#cleanup-1}
-->
<h3 id="cleanup-1">清理</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 删除所创建的 Job</span>
<span style="color:#080;font-style:italic"># 集群会自动清理 Job 对应的 Pod</span>
kubectl delete job -l <span style="color:#b8860b">jobgroup</span><span style="color:#666">=</span>jobexample
</code></pre></div><!--
## Use advanced template parameters

In the [first example](#create-jobs-based-on-a-template), each instance of the template had one
parameter, and that parameter was also used in the Job's name. However,
[names](/docs/concepts/overview/working-with-objects/names/#names) are restricted
to contain only certain characters.
-->
<h2 id="使用高级模板参数">使用高级模板参数</h2>
<p>在<a href="#create-jobs-based-on-a-template">第一个例子</a>中，模板的每个示例都有一个参数
而该参数也用在 Job 名称中。不过，对象
<a href="/zh/docs/concepts/overview/working-with-objects/names/#names">名称</a>
被限制只能使用某些字符。</p>
<!--
This slightly more complex example uses the
[Jinja template language](https://palletsprojects.com/p/jinja/) to generate manifests
and then objects from those manifests, with a multiple parameters for each Job.

For this part of the task, you are going to use a one-line Python script to
convert the template to a set of manifests.

First, copy and paste the following template of a Job object, into a file called `job.yaml.jinja2`:
-->
<p>这里的略微复杂的例子使用 <a href="https://palletsprojects.com/p/jinja/">Jinja 模板语言</a>
来生成清单，并基于清单来生成对象，每个 Job 都有多个参数。</p>
<p>在本任务中，你将会使用一个一行的 Python 脚本，将模板转换为一组清单文件。</p>
<p>首先，复制下面的 Job 对象模板到一个名为 <code>job.yaml.jinja2</code> 的文件。</p>
<pre><code class="language-liquid" data-lang="liquid">{% set params = [{ &quot;name&quot;: &quot;apple&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Apple&quot;, },
                  { &quot;name&quot;: &quot;banana&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Banana&quot;, },
                  { &quot;name&quot;: &quot;cherry&quot;, &quot;url&quot;: &quot;http://dbpedia.org/resource/Cherry&quot; }]
%}
{% for p in params %}
{% set name = p[&quot;name&quot;] %}
{% set url = p[&quot;url&quot;] %}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: jobexample-{{ name }}
  labels:
    jobgroup: jobexample
spec:
  template:
    metadata:
      name: jobexample
      labels:
        jobgroup: jobexample
    spec:
      containers:
      - name: c
        image: busybox:1.28
        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo Processing URL {{ url }} &amp;&amp; sleep 5&quot;]
      restartPolicy: Never
{% endfor %}
</code></pre><!--
The above template defines two parameters for each Job object using a list of
python dicts (lines 1-4). A `for` loop emits one Job manifest for each
set of parameters (remaining lines).

This example relies on a feature of YAML. One YAML file can contain multiple
documents (Kubernetes manifests, in this case), separated by `---` on a line
by itself.
You can pipe the output directly to `kubectl` to create the Jobs.

Next, use this one-line Python program to expand the template:
-->
<p>上面的模板使用 python 字典列表（第 1-4 行）定义每个作业对象的参数。
然后使用 for 循环为每组参数（剩余行）生成一个作业 yaml 对象。
我们利用了多个 YAML 文档（这里的 Kubernetes 清单）可以用 <code>---</code> 分隔符连接的事实。
我们可以将输出直接传递给 kubectl 来创建对象。</p>
<p>接下来我们用单行的 Python 程序将模板展开。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">alias</span> <span style="color:#b8860b">render_template</span><span style="color:#666">=</span><span style="color:#b44">&#39;python -c &#34;from jinja2 import Template; import sys; print(Template(sys.stdin.read()).render());&#34;&#39;</span>
</code></pre></div><!--
Use `render_template` to convert the parameters and template into a single
YAML file containing Kubernetes manifests:
-->
<p>使用 <code>render_template</code> 将参数和模板转换成一个 YAML 文件，其中包含 Kubernetes
资源清单：</p>
<!--
```shell
# This requires the alias you defined earlier
cat job.yaml.jinja2 | render_template > jobs.yaml
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 此命令需要之前定义的别名</span>
cat job.yaml.jinja2 | render_template &gt; jobs.yaml
</code></pre></div><!--
You can view `jobs.yaml` to verify that the `render_template` script worked
correctly.

Once you are happy that `render_template` is working how you intend,
you can pipe its output into `kubectl`:
-->
<p>你可以查看 <code>jobs.yaml</code> 以验证 <code>render_template</code> 脚本是否正常工作。</p>
<p>当你对输出结果比较满意时，可以用管道将其输出发送给 kubectl，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat job.yaml.jinja2 | render_template | kubectl apply -f -
</code></pre></div><!--
Kubernetes accepts and runs the Jobs you created.
-->
<p>Kubernetes 接收清单文件并执行你所创建的 Job。</p>
<!--
### Clean up {#cleanup-2}
```shell
# Remove the Jobs you created
# Your cluster automatically cleans up their Pods
kubectl delete job -l jobgroup=jobexample
```
-->
<h3 id="cleanup-2">清理</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># 删除所创建的 Job</span>
<span style="color:#080;font-style:italic"># 集群会自动清理 Job 对应的 Pod</span>
kubectl delete job -l <span style="color:#b8860b">jobgroup</span><span style="color:#666">=</span>jobexample
</code></pre></div><!-- discussion -->
<!--
## Using Jobs in real workloads

In a real use case, each Job performs some substantial computation, such as rendering a frame
of a movie, or processing a range of rows in a database. If you were rendering a movie
you would set `$ITEM` to the frame number. If you were processing rows from a database
table, you would set `$ITEM` to represent the range of database rows to process.

In the task, you ran a command to collect the output from Pods by fetching
their logs. In a real use case, each Pod for a Job writes its output to
durable storage before completing. You can use a PersistentVolume for each Job,
or an external storage service. For example, if you are rendering frames for a movie,
use HTTP to `PUT` the rendered frame data to a URL, using a different URL for each
frame.
-->
<h2 id="using-jobs-in-real-workloads">在真实负载中使用 Job</h2>
<p>在真实的负载中，每个 Job 都会执行一些重要的计算，例如渲染电影的一帧，
或者处理数据库中的若干行。这时，<code>$ITEM</code> 参数将指定帧号或行范围。</p>
<p>在此任务中，你运行一个命令通过取回 Pod 的日志来收集其输出。
在真实应用场景中，Job 的每个 Pod 都会在结束之前将其输出写入到某持久性存储中。
你可以为每个 Job 指定 PersistentVolume 卷，或者使用其他外部存储服务。
例如，如果你在渲染视频帧，你可能会使用 HTTP 协议将渲染完的帧数据
用 'PUT' 请求发送到某 URL，每个帧使用不同的 URl。</p>
<!--
## Labels on Jobs and Pods

After you create a Job, Kubernetes automatically adds additional
<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='labels'>labels</a> that
distinguish one Job's pods from another Job's pods.

In this example, each Job and its Pod template have a label:
`jobgroup=jobexample`.

Kubernetes itself pays no attention to labels named `jobgroup`. Setting a label
for all the Jobs you create from a template makes it convenient to operate on all
those Jobs at once.
In the [first example](#create-jobs-based-on-a-template) you used a template to
create several Jobs. The template ensures that each Pod also gets the same label, so
you can check on all Pods for these templated Jobs with a single command.
-->
<h2 id="job-和-pod-上的标签">Job 和 Pod 上的标签</h2>
<p>你创建了 Job 之后，Kubernetes 自动为 Job 的 Pod 添加
<a class='glossary-tooltip' title='用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='标签'>标签</a>，以便能够将一个 Job
的 Pod 与另一个 Job 的 Pod 区分开来。</p>
<p>在本例中，每个 Job 及其 Pod 模板有一个标签: <code>jobgroup=jobexample</code>。</p>
<p>Kubernetes 自身对标签名 <code>jobgroup</code> 没有什么要求。
为创建自同一模板的所有 Job 使用同一标签使得我们可以方便地同时操作组中的所有作业。
在<a href="#create-jobs-based-on-a-template">第一个例子</a>中，你使用模板来创建了若干 Job。
模板确保每个 Pod 都能够获得相同的标签，这样你可以用一条命令检查这些模板化
Job 所生成的全部 Pod。</p>
<!--
The label key `jobgroup` is not special or reserved.
You can pick your own labelling scheme.
There are [recommended labels](/docs/concepts/overview/working-with-objects/common-labels/#labels)
that you can use if you wish.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 标签键 <code>jobgroup</code> 没什么特殊的，也不是保留字。 你可以选择你自己的标签方案。
如果愿意，有一些<a href="/zh/docs/concepts/overview/working-with-objects/common-labels/#labels">建议的标签</a>
可供使用。
</div>
<!--
## Alternatives

If you plan to create a large number of Job objects, you may find that:
-->
<h2 id="替代方案">替代方案</h2>
<p>如果你有计划创建大量 Job 对象，你可能会发现：</p>
<!--
- Even using labels, managing so many Job objects is cumbersome.
- If you create many Jobs in a batch, you might place high load
  on the Kubernetes control plane. Alternatively, the Kubernetes API
  server could rate limit you, temporarily rejecting your requests with a 429 status.
- You are limited by a <a class='glossary-tooltip' title='资源配额提供了限制每个命名空间的资源消耗总和的约束。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/policy/resource-quotas/' target='_blank' aria-label='resource quota'>resource quota</a>
  on Jobs: the API server permanently rejects some of your requests
  when you create a great deal of work in one batch.
-->
<ul>
<li>即使使用标签，管理这么多 Job 对象也很麻烦。</li>
<li>如果你一次性创建很多 Job，很可能会给 Kubernetes 控制面带来很大压力。
一种替代方案是，Kubernetes API 可能对请求施加速率限制，通过 429 返回
状态值临时拒绝你的请求。</li>
<li>你可能会受到 Job 相关的<a class='glossary-tooltip' title='资源配额提供了限制每个命名空间的资源消耗总和的约束。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/policy/resource-quotas/' target='_blank' aria-label='资源配额'>资源配额</a>
限制：如果你在一个批量请求中触发了太多的任务，API 服务器会永久性地拒绝你的某些请求。</li>
</ul>
<!--
There are other [job patterns](/docs/concepts/workloads/controllers/job/#job-patterns)
that you can use to process large amounts of work without creating very many Job
objects.

You could also consider writing your own [controller](/docs/concepts/architecture/controller/)
to manage Job objects automatically.
-->
<p>还有一些其他<a href="/zh/docs/concepts/workloads/controllers/job/#job-patterns">作业模式</a>
可供选择，这些模式都能用来处理大量任务而又不会创建过多的 Job 对象。</p>
<p>你也可以考虑编写自己的<a href="/zh/docs/concepts/architecture/controller/">控制器</a>
来自动管理 Job 对象。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
