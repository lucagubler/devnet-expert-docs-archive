<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/tasks/tls/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/tasks/tls/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/tasks/tls/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/tasks/tls/">
<link rel="alternate" hreflang="de" href="http://localhost:1313/de/docs/tasks/tls/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/tasks/tls/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/tasks/tls/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/tasks/tls/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>TLS | Kubernetes</title><meta property="og:title" content="TLS" />
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/tls/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="TLS">
<meta itemprop="description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TLS"/>
<meta name="twitter:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta name="twitter:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。">
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/tls/">
<meta property="og:title" content="TLS">
<meta name="twitter:title" content="TLS">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tasks/tls/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/tasks/tls/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/tls/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tasks/tls/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tasks/tls/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tasks/tls/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tasks/tls/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/tasks/tls/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/tasks/tls/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/tasks/tls/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/tasks/tls/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/tasks/tls/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tasks/tls/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">TLS</h1>
<div class="lead">了解如何使用传输层安全性（ TLS ）保护集群中的流量。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-1272b18ac0c008f6ffc2c62a29fa929f">为 kubelet 配置证书轮换</a></li>


    
  
    
    
	
<li>2: <a href="#pg-43d5e2b1fc2a7e104e66d481d08578dc">手动轮换 CA 证书</a></li>


    
  
    
    
	
<li>3: <a href="#pg-9a87de8ee8332cb487f34a05debb1125">管理集群中的 TLS 认证</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-1272b18ac0c008f6ffc2c62a29fa929f">1 - 为 kubelet 配置证书轮换</h1>
    
	<!--
reviewers:
- jcbsmpsn
- mikedanese
title: Configure Certificate Rotation for the Kubelet
content_type: task
-->
<!-- overview -->
<!--
This page shows how to enable and configure certificate rotation for the kubelet.
-->
<p>本文展示如何在 kubelet 中启用并配置证书轮换。</p>





<div style="margin-top: 10px; margin-bottom: 10px;">
  <b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>


<h2 id="before-you-begin">Before you begin</h2>
<!--
* Kubernetes version 1.8.0 or later is required
-->
<ul>
<li>要求 Kubernetes 1.8.0 或更高的版本</li>
</ul>
<!-- steps -->
<!--
## Overview

The kubelet uses certificates for authenticating to the Kubernetes API.  By
default, these certificates are issued with one year expiration so that they do
not need to be renewed too frequently.
-->
<h2 id="概述">概述</h2>
<p>Kubelet 使用证书进行 Kubernetes API 的认证。
默认情况下，这些证书的签发期限为一年，所以不需要太频繁地进行更新。</p>
<!--
Kubernetes contains [kubelet certificate
rotation](/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/),
that will automatically generate a new key and request a new certificate from
the Kubernetes API as the current certificate approaches expiration. Once the
new certificate is available, it will be used for authenticating connections to
the Kubernetes API.
-->
<p>Kubernetes 包含特性
<a href="/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet 证书轮换</a>，
在当前证书即将过期时，
将自动生成新的秘钥，并从 Kubernetes API 申请新的证书。 一旦新的证书可用，它将被用于与
Kubernetes API 间的连接认证。</p>
<!--
## Enabling client certificate rotation

The `kubelet` process accepts an argument `--rotate-certificates` that controls
if the kubelet will automatically request a new certificate as the expiration of
the certificate currently in use approaches.
-->
<h2 id="启用客户端证书轮换">启用客户端证书轮换</h2>
<p><code>kubelet</code> 进程接收 <code>--rotate-certificates</code> 参数，该参数决定 kubelet 在当前使用的
证书即将到期时，是否会自动申请新的证书。</p>
<!--
The `kube-controller-manager` process accepts an argument
`--cluster-signing-duration`  (`--experimental-cluster-signing-duration` prior to 1.19)
that controls how long certificates will be issued for.
-->
<p><code>kube-controller-manager</code> 进程接收 <code>--cluster-signing-duration</code> 参数
（在 1.19 版本之前为 <code>--experimental-cluster-signing-duration</code>），用来
控制签发证书的有效期限。</p>
<!--
## Understanding the certificate rotation configuration

When a kubelet starts up, if it is configured to bootstrap (using the
`--bootstrap-kubeconfig` flag), it will use its initial certificate to connect
to the Kubernetes API and issue a certificate signing request. You can view the
status of certificate signing requests using:
-->
<h2 id="理解证书轮换配置">理解证书轮换配置</h2>
<p>当 kubelet 启动时，如被配置为自举（使用<code>--bootstrap-kubeconfig</code> 参数），kubelet
会使用其初始证书连接到 Kubernetes API ，并发送证书签名的请求。
可以通过以下方式查看证书签名请求的状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!--
Initially a certificate signing request from the kubelet on a node will have a
status of `Pending`. If the certificate signing requests meets specific
criteria, it will be auto approved by the controller manager, then it will have
a status of `Approved`. Next, the controller manager will sign a certificate,
issued for the duration specified by the
`--cluster-signing-duration` parameter, and the signed certificate
will be attached to the certificate signing request.
-->
<p>最初，来自节点上 kubelet 的证书签名请求处于 <code>Pending</code> 状态。 如果证书签名请求满足特定条件，
控制器管理器会自动批准，此时请求会处于 <code>Approved</code> 状态。 接下来，控制器管理器会签署证书，
证书的有效期限由 <code>--cluster-signing-duration</code> 参数指定，签署的证书会被附加到证书签名请求中。</p>
<!--
The kubelet will retrieve the signed certificate from the Kubernetes API and
write that to disk, in the location specified by `--cert-dir`. Then the kubelet
will use the new certificate to connect to the Kubernetes API.
-->
<p>Kubelet 会从 Kubernetes API 取回签署的证书，并将其写入磁盘，存储位置通过 <code>--cert-dir</code>
参数指定。
然后 kubelet 会使用新的证书连接到 Kubernetes API。</p>
<!--
As the expiration of the signed certificate approaches, the kubelet will
automatically issue a new certificate signing request, using the Kubernetes API. 
This can happen at any point between 30% and 10% of the time remaining on the 
certificate. Again, the controller manager will automatically approve the certificate
request and attach a signed certificate to the certificate signing request. The
kubelet will retrieve the new signed certificate from the Kubernetes API and
write that to disk. Then it will update the connections it has to the
Kubernetes API to reconnect using the new certificate.
-->
<p>当签署的证书即将到期时，kubelet 会使用 Kubernetes API，自动发起新的证书签名请求。
该请求会发生在证书的有效时间剩下 30% 到 10% 之间的任意时间点。
同样地，控制器管理器会自动批准证书请求，并将签署的证书附加到证书签名请求中。 Kubelet
会从 Kubernetes API 取回签署的证书，并将其写入磁盘。 然后它会更新与 Kubernetes API
的连接，使用新的证书重新连接到 Kubernetes API。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-43d5e2b1fc2a7e104e66d481d08578dc">2 - 手动轮换 CA 证书</h1>
    
	<!--
title: Manual Rotation of CA Certificates
min-kubernetes-server-version: v1.13
content_type: task
-->
<!-- overview -->
<!--
This page shows how to manually rotate the certificate authority (CA) certificates.
-->
<p>本页展示如何手动轮换证书机构（CA）证书。</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version v1.13.
 To check the version, enter <code>kubectl version</code>.
</p>
<!--
- For more information about authentication in Kubernetes, see [Authenticating](/docs/reference/access-authn-authz/authentication).
- For more information about best practices for CA certificates, see [Single root CA](/docs/setup/best-practices/certificates/#single-root-ca).
-->
<ul>
<li>要了解 Kubernetes 中用户认证的更多信息，参阅
<a href="/zh/docs/reference/access-authn-authz/authentication">认证</a>；</li>
<li>要了解与 CA 证书最佳实践有关的更多信息，参阅<a href="/zh/docs/setup/best-practices/certificates/#single-root-ca">单根 CA</a>。</li>
</ul>
<!-- steps -->
<!--
## Rotate the CA certificates manually
-->
<h2 id="rotate-the-ca-certificates-manually">手动轮换 CA 证书 </h2>
<!--
Make sure to back up your certificate directory along with configuration files and any other necessary files.

This approach assumes operation of the Kubernetes control plane in a HA configuration with multiple API servers.
Graceful termination of the API server is also assumed so clients can cleanly disconnect from one API server and reconnect to another.

Configurations with a single API server will experience unavailability while the API server is being restarted.
-->
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <p>确保备份你的证书目录、配置文件以及其他必要文件。</p>
<p>这里的方法假定 Kubernetes 的控制面通过运行多个 API 服务器以高可用配置模式运行。
另一假定是 API 服务器可体面地终止，因而客户端可以彻底地与一个 API 服务器断开
连接并连接到另一个 API 服务器。</p>
<p>如果集群中只有一个 API 服务器，则在 API 服务器重启期间会经历服务中断期。</p>

</div>

<!--
1. Distribute the new CA certificates and private keys
   (ex: `ca.crt`, `ca.key`, `front-proxy-ca.crt`, and `front-proxy-ca.key`)
   to all your control plane nodes in the Kubernetes certificates directory.
-->
<ol>
<li>将新的 CA 证书和私钥（例如：<code>ca.crt</code>、<code>ca.key</code>、<code>front-proxy-ca.crt</code> 和
<code>front-proxy-client.key</code>）分发到所有控制面节点，放在其 Kubernetes 证书目录下。</li>
</ol>
<!--
1. Update <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a>'s `--root-ca-file` to
   include both old and new CA. Then restart the component.

   Any service account created after this point will get secrets that include both old and new CAs.
   
   <div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> The files specified by the kube-controller-manager flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code>
cannot be CA bundles. If these flags and <code>--root-ca-file</code> point to the same <code>ca.crt</code> file which is now a
bundle (includes both old and new CA) you will face an error. To workaround this problem you can copy the new CA to a separate
file and make the flags <code>--client-ca-file</code> and <code>--cluster-signing-cert-file</code> point to the copy. Once <code>ca.crt</code> is no longer
a bundle you can restore the problem flags to point to <code>ca.crt</code> and delete the copy.
</div>
-->
<ol start="2">
<li>
<p>更新 <a class='glossary-tooltip' title='主节点上运行控制器的组件。' data-toggle='tooltip' data-placement='top' href='/docs/reference/generated/kube-controller-manager/' target='_blank' aria-label='kube-controller-manager'>kube-controller-manager</a> 的
<code>--root-ca-file</code> 标志，使之同时包含老的和新的 CA，之后重启组件。</p>
<p>自此刻起，所创建的所有服务账号都会获得同时包含老的 CA 和新的 CA 的 Secret。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> kube-controller-manager 标志 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code> 所引用的文件
不能是 CA 证书包。如果这些标志和 <code>--root-ca-file</code> 指向同一个 <code>ca.crt</code> 包文件（包含老的和新的 CA 证书），
你将会收到出错信息。
要解决这个问题，可以将新的 CA 证书复制到单独的文件中，并将 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code>
标志指向该副本。一旦 <code>ca.crt</code> 不再是证书包文件，就可以恢复有问题的标志指向  <code>ca.crt</code> 并删除该副本。
</div>
</li>
</ol>
<!--
   1. Update all service account tokens to include both old and new CA certificates.

   If any pods are started before new CA is used by API servers, they will get this update and trust both old and new CAs.
-->
<ol start="3">
<li>
<p>更新所有服务账号令牌，使之同时包含老的和新的 CA 证书。</p>
<p>如果在 API 服务器使用新的 CA 之前启动了新的 Pod，这些 Pod
也会获得此更新并且同时信任老的和新的 CA 证书。</p>
<!--
```shell
base64_encoded_ca="$(base64 -w0 <path to file containing both old and new CAs>)"

for namespace in $(kubectl get ns --no-headers | awk '{print $1}'); do
    for token in $(kubectl get secrets --namespace "$namespace" --field-selector type=kubernetes.io/service-account-token -o name); do
        kubectl get $token --namespace "$namespace" -o yaml | \
          /bin/sed "s/\(ca.crt:\).*/\1 ${base64_encoded_ca}/" | \
          kubectl apply -f -
    done
done
```
-->
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#666">=</span><span style="color:#b44">&#34;</span><span style="color:#a2f;font-weight:bold">$(</span>base64 -w0 &lt;path to file containing both old and new CAs&gt;<span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#34;</span>

<span style="color:#a2f;font-weight:bold">for</span> namespace in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get ns --no-headers | awk <span style="color:#b44">&#39;{print $1}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
    <span style="color:#a2f;font-weight:bold">for</span> token in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get secrets --namespace <span style="color:#b44">&#34;</span><span style="color:#b8860b">$namespace</span><span style="color:#b44">&#34;</span> --field-selector <span style="color:#b8860b">type</span><span style="color:#666">=</span>kubernetes.io/service-account-token -o name<span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl get <span style="color:#b8860b">$token</span> --namespace <span style="color:#b44">&#34;</span><span style="color:#b8860b">$namespace</span><span style="color:#b44">&#34;</span> -o yaml | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>          /bin/sed <span style="color:#b44">&#34;s/\(ca.crt:\).*/\1 </span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">/&#34;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>          kubectl apply -f -
    <span style="color:#a2f;font-weight:bold">done</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div></li>
</ol>
<!--
1. Restart all pods using in-cluster configs (ex: kube-proxy, coredns, etc) so they can use the updated certificate authority data from *ServiceAccount* secrets.

   * Make sure coredns, kube-proxy and other pods using in-cluster configs are working as expected.

1. Append the both old and new CA to the file against `-client-ca-file` and `-kubelet-certificate-authority` flag in the `kube-apiserver` configuration.

1. Append the both old and new CA to the file against `-client-ca-file` flag in the `kube-scheduler` configuration.
-->
<ol start="4">
<li>
<p>重启所有使用集群内配置的 Pods（例如：<code>kube-proxy</code>、<code>coredns</code> 等），以便这些 Pod 能够使用
来自 <em>ServiceAccount</em> Secret 中的、已更新的证书机构数据。</p>
<ul>
<li>确保 <code>coredns</code>、<code>kube-proxy</code> 和其他使用集群内配置的 Pod 都正按预期方式工作。</li>
</ul>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-apiserver</code> 配置的 <code>--client-ca-file</code> 和 <code>--kubelet-certificate-authority</code> 标志所指的文件。</p>
</li>
<li>
<p>将老的和新的 CA 都追加到 <code>kube-scheduler</code> 配置的 <code>--client-ca-file</code> 标志所指的文件。</p>
</li>
</ol>
<!--
1. Update certificates for user accounts by replacing the content of `client-certificate-data` and `client-key-data` respectively.

   For information about creating certificates for individual user accounts, see
   [Configure certificates for user accounts](/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts).

   Additionally, update the `certificate-authority-data` section in the kubeconfig files,
   respectively with Base64-encoded old and new certificate authority data
-->
<ol start="7">
<li>
<p>通过替换 <code>client-certificate-data</code> 和 <code>client-key-data</code>
中的内容，更新用户账号的证书。</p>
<p>有关为独立用户账号创建证书的更多信息，可参阅
<a href="/zh/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts">为用户帐号配置证书</a>。</p>
<p>另外，还要更新 kubeconfig 文件中的 <code>certificate-authority-data</code>
节，使之包含 Base64 编码的老的和新的证书机构数据。</p>
</li>
</ol>
<!--
1. Follow below steps in a rolling fashion.

   1. Restart any other *[aggregated api servers](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)*
      or *webhook handlers* to trust the new CA certificates.

   1. Restart the kubelet by update the file against `clientCAFile` in kubelet configuration and
      `certificate-authority-data` in kubelet.conf to use both the old and new CA on all nodes.

      If your kubelet is not using client certificate rotation update `client-certificate-data` and
      `client-key-data` in kubelet.conf on all nodes along with the kubelet client certificate file
      usually found in `/var/lib/kubelet/pki`.
-->
<ol start="8">
<li>
<p>遵循下列步骤执行滚动更新</p>
<ol>
<li>
<p>重新启动所有其他 <em><a href="/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">被聚合的 API 服务器</a></em>
或者 <em>Webhook 处理程序</em>，使之信任新的 CA 证书。</p>
</li>
<li>
<p>在所有节点上更新 kubelet 配置中的 <code>clientCAFile</code> 所指文件以及 kubelet.conf 中的
<code>certificate-authority-data</code> 并重启 kubelet 以同时使用老的和新的 CA 证书。</p>
<p>如果你的 kubelet 并未使用客户端证书轮换，则在所有节点上更新 kubelet.conf 中
<code>client-certificate-data</code> 和 <code>client-key-data</code> 以及 kubelet
客户端证书文件（通常位于 <code>/var/lib/kubelet/pki</code> 目录下）</p>
</li>
</ol>
<!--
1. Restart API servers with the certificates (`apiserver.crt`, `apiserver-kubelet-client.crt` and
   `front-proxy-client.crt`) signed by new CA.
   You can use the existing private keys or new private keys.
   If you changed the private keys then update these in the Kubernetes certificates directory as well.
-->
<ol start="3">
<li>
<p>使用用新的 CA 签名的证书
（<code>apiserver.crt</code>、<code>apiserver-kubelet-client.crt</code> 和 <code>front-proxy-client.crt</code>）
来重启 API 服务器。
你可以使用现有的私钥，也可以使用新的私钥。
如果你改变了私钥，则要将更新的私钥也放到 Kubernetes 证书目录下。</p>
<p>由于 Pod 既信任老的 CA 也信任新的 CA，Pod 中的客户端会经历短暂的连接断开状态，
之后再连接到使用新的 CA 所签名的证书的新的 API 服务器。</p>
<!--
* Restart Scheduler to use the new CAs.
* Make sure control plane components logs no TLS errors.
-->
<ul>
<li>重启调度器以使用新的 CA 证书。</li>
<li>确保控制面组件的日志中没有 TLS 相关的错误信息。</li>
</ul>
<!--
To generate certificates and private keys for your cluster using the `openssl`
command line tool, see [Certificates (`openssl`)](/docs/tasks/administer-cluster/certificates/#openssl).
You can also use [`cfssl`](/docs/tasks/administer-cluster/certificates/#cfssl).
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 要使用 <code>openssl</code> 命令行为集群生成新的证书和私钥，可参阅
<a href="/zh/docs/tasks/administer-cluster/certificates/#openssl">证书（<code>openssl</code>）</a>。
你也可以使用<a href="/zh/docs/tasks/administer-cluster/certificates/#cfssl"><code>cfssl</code></a>.
</div>
</li>
</ol>
<!--
1. Annotate any Daemonsets and Deployments to trigger pod replacement in a safer rolling fashion.

   Example:
-->
<ol start="4">
<li>
<p>为 Daemonset 和 Deployment 添加注解，从而触发较安全的滚动更新，替换 Pod。</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">for</span> namespace in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get namespace -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
    <span style="color:#a2f;font-weight:bold">for</span> name in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get deployments -n <span style="color:#b8860b">$namespace</span> -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl patch deployment -n <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">namespace</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">name</span><span style="color:#b68;font-weight:bold">}</span> -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style="color:#a2f;font-weight:bold">done</span>
    <span style="color:#a2f;font-weight:bold">for</span> name in <span style="color:#a2f;font-weight:bold">$(</span>kubectl get daemonset -n <span style="color:#b8860b">$namespace</span> -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.items[*].metadata.name}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>; <span style="color:#a2f;font-weight:bold">do</span>
        kubectl patch daemonset -n <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">namespace</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">name</span><span style="color:#b68;font-weight:bold">}</span> -p <span style="color:#b44">&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
    <span style="color:#a2f;font-weight:bold">done</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><!--
To limit the number of concurrent disruptions that your application experiences,
see [configure pod disruption budget](/docs/tasks/run-application/configure-pdb/).
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 要限制应用可能受到的并发干扰数量，可以参阅
<a href="/zh/docs/tasks/run-application/configure-pdb/">配置 Pod 干扰预算</a>.
</div>
</li>
</ol>
</li>
</ol>
<!--
1. If your cluster is using bootstrap tokens to join nodes, update the ConfigMap `cluster-info` in the `kube-public` namespace with new CA.
-->
<ol start="9">
<li>
<p>如果你的集群使用启动引导令牌来添加节点，则需要更新 <code>kube-public</code> 名字空间下的
ConfigMap <code>cluster-info</code>，使之包含新的 CA 证书。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#666">=</span><span style="color:#b44">&#34;</span><span style="color:#a2f;font-weight:bold">$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#34;</span>

kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    /bin/sed <span style="color:#b44">&#34;s/\(certificate-authority-data:\).*/\1 </span><span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">base64_encoded_ca</span><span style="color:#b68;font-weight:bold">}</span><span style="color:#b44">/&#34;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    kubectl apply -f -
</code></pre></div></li>
</ol>
<!--
1. Verify the cluster functionality.

   1. Validate the logs from control plane components, along with the kubelet and the
      kube-proxy are not throwing any tls errors, see
      [looking at the logs](/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs).

   1. Validate logs from any aggregated api servers and pods using in-cluster config.
-->
<ol start="10">
<li>
<p>验证集群的功能正常</p>
<ol>
<li>
<p>验证控制面组件的日志，以及 <code>kubelet</code> 和 <code>kube-proxy</code> 的日志，确保其中没有
抛出 TLS 错误，参阅
<a href="/zh/docs/tasks/debug-application-cluster/debug-cluster/#looking-at-logs">查看日志</a>.</p>
</li>
<li>
<p>验证被聚合的 API 服务器的日志，以及所有使用集群内配置的 Pod 的日志。</p>
</li>
</ol>
</li>
</ol>
<!--
1. Once the cluster functionality is successfully verified:

   1. Update all service account tokens to include new CA certificate only.

      * All pods using an in-cluster kubeconfig will eventually need to be restarted to pick up the new SA secret for the old CA to be completely untrusted.

   1. Restart the control plane components by removing the old CA from the kubeconfig files and the files against `--client-ca-file`, `--root-ca-file` flags resp.

   1. Restart kubelet by removing the old CA from file against the `clientCAFile` flag and kubelet kubeconfig file.
-->
<ol start="11">
<li>
<p>完成集群功能的检查之后：</p>
<ol>
<li>
<p>更新所有的服务账号令牌，使之仅包含新的 CA 证书。</p>
<ul>
<li>使用集群内 kubeconfig 的 Pod 最终也需要被重启，以获得新的服务账号 Secret
数据，进而不再信任老的 CA 证书。</li>
</ul>
</li>
<li>
<p>从 kubeconfig 文件和 <code>--client-ca-file</code> 以及 <code>--root-ca-file</code> 标志所指向的文件
中去除老的 CA 数据，之后重启控制面组件。</p>
</li>
<li>
<p>重启 kubelet，移除 <code>clientCAFile</code> 标志所指向的文件以及 kubelet kubeconfig 文件中
的老的 CA 数据。</p>
</li>
</ol>
</li>
</ol>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-9a87de8ee8332cb487f34a05debb1125">3 - 管理集群中的 TLS 认证</h1>
    
	<!--
title: Manage TLS Certificates in a Cluster
content_type: task
reviewers:
- mikedanese
- beacham
- liggit
-->
<!-- overview -->
<!--
Kubernetes provides a `certificates.k8s.io` API, which lets you provision TLS
certificates signed by a Certificate Authority (CA) that you control. These CA
and certificates can be used by your workloads to establish trust.

`certificates.k8s.io` API uses a protocol that is similar to the [ACME
draft](https://github.com/ietf-wg-acme/acme/).
-->
<p>Kubernetes 提供 <code>certificates.k8s.io</code> API，可让你配置由你控制的证书颁发机构（CA）
签名的 TLS 证书。 你的工作负载可以使用这些 CA 和证书来建立信任。</p>
<p><code>certificates.k8s.io</code> API使用的协议类似于
<a href="https://github.com/ietf-wg-acme/acme/">ACME 草案</a>。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!--
Certificates created using the `certificates.k8s.io` API are signed by a
[dedicated CA](#a-note-to-cluster-administrators). It is possible to configure your cluster to use the cluster root
CA for this purpose, but you should never rely on this. Do not assume that
these certificates will validate against the cluster root CA.
-->
<p>使用 <code>certificates.k8s.io</code> API 创建的证书由指定 <a href="#a-note-to-cluster-administrators">CA</a> 颁发。
将集群配置为使用集群根目录 CA 可以达到这个目的，但是你永远不要依赖这一假定。
不要以为这些证书将针对群根目录 CA 进行验证。
</div>
<h2 id="before-you-begin">Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>

<!-- 
You need the `cfssl` tool. You can download `cfssl` from
[https://github.com/cloudflare/cfssl/releases](https://github.com/cloudflare/cfssl/releases).

Some steps in this page use the `jq` tool. If you don't have `jq`, you can
install it via your operating system's software sources, or fetch it from
[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/).
-->
<p>你需要 <code>cfssl</code> 工具。
你可以从 <a href="https://github.com/cloudflare/cfssl/releases">https://github.com/cloudflare/cfssl/releases</a>
下载 <code>cfssl</code>。</p>
<p>本文中某些步骤使用 <code>jq</code> 工具。如果你没有 <code>jq</code>，你可以通过操作系统的软件源安装，
或者从 <a href="https://stedolan.github.io/jq/">https://stedolan.github.io/jq/</a> 获取。</p>
<!-- steps -->
<!--
## Trusting TLS in a cluster

Trusting the [custom CA](#a-note-to-cluster-administrators) from an application running as a pod usually requires
some extra application configuration. You will need to add the CA certificate
bundle to the list of CA certificates that the TLS client or server trusts. For
example, you would do this with a golang TLS config by parsing the certificate
chain and adding the parsed certificates to the `RootCAs` field in the
[`tls.Config`](https://pkg.go.dev/crypto/tls#Config) struct.
-->
<h2 id="集群中的-tls-信任">集群中的 TLS 信任</h2>
<p>信任 Pod 中运行的应用程序所提供的<a href="#a-note-to-cluster-administrators">自定义 CA</a> 通常需要一些额外的应用程序配置。
你需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。
例如，你可以使用 Golang TLS 配置通过解析证书链并将解析的证书添加到
<a href="https://pkg.go.dev/crypto/tls#Config"><code>tls.Config</code></a> 结构中的 <code>RootCAs</code>
字段中。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
Even though the custom CA certificate may be included in the filesystem (in the
ConfigMap `kube-root-ca.crt`),
you should not use that certificate authority for any purpose other than to verify internal
Kubernetes endpoints. An example of an internal Kubernetes endpoint is the
Service named `kubernetes` in the default namespace.

If you want to use a custom certificate authority for your workloads, you should generate
that CA separately, and distribute its CA certificate using a 
[ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap) that your pods 
have access to read.
-->
<p>即使自定义 CA 证书可能包含在文件系统中（在 ConfigMap <code>kube-root-ca.crt</code> 中），
除了验证内部 Kubernetes 端点之外，你不应将该证书颁发机构用于任何目的。
内部 Kubernetes 端点的一个示例是默认命名空间中名为 <code>kubernetes</code> 的服务。</p>
<p>如果你想为你的工作负载使用自定义证书颁发机构，你应该单独生成该 CA，
并使用你的 Pod 有读权限的 <a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap">ConfigMap</a>
分发该 CA 证书。</p>

</div>
<!--
## Requesting a certificate

The following section demonstrates how to create a TLS certificate for a
Kubernetes service accessed through DNS.

<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> This tutorial uses CFSSL: Cloudflare's PKI and TLS toolkit <a href="https://blog.cloudflare.com/introducing-cfssl/">click here</a> to know more.
</div>
-->
<h2 id="请求证书">请求证书</h2>
<p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。</p>
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 本教程使用 CFSSL：Cloudflare's PKI 和 TLS 工具包
<a href="https://blog.cloudflare.com/introducing-cfssl/">点击此处</a>了解更多信息。
</div>
<!--
## Create a certificate signing request

Generate a private key and certificate signing request (or CSR) by running
the following command:
-->
<h2 id="创建证书签名请求">创建证书签名请求</h2>
<p>通过运行以下命令生成私钥和证书签名请求（或 CSR）:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span><span style="color:#b44">{
</span><span style="color:#b44">  &#34;hosts&#34;: [
</span><span style="color:#b44">    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span><span style="color:#b44">    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style="color:#b44">    &#34;192.0.2.24&#34;,
</span><span style="color:#b44">    &#34;10.0.34.2&#34;
</span><span style="color:#b44">  ],
</span><span style="color:#b44">  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span><span style="color:#b44">  &#34;key&#34;: {
</span><span style="color:#b44">    &#34;algo&#34;: &#34;ecdsa&#34;,
</span><span style="color:#b44">    &#34;size&#34;: 256
</span><span style="color:#b44">  }
</span><span style="color:#b44">}
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Where `192.0.2.24` is the service's cluster IP,
`my-svc.my-namespace.svc.cluster.local` is the service's DNS name,
`10.0.34.2` is the pod's IP and `my-pod.my-namespace.pod.cluster.local`
is the pod's DNS name. You should see the output similar to:
-->
<p>其中 <code>192.0.2.24</code> 是服务的集群 IP，<code>my-svc.my-namespace.svc.cluster.local</code>
是服务的 DNS 名称，<code>10.0.34.2</code> 是 Pod 的 IP，而
<code>my-pod.my-namespace.pod.cluster.local</code> 是 Pod 的 DNS 名称。
你能看到的输出类似于：</p>
<pre><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre><!--
This command generates two files; it generates `server.csr` containing the PEM
encoded [PKCS#10](https://tools.ietf.org/html/rfc2986) certification request,
and `server-key.pem` containing the PEM encoded key to the certificate that
is still to be created.
-->
<p>此命令生成两个文件；它生成包含 PEM 编码
<a href="https://tools.ietf.org/html/rfc2986">PKCS#10</a> 证书请求的 <code>server.csr</code>，
以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p>
<!--
## Create a CertificateSigningRequest object to send to the Kubernetes API

Generate a CSR yaml blob and send it to the apiserver by running the following
command:
-->
<h2 id="创建证书签名请求-csr-对象发送到-kubernetes-api">创建证书签名请求（CSR）对象发送到 Kubernetes API</h2>
<p>使用以下命令创建 CSR YAML 文件，并发送到 API 服务器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | kubectl apply -f -
</span><span style="color:#b44">apiVersion: certificates.k8s.io/v1
</span><span style="color:#b44">kind: CertificateSigningRequest
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: my-svc.my-namespace
</span><span style="color:#b44">spec:
</span><span style="color:#b44">  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span><span style="color:#b44">  signerName: example.com/serving
</span><span style="color:#b44">  usages:
</span><span style="color:#b44">  - digital signature
</span><span style="color:#b44">  - key encipherment
</span><span style="color:#b44">  - server auth
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Notice that the `server.csr` file created in step 1 is base64 encoded
and stashed in the `.spec.request` field. You are also requesting a
certificate with the "digital signature", "key encipherment", and "server
auth" key usages, signed by an example `example.com/serving` signer.
A specific `signerName` must be requested.
View documentation for [supported signer names](/docs/reference/access-authn-authz/certificate-signing-requests/#signers)
for more information.

The CSR should now be visible from the API in a Pending state. You can see
it by running:
-->
<p>请注意，在步骤 1 中创建的 <code>server.csr</code> 文件是 base64 编码并存储在
<code>.spec.request</code> 字段中的。你还要求提供 “digital signature（数字签名）”，
“密钥加密（key encipherment）” 和 “服务器身份验证（server auth）” 密钥用途，
由 <code>example.com/serving</code> 示例签名程序签名的证书。
你也可以要求使用特定的 <code>signerName</code>。更多信息可参阅
<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signers">支持的签署者名称</a>。</p>
<p>在 API server 中可以看到这些 CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe csr my-svc.my-namespace
</code></pre></div><pre><code class="language-none" data-lang="none">Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><!--
## Get the CertificateSigningRequest approved {#get-the-certificate-signing-request-approved}

Approving the [certificate signing request](/docs/reference/access-authn-authz/certificate-signing-requests/)
is either done by an automated approval process or on a one off basis by a cluster
administrator. If you're authorized to approve a certificate request, you can do that
manually using `kubectl`; for example:
-->
<h2 id="get-the-certificate-signing-request-approved">批准证书签名请求（CSR） </h2>
<p><a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a>
的批准或者是通过自动批准过程完成的，或由集群管理员一次性完成。
如果你被授权批准证书请求，你可以使用 <code>kubectl</code> 来手动完成此操作；例如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl certificate approve my-svc.my-namespace
</code></pre></div><pre><code class="language-none" data-lang="none">certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre><!-- You should now see the following: -->
<p>你现在应该能看到如下输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><pre><code class="language-none" data-lang="none">NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre><!-- 
This means the certificate request has been approved and is waiting for the
requested signer to sign it.
-->
<p>这意味着证书请求已被批准，并正在等待请求的签名者对其签名。</p>
<!--  
## Sign the CertificateSigningRequest {#sign-the-certificate-signing-request}

Next, you'll play the part of a certificate signer, issue the certificate, and upload it to the API.

A signer would typically watch the CertificateSigningRequest API for objects with its `signerName`,
check that they have been approved, sign certificates for those requests,
and update the API object status with the issued certificate.
-->
<h2 id="sign-the-certificate-signing-request">签名证书签名请求（CSR）</h2>
<p>接下来，你将扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p>
<p>签名者通常会使用其 <code>signerName</code> 查看对象的 CertificateSigningRequest API，
检查它们是否已被批准，为这些请求签署证书，并使用已颁发的证书更新 API 对象状态。</p>
<!-- 
### Create a Certificate Authority

You need an authority to provide the digital signature on the new certificate.

First, create a signing certificate by running the following:
-->
<h3 id="创建证书颁发机构">创建证书颁发机构</h3>
<p>你需要授权在新证书上提供数字签名。</p>
<p>首先，通过运行以下命令创建签名证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">cat <span style="color:#b44">&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span><span style="color:#b44">{
</span><span style="color:#b44">  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span><span style="color:#b44">  &#34;key&#34;: {
</span><span style="color:#b44">    &#34;algo&#34;: &#34;rsa&#34;,
</span><span style="color:#b44">    &#34;size&#34;: 2048
</span><span style="color:#b44">  }
</span><span style="color:#b44">}
</span><span style="color:#b44">EOF</span>
</code></pre></div><!-- You should see output similar to: -->
<p>你应该看到类似于以下的输出：</p>
<pre><code class="language-none" data-lang="none">2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre><!-- 
This produces a certificate authority key file (`ca-key.pem`) and certificate (`ca.pem`). 
-->
<p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p>
<!-- ### Issue a certificate -->
<h3 id="颁发证书">颁发证书</h3>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/tls/server-signing-config.json" download="tls/server-signing-config.json"><code>tls/server-signing-config.json</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('tls-server-signing-config-json')" title="Copy tls/server-signing-config.json to clipboard">
    </img>
    </div>
    <div class="includecode" id="tls-server-signing-config-json">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#008000;font-weight:bold">&#34;signing&#34;</span>: {
        <span style="color:#008000;font-weight:bold">&#34;default&#34;</span>: {
            <span style="color:#008000;font-weight:bold">&#34;usages&#34;</span>: [
                <span style="color:#b44">&#34;digital signature&#34;</span>,
                <span style="color:#b44">&#34;key encipherment&#34;</span>,
                <span style="color:#b44">&#34;server auth&#34;</span>
            ],
            <span style="color:#008000;font-weight:bold">&#34;expiry&#34;</span>: <span style="color:#b44">&#34;876000h&#34;</span>,
            <span style="color:#008000;font-weight:bold">&#34;ca_constraint&#34;</span>: {
                <span style="color:#008000;font-weight:bold">&#34;is_ca&#34;</span>: <span style="color:#a2f;font-weight:bold">false</span>
            }
        }
    }
}</code></pre></div>
    </div>
</div>


<!-- 
Use a `server-signing-config.json` signing configuration and the certificate authority key file 
and certificate to sign the certificate request:
-->
<p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr my-svc.my-namespace -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.spec.request}&#39;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  base64 --decode | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  cfssljson -bare ca-signed-server
</code></pre></div><!-- You should see output similar to: -->
<p>你应该看到类似于以下的输出：</p>
<pre><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre><!-- This produces a signed serving certificate file, `ca-signed-server.pem`. -->
<p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p>
<!-- 
### Upload the signed certificate

Finally, populate the signed certificate in the API object's status:
-->
<h3 id="上传签名证书">上传签名证书</h3>
<p>最后，在 API 对象的状态中填充签名证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr my-svc.my-namespace -o json | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  jq <span style="color:#b44">&#39;.status.certificate = &#34;&#39;</span><span style="color:#a2f;font-weight:bold">$(</span>base64 ca-signed-server.pem | tr -d <span style="color:#b44">&#39;\n&#39;</span><span style="color:#a2f;font-weight:bold">)</span><span style="color:#b44">&#39;&#34;&#39;</span> | <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</code></pre></div><div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <!-- 
This uses the command line tool [`jq`](https://stedolan.github.io/jq/) to populate the base64-encoded
content in the `.status.certificate` field.
If you do not have `jq`, you can also save the JSON output to a file, populate this field manually, and
upload the resulting file.
-->
<p>这使用命令行工具 <a href="https://stedolan.github.io/jq/"><code>jq</code></a>
在 <code>.status.certificate</code> 字段中填充 base64 编码的内容。
如果你没有 <code>jq</code> 工具，你还可以将 JSON 输出保存到文件中，手动填充此字段，然后上传结果文件。
</div>
<!-- 
Once the CSR is approved and the signed certificate is uploaded, run:
-->
<p>批准 CSR 并上传签名证书后，运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr
</code></pre></div><!-- The output is similar to: -->
<p>输入类似于：</p>
<pre><code class="language-none" data-lang="none">NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre><!--
## Download the certificate and use it

Now, as the requesting user, you can download the issued certificate
and save it to a `server.crt` file by running the following:
-->
<h2 id="下载证书并使用它">下载证书并使用它</h2>
<p>现在，作为请求用户，你可以通过运行以下命令下载颁发的证书并将其保存到 <code>server.crt</code> 文件中：</p>
<p>CSR 被签署并获得批准后，你应该看到以下内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get csr my-svc.my-namespace -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.status.certificate}&#39;</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>    | base64 --decode &gt; server.crt
</code></pre></div><!--
Now you can populate `server.crt` and `server-key.pem` in a
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='Secret'>Secret</a>
that you could later mount into a Pod (for example, to use with a webserver
that serves HTTPS). 
-->
<p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 填充到
<a class='glossary-tooltip' title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/configuration/secret/' target='_blank' aria-label='Secret'>Secret</a> 中，
稍后你可以将其挂载到 Pod 中（例如，用于提供 HTTPS 的网络服务器）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create secret tls server --cert server.crt --key server-key.pem
</code></pre></div><pre><code class="language-none" data-lang="none">secret/server created
</code></pre><!-- 
Finally, you can populate `ca.pem` into a <a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a>
and use it as the trust root to verify the serving certificate:
-->
<p>最后，你可以将 <code>ca.pem</code> 填充到
<a class='glossary-tooltip' title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle='tooltip' data-placement='top' href='/zh/docs/tasks/configure-pod-container/configure-pod-configmap/' target='_blank' aria-label='ConfigMap'>ConfigMap</a>
并将其用作信任根来验证服务证书：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create configmap example-serving-ca --from-file ca.crt<span style="color:#666">=</span>ca.pem
</code></pre></div><pre><code class="language-none" data-lang="none">configmap/example-serving-ca created
</code></pre><!--
## Approving CertificateSigningRequests {#approving-certificate-signing-requests}

A Kubernetes administrator (with appropriate permissions) can manually approve
(or deny) CertificateSigningRequests by using the `kubectl certificate
approve` and `kubectl certificate deny` commands. However if you intend
to make heavy usage of this API, you might consider writing an automated
certificates controller.
-->
<h2 id="approving-certificate-signing-requests">批准证书签名请求（CSR） </h2>
<p>Kubernetes 管理员（具有适当权限）可以使用 <code>kubectl certificate approve</code> 和
<code>kubectl certificate deny</code> 命令手动批准（或拒绝）证书签名请求（CSR）。
但是，如果你打算大量使用此 API，则可以考虑编写自动化的证书控制器。</p>
<div class="alert alert-warning caution callout" role="alert">
  <strong>Caution:</strong> <!-- 
The ability to approve CSRs decides who trusts whom within your environment. The
ability to approve CSRs should not be granted broadly or lightly.

You should make sure that you confidently understand both the verification requirements
that fall on the approver **and** the repercussions of issuing a specific certificate
before you grant the `approve` permission.
-->
<p>批准证书 CSR 的能力决定了在你的环境中谁信任谁。
不应广泛或轻率地授予批准 CSR 的能力。</p>
<p>在授予 <code>approve</code> 权限之前，你应该确保自己充分了解批准人的验证要求<strong>和</strong>颁发特定证书的后果。</p>

</div>

<!--
Whether a machine or a human using kubectl as above, the role of the _approver_ is
to verify that the CSR satisfies two requirements:
-->
<p>无论上述机器或人使用 kubectl，“批准者”的作用是验证 CSR 满足如下两个要求：</p>
<!--
1. The subject of the CSR controls the private key used to sign the CSR. This
   addresses the threat of a third party masquerading as an authorized subject.
   In the above example, this step would be to verify that the pod controls the
   private key used to generate the CSR.
2. The subject of the CSR is authorized to act in the requested context. This
   addresses the threat of an undesired subject joining the cluster. In the
   above example, this step would be to verify that the pod is allowed to
   participate in the requested service.
-->
<ol>
<li>CSR 的 subject 控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。
在上述示例中，此步骤将验证该 Pod 控制了用于生成 CSR 的私钥。</li>
<li>CSR 的 subject 被授权在请求的上下文中执行。
这点用于处理不期望的主体被加入集群的威胁。
在上述示例中，此步骤将是验证该 Pod 是否被允许加入到所请求的服务中。</li>
</ol>
<!--
If and only if these two requirements are met, the approver should approve
the CSR and otherwise should deny the CSR.

For more information on certificate approval and access control, read
the [Certificate Signing Requests](/docs/reference/access-authn-authz/certificate-signing-requests/)
reference page.
-->
<p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。</p>
<p>有关证书批准和访问控制的更多信息，
请阅读<a href="/zh/docs/reference/access-authn-authz/certificate-signing-requests/">证书签名请求</a>参考页。</p>
<!--
## Configuring your cluster to provide signing

This page assumes that a signer is setup to serve the certificates API. The
Kubernetes controller manager provides a default implementation of a signer. To
enable it, pass the `--cluster-signing-cert-file` and
`--cluster-signing-key-file` parameters to the controller manager with paths to
your Certificate Authority's keypair.
-->
<h2 id="给集群管理员的一个建议">给集群管理员的一个建议</h2>
<p>本页面假设已经为 certificates API 配置了签名者。
Kubernetes 控制器管理器提供了一个签名者的默认实现。要启用它，请为控制器管理器设置
<code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，
使之取值为你的证书机构的密钥对的路径。</p>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
