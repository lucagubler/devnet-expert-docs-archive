<!doctype html>
<html lang="zh" class="no-js">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-36037335-10');
</script>


<link rel="alternate" hreflang="en" href="http://localhost:1313/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/ko/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="ja" href="http://localhost:1313/ja/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="fr" href="http://localhost:1313/fr/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="de" href="http://localhost:1313/de/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="es" href="http://localhost:1313/es/docs/tasks/access-application-cluster/">
<link rel="alternate" hreflang="id" href="http://localhost:1313/id/docs/tasks/access-application-cluster/">

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.87.0" />
<link rel="canonical" type="text/html" href="http://localhost:1313/zh/docs/tasks/access-application-cluster/">
<link rel="shortcut icon" type="image/png" href="/images/favicon.png">
<link rel="apple-touch-icon" href="/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>访问集群中的应用程序 | Kubernetes</title><meta property="og:title" content="访问集群中的应用程序" />
<meta property="og:description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/access-application-cluster/" /><meta property="og:site_name" content="Kubernetes" />

<meta itemprop="name" content="访问集群中的应用程序">
<meta itemprop="description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="访问集群中的应用程序"/>
<meta name="twitter:description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。"/>






<link href="/scss/main.css" rel="stylesheet">


<script
  src="/js/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "http://localhost:1313/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href="/css/feature-states.css">



<meta name="description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。">
<meta property="og:description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。">
<meta name="twitter:description" content="配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。">
<meta property="og:url" content="http://localhost:1313/zh/docs/tasks/access-application-cluster/">
<meta property="og:title" content="访问集群中的应用程序">
<meta name="twitter:title" content="访问集群中的应用程序">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">

<script src="/js/script.js"></script>


  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-column flex-md-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/zh/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/zh/docs/" >文档</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/blog/" >Kubernetes 博客</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/training/" >培训</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/partners/" >合作伙伴</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/community/" >社区</a>
			</li>
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link" href="/zh/case-studies/" >案例分析</a>
			</li>
			
			
			
			<li class="nav-item dropdown">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/releases">Release Information</a>
	
	<a class="dropdown-item" href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/">v1.23</a>
	
	<a class="dropdown-item" href="https://v1-22.docs.kubernetes.io/zh/docs/tasks/access-application-cluster/">v1.22</a>
	
	<a class="dropdown-item" href="https://v1-21.docs.kubernetes.io/zh/docs/tasks/access-application-cluster/">v1.21</a>
	
	<a class="dropdown-item" href="https://v1-20.docs.kubernetes.io/zh/docs/tasks/access-application-cluster/">v1.20</a>
	
	<a class="dropdown-item" href="https://v1-19.docs.kubernetes.io/zh/docs/tasks/access-application-cluster/">v1.19</a>
	
</div>
			</li>
			
			
			<li class="nav-item dropdown">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/docs/tasks/access-application-cluster/">English</a>
	
	<a class="dropdown-item" href="/ko/docs/tasks/access-application-cluster/">한국어 Korean</a>
	
	<a class="dropdown-item" href="/ja/docs/tasks/access-application-cluster/">日本語 Japanese</a>
	
	<a class="dropdown-item" href="/fr/docs/tasks/access-application-cluster/">Français</a>
	
	<a class="dropdown-item" href="/de/docs/tasks/access-application-cluster/">Deutsch</a>
	
	<a class="dropdown-item" href="/es/docs/tasks/access-application-cluster/">Español</a>
	
	<a class="dropdown-item" href="/id/docs/tasks/access-application-cluster/">Bahasa Indonesia</a>
	
</div>

			</li>
			
		</ul>
	</div>
	<button id="hamburger" onclick="kub.toggleMenu()" data-auto-burger-exclude><div></div></button>
</nav>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/zh/docs/tasks/access-application-cluster/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">访问集群中的应用程序</h1>
<div class="lead">配置负载平衡、端口转发或设置防火墙或 DNS 配置，以访问集群中的应用程序。</div>




    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-777447042cd4e81df3fa5beb3357a485">部署和访问 Kubernetes 仪表板（Dashboard）</a></li>


    
  
    
    
	
<li>2: <a href="#pg-6a8d9e9e05f2b6825afbb8889c957370">访问集群</a></li>


    
  
    
    
	
<li>3: <a href="#pg-72d3dddbc0c166c9a364e753d2b31ff0">使用端口转发来访问集群中的应用</a></li>


    
  
    
    
	
<li>4: <a href="#pg-312f29f850826b74618634cd877aa065">使用服务来访问集群中的应用</a></li>


    
  
    
    
	
<li>5: <a href="#pg-f3dac629bea950fc026d920306f09fb4">使用 Service 把前端连接到后端</a></li>


    
  
    
    
	
<li>6: <a href="#pg-21cd8f87563675fb0278d3694ba9ecb0">创建外部负载均衡器</a></li>


    
  
    
    
	
<li>7: <a href="#pg-48e8f306f919c5b81265e265a2b76ab4">列出集群中所有运行容器的镜像</a></li>


    
  
    
    
	
<li>8: <a href="#pg-1839d8468a083839ed1cc8d18fe1142e">在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</a></li>


    
  
    
    
	
<li>9: <a href="#pg-322786b38586b210fab68f785259c5f6">为集群配置 DNS</a></li>


    
  
    
    
	
<li>10: <a href="#pg-7c319a9981586e5fbcfa21b392720650">同 Pod 内的容器使用共享卷通信</a></li>


    
  
    
    
	
<li>11: <a href="#pg-43591bb11cc02c39e278cf07f6546810">访问集群上运行的服务</a></li>


    
  
    
    
	
<li>12: <a href="#pg-5a233e14205d77fe1294917d2da6f876">配置对多集群的访问</a></li>


    
  

    </ul>


<div class="content">
      
</div>
</div>


  
  
  
  

  
  

  
    
    
	
    

<div class="td-content" style="">
    
	<h1 id="pg-777447042cd4e81df3fa5beb3357a485">1 - 部署和访问 Kubernetes 仪表板（Dashboard）</h1>
    
	<!--
reviewers:
- floreks
- maciaszczykm
- shu-mutou
- mikedanese
title: Deploy and Access the Kubernetes Dashboard
content_type: concept
weight: 10
card:
  name: tasks
  weight: 30
  title: Use the Web UI Dashboard
-->
<!-- overview -->
<!--
Dashboard is a web-based Kubernetes user interface.
You can use Dashboard to deploy containerized applications to a Kubernetes cluster,
troubleshoot your containerized application, and manage the cluster resources.
You can use Dashboard to get an overview of applications running on your cluster,
as well as for creating or modifying individual Kubernetes resources
(such as Deployments, Jobs, DaemonSets, etc).
For example, you can scale a Deployment, initiate a rolling update, restart a pod
or deploy new applications using a deploy wizard.

Dashboard also provides information on the state of Kubernetes resources in your cluster and on any errors that may have occurred.
-->
<p>Dashboard 是基于网页的 Kubernetes 用户界面。
你可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。
你可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源
（如 Deployment，Job，DaemonSet 等等）。
例如，你可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p>
<p>Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。</p>
<p><img src="/images/docs/ui-dashboard.png" alt="Kubernetes Dashboard UI"></p>
<!-- body -->
<!--
## Deploying the Dashboard UI

The Dashboard UI is not deployed by default. To deploy it, run the following command:
-->
<h2 id="部署-dashboard-ui">部署 Dashboard UI</h2>
<p>默认情况下不会部署 Dashboard。可以通过以下命令部署：</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.5.0/aio/deploy/recommended.yaml
</code></pre><!--
## Accessing the Dashboard UI

To protect your cluster data, Dashboard deploys with a minimal RBAC configuration by default.
Currently, Dashboard only supports logging in with a Bearer Token.
To create a token for this demo, you can follow our guide on
[creating a sample user](https://github.com/kubernetes/dashboard/wiki/Creating-sample-user).
-->
<h2 id="访问-dashboard-用户界面">访问 Dashboard 用户界面</h2>
<p>为了保护你的集群数据，默认情况下，Dashboard 会使用最少的 RBAC 配置进行部署。
当前，Dashboard 仅支持使用 Bearer 令牌登录。
要为此样本演示创建令牌，你可以按照
<a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user">创建示例用户</a>
上的指南进行操作。</p>
<!--
The sample user created in the tutorial will have administrative privileges and is for educational purposes only.
-->
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> 在教程中创建的样本用户将具有管理特权，并且仅用于教育目的。
</div>


<!--
### Command line proxy

You can enable access to the Dashboard using the `kubectl` command-line tool,
by running the following command:
-->
<h3 id="命令行代理">命令行代理</h3>
<p>你可以使用 <code>kubectl</code> 命令行工具来启用 Dashboard 访问，命令如下：</p>
<pre><code>kubectl proxy
</code></pre><!--
Kubectl will make Dashboard available at [http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/).
-->
<p>kubectl 会使得 Dashboard 可以通过 <a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> 访问。</p>
<!--
The UI can _only_ be accessed from the machine where the command is executed. See `kubectl proxy --help` for more options.
-->
<p>UI <em>只能</em> 通过执行这条命令的机器进行访问。更多选项参见 <code>kubectl proxy --help</code>。</p>
<!--
The kubeconfig authentication method does **not** support external identity providers
or X.509 certificate-based authentication.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> Kubeconfig 身份验证方法<strong>不</strong>支持外部身份提供程序或基于 x509 证书的身份验证。
</div>
<!--
## Welcome view
-->
<h2 id="欢迎界面">欢迎界面</h2>
<!--
When you access Dashboard on an empty cluster, you'll see the welcome page. This page contains a link to this document as well as a button to deploy your first application. In addition, you can view which system applications are running by default in the `kube-system` [namespace](/docs/tasks/administer-cluster/namespaces/) of your cluster, for example the Dashboard itself.
 -->
<p>当访问空集群的 Dashboard 时，你会看到欢迎界面。
页面包含一个指向此文档的链接，以及一个用于部署第一个应用程序的按钮。
此外，你可以看到在默认情况下有哪些默认系统应用运行在 <code>kube-system</code>
<a href="/zh/docs/tasks/administer-cluster/namespaces/">名字空间</a> 中，比如 Dashboard 自己。</p>
<!--
![Kubernetes Dashboard welcome page](/images/docs/ui-dashboard-zerostate.png)
 -->
<p><img src="/images/docs/ui-dashboard-zerostate.png" alt="Kubernetes Dashboard 欢迎页面"></p>
<!--
## Deploying containerized applications

Dashboard lets you create and deploy a containerized application as a Deployment and optional Service with a simple wizard.
You can either manually specify application details, or upload a YAML or JSON _manifest_ file containing application configuration.
-->
<h2 id="部署容器化应用">部署容器化应用</h2>
<p>通过一个简单的部署向导，你可以使用 Dashboard 将容器化应用作为一个 Deployment 和可选的
Service 进行创建和部署。你可以手工指定应用的详细配置，或者上传一个包含应用配置的 YAML
或 JSON _清单_文件。</p>
<!--
Click the **CREATE** button in the upper right corner of any page to begin.
-->
<p>点击任何页面右上角的 <strong>CREATE</strong> 按钮以开始。</p>
<!--
### Specifying application details

The deploy wizard expects that you provide the following information:
-->
<h3 id="指定应用的详细配置">指定应用的详细配置</h3>
<p>部署向导需要你提供以下信息：</p>
<!--
- **App name** (mandatory): Name for your application. A [label](/docs/concepts/overview/working-with-objects/labels/) with the name will be added to the Deployment and Service, if any, that will be deployed.
-->
<ul>
<li>
<p><strong>应用名称</strong>（必填）：应用的名称。内容为<code>应用名称</code>的
<a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签</a>
会被添加到任何将被部署的 Deployment 和 Service。</p>
<!--
The application name must be unique within the selected Kubernetes [namespace](/docs/tasks/administer-cluster/namespaces/). It must start with a lowercase character, and end with a lowercase character or a number, and contain only lowercase letters, numbers and dashes (-). It is limited to 24 characters. Leading and trailing spaces are ignored.
-->
<p>在选定的 Kubernetes <a href="/zh/docs/tasks/administer-cluster/namespaces/">名字空间</a> 中，
应用名称必须唯一。必须由小写字母开头，以数字或者小写字母结尾，
并且只含有小写字母、数字和中划线（-）。小于等于24个字符。开头和结尾的空格会被忽略。</p>
</li>
</ul>
<!--
- **Container image** (mandatory): The URL of a public Docker [container image](/docs/concepts/containers/images/) on any registry, or a private image (commonly hosted on the Google Container Registry or Docker Hub). The container image specification must end with a colon.
 -->
<ul>
<li><strong>容器镜像</strong>（必填）：公共镜像仓库上的 Docker
<a href="/zh/docs/concepts/containers/images/">容器镜像</a> 或者私有镜像仓库
（通常是 Google Container Registry 或者 Docker Hub）的 URL。容器镜像参数说明必须以冒号结尾。</li>
</ul>
<!--
- **Number of pods** (mandatory): The target number of Pods you want your application to be deployed in. The value must be a positive integer.
-->
<ul>
<li>
<p><strong>Pod 的数量</strong>（必填）：你希望应用程序部署的 Pod 的数量。值必须为正整数。</p>
<!--
A [Deployment](/docs/concepts/workloads/controllers/deployment/) will be created to
maintain the desired number of Pods across your cluster.
-->
<p>系统会创建一个 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a>
以保证集群中运行期望的 Pod 数量。</p>
</li>
</ul>
<!--
- **Service** (optional): For some parts of your application (e.g. frontends) you may want to expose a [Service](/docs/concepts/services-networking/service/) onto an external, maybe public IP address outside of your cluster (external Service).
 -->
<ul>
<li>
<p><strong>服务</strong>（可选）：对于部分应用（比如前端），你可能想对外暴露一个
<a href="/zh/docs/concepts/services-networking/service/">Service</a> ，这个 Service
可能用的是集群之外的公网 IP 地址（外部 Service）。</p>
<!-- 
For external Services, you may need to open up one or more ports to do so.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 对于外部服务，你可能需要开放一个或多个端口才行。
</div>
<!--
Other Services that are only visible from inside the cluster are called internal Services.
-->
<p>其它只能对集群内部可见的 Service 称为内部 Service。</p>
<!--
Irrespective of the Service type, if you choose to create a Service and your container listens
on a port (incoming), you need to specify two ports.
The Service will be created mapping the port (incoming) to the target port seen by the container.
This Service will route to your deployed Pods. Supported protocols are TCP and UDP.
The internal DNS name for this Service will be the value you specified as application name above.
-->
<p>不管哪种 Service 类型，如果你选择创建一个 Service，而且容器在一个端口上开启了监听（入向的），
那么你需要定义两个端口。创建的 Service 会把（入向的）端口映射到容器可见的目标端口。
该 Service 会把流量路由到你部署的 Pod。支持 TCP 协议和 UDP 协议。
这个 Service 的内部 DNS 解析名就是之前你定义的应用名称的值。</p>
</li>
</ul>
<!--
If needed, you can expand the **Advanced options** section where you can specify more settings:
 -->
<p>如果需要，你可以打开 <strong>Advanced Options</strong> 部分，这里你可以定义更多设置：</p>
<!--
- **Description**: The text you enter here will be added as an
  [annotation](/docs/concepts/overview/working-with-objects/annotations/)
  to the Deployment and displayed in the application's details.
 -->
<ul>
<li><strong>描述</strong>：这里你输入的文本会作为一个
<a href="/zh/docs/concepts/overview/working-with-objects/annotations/">注解</a>
添加到 Deployment，并显示在应用的详细信息中。</li>
</ul>
<!--
- **Labels**: Default [labels](/docs/concepts/overview/working-with-objects/labels/) to be used for your application are application name and version. You can specify additional labels to be applied to the Deployment, Service (if any), and Pods, such as release, environment, tier, partition, and release track.
-->
<ul>
<li>
<p><strong>标签</strong>：应用默认使用的
<a href="/zh/docs/concepts/overview/working-with-objects/labels/">标签</a> 是应用名称和版本。
你可以为 Deployment、Service（如果有）定义额外的标签，比如 release（版本）、
environment（环境）、tier（层级）、partition（分区） 和 release track（版本跟踪）。</p>
<!-- Example: -->
<p>例子：</p>
<pre><code class="language-conf" data-lang="conf">release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li>
</ul>
<!--
- **Namespace**: Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called [namespaces](/docs/tasks/administer-cluster/namespaces/). They let you partition resources into logically named groups.
-->
<ul>
<li>
<p><strong>名字空间</strong>：Kubernetes 支持多个虚拟集群依附于同一个物理集群。
这些虚拟集群被称为
<a href="/zh/docs/tasks/administer-cluster/namespaces/">名字空间</a>，
可以让你将资源划分为逻辑命名的组。</p>
<!--
Dashboard offers all available namespaces in a dropdown list, and allows you to create a new namespace.
The namespace name may contain a maximum of 63 alphanumeric characters and dashes (-) 
but can not contain capital letters.
-->
<p>Dashboard 通过下拉菜单提供所有可用的名字空间，并允许你创建新的名字空间。
名字空间的名称最长可以包含 63 个字母或数字和中横线（-），但是不能包含大写字母。</p>
<!--
Namespace names should not consist of only numbers.
If the name is set as a number, such as 10, the pod will be put in the default namespace.
-->
<p>名字空间的名称不能只包含数字。如果名字被设置成一个数字，比如 10，pod 就</p>
<!--
In case the creation of the namespace is successful, it is selected by default.
If the creation fails, the first namespace is selected.
-->
<p>在名字空间创建成功的情况下，默认会使用新创建的名字空间。如果创建失败，那么第一个名字空间会被选中。</p>
</li>
</ul>
<!--
- **Image Pull Secret**: In case the specified Docker container image is private, it may require [pull secret](/docs/concepts/configuration/secret/) credentials.
-->
<ul>
<li>
<p><strong>镜像拉取 Secret</strong>：如果要使用私有的 Docker 容器镜像，需要拉取
<a href="/zh/docs/concepts/configuration/secret/">Secret</a> 凭证。</p>
<!--
Dashboard offers all available secrets in a dropdown list, and allows you to create a new secret.
The secret name must follow the DNS domain name syntax, e.g. `new.image-pull.secret`.
The content of a secret must be base64-encoded and specified in a
[`.dockercfg`](/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod) file.
The secret name may consist of a maximum of 253 characters.
-->
<p>Dashboard 通过下拉菜单提供所有可用的 Secret，并允许你创建新的 Secret。
Secret 名称必须遵循 DNS 域名语法，比如 <code>new.image-pull.secret</code>。
Secret 的内容必须是 base64 编码的，并且在一个
<a href="/zh/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"><code>.dockercfg</code></a>
文件中声明。Secret 名称最大可以包含 253 个字符。</p>
<!--
In case the creation of the image pull secret is successful, it is selected by default.
If the creation fails, no secret is applied.
-->
<p>在镜像拉取 Secret 创建成功的情况下，默认会使用新创建的 Secret。
如果创建失败，则不会使用任何 Secret。</p>
</li>
</ul>
<!--
- **CPU requirement (cores)** and **Memory requirement (MiB)**: You can specify the minimum [resource limits](/docs/tasks/configure-pod-container/limit-range/) for the container. By default, Pods run with unbounded CPU and memory limits.
 -->
<ul>
<li><strong>CPU 需求（核数）<strong>和</strong>内存需求（MiB）</strong>：你可以为容器定义最小的
<a href="/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">资源限制</a>。
默认情况下，Pod 没有 CPU 和内存限制。</li>
</ul>
<!--
- **Run command** and **Run command arguments**: By default, your containers run the specified Docker image's default [entrypoint command](/docs/user-guide/containers/#containers-and-commands). You can use the command options and arguments to override the default.
 -->
<ul>
<li><strong>运行命令</strong>和<strong>运行命令参数</strong>：默认情况下，你的容器会运行 Docker 镜像的默认
<a href="/zh/docs/tasks/inject-data-application/define-command-argument-container/">入口命令</a>。
你可以使用 command 选项覆盖默认值。</li>
</ul>
<!--
- **Run as privileged**: This setting determines whether processes in [privileged containers](/docs/user-guide/pods/#privileged-mode-for-pod-containers) are equivalent to processes running as root on the host. Privileged containers can make use of capabilities like manipulating the network stack and accessing devices.
 -->
<ul>
<li><strong>以特权模式运行</strong>：这个设置决定了在
<a href="/zh/docs/concepts/workloads/pods/#privileged-mode-for-containers">特权容器</a>
中运行的进程是否像主机中使用 root 运行的进程一样。
特权容器可以使用诸如操纵网络堆栈和访问设备的功能。</li>
</ul>
<!--
- **Environment variables**: Kubernetes exposes Services through [environment variables](/docs/tasks/inject-data-application/environment-variable-expose-pod-information/). You can compose environment variable or pass arguments to your commands using the values of environment variables. They can be used in applications to find a Service. Values can reference other variables using the `$(VAR_NAME)` syntax.
 -->
<ul>
<li><strong>环境变量</strong>：Kubernetes 通过
<a href="/zh/docs/tasks/inject-data-application/environment-variable-expose-pod-information/">环境变量</a>
暴露 Service。你可以构建环境变量，或者将环境变量的值作为参数传递给你的命令。
它们可以被应用用于查找 Service。值可以通过  <code>$(VAR_NAME)</code> 语法关联其他变量。</li>
</ul>
<!--
### Uploading a YAML or JSON file

Kubernetes supports declarative configuration.
In this style, all configuration is stored in manifests (YAML or JSON configuration files).
The manifests use the Kubernetes [API](/docs/concepts/overview/kubernetes-api/) resource schemas.
-->
<h3 id="上传-yaml-或者-json-文件">上传 YAML 或者 JSON 文件</h3>
<p>Kubernetes 支持声明式配置。所有的配置都存储在清单文件
（YAML 或者 JSON 配置文件）中。这些
清单使用 Kubernetes <a href="/zh/docs/concepts/overview/kubernetes-api/">API</a> 定义的资源模式。</p>
<!--
As an alternative to specifying application details in the deploy wizard,
you can define your application one or more manifests, and upload the files using Dashboard.
-->
<p>作为一种替代在部署向导中指定应用详情的方式，你可以在一个或多个清单文件中定义应用，并且使用
Dashboard 上传文件。</p>
<!--
## Using Dashboard

Following sections describe views of the Kubernetes Dashboard UI; what they provide and how can they be used.
-->
<h2 id="使用-dashboard">使用 Dashboard</h2>
<p>以下各节描述了 Kubernetes Dashboard UI 视图；包括它们提供的内容，以及怎么使用它们。</p>
<!--
### Navigation

When there are Kubernetes objects defined in the cluster, Dashboard shows them in the initial view. By default only objects from the _default_ namespace are shown and this can be changed using the namespace selector located in the navigation menu.
-->
<h3 id="导航">导航</h3>
<p>当在集群中定义 Kubernetes 对象时，Dashboard 会在初始视图中显示它们。
默认情况下只会显示 <em>默认</em> 名字空间中的对象，可以通过更改导航栏菜单中的名字空间筛选器进行改变。</p>
<!--
Dashboard shows most Kubernetes object kinds and groups them in a few menu categories.
-->
<p>Dashboard 展示大部分 Kubernetes 对象，并将它们分组放在几个菜单类别中。</p>
<!--
#### Admin Overview

For cluster and namespace administrators, Dashboard lists Nodes, Namespaces and PersistentVolumes and has detail views for them.
Node list view contains CPU and memory usage metrics aggregated across all Nodes.
The details view shows the metrics for a Node, its specification, status,
allocated resources, events and pods running on the node.
-->
<h4 id="管理概述">管理概述</h4>
<p>集群和名字空间管理的视图, Dashboard 会列出节点、名字空间和持久卷，并且有它们的详细视图。
节点列表视图包含从所有节点聚合的 CPU 和内存使用的度量值。
详细信息视图显示了一个节点的度量值，它的规格、状态、分配的资源、事件和这个节点上运行的 Pod。</p>
<!--
#### Workloads

Shows all applications running in the selected namespace.
The view lists applications by workload kind (e.g., Deployments, ReplicaSets, Stateful Sets, etc.).
Each workload kind can be viewed separately.
The lists summarize actionable information about the workloads,
such as the number of ready pods for a ReplicaSet or current memory usage for a Pod.
 -->
<h4 id="负载">负载</h4>
<p>显示选中的名字空间中所有运行的应用。
视图按照负载类型（如 Deployment、ReplicaSet、StatefulSet 等）罗列应用，并且每种负载都可以单独查看。
列表总结了关于负载的可执行信息，比如一个 ReplicaSet 的就绪状态的 Pod 数量，或者目前一个 Pod 的内存用量。</p>
<!--
Detail views for workloads show status and specification information and
surface relationships between objects.
For example, Pods that Replica Set is controlling or New ReplicaSets and HorizontalPodAutoscalers for Deployments.
-->
<p>工作负载的详情视图展示了对象的状态、详细信息和相互关系。
例如，ReplicaSet 所控制的 Pod，或者 Deployment 所关联的新 ReplicaSet 和
HorizontalPodAutoscalers。</p>
<!--
#### Services

Shows Kubernetes resources that allow for exposing services to external world and discovering them within a cluster. For that reason, Service and Ingress views show Pods targeted by them, internal endpoints for cluster connections and external endpoints for external users.
-->
<h4 id="服务">服务</h4>
<p>展示允许暴露给外网服务和允许集群内部发现的 Kubernetes 资源。
因此，Service 和 Ingress 视图展示他们关联的 Pod、给集群连接使用的内部端点和给外部用户使用的外部端点。</p>
<!--
#### Storage

Storage view shows PersistentVolumeClaim resources which are used by applications for storing data.
-->
<h4 id="存储">存储</h4>
<p>存储视图展示持久卷申领（PVC）资源，这些资源被应用程序用来存储数据。</p>
<!--
#### Config Maps and Secrets

Shows all Kubernetes resources that are used for live configuration of applications running in clusters. The view allows for editing and managing config objects and displays secrets hidden by default.
-->
<h4 id="configmap-和-secret">ConfigMap 和 Secret</h4>
<p>展示的所有 Kubernetes 资源是在集群中运行的应用程序的实时配置。
通过这个视图可以编辑和管理配置对象，并显示那些默认隐藏的 Secret。</p>
<!--
#### Logs viewer

Pod lists and detail pages link to logs viewer that is built into Dashboard. The viewer allows for drilling down logs from containers belonging to a single Pod.
-->
<h4 id="日志查看器">日志查看器</h4>
<p>Pod 列表和详细信息页面可以链接到 Dashboard 内置的日志查看器。
查看器可以深入查看属于同一个 Pod 的不同容器的日志。</p>
<!--
![Logs viewer](/images/docs/ui-dashboard-logs-view.png)
 -->
<p><img src="/images/docs/ui-dashboard-logs-view.png" alt="日志浏览"></p>
<h2 id="what-s-next">What's next</h2>
<!--
For more information, see the
[Kubernetes Dashboard project page](https://github.com/kubernetes/dashboard).
-->
<p>更多信息，参见 <a href="https://github.com/kubernetes/dashboard">Kubernetes Dashboard 项目页面</a>.</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-6a8d9e9e05f2b6825afbb8889c957370">2 - 访问集群</h1>
    
	<!--
title: Accessing Clusters
weight: 20
content_type: concept
-->
<!-- overview -->
<!--
This topic discusses multiple ways to interact with clusters.
-->
<p>本文阐述多种与集群交互的方法。</p>
<nav id="TableOfContents">
  <ul>
    <li><a href="#使用-kubectl-完成集群的第一次访问">使用 kubectl 完成集群的第一次访问</a></li>
    <li><a href="#直接访问-rest-api">直接访问 REST API</a>
      <ul>
        <li><a href="#使用-kubectl-proxy">使用 kubectl proxy</a></li>
        <li><a href="#不使用-kubectl-proxy">不使用 kubectl proxy</a></li>
      </ul>
    </li>
    <li><a href="#以编程方式访问-api">以编程方式访问 API</a>
      <ul>
        <li><a href="#go-客户端">Go 客户端</a></li>
        <li><a href="#python-客户端">Python 客户端</a></li>
        <li><a href="#其它语言">其它语言</a></li>
        <li><a href="#accessing-the-api-from-a-pod">从 Pod 中访问 API  </a></li>
      </ul>
    </li>
    <li><a href="#accessing-services-running-on-the-cluster">访问集群上运行的服务 </a></li>
    <li><a href="#请求重定向">请求重定向</a></li>
    <li><a href="#多种代理">多种代理</a></li>
  </ul>
</nav>
<!-- body -->
<!--
## Accessing for the first time with kubectl

When accessing the Kubernetes API for the first time, we suggest using the
Kubernetes CLI, `kubectl`.

To access a cluster, you need to know the location of the cluster and have credentials
to access it.  Typically, this is automatically set-up when you work through
a [Getting started guide](/docs/setup/),
or someone else setup the cluster and provided you with credentials and a location.

Check the location and credentials that kubectl knows about with this command:
-->
<h2 id="使用-kubectl-完成集群的第一次访问">使用 kubectl 完成集群的第一次访问</h2>
<p>当你第一次访问 Kubernetes API 的时候，我们建议你使用 Kubernetes CLI，<code>kubectl</code>。</p>
<p>访问集群时，你需要知道集群的地址并且拥有访问的凭证。通常，这些在你通过
<a href="/zh/docs/setup/">启动安装</a>安装集群时都是自动安装好的，或者其他人安装时
也应该提供了凭证和集群地址。</p>
<p>通过以下命令检查 kubectl 是否知道集群地址及凭证：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><!--
Many of the [examples](/docs/user-guide/kubectl-cheatsheet) provide an introduction to using
`kubectl` and complete documentation is found in the [kubectl reference](/docs/reference/kubectl/).
-->
<p>有许多 <a href="/zh/docs/reference/kubectl/cheatsheet/">例子</a> 介绍了如何使用 kubectl，
可以在 <a href="/zh/docs/reference/kubectl/overview/">kubectl 参考</a> 中找到更完整的文档。</p>
<!--
## Directly accessing the REST API

Kubectl handles locating and authenticating to the apiserver.
If you want to directly access the REST API with an http client like
curl or wget, or a browser, there are several ways to locate and authenticate:

  - Run kubectl in proxy mode.
    - Recommended approach.
    - Uses stored apiserver location.
    - Verifies identity of apiserver using self-signed cert.  No MITM possible.
    - Authenticates to apiserver.
    - In future, may do intelligent client-side load-balancing and failover.
  - Provide the location and credentials directly to the http client.
    - Alternate approach.
    - Works with some types of client code that are confused by using a proxy.
    - Need to import a root cert into your browser to protect against MITM.
-->
<h2 id="直接访问-rest-api">直接访问 REST API</h2>
<p>Kubectl 处理 apiserver 的定位和身份验证。
如果要使用 curl 或 wget 等 http 客户端或浏览器直接访问 REST API，可以通过
多种方式查找和验证：</p>
<ul>
<li>以代理模式运行 kubectl。
<ul>
<li>推荐此方式。</li>
<li>使用已存储的 apiserver 地址。</li>
<li>使用自签名的证书来验证 apiserver 的身份。杜绝 MITM 攻击。</li>
<li>对 apiserver 进行身份验证。</li>
<li>未来可能会实现智能化的客户端负载均衡和故障恢复。</li>
</ul>
</li>
<li>直接向 http 客户端提供位置和凭据。
<ul>
<li>可选的方案。</li>
<li>适用于代理可能引起混淆的某些客户端类型。</li>
<li>需要引入根证书到你的浏览器以防止 MITM 攻击。</li>
</ul>
</li>
</ul>
<!--
### Using kubectl proxy

The following command runs kubectl in a mode where it acts as a reverse proxy.  It handles
locating the apiserver and authenticating.
Run it like this:
-->
<h3 id="使用-kubectl-proxy">使用 kubectl proxy</h3>
<p>以下命令以反向代理的模式运行 kubectl。它处理 apiserver 的定位和验证。
像这样运行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl proxy --port<span style="color:#666">=</span><span style="color:#666">8080</span> &amp;
</code></pre></div><!--
See [kubectl proxy](/docs/reference/generated/kubectl/kubectl-commands/#proxy) for more details.

Then you can explore the API with curl, wget, or a browser, replacing localhost
with [::1] for IPv6, like so:
-->
<p>参阅 <a href="/docs/reference/generated/kubectl/kubectl-commands/#proxy">kubectl proxy</a>
获取更多详细信息。</p>
<p>然后，你可以使用 curl、wget 或浏览器访问 API，如果是 IPv6 则用 [::1] 替换 localhost，
如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl http://localhost:8080/api/
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;APIVersions&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><!--
### Without kubectl proxy

In Kubernetes version 1.3 or later, `kubectl config view` no longer displays the token. Use `kubectl apply` and `kubectl describe secret...` to create a token for the default service account with grep/cut:

First, create the Secret, requesting a token for the default ServiceAccount:

-->
<h3 id="不使用-kubectl-proxy">不使用 kubectl proxy</h3>
<p>在 Kubernetes 1.3 或更高版本中，<code>kubectl config view</code> 不再显示 token。
使用 <code>kubectl apply</code> 和 <code>kubectl describe secret ...</code> 及 grep 和剪切操作来为 default 服务帐户创建令牌，如下所示：
<code>grep/cut</code> 方法实现：
首先，创建 Secret，请求默认 ServiceAccount 的令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f - <span style="color:#b44">&lt;&lt;EOF
</span><span style="color:#b44">apiVersion: v1
</span><span style="color:#b44">kind: Secret
</span><span style="color:#b44">metadata:
</span><span style="color:#b44">  name: default-token
</span><span style="color:#b44">  annotations:
</span><span style="color:#b44">    kubernetes.io/service-account.name: default
</span><span style="color:#b44">type: kubernetes.io/service-account-token
</span><span style="color:#b44">EOF</span>
</code></pre></div><!--
Next, wait for the token controller to populate the Secret with a token:

Capture and use the generated token:
-->
<p>接下来，等待令牌控制器使用令牌填充 Secret：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f;font-weight:bold">while</span> ! kubectl describe secret default-token | grep -E <span style="color:#b44">&#39;^token&#39;</span> &gt;/dev/null; <span style="color:#a2f;font-weight:bold">do</span>
  <span style="color:#a2f">echo</span> <span style="color:#b44">&#34;waiting for token...&#34;</span> &gt;&amp;<span style="color:#666">2</span>
  sleep <span style="color:#666">1</span>
<span style="color:#a2f;font-weight:bold">done</span>
</code></pre></div><p>捕获并使用生成的令牌：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">APISERVER</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl config view | grep server | cut -f 2- -d <span style="color:#b44">&#34;:&#34;</span> | tr -d <span style="color:#b44">&#34; &#34;</span><span style="color:#a2f;font-weight:bold">)</span>
<span style="color:#b8860b">TOKEN</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl describe secret default-token | grep -E <span style="color:#b44">&#39;^token&#39;</span> | cut -f2 -d<span style="color:#b44">&#39;:&#39;</span> | tr -d <span style="color:#b44">&#39; &#39;</span><span style="color:#a2f;font-weight:bold">)</span>
curl <span style="color:#b8860b">$APISERVER</span>/api --header <span style="color:#b44">&#34;Authorization: Bearer </span><span style="color:#b8860b">$TOKEN</span><span style="color:#b44">&#34;</span> --insecure
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;APIVersions&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><p><code>jsonpath</code> 方法实现：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#b8860b">APISERVER</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl config view --minify -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.clusters[0].cluster.server}&#39;</span><span style="color:#a2f;font-weight:bold">)</span>
<span style="color:#b8860b">TOKEN</span><span style="color:#666">=</span><span style="color:#a2f;font-weight:bold">$(</span>kubectl get secret default-token -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{.data.token}&#39;</span> | base64 --decode <span style="color:#a2f;font-weight:bold">)</span>
curl <span style="color:#b8860b">$APISERVER</span>/api --header <span style="color:#b44">&#34;Authorization: Bearer </span><span style="color:#b8860b">$TOKEN</span><span style="color:#b44">&#34;</span> --insecure
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;kind&#34;</span>: <span style="color:#b44">&#34;APIVersions&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;versions&#34;</span>: [
    <span style="color:#b44">&#34;v1&#34;</span>
  ],
  <span style="color:#008000;font-weight:bold">&#34;serverAddressByClientCIDRs&#34;</span>: [
    {
      <span style="color:#008000;font-weight:bold">&#34;clientCIDR&#34;</span>: <span style="color:#b44">&#34;0.0.0.0/0&#34;</span>,
      <span style="color:#008000;font-weight:bold">&#34;serverAddress&#34;</span>: <span style="color:#b44">&#34;10.0.1.149:443&#34;</span>
    }
  ]
}
</code></pre></div><!--
The above examples use the `--insecure` flag.  This leaves it subject to MITM
attacks.  When kubectl accesses the cluster it uses a stored root certificate
and client certificates to access the server.  (These are installed in the
`~/.kube` directory).  Since cluster certificates are typically self-signed, it
may take special configuration to get your http client to use root
certificate.

On some clusters, the apiserver does not require authentication; it may serve
on localhost, or be protected by a firewall.  There is not a standard
for this.  [Configuring Access to the API](/docs/admin/accessing-the-api)
describes how a cluster admin can configure this.  Such approaches may conflict
with future high-availability support.
-->
<p>上面的例子使用了 <code>--insecure</code> 参数，这使得它很容易受到 MITM 攻击。
当 kubectl 访问集群时，它使用存储的根证书和客户端证书来访问服务器
（它们安装在 <code>~/.kube</code> 目录中）。
由于集群证书通常是自签名的，因此可能需要特殊配置才能让你的 http 客户端使用根证书。</p>
<p>在一些集群中，apiserver 不需要身份验证；它可能只服务于 localhost，或者被防火墙保护，
这个没有一定的标准。
<a href="/zh/docs/concepts/security/controlling-access/">配置对 API 的访问</a>
描述了集群管理员如何进行配置。此类方法可能与未来的高可用性支持相冲突。</p>
<!--
## Programmatic access to the API

Kubernetes officially supports [Go](#go-client) and [Python](#python-client)
client libraries.

### Go client

* To get the library, run the following command: `go get k8s.io/client-go/<version number>/kubernetes`. See [https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go) to see which versions are supported.
* Write an application atop of the client-go clients. Note that client-go defines its own API objects, so if needed, please import API definitions from client-go rather than from the main repository, e.g., `import "k8s.io/client-go/1.4/pkg/api/v1"` is correct.

The Go client can use the same [kubeconfig file](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the apiserver. See this [example](https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go).

If the application is deployed as a Pod in the cluster, please refer to the [next section](#accessing-the-api-from-a-pod).
-->
<h2 id="以编程方式访问-api">以编程方式访问 API</h2>
<p>Kubernetes 官方提供对 <a href="#go-client">Go</a> 和 <a href="#python-client">Python</a> 的客户端库支持。</p>
<h3 id="go-客户端">Go 客户端</h3>
<ul>
<li>想要获得这个库，请运行命令：<code>go get k8s.io/client-go/&lt;version number&gt;/kubernetes</code>。
参阅 <a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go</a>
来查看目前支持哪些版本。</li>
<li>基于这个 client-go 客户端库编写应用程序。
请注意，client-go 定义了自己的 API 对象，因此如果需要，请从 client-go 而不是从主存储库
导入 API 定义，例如，<code>import &quot;k8s.io/client-go/1.4/pkg/api/v1&quot;</code> 才是对的。</li>
</ul>
<p>Go 客户端可以像 kubectl CLI 一样使用相同的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
来定位和验证 apiserver。可参阅
<a href="https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go">示例</a>。</p>
<p>如果应用程序以 Pod 的形式部署在集群中，那么请参阅
<a href="#accessing-the-api-from-a-pod">下一章</a>。</p>
<!--
### Python client

To use [Python client](https://github.com/kubernetes-client/python), run the following command: `pip install kubernetes`. See [Python Client Library page](https://github.com/kubernetes-client/python) for more installation options.

The Python client can use the same [kubeconfig file](/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/)
as the kubectl CLI does to locate and authenticate to the apiserver. See this [example](https://github.com/kubernetes-client/python/tree/master/examples).

### Other languages

There are [client libraries](/docs/reference/using-api/client-libraries/) for accessing the API from other languages.
See documentation for other libraries for how they authenticate.
-->
<h3 id="python-客户端">Python 客户端</h3>
<p>如果想要使用 <a href="https://github.com/kubernetes-client/python">Python 客户端</a>，
请运行命令：<code>pip install kubernetes</code>。参阅
<a href="https://github.com/kubernetes-client/python">Python Client Library page</a>
以获得更详细的安装参数。</p>
<p>Python 客户端可以像 kubectl CLI 一样使用相同的
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>
来定位和验证 apiserver，可参阅
<a href="https://github.com/kubernetes-client/python/tree/master/examples">示例</a>。</p>
<h3 id="其它语言">其它语言</h3>
<p>目前有多个<a href="/zh/docs/reference/using-api/client-libraries/">客户端库</a>
为其它语言提供访问 API 的方法。
参阅其它库的相关文档以获取他们是如何验证的。</p>
<!--
## Accessing the API from a Pod

When accessing the API from a pod, locating and authenticating
to the API server are somewhat different.
-->
<h3 id="accessing-the-api-from-a-pod">从 Pod 中访问 API  </h3>
<p>当你从 Pod 中访问 API 时，定位和验证 API 服务器会有些许不同。</p>
<!--
Please check [Accessing the API from within a Pod](/docs/tasks/run-application/access-api-from-pod/)
for more details.
-->
<p>请参阅<a href="/zh/docs/tasks/run-application/access-api-from-pod/">从 Pod 中访问 API</a>
了解更多详情。</p>
<!--
## Accessing services running on the cluster

The previous section describes how to connect to the Kubernetes API server. 
For information about connecting to other services running on a Kubernetes cluster, see
[Access Cluster Services](/docs/tasks/administer-cluster/access-cluster-services/).
-->
<h2 id="accessing-services-running-on-the-cluster">访问集群上运行的服务 </h2>
<p>上一节介绍了如何连接到 Kubernetes API 服务器。
有关连接到 Kubernetes 集群上运行的其他服务的信息，请参阅
<a href="/zh/docs/tasks/administer-cluster/access-cluster-services/">访问集群服务</a>。</p>
<!--
## Requesting redirects

The redirect capabilities have been deprecated and removed.  Please use a proxy (see below) instead.
-->
<h2 id="请求重定向">请求重定向</h2>
<p>重定向功能已弃用并被删除。请改用代理（见下文）。</p>
<!--
## So Many Proxies

There are several different proxies you may encounter when using Kubernetes:

1.  The [kubectl proxy](#directly-accessing-the-rest-api):

    - runs on a user's desktop or in a pod
    - proxies from a localhost address to the Kubernetes apiserver
    - client to proxy uses HTTP
    - proxy to apiserver uses HTTPS
    - locates apiserver
    - adds authentication headers

-->
<h2 id="多种代理">多种代理</h2>
<p>使用 Kubernetes 时可能会遇到几种不同的代理：</p>
<ol>
<li>
<p><a href="#directly-accessing-the-rest-api">kubectl 代理</a>：</p>
<ul>
<li>在用户的桌面或 Pod 中运行</li>
<li>代理从本地主机地址到 Kubernetes apiserver</li>
<li>客户端到代理将使用 HTTP</li>
<li>代理到 apiserver 使用 HTTPS</li>
<li>定位 apiserver</li>
<li>添加身份验证头部</li>
</ul>
</li>
</ol>
<!--
1.  The [apiserver proxy](#discovering-builtin-services):

    - is a bastion built into the apiserver
    - connects a user outside of the cluster to cluster IPs which otherwise might not be reachable
    - runs in the apiserver processes
    - client to proxy uses HTTPS (or http if apiserver so configured)
    - proxy to target may use HTTP or HTTPS as chosen by proxy using available information
    - can be used to reach a Node, Pod, or Service
    - does load balancing when used to reach a Service
-->
<ol start="2">
<li>
<p><a href="#discovering-builtin-services">apiserver 代理</a>：</p>
<ul>
<li>内置于 apiserver 中</li>
<li>将集群外部的用户连接到集群 IP，否则这些 IP 可能无法访问</li>
<li>运行在 apiserver 进程中</li>
<li>客户端代理使用 HTTPS（也可配置为 http）</li>
<li>代理将根据可用的信息决定使用 HTTP 或者 HTTPS 代理到目标</li>
<li>可用于访问节点、Pod 或服务</li>
<li>在访问服务时进行负载平衡</li>
</ul>
</li>
</ol>
<!--
1.  The [kube proxy](/docs/concepts/services-networking/service/#ips-and-vips):

    - runs on each node
    - proxies UDP and TCP
    - does not understand HTTP
    - provides load balancing
    - is only used to reach services
-->
<ol start="3">
<li>
<p><a href="/zh/docs/concepts/services-networking/service/#ips-and-vips">kube proxy</a>：</p>
<ul>
<li>运行在每个节点上</li>
<li>代理 UDP 和 TCP</li>
<li>不能代理 HTTP</li>
<li>提供负载均衡</li>
<li>只能用来访问服务</li>
</ul>
</li>
</ol>
<!--
1.  A Proxy/Load-balancer in front of apiserver(s):

    - existence and implementation varies from cluster to cluster (e.g. nginx)
    - sits between all clients and one or more apiservers
    - acts as load balancer if there are several apiservers.
-->
<ol start="4">
<li>
<p>位于 apiserver 之前的 Proxy/Load-balancer：</p>
<ul>
<li>存在和实现因集群而异（例如 nginx）</li>
<li>位于所有客户和一个或多个 apiserver 之间</li>
<li>如果有多个 apiserver，则充当负载均衡器</li>
</ul>
</li>
</ol>
<!--
1.  Cloud Load Balancers on external services:

    - are provided by some cloud providers (e.g. AWS ELB, Google Cloud Load Balancer)
    - are created automatically when the Kubernetes service has type `LoadBalancer`
    - use UDP/TCP only
    - implementation varies by cloud provider.

Kubernetes users will typically not need to worry about anything other than the first two types.  The cluster admin
will typically ensure that the latter types are setup correctly.
-->
<ol start="5">
<li>
<p>外部服务上的云负载均衡器：</p>
<ul>
<li>由一些云提供商提供（例如 AWS ELB，Google Cloud Load Balancer）</li>
<li>当 Kubernetes 服务类型为 <code>LoadBalancer</code> 时自动创建</li>
<li>只使用 UDP/TCP</li>
<li>具体实现因云提供商而异。</li>
</ul>
</li>
</ol>
<p>除了前两种类型之外，Kubernetes 用户通常不需要担心任何其他问题。
集群管理员通常会确保后者的正确配置。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-72d3dddbc0c166c9a364e753d2b31ff0">3 - 使用端口转发来访问集群中的应用</h1>
    
	<!--
title: Use Port Forwarding to Access Applications in a Cluster
content_type: task
weight: 40
-->
<!-- overview -->
<!--
This page shows how to use `kubectl port-forward` to connect to a MongoDB
server running in a Kubernetes cluster. This type of connection can be useful
for database debugging.
-->
<p>本文展示如何使用 <code>kubectl port-forward</code> 连接到在 Kubernetes 集群中
运行的 MongoDB 服务。这种类型的连接对数据库调试很有用。</p>
<h2 id="before-you-begin">Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<!--
* Install [MongoDB Shell](https://www.mongodb.com/try/download/shell).
-->
<ul>
<li>安装 <a href="https://www.mongodb.com/try/download/shell">MongoDB Shell</a>。</li>
</ul>
<!-- steps -->
<!--
## Creating MongoDB deployment and service

1. Create a Deployment that runs MongoDB:
-->
<h2 id="创建-mongodb-deployment-和服务">创建 MongoDB deployment 和服务</h2>
<ol>
<li>
<p>创建一个运行 MongoDB 的 deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-deployment.yaml
</code></pre></div><!--
The output of a successful command verifies that the deployment was created:
-->
<p>查看输出是否成功，以验证是否成功创建 deployment：</p>
<pre><code>deployment.apps/mongo created
</code></pre><!--
View the pod status to check that it is ready:
-->
<p>查看 pod 状态，检查其是否准备就绪：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods
</code></pre></div><!--
The output displays the pod created:
-->
<p>输出显示创建的 pod：</p>
<pre><code>NAME                     READY   STATUS    RESTARTS   AGE
mongo-75f59d57f4-4nd6q   1/1     Running   0          2m4s
</code></pre><!--
View the Deployment's status:
-->
<p>查看 Deployment 状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployment
</code></pre></div><!--
The output displays that the Deployment was created:
-->
<p>输出显示创建的 Deployment：</p>
<pre><code>NAME    READY   UP-TO-DATE   AVAILABLE   AGE
mongo   1/1     1            1           2m21s
</code></pre><!--
The Deployment automatically manages a ReplicaSet.
View the ReplicaSet status using:
-->
<p>Deployment 自动管理 ReplicaSet。
查看 ReplicaSet 状态：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get replicaset
</code></pre></div><!--
The output displays that the ReplicaSet was created:
-->
<p>输出显示创建的 ReplicaSet：</p>
<pre><code>NAME               DESIRED   CURRENT   READY   AGE
mongo-75f59d57f4   1         1         1       3m12s
</code></pre></li>
</ol>
<!--
2. Create a Service to expose MongoDB on the network:
-->
<ol start="2">
<li>
<p>创建一个在网络上公开的 MongoDB 服务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/application/mongodb/mongo-service.yaml
</code></pre></div><!--
The output of a successful command verifies that the Service was created:
-->
<p>查看输出是否成功，以验证是否成功创建 Service：</p>
<pre><code>service/mongo created
</code></pre><!--
Check the Service created:
-->
<p>检查 Service 是否创建：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service mongo
</code></pre></div><!--   
The output displays the service created:
-->
<p>输出显示创建的 Service：</p>
<pre><code>NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)     AGE
mongo   ClusterIP   10.96.41.183   &lt;none&gt;        27017/TCP   11s
</code></pre></li>
</ol>
<!--
3. Verify that the MongoDB server is running in the Pod, and listening on port 27017:
-->
<ol start="3">
<li>
<p>验证 MongoDB 服务是否运行在 Pod 中并且监听 27017 端口：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># Change mongo-75f59d57f4-4nd6q to the name of the Pod</span>
kubectl get pod mongo-75f59d57f4-4nd6q --template<span style="color:#666">=</span><span style="color:#b44">&#39;{{(index (index .spec.containers 0).ports 0).containerPort}}{{&#34;\n&#34;}}&#39;</span>
</code></pre></div><!--
The output displays the port for MongoDB in that Pod:
-->
<p>输出应该显示 Pod 中 MongoDB 的端口：</p>
<pre><code>27017
</code></pre><!--
(this is the TCP port allocated to MongoDB on the internet).
-->
<p>（这是 Internet 分配给 MongoDB 的 TCP 端口）。</p>
</li>
</ol>
<!--
## Forward a local port to a port on the Pod

1.  `kubectl port-forward` allows using resource name, such as a pod name, to select a matching pod to port forward to.
-->
<h2 id="转发一个本地端口到-pod-端口">转发一个本地端口到 Pod 端口</h2>
<ol>
<li>
<p><code>kubectl port-forward</code> 允许使用资源名称
（例如 pod 名称）来选择匹配的 pod 来进行端口转发。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#080;font-style:italic"># Change mongo-75f59d57f4-4nd6q to the name of the Pod</span>
kubectl port-forward mongo-75f59d57f4-4nd6q 28015:27017
</code></pre></div><!--
which is the same as
-->
<p>这相当于</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl port-forward pods/mongo-75f59d57f4-4nd6q 28015:27017
</code></pre></div><!-- or -->
<p>或者</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl port-forward deployment/mongo 28015:27017
</code></pre></div><!-- or -->
<p>或者</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl port-forward replicaset/mongo-75f59d57f4 28015:27017
</code></pre></div><!-- or -->
<p>或者</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl port-forward service/mongo 28015:27017
</code></pre></div><!--
Any of the above commands works. The output is similar to this:
-->
<p>以上所有命令都应该有效。输出应该类似于：</p>
<pre><code>Forwarding from 127.0.0.1:28015 -&gt; 27017
Forwarding from [::1]:28015 -&gt; 27017
</code></pre></li>
</ol>
<!--
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <code>kubectl port-forward</code> does not return. To continue with the exercises, you will need to open another terminal.
</div>
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <code>kubectl port-forward</code> 不会返回。你需要打开另一个终端来继续这个练习。
</div>
<!--
2.  Start the MongoDB command line interface:
-->
<ol start="2">
<li>启动 MongoDB 命令行接口：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mongosh --port <span style="color:#666">28015</span>
</code></pre></div><!--
3.  At the MongoDB command line prompt, enter the `ping` command:
-->
<ol start="3">
<li>
<p>在 MongoDB 命令行提示符下，输入 <code>ping</code> 命令：</p>
<pre><code>db.runCommand( { ping: 1 } )
</code></pre><!--
A successful ping request returns:
-->
<p>成功的 ping 请求应该返回：</p>
<pre><code>{ ok: 1 }
</code></pre></li>
</ol>
<!--
### Optionally let _kubectl_ choose the local port {#let-kubectl-choose-local-port}
-->
<h3 id="let-kubectl-choose-local-port">（可选操作）让 <em>kubectl</em> 来选择本地端口</h3>
<!--
If you don't need a specific local port, you can let `kubectl` choose and allocate 
the local port and thus relieve you from having to manage local port conflicts, with 
the slightly simpler syntax:
-->
<p>如果你不需要指定特定的本地端口，你可以让 <code>kubectl</code> 来选择和分配本地端口，
以便你不需要管理本地端口冲突。该命令使用稍微不同的语法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl port-forward deployment/mongo :27017
</code></pre></div><!--
The `kubectl` tool finds a local port number that is not in use (avoiding low ports numbers,
because these might be used by other applications). The output is similar to:
-->
<p><code>kubectl</code> 工具会找到一个未被使用的本地端口号（避免使用低段位的端口号，因为他们可能会被其他应用程序使用）。
输出应该类似于：</p>
<pre><code>Forwarding from 127.0.0.1:63753 -&gt; 27017
Forwarding from [::1]:63753 -&gt; 27017
</code></pre><!-- discussion -->
<!--
## Discussion

Connections made to local port 28015 are forwarded to port 27017 of the Pod that
is running the MongoDB server. With this connection in place, you can use your
local workstation to debug the database that is running in the Pod.
-->
<h2 id="discussion">讨论 </h2>
<p>与本地 28015 端口建立的连接将转发到运行 MongoDB 服务器的 Pod 的 27017 端口。
通过此连接，您可以使用本地工作站来调试在 Pod 中运行的数据库。</p>
<!--
`kubectl port-forward` is implemented for TCP ports only.
The support for UDP protocol is tracked in
[issue 47862](https://github.com/kubernetes/kubernetes/issues/47862).
-->
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> <code>kubectl port-forward</code> 仅适用于 TCP 端口。
在 <a href="https://github.com/kubernetes/kubernetes/issues/47862">issue 47862</a>
中跟踪了对 UDP 协议的支持。
</div>


<h2 id="what-s-next">What's next</h2>
<!--
Learn more about [kubectl port-forward](/docs/reference/generated/kubectl/kubectl-commands/#port-forward).
-->
<p>进一步了解 <a href="/docs/reference/generated/kubectl/kubectl-commands/#port-forward">kubectl port-forward</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-312f29f850826b74618634cd877aa065">4 - 使用服务来访问集群中的应用</h1>
    
	<!--
title: Use a Service to Access an Application in a Cluster
content_type: tutorial
weight: 60
-->
<!-- overview -->
<!--
This page shows how to create a Kubernetes Service object that external
clients can use to access an application running in a cluster. The Service
provides load balancing for an application that has two running instances.
-->
<p>本文展示如何创建一个 Kubernetes 服务对象，能让外部客户端访问在集群中运行的应用。
该服务为一个应用的两个运行实例提供负载均衡。</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</p>
<h2 id="objectives">Objectives</h2>
<!--
* Run two instances of a Hello World application.
* Create a Service object that exposes a node port.
* Use the Service object to access the running application.
-->
<ul>
<li>运行 Hello World 应用的两个实例。</li>
<li>创建一个服务对象来暴露 node port。</li>
<li>使用服务对象来访问正在运行的应用。</li>
</ul>
<!-- lessoncontent -->
<!--
## Creating a service for an application running in two pods

Here is the configuration file for the application Deployment:
-->
<h2 id="为运行在两个-pod-中的应用创建一个服务">为运行在两个 pod 中的应用创建一个服务</h2>
<p>这是应用程序部署的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/hello-application.yaml" download="service/access/hello-application.yaml"><code>service/access/hello-application.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-hello-application-yaml')" title="Copy service/access/hello-application.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-hello-application-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello-world<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">run</span>:<span style="color:#bbb"> </span>load-balancer-example<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">2</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">run</span>:<span style="color:#bbb"> </span>load-balancer-example<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello-world<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>gcr.io/google-samples/node-hello:1.0<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">8080</span><span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
1. Run a Hello World application in your cluster:
   Create the application Deployment using the file above:
   ```shell
   kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
   ```
   The preceding command creates a
   [Deployment](/docs/concepts/workloads/controllers/deployment/)
   object and an associated
   [ReplicaSet](/docs/concepts/workloads/controllers/replicaset/)
   object. The ReplicaSet has two
   [Pods](/docs/concepts/workloads/pods/pod/),
   each of which runs the Hello World application.
-->
<ol>
<li>
<p>在你的集群中运行一个 Hello World 应用：
使用上面的文件创建应用程序 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</code></pre></div><p>上面的命令创建一个 <a href="/zh/docs/concepts/workloads/controllers/deployment/">Deployment</a> 对象
和一个关联的 <a href="/zh/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 对象。
这个 ReplicaSet 有两个 <a href="/zh/docs/concepts/workloads/pods/">Pod</a>，
每个 Pod 都运行着 Hello World 应用。</p>
</li>
</ol>
<!--
1. Display information about the Deployment:
-->
<ol start="2">
<li>
<p>展示 Deployment 的信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get deployments hello-world
kubectl describe deployments hello-world
</code></pre></div></li>
</ol>
<!--
1. Display information about your ReplicaSet objects:
-->
<ol start="3">
<li>
<p>展示你的 ReplicaSet 对象信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get replicasets
kubectl describe replicasets
</code></pre></div></li>
</ol>
<!--
1. Create a Service object that exposes the deployment:
-->
<ol start="4">
<li>
<p>创建一个服务对象来暴露 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose deployment hello-world --type<span style="color:#666">=</span>NodePort --name<span style="color:#666">=</span>example-service
</code></pre></div></li>
</ol>
<!--
1. Display information about the Service:
-->
<ol start="5">
<li>
<p>展示 Service 信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe services example-service
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Name:                   example-service
Namespace:              default
Labels:                 <span style="color:#b8860b">run</span><span style="color:#666">=</span>load-balancer-example
Annotations:            &lt;none&gt;
Selector:               <span style="color:#b8860b">run</span><span style="color:#666">=</span>load-balancer-example
Type:                   NodePort
IP:                     10.32.0.16
Port:                   &lt;unset&gt; 8080/TCP
TargetPort:             8080/TCP
NodePort:               &lt;unset&gt; 31496/TCP
Endpoints:              10.200.1.4:8080,10.200.2.5:8080
Session Affinity:       None
Events:                 &lt;none&gt;
</code></pre></div><!--
Make a note of the NodePort value for the service. For example,
in the preceding output, the NodePort value is 31496.
-->
<p>注意服务中的 NodePort 值。例如在上面的输出中，NodePort 是 31496。</p>
</li>
</ol>
<!--
1. List the pods that are running the Hello World application:
-->
<ol start="7">
<li>
<p>列出运行 Hello World 应用的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --selector<span style="color:#666">=</span><span style="color:#b44">&#34;run=load-balancer-example&#34;</span> --output<span style="color:#666">=</span>wide
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">NAME                           READY   STATUS    ...  IP           NODE
hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</code></pre></div></li>
</ol>
<!--
1. Get the public IP address of one of your nodes that is running
   a Hello World pod. How you get this address depends on how you set
   up your cluster. For example, if you are using Minikube, you can
   see the node address by running `kubectl cluster-info`. If you are
   using Google Compute Engine instances, you can use the
   `gcloud compute instances list` command to see the public addresses of your
   nodes.

1. On your chosen node, create a firewall rule that allows TCP traffic
   on your node port. For example, if your Service has a NodePort value of
   31568, create a firewall rule that allows TCP traffic on port 31568. Different
   cloud providers offer different ways of configuring firewall rules.

1. Use the node address and node port to access the Hello World application:
-->
<ol start="8">
<li>
<p>获取运行 Hello World 的 pod 的其中一个节点的公共 IP 地址。如何获得此地址取决于你设置集群的方式。
例如，如果你使用的是 Minikube，则可以通过运行 <code>kubectl cluster-info</code> 来查看节点地址。
如果你使用的是 Google Compute Engine 实例，则可以使用 <code>gcloud compute instances list</code> 命令查看节点的公共地址。</p>
</li>
<li>
<p>在你选择的节点上，创建一个防火墙规则以开放节点端口上的 TCP 流量。
例如，如果你的服务的 NodePort 值为 31568，请创建一个防火墙规则以允许 31568 端口上的 TCP 流量。
不同的云提供商提供了不同方法来配置防火墙规则。</p>
</li>
<li>
<p>使用节点地址和 node port 来访问 Hello World 应用：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</code></pre></div>   <!--
   where `<public-node-ip>` is the public IP address of your node,
   and `<node-port>` is the NodePort value for your service. The
   response to a successful request is a hello message:
   -->
<p>这里的 <code>&lt;public-node-ip&gt;</code> 是你节点的公共 IP 地址，<code>&lt;node-port&gt;</code> 是你服务的 NodePort 值。
对于请求成功的响应是一个 hello 消息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Hello Kubernetes!
</code></pre></div><!--
## Using a service configuration file

As an alternative to using `kubectl expose`, you can use a
[service configuration file](/docs/concepts/services-networking/service/)
to create a Service.
-->
<h2 id="使用服务配置文件">使用服务配置文件</h2>
<p>作为 <code>kubectl expose</code> 的替代方法，你可以使用
<a href="/zh/docs/concepts/services-networking/service/">服务配置文件</a> 来创建服务。</p>
<h2 id="cleaning-up">Cleaning up</h2>
<!--
To delete the Service, enter this command:
-->
<p>想要删除服务，输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete services example-service
</code></pre></div><!--
To delete the Deployment, the ReplicaSet, and the Pods that are running
the Hello World application, enter this command:
-->
<p>想要删除运行 Hello World 应用的 Deployment、ReplicaSet 和 Pod，输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete deployment hello-world
</code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
Learn more about
[connecting applications with services](/docs/concepts/services-networking/connect-applications-service/).
-->
<ul>
<li>进一步了解<a href="/zh/docs/concepts/services-networking/connect-applications-service/">通过服务连接应用</a>。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-f3dac629bea950fc026d920306f09fb4">5 - 使用 Service 把前端连接到后端</h1>
    
	<!--
title: Connect a Frontend to a Backend Using Services
content_type: tutorial
weight: 70
-->
<!-- overview -->
<!--
This task shows how to create a _frontend_ and a _backend_ microservice. The backend 
microservice is a hello greeter. The frontend exposes the backend using nginx and a 
Kubernetes <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='服务（Service）'>服务（Service）</a> object.
-->
<p>本任务会描述如何创建前端（Frontend）微服务和后端（Backend）微服务。后端微服务是一个 hello 欢迎程序。
前端通过 nginx 和一个 Kubernetes <a class='glossary-tooltip' title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/services-networking/service/' target='_blank' aria-label='服务'>服务</a>
暴露后端所提供的服务。</p>
<h2 id="objectives">Objectives</h2>
<!--
* Create and run a sample `hello` backend microservice using a
  <a class='glossary-tooltip' title='Deployment 是管理应用副本的 API 对象。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/workloads/controllers/deployment/' target='_blank' aria-label='Deployment'>Deployment</a> object.
* Use a Service object to send traffic to the backend microservice's multiple replicas.
* Create and run a `nginx` frontend microservice, also using a Deployment object.
* Configure the frontend microservice to send traffic to the backend microservice.
* Use a Service object of `type=LoadBalancer` to expose the frontend microservice
  outside the cluster.
-->
<ul>
<li>使用部署对象（Deployment object）创建并运行一个 <code>hello</code> 后端微服务</li>
<li>使用一个 Service 对象将请求流量发送到后端微服务的多个副本</li>
<li>同样使用一个 Deployment 对象创建并运行一个 <code>nginx</code> 前端微服务</li>
<li>配置前端微服务将请求流量发送到后端微服务</li>
<li>使用 <code>type=LoadBalancer</code> 的 Service 对象将全段微服务暴露到集群外部</li>
</ul>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</p>
<!--
This task uses
[Services with external load balancers](/docs/tasks/access-application-cluster/create-external-load-balancer/), which
require a supported environment. If your environment does not support this, you can use a Service of type
[NodePort](/docs/concepts/services-networking/service/#type-nodeport) instead.
-->
<p>本任务使用<a href="/zh/docs/tasks/access-application-cluster/create-external-load-balancer/">外部负载均衡服务</a>，
所以需要对应的可支持此功能的环境。如果你的环境不能支持，你可以使用
<a href="/zh/docs/concepts/services-networking/service/#type-nodeport">NodePort</a>
类型的服务代替。</p>
<!-- lessoncontent -->
<!--
## Creating the backend using a Deployment

The backend is a simple hello greeter microservice. Here is the configuration
file for the backend Deployment:
-->
<h3 id="使用部署对象-deployment-创建后端">使用部署对象（Deployment）创建后端</h3>
<p>后端是一个简单的 hello 欢迎微服务应用。这是后端应用的 Deployment 配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/backend-deployment.yaml" download="service/access/backend-deployment.yaml"><code>service/access/backend-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-backend-deployment-yaml')" title="Copy service/access/backend-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-backend-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">track</span>:<span style="color:#bbb"> </span>stable<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">3</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">track</span>:<span style="color:#bbb"> </span>stable<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">containerPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span></code></pre></div>
    </div>
</div>


<!-- 
Create the backend Deployment:
-->
<p>创建后端 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/access/backend-deployment.yaml
</code></pre></div><!--
View information about the backend Deployment:
-->
<p>查看后端的 Deployment 信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe deployment backend
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>Name:                           backend
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &quot;gcr.io/google-samples/hello-go-gke:1.0&quot;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (3/3 replicas created)
Events:
...
</code></pre><!--
## Creating the `hello` Service object

The key to sending requests from a frontend to a backend is the backend
Service. A Service creates a persistent IP address and DNS name entry
so that the backend microservice can always be reached. A Service uses
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='selectors'>selectors</a> to find
the Pods that it routes traffic to.

First, explore the Service configuration file:
-->
<h3 id="创建-hello-service-对象">创建 <code>hello</code> Service 对象</h3>
<p>将请求从前端发送到到后端的关键是后端 Service。Service 创建一个固定 IP 和 DNS 解析名入口，
使得后端微服务总是可达。Service 使用
<a class='glossary-tooltip' title='选择算符允许用户通过标签对一组资源对象进行筛选过滤。' data-toggle='tooltip' data-placement='top' href='/zh/docs/concepts/overview/working-with-objects/labels/' target='_blank' aria-label='选择算符'>选择算符</a>
来寻找目标 Pod。</p>
<p>首先，浏览 Service 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/backend-service.yaml" download="service/access/backend-service.yaml"><code>service/access/backend-service.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-backend-service-yaml')" title="Copy service/access/backend-service.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-backend-service-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>backend<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span>TCP<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span>http<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span></code></pre></div>
    </div>
</div>


<!--
In the configuration file, you can see that the Service named `hello` routes
traffic to Pods that have the labels `app: hello` and `tier: backend`.
-->
<p>配置文件中，你可以看到名为 <code>hello</code> 的 Service 将流量路由到包含 <code>app: hello</code>
和 <code>tier: backend</code> 标签的 Pod。</p>
<!--
Create the backend Service:
-->
<p>创建后端 Service：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/access/backend-service.yaml
</code></pre></div><!--
At this point, you have a `backend` Deployment running three replicas of your `hello`
application, and you have a Service that can route traffic to them. However, this
service is neither available nor resolvable outside the cluster.
-->
<p>此时，你已经有了一个运行着 <code>hello</code> 应用的三个副本的 <code>backend</code> Deployment，你也有了
一个 Service 用于路由网络流量。不过，这个服务在集群外部无法访问也无法解析。</p>
<!--
## Creating the frontend

Now that you have your backend running, you can create a frontend that is accessible 
outside the cluster, and connects to the backend by proxying requests to it.

The frontend sends requests to the backend worker Pods by using the DNS name
given to the backend Service. The DNS name is `hello`, which is the value
of the `name` field in the `examples/service/access/backend-service.yaml` 
configuration file.

The Pods in the frontend Deployment run an nginx image that is configured
to proxy requests to the hello backend Service. Here is the nginx configuration file:
-->
<h3 id="创建前端应用">创建前端应用</h3>
<p>现在你已经有了运行中的后端应用，你可以创建一个可在集群外部访问的前端，并通过代理
前端的请求连接到后端。</p>
<p>前端使用被赋予后端 Service 的 DNS 名称将请求发送到后端工作 Pods。这一 DNS
名称为 <code>hello</code>，也就是 <code>examples/service/access/backend-service.yaml</code> 配置
文件中 <code>name</code> 字段的取值。</p>
<p>前端 Deployment 中的 Pods 运行一个 nginx 镜像，这个已经配置好的镜像会将请求转发
给后端的 hello Service。下面是  nginx 的配置文件：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/frontend-nginx.conf" download="service/access/frontend-nginx.conf"><code>service/access/frontend-nginx.conf</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-frontend-nginx-conf')" title="Copy service/access/frontend-nginx.conf to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-frontend-nginx-conf">
    <pre tabindex="0"><code class="language-conf" data-lang="conf"># The identifier Backend is internal to nginx, and used to name this specific upstream
upstream Backend {
    # hello is the internal DNS name used by the backend Service inside Kubernetes
    server hello;
}

server {
    listen 80;

    location / {
        # The following statement will proxy traffic to the upstream named Backend
        proxy_pass http://Backend;
    }
}
</code></pre>
    </div>
</div>


<!--
Similar to the backend, the frontend has a Deployment and a Service. An important
difference to notice between the backend and frontend services, is that the
configuration for the frontend Service has `type: LoadBalancer`, which means that
the Service uses a load balancer provisioned by your cloud provider and will be
accessible from outside the cluster.
-->
<p>与后端类似，前端用包含一个 Deployment 和一个 Service。后端与前端服务之间的一个
重要区别是前端 Service 的配置文件包含了 <code>type: LoadBalancer</code>，也就是说，Service
会使用你的云服务商的默认负载均衡设备，从而实现从集群外访问的目的。</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/frontend-service.yaml" download="service/access/frontend-service.yaml"><code>service/access/frontend-service.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-frontend-service-yaml')" title="Copy service/access/frontend-service.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-frontend-service-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">protocol</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;TCP&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">80</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span></code></pre></div>
    </div>
</div>




 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/access/frontend-deployment.yaml" download="service/access/frontend-deployment.yaml"><code>service/access/frontend-deployment.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-access-frontend-deployment-yaml')" title="Copy service/access/frontend-deployment.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-access-frontend-deployment-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#00f;font-weight:bold">---</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>apps/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Deployment<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">matchLabels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">track</span>:<span style="color:#bbb"> </span>stable<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">replicas</span>:<span style="color:#bbb"> </span><span style="color:#666">1</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">template</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">labels</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>hello<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">tier</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">track</span>:<span style="color:#bbb"> </span>stable<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">          </span><span style="color:#008000;font-weight:bold">lifecycle</span>:<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">preStop</span>:<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">exec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;/usr/sbin/nginx&#34;</span>,<span style="color:#b44">&#34;-s&#34;</span>,<span style="color:#b44">&#34;quit&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00f;font-weight:bold">...</span></code></pre></div>
    </div>
</div>


<!--
Create the frontend Deployment and Service:
-->
<p>创建前端 Deployment 和 Service：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/access/frontend-deployment.yaml
kubectl apply -f https://k8s.io/examples/service/access/frontend-service.yaml
</code></pre></div><!--
The output verifies that both resources were created:
-->
<p>通过输出确认两个资源都已经被创建：</p>
<pre><code>deployment.apps/frontend created
service/frontend created
</code></pre><!--
The nginx configuration is baked into the
[container image](/examples/service/access/Dockerfile). A better way to do this would
be to use a
[ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/),
so that you can change the configuration more easily.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 这个 nginx 配置文件是被打包在
<a href="/examples/service/access/Dockerfile">容器镜像</a> 里的。
更好的方法是使用
<a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a>，
这样的话你可以更轻易地更改配置。
</div>
<!--
## Interact with the frontend Service

Once you've created a Service of type LoadBalancer, you can use this
command to find the external IP:
-->
<h3 id="interact-with-the-frontend-service">与前端 Service 交互  </h3>
<p>一旦你创建了 LoadBalancer 类型的 Service，你可以使用这条命令查看外部 IP：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service frontend
</code></pre></div><!--
This displays the configuration for the `frontend` Service and watches for
changes. Initially, the external IP is listed as `<pending>`:
-->
<p>外部 IP 字段的生成可能需要一些时间。如果是这种情况，外部 IP 会显示为 <code>&lt;pending&gt;</code>。</p>
<pre><code>NAME       CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre><!--
As soon as an external IP is provisioned, however, the configuration updates
to include the new IP under the `EXTERNAL-IP` heading:
-->
<p>当外部 IP 地址被分配可用时，配置会更新，在 <code>EXTERNAL-IP</code> 头部下显示新的 IP：</p>
<pre><code>NAME       CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre><!--
That IP can now be used to interact with the `frontend` service from outside the
cluster.
-->
<p>这一新的 IP 地址就可以用来从集群外与 <code>frontend</code> 服务交互了。</p>
<!--
## Send traffic through the frontend

The frontend and backend are now connected. You can hit the endpoint
by using the curl command on the external IP of your frontend Service.
-->
<h3 id="通过前端发送流量">通过前端发送流量</h3>
<p>前端和后端已经完成连接了。你可以使用 curl 命令通过你的前端 Service 的外部
IP 访问服务端点。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl http://<span style="color:#b68;font-weight:bold">${</span><span style="color:#b8860b">EXTERNAL_IP</span><span style="color:#b68;font-weight:bold">}</span> <span style="color:#080;font-style:italic"># 将 EXTERNAL_P 替换为你之前看到的外部 IP</span>
</code></pre></div><!--
The output shows the message generated by the backend:
-->
<p>输出显示后端生成的消息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#008000;font-weight:bold">&#34;message&#34;</span>:<span style="color:#b44">&#34;Hello&#34;</span>}
</code></pre></div><h2 id="cleaning-up">Cleaning up</h2>
<!--
To delete the Services, enter this command:
-->
<p>要删除服务，输入下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete services frontend backend
</code></pre></div><!--
To delete the Deployments, the ReplicaSets and the Pods that are running the backend and frontend applications, enter this command:
-->
<p>要删除在前端和后端应用中运行的 Deployment、ReplicaSet 和 Pod，输入下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete deployment frontend backend
</code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
* Learn more about [Services](/docs/concepts/services-networking/service/)
* Learn more about [ConfigMaps](/docs/tasks/configure-pod-container/configure-pod-configmap/)
* Learn more about [DNS for Service and Pods](/docs/concepts/services-networking/dns-pod-service/)
-->
<ul>
<li>进一步了解 <a href="/zh/docs/concepts/services-networking/service/">Service</a></li>
<li>进一步了解 <a href="/zh/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap</a></li>
<li>进一步了解 <a href="/zh/docs/concepts/services-networking/dns-pod-service/">Service 和 Pods 的 DNS</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-21cd8f87563675fb0278d3694ba9ecb0">6 - 创建外部负载均衡器</h1>
    
	<!--
title: Create an External Load Balancer
content_type: task
weight: 80
-->
<!-- overview -->
<!--
This page shows how to create an External Load Balancer.
-->
<p>本文展示如何创建一个外部负载均衡器。</p>
<!-- 
This feature is only available for cloud providers or environments which support external load balancers. 
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 此功能仅适用于支持外部负载均衡器的云提供商或环境。
</div>
<!--
When creating a service, you have the option of automatically creating a
cloud network load balancer. This provides an externally-accessible IP address
that sends traffic to the correct port on your cluster nodes
_provided your cluster runs in a supported environment and is configured with
the correct cloud load balancer provider package_.
-->
<p>创建服务时，你可以选择自动创建云网络负载均衡器。这提供了一个外部可访问的 IP 地址，
可将流量分配到集群节点上的正确端口上
（ <em>假设集群在支持的环境中运行，并配置了正确的云负载平衡器提供商包</em>）。</p>
<!--
For information on provisioning and using an Ingress resource that can give
services externally-reachable URLs, load balance the traffic, terminate SSL etc.,
please check the [Ingress](/docs/concepts/services-networking/ingress/)
documentation.
-->
<p>有关如何配置和使用 Ingress 资源为服务提供外部可访问的 URL、负载均衡流量、终止 SSL 等功能，
请查看 <a href="/zh/docs/concepts/services-networking/ingress/">Ingress</a> 文档。</p>
<h2 id="before-you-begin">Before you begin</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</li>
</ul>
<!-- steps -->
<!--
## Configuration file

To create an external load balancer, add the following line to your
[service configuration file](/docs/concepts/services-networking/service/#loadbalancer):
-->
<h2 id="配置文件">配置文件</h2>
<p>要创建外部负载均衡器，请将以下内容添加到
<a href="/zh/docs/concepts/services-networking/service/#loadbalancer">服务配置文件</a>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span></code></pre></div><!--
Your configuration file might look like:
-->
<p>你的配置文件可能会如下所示：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>example-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>example<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">8765</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span></code></pre></div><!--
## Using kubectl

You can alternatively create the service with the `kubectl expose` command and
its `--type=LoadBalancer` flag:
-->
<h2 id="使用-kubectl">使用 kubectl</h2>
<p>你也可以使用 <code>kubectl expose</code> 命令及其 <code>--type=LoadBalancer</code> 参数创建服务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl expose rc example --port<span style="color:#666">=</span><span style="color:#666">8765</span> --target-port<span style="color:#666">=</span><span style="color:#666">9376</span> <span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>        --name<span style="color:#666">=</span>example-service --type<span style="color:#666">=</span>LoadBalancer
</code></pre></div><!--
This command creates a new service using the same selectors as the referenced
resource (in the case of the example above, a replication controller named
`example`).

For more information, including optional flags, refer to the
[`kubectl expose` reference](/docs/reference/generated/kubectl/kubectl-commands/#expose).
-->
<p>此命令通过使用与引用资源（在上面的示例的情况下，名为 <code>example</code> 的 replication controller）相同的选择器来创建一个新的服务。</p>
<p>更多信息（包括更多的可选参数），请参阅
<a href="/docs/reference/generated/kubectl/kubectl-commands/#expose"><code>kubectl expose</code> 指南</a>。</p>
<!--
## Finding your IP address

You can find the IP address created for your service by getting the service
information through `kubectl`:
-->
<h2 id="找到你的-ip-地址">找到你的 IP 地址</h2>
<p>你可以通过 <code>kubectl</code> 获取服务信息，找到为你的服务创建的 IP 地址：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">kubectl describe services example-service
</code></pre></div><!--
which should produce output like this:
-->
<p>这将获得如下输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">    Name:                   example-service
    Namespace:              default
    Labels:                 &lt;none&gt;
    Annotations:            &lt;none&gt;
    Selector:               <span style="color:#b8860b">app</span><span style="color:#666">=</span>example
    Type:                   LoadBalancer
    IP:                     10.67.252.103
    LoadBalancer Ingress:   192.0.2.89
    Port:                   &lt;unnamed&gt; 80/TCP
    NodePort:               &lt;unnamed&gt; 32445/TCP
    Endpoints:              10.64.0.4:80,10.64.1.5:80,10.64.2.4:80
    Session Affinity:       None
    Events:                 &lt;none&gt;
</code></pre></div><!--
The IP address is listed next to `LoadBalancer Ingress`.
-->
<p>IP 地址列在 <code>LoadBalancer Ingress</code> 旁边。</p>
<!--
If you are running your service on Minikube, you can find the assigned IP address and port with:
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> <p>如果你在 Minikube 上运行服务，你可以通过以下命令找到分配的 IP 地址和端口：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">minikube service example-service --url
</code></pre></div>
</div>
<!--
## Preserving the client source IP

Due to the implementation of this feature, the source IP seen in the target
container is *not the original source IP* of the client. To enable
preservation of the client IP, the following fields can be configured in the
service spec (supported in GCE/Google Kubernetes Engine environments):
-->
<h2 id="保留客户端源-ip">保留客户端源 IP</h2>
<p>由于此功能的实现，目标容器中看到的源 IP 将 <em>不是客户端的原始源 IP</em>。
要启用保留客户端 IP，可以在服务的 spec 中配置以下字段（支持 GCE/Google Kubernetes Engine  环境）：</p>
<!--
* `service.spec.externalTrafficPolicy` - denotes if this Service desires to route
external traffic to node-local or cluster-wide endpoints. There are two available
options: Cluster (default) and Local. Cluster obscures the client source
IP and may cause a second hop to another node, but should have good overall
load-spreading. Local preserves the client source IP and avoids a second hop
for LoadBalancer and NodePort type services, but risks potentially imbalanced
traffic spreading.
-->
<ul>
<li><code>service.spec.externalTrafficPolicy</code> - 表示此服务是否希望将外部流量路由到节点本地或集群范围的端点。
有两个可用选项：Cluster（默认）和 Local。
Cluster 隐藏了客户端源 IP，可能导致第二跳到另一个节点，但具有良好的整体负载分布。
Local 保留客户端源 IP 并避免 LoadBalancer 和 NodePort 类型服务的第二跳，
但存在潜在的不均衡流量传播风险。</li>
</ul>
<!--
* `service.spec.healthCheckNodePort` - specifies the health check nodePort
(numeric port number) for the service. If `healthCheckNodePort` isn't specified,
the service controller allocates a port from your cluster's NodePort range. You
can configure that range by setting an API server command line option,
`--service-node-port-range`. It will use the
user-specified `healthCheckNodePort` value if specified by the client. It only has an
effect when `type` is set to LoadBalancer and `externalTrafficPolicy` is set
to Local.
-->
<ul>
<li><code>service.spec.healthCheckNodePort</code> - 指定服务的 healthcheck nodePort（数字端口号）。
如果未指定 <code>healthCheckNodePort</code>，服务控制器从集群的 NodePort 范围内分配一个端口。
你可以通过设置 API 服务器的命令行选项 <code>--service-node-port-range</code> 来配置上述范围。
它将会使用用户指定的 <code>healthCheckNodePort</code> 值（如果被客户端指定）。
仅当 <code>type</code>  设置为 LoadBalancer 并且 <code>externalTrafficPolicy</code> 设置为 Local 时才生效。</li>
</ul>
<!--
Setting `externalTrafficPolicy` to Local in the Service configuration file
activates this feature.
-->
<p>可以通过在服务的配置文件中将 <code>externalTrafficPolicy</code> 设置为 Local 来激活此功能。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>example-service<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">selector</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">app</span>:<span style="color:#bbb"> </span>example<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">ports</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb"> </span><span style="color:#666">8765</span><span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">targetPort</span>:<span style="color:#bbb"> </span><span style="color:#666">9376</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">externalTrafficPolicy</span>:<span style="color:#bbb"> </span>Local<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">type</span>:<span style="color:#bbb"> </span>LoadBalancer<span style="color:#bbb">
</span></code></pre></div><!--
## Garbage Collecting Load Balancers

In usual case, the correlating load balancer resources in cloud provider should
be cleaned up soon after a LoadBalancer type Service is deleted. But it is known
that there are various corner cases where cloud resources are orphaned after the
associated Service is deleted. Finalizer Protection for Service LoadBalancers was
introduced to prevent this from happening. By using finalizers, a Service resource
will never be deleted until the correlating load balancer resources are also deleted.
-->
<h2 id="回收负载均衡器">回收负载均衡器</h2>
<p>在通常情况下，应在删除 LoadBalancer 类型服务后立即清除云提供商中的相关负载均衡器资源。
但是，众所周知，在删除关联的服务后，云资源被孤立的情况很多。
引入了针对服务负载均衡器的终结器保护，以防止这种情况发生。
通过使用终结器，在删除相关的负载均衡器资源之前，也不会删除服务资源。</p>
<!--
Specifically, if a Service has `type` LoadBalancer, the service controller will attach
a finalizer named `service.kubernetes.io/load-balancer-cleanup`.
The finalizer will only be removed after the load balancer resource is cleaned up.
This prevents dangling load balancer resources even in corner cases such as the
service controller crashing.
-->
<p>具体来说，如果服务具有 <code>type</code> LoadBalancer，则服务控制器将附加一个名为
<code>service.kubernetes.io/load-balancer-cleanup</code> 的终结器。
仅在清除负载均衡器资源后才能删除终结器。
即使在诸如服务控制器崩溃之类的极端情况下，这也可以防止负载均衡器资源悬空。</p>
<!--
## External Load Balancer Providers

It is important to note that the datapath for this functionality is provided by a load balancer external to the Kubernetes cluster.
-->
<h2 id="外部负载均衡器提供商">外部负载均衡器提供商</h2>
<p>请务必注意，此功能的数据路径由 Kubernetes 集群外部的负载均衡器提供。</p>
<!--
When the Service `type` is set to LoadBalancer, Kubernetes provides functionality equivalent to `type` equals ClusterIP to pods
within the cluster and extends it by programming the (external to Kubernetes) load balancer with entries for the Kubernetes
pods. The Kubernetes service controller automates the creation of the external load balancer, health checks (if needed),
firewall rules (if needed) and retrieves the external IP allocated by the cloud provider and populates it in the service
object.
-->
<p>当服务 <code>type</code> 设置为 LoadBalancer 时，Kubernetes 向集群中的 Pod 提供的功能等同于
<code>type</code> 等于  ClusterIP，并通过使用 Kubernetes pod 的条目对负载均衡器（从外部到 Kubernetes）
进行编程来扩展它。
Kubernetes 服务控制器自动创建外部负载均衡器、健康检查（如果需要）、防火墙规则（如果需要），
并获取云提供商分配的外部 IP 并将其填充到服务对象中。</p>
<!--
## Caveats and Limitations when preserving source IPs

GCE/AWS load balancers do not provide weights for their target pools. This was not an issue with the old LB
kube-proxy rules which would correctly balance across all endpoints.
-->
<h2 id="保留源-ip-时的注意事项和限制">保留源 IP 时的注意事项和限制</h2>
<p>GCE/AWS 负载均衡器不为其目标池提供权重。
对于旧的 LB kube-proxy 规则来说，这不是一个问题，它可以在所有端点之间正确平衡。</p>
<!--
With the new functionality, the external traffic is not equally load balanced across pods, but rather
equally balanced at the node level (because GCE/AWS and other external LB implementations do not have the ability
for specifying the weight per node, they balance equally across all target nodes, disregarding the number of
pods on each node).
-->
<p>使用新功能，外部流量不会在 pod 之间平均负载，而是在节点级别平均负载
（因为 GCE/AWS 和其他外部 LB 实现无法指定每个节点的权重，
因此它们的平衡跨所有目标节点，并忽略每个节点上的 Pod 数量）。</p>
<!--
We can, however, state that for NumServicePods << NumNodes or NumServicePods >> NumNodes, a fairly close-to-equal
distribution will be seen, even without weights.
-->
<p>但是，我们可以声明，对于 <code>NumServicePods &lt;&lt; NumNodes</code> 或 <code>NumServicePods &gt;&gt; NumNodes</code> 时，
即使没有权重，也会看到接近相等的分布。</p>
<!--
Once the external load balancers provide weights, this functionality can be added to the LB programming path.
*Future Work: No support for weights is provided for the 1.4 release, but may be added at a future date*

Internal pod to pod traffic should behave similar to ClusterIP services, with equal probability across all pods.
-->
<p>一旦外部负载平衡器提供权重，就可以将此功能添加到 LB 编程路径中。
<em>未来工作：1.4 版本不提供权重支持，但可能会在将来版本中添加</em></p>
<p>内部 Pod 到 Pod 的流量应该与 ClusterIP 服务类似，所有 Pod 的概率相同。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-48e8f306f919c5b81265e265a2b76ab4">7 - 列出集群中所有运行容器的镜像</h1>
    
	<!--
title: List All Container Images Running in a Cluster
content_type: task
weight: 100
-->
<!-- overview -->
<!--
This page shows how to use kubectl to list all of the Container images
for Pods running in a cluster.
-->
<p>本文展示如何使用 kubectl 来列出集群中所有运行 Pod 的容器的镜像</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
In this exercise you will use kubectl to fetch all of the Pods
running in a cluster, and format the output to pull out the list
of Containers for each.
-->
<p>在本练习中，你将使用 kubectl 来获取集群中运行的所有 Pod，并格式化输出来提取每个 Pod 中的容器列表。</p>
<!--
## List all Containers in all namespaces

- Fetch all Pods in all namespaces using `kubectl get pods --all-namespaces`
- Format the output to include only the list of Container image names
  using `-o jsonpath={.items[*].spec.containers[*].image}`.  This will recursively parse out the
  `image` field from the returned json.
  - See the [jsonpath reference](/docs/user-guide/jsonpath/)
    for further information on how to use jsonpath.
- Format the output using standard tools: `tr`, `sort`, `uniq`
  - Use `tr` to replace spaces with newlines
  - Use `sort` to sort the results
  - Use `uniq` to aggregate image counts
-->
<h2 id="列出所有命名空间下的所有容器">列出所有命名空间下的所有容器</h2>
<ul>
<li>使用 <code>kubectl get pods --all-namespaces</code> 获取所有命名空间下的所有 Pod</li>
<li>使用 <code>-o jsonpath={.items[*].spec.containers[*].image}</code> 来格式化输出，以仅包含容器镜像名称。
这将以递归方式从返回的 json 中解析出 <code>image</code> 字段。
<ul>
<li>参阅 <a href="/zh/docs/reference/kubectl/jsonpath/">jsonpath 说明</a>
获取更多关于如何使用 jsonpath 的信息。</li>
</ul>
</li>
<li>使用标准化工具来格式化输出：<code>tr</code>, <code>sort</code>, <code>uniq</code>
<ul>
<li>使用 <code>tr</code> 以用换行符替换空格</li>
<li>使用 <code>sort</code> 来对结果进行排序</li>
<li>使用 <code>uniq</code> 来聚合镜像计数</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --all-namespaces -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>tr -s <span style="color:#b44">&#39;[[:space:]]&#39;</span> <span style="color:#b44">&#39;\n&#39;</span> |<span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>sort |<span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>uniq -c
</code></pre></div><!--
The above command will recursively return all fields named `image`
for all items returned.

As an alternative, it is possible to use the absolute path to the image
field within the Pod.  This ensures the correct field is retrieved
even when the field name is repeated,
e.g. many fields are called `name` within a given item:
-->
<p>上面的命令将递归获取所有返回项目的名为 <code>image</code> 的字段。</p>
<p>作为替代方案，可以使用 Pod 的镜像字段的绝对路径。这确保即使字段名称重复的情况下也能检索到正确的字段，例如，特定项目中的许多字段都称为 <code>name</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --all-namespaces -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div><!--
The jsonpath is interpreted as follows:

- `.items[*]`: for each returned value
- `.spec`: get the spec
- `.containers[*]`: for each container
- `.image`: get the image
-->
<p>jsonpath 解释如下：</p>
<ul>
<li><code>.items[*]</code>: 对于每个返回的值</li>
<li><code>.spec</code>: 获取 spec</li>
<li><code>.containers[*]</code>: 对于每个容器</li>
<li><code>.image</code>: 获取镜像</li>
</ul>
<!--
When fetching a single Pod by name, e.g. `kubectl get pod nginx`,
the `.items[*]` portion of the path should be omitted because a single
Pod is returned instead of a list of items.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 按名字获取单个 Pod 时，例如 <code>kubectl get pod nginx</code>，路径的 <code>.items[*]</code> 部分应该省略，
因为返回的是一个 Pod 而不是一个项目列表。
</div>
<!--
## List Container images by Pod

The formatting can be controlled further by using the `range` operation to
iterate over elements individually.
-->
<h2 id="按-pod-列出容器镜像">按 Pod 列出容器镜像</h2>
<p>可以使用 <code>range</code> 操作进一步控制格式化，以单独操作每个元素。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --all-namespaces -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style="color:#b62;font-weight:bold">\
</span><span style="color:#b62;font-weight:bold"></span>sort
</code></pre></div><!--
## List Containers filtering by Pod label

To target only Pods matching a specific label, use the -l flag.  The
following matches only Pods with labels matching `app=nginx`.
-->
<h2 id="列出以标签过滤后的-pod-的所有容器">列出以标签过滤后的 Pod 的所有容器</h2>
<p>要获取匹配特定标签的 Pod，请使用 -l 参数。以下匹配仅与标签 <code>app=nginx</code> 相符的 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --all-namespaces -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style="color:#b8860b">app</span><span style="color:#666">=</span>nginx
</code></pre></div><!--
## List Containers filtering by Pod namespace

To target only pods in a specific namespace, use the namespace flag. The
following matches only Pods in the `kube-system` namespace.
-->
<h2 id="列出以命名空间过滤后的-pod-的所有容器">列出以命名空间过滤后的 Pod 的所有容器</h2>
<p>要获取匹配特定命名空间的 Pod，请使用 namespace 参数。以下仅匹配 <code>kube-system</code> 命名空间下的 Pod。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --namespace kube-system -o <span style="color:#b8860b">jsonpath</span><span style="color:#666">=</span><span style="color:#b44">&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div><!--
## List Containers using a go-template instead of jsonpath

As an alternative to jsonpath, Kubectl supports using [go-templates](https://golang.org/pkg/text/template/)
for formatting the output:
-->
<h2 id="使用-go-template-代替-jsonpath-来获取容器">使用 go-template 代替 jsonpath 来获取容器</h2>
<p>作为 jsonpath 的替代，Kubectl 支持使用 <a href="https://golang.org/pkg/text/template/">go-templates</a> 来格式化输出：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods --all-namespaces -o go-template --template<span style="color:#666">=</span><span style="color:#b44">&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
### Reference

* [Jsonpath](/docs/reference/kubectl/jsonpath/) reference guide
* [Go template](https://golang.org/pkg/text/template/) reference guide
-->
<h3 id="参考">参考</h3>
<ul>
<li><a href="/zh/docs/reference/kubectl/jsonpath/">Jsonpath</a> 参考指南</li>
<li><a href="https://golang.org/pkg/text/template/">Go template</a> 参考指南</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-1839d8468a083839ed1cc8d18fe1142e">8 - 在 Minikube 环境中使用 NGINX Ingress 控制器配置 Ingress</h1>
    
	<!--
title: Set up Ingress on Minikube with the NGINX Ingress Controller
content_type: task
weight: 100
min-kubernetes-server-version: 1.19
-->
<!-- overview -->
<!--
An [Ingress](/docs/concepts/services-networking/ingress/) is an API object that defines rules which allow external access
to services in a cluster. An [Ingress controller](/docs/concepts/services-networking/ingress-controllers/) fulfills the rules set in the Ingress.

This page shows you how to set up a simple Ingress which routes requests to Service web or web2 depending on the HTTP URI.
-->
<p><a href="/zh/docs/concepts/services-networking/ingress/">Ingress</a>是一种 API 对象，其中定义了一些规则使得集群中的
服务可以从集群外访问。
<a href="/zh/docs/concepts/services-networking/ingress-controllers/">Ingress 控制器</a>
负责满足 Ingress 中所设置的规则。</p>
<p>本节为你展示如何配置一个简单的 Ingress，根据 HTTP URI 将服务请求路由到
服务 <code>web</code> 或 <code>web2</code>。</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 

Your Kubernetes server must be at or later than version 1.19.
 To check the version, enter <code>kubectl version</code>.

如果你使用的是较早的 Kubernetes 版本，请切换到该版本的文档。</p>
<!-- steps -->
<!--
### Create a Minikube cluster
-->
<h3 id="创建一个-minikube-集群">创建一个 Minikube  集群</h3>
<dl>
<dt>使用 Katacoda</dt>
<dd><script defer src="https://katacoda.com/embed.js"></script>
<button class="button" onclick="window.katacoda.init(); ">Launch Terminal</button>
</dd>
<dt>本地</dt>
<dd>如果已经在本地<a href="/zh/docs/tasks/tools/#minikube">安装Minikube</a>，
请运行 <code>minikube start</code> 创建一个集群。</dd>
</dl>
<!--
## Enable the Ingress controller

1. To enable the NGINX Ingress controller, run the following command:
-->
<h2 id="启用-ingress-控制器">启用 Ingress 控制器</h2>
<ol>
<li>
<p>为了启用 NGINIX Ingress 控制器，可以运行下面的命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube addons <span style="color:#a2f">enable</span> ingress
</code></pre></div></li>
</ol>
<!--
1. Verify that the NGINX Ingress controller is running
-->
<ol start="2">
<li>
<p>检查验证 NGINX Ingress 控制器处于运行状态：</p>
<ul class="nav nav-tabs" id="tab-with-md" role="tablist"><li class="nav-item"><a data-toggle="tab" class="nav-link active" href="#tab-with-md-0" role="tab" aria-controls="tab-with-md-0" aria-selected="true">minikube v1.19 或更高版本</a></li>
	  
		<li class="nav-item"><a data-toggle="tab" class="nav-link" href="#tab-with-md-1" role="tab" aria-controls="tab-with-md-1">minikube v1.18.1 或更早版本</a></li></ul>
<div class="tab-content" id="tab-with-md"><div id="tab-with-md-0" class="tab-pane show active" role="tabpanel" aria-labelledby="tab-with-md-0">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -n ingress-nginx
</code></pre></div>   <!-- It can take up to a minute before you see these pods running OK. -->
   <div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 最多可能需要等待一分钟才能看到这些 Pod 运行正常。
</div>
   <!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>NAME                                        READY   STATUS      RESTARTS    AGE
ingress-nginx-admission-create-g9g49        0/1     Completed   0          11m
ingress-nginx-admission-patch-rqp78         0/1     Completed   1          11m
ingress-nginx-controller-59b45fb494-26npt   1/1     Running     0          11m
</code></pre></div>
  <div id="tab-with-md-1" class="tab-pane" role="tabpanel" aria-labelledby="tab-with-md-1">

<p><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -n kube-system
</code></pre></div>   <!-- It can take up to a minute before you see these pods running OK. -->
   <div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 最多可能需要等待一分钟才能看到这些 Pod 运行正常。
</div>
   <!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   0          1m
kube-addon-manager-minikube                 1/1       Running   0          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   0          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   0          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   0          1m
storage-provisioner                         1/1       Running   0          2m
</code></pre>   <!--
   Make sure that you see a Pod with a name that starts with `nginx-ingress-controller-`.
   -->
<p>请确保可以在输出中看到一个名称以 <code>nginx-ingress-controller-</code> 为前缀的 Pod。</p>
</div></div>

</li>
</ol>
<!--
## Deploy a hello, world app

1. Create a Deployment using the following command:
-->
<h2 id="部署一个-hello-world-应用">部署一个 Hello World 应用</h2>
<ol>
<li>
<p>使用下面的命令创建一个 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment web --image<span style="color:#666">=</span>gcr.io/google-samples/hello-app:1.0
</code></pre></div><!--The output should be:-->
<p>输出：</p>
<pre><code>deployment.apps/web created
</code></pre></li>
</ol>
<!--
1. Expose the Deployment:
-->
<ol start="2">
<li>
<p>将 Deployment 暴露出来：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose deployment web --type<span style="color:#666">=</span>NodePort --port<span style="color:#666">=</span><span style="color:#666">8080</span>
</code></pre></div><!--The output should be:-->
<p>输出：</p>
<pre><code>service/web exposed
</code></pre></li>
</ol>
<!--
1. Verify the Service is created and is available on a node port:
-->
<ol start="3">
<li>
<p>验证 Service 已经创建，并且可能从节点端口访问：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get service web
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT<span style="color:#666">(</span>S<span style="color:#666">)</span>          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></div></li>
</ol>
<!--
1. Visit the service via NodePort:
-->
<ol start="4">
<li>
<p>使用节点端口信息访问服务：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">minikube service web --url
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">http://172.17.0.15:31637
</code></pre></div><!--
Katacoda environment only: at the top of the terminal panel, click the plus sign, and then click **Select port to view on Host 1**. Enter the NodePort, in this case `31637`, and then click **Display Port**.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 如果使用的是 Katacoda 环境，在终端面板顶端，请点击加号标志。
然后点击 <strong>Select port to view on Host 1</strong>。
输入节点和端口号（这里是<code>31637</code>），之后点击 <strong>Display Port</strong>。
</div>
<!-- The output is similar to: -->
<p>输出类似于：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div><!--
You can now access the sample app via the Minikube IP address and NodePort. The next step lets you access
the app using the Ingress resource.
-->
<p>你现在应该可以通过 Minikube 的 IP 地址和节点端口来访问示例应用了。
下一步是让自己能够通过 Ingress 资源来访问应用。</p>
</li>
</ol>
<!--
## Create an Ingress

The following manifest defines an Ingress that sends traffic to your Service via hello-world.info.

1. Create `example-ingress.yaml` from the following file:
-->
<h2 id="创建一个-ingress">创建一个 Ingress</h2>
<p>下面是一个定义 Ingress 的配置文件，负责通过 <code>hello-world.info</code> 将请求
转发到你的服务。</p>
<ol>
<li>
<p>根据下面的 YAML 创建文件 <code>example-ingress.yaml</code>：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/service/networking/example-ingress.yaml" download="service/networking/example-ingress.yaml"><code>service/networking/example-ingress.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('service-networking-example-ingress-yaml')" title="Copy service/networking/example-ingress.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="service-networking-example-ingress-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>networking.k8s.io/v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Ingress<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>example-ingress<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">annotations</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">nginx.ingress.kubernetes.io/rewrite-target</span>:<span style="color:#bbb"> </span>/$1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">rules</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">host</span>:<span style="color:#bbb"> </span>hello-world.info<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">http</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#008000;font-weight:bold">paths</span>:<span style="color:#bbb">
</span><span style="color:#bbb">          </span>- <span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">pathType</span>:<span style="color:#bbb"> </span>Prefix<span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#008000;font-weight:bold">backend</span>:<span style="color:#bbb">
</span><span style="color:#bbb">              </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>web<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                  </span><span style="color:#008000;font-weight:bold">number</span>:<span style="color:#bbb"> </span><span style="color:#666">8080</span></code></pre></div>
    </div>
</div>


</li>
</ol>
<!--
1. Create the Ingress object by running the following command:
-->
<ol start="2">
<li>
<p>通过运行下面的命令创建 Ingress 对象：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/service/networking/example-ingress.yaml
</code></pre></div><!-- The output should be: -->
<p>输出：</p>
<pre><code>ingress.networking.k8s.io/example-ingress created
</code></pre></li>
</ol>
<!--
1. Verify the IP address is set:
-->
<ol start="3">
<li>
<p>验证 IP 地址已被设置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get ingress
</code></pre></div><!-- This can take a couple of minutes. -->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 此操作可能需要几分钟时间。
</div>
<!-- You should see an IPv4 address in the ADDRESS column; for example: -->
<p>接下来你将会在ADDRESS列中看到IPv4地址，例如：</p>
<pre><code>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    80      38s
</code></pre></li>
</ol>
<!--
1. Add the following line to the bottom of the `/etc/hosts` file on
   your computer (you will need administrator access):
-->
<ol start="4">
<li>
<p>在 <code>/etc/hosts</code> 文件的末尾添加以下内容（需要管理员访问权限）：</p>
<!--
If you are running Minikube locally, use `minikube ip` to get the external IP. The IP address displayed within the ingress list will be the internal IP.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 如果你在本地运行 Minikube 环境，需要使用 <code>minikube ip</code> 获得外部 IP 地址。
Ingress 列表中显示的 IP 地址会是内部 IP 地址。
</div>
<pre><code>172.17.0.15 hello-world.info
</code></pre><!--     
After you make this change, your web browser sends requests for
hello-world.info URLs to Minikube.
-->
<p>添加完成后，在浏览器中访问URL <code>hello-world.info</code>，请求将被发送到 Minikube。</p>
</li>
</ol>
<!--
1. Verify that the Ingress controller is directing traffic:
-->
<ol start="5">
<li>
<p>验证 Ingress 控制器能够转发请求流量：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl hello-world.info
</code></pre></div><!-- You should see: -->
<p>你应该看到类似输出：</p>
<pre><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre><!--
If you are running Minikube locally, you can visit hello-world.info from your browser.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 如果你在使用本地 Minikube 环境，你可以从浏览器中访问 hello-world.info。
</div>
</li>
</ol>
<!--
## Create a second Deployment

1. Create another Deployment using the following command:
-->
<h2 id="创建第二个-deployment">创建第二个 Deployment</h2>
<ol>
<li>
<p>使用下面的命令创建第二个 Deployment：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create deployment web2 --image<span style="color:#666">=</span>gcr.io/google-samples/hello-app:2.0
</code></pre></div><!-- The output should be: -->
<p>输出：</p>
<pre><code>deployment.apps/web2 created
</code></pre></li>
</ol>
<!--
1. Expose the second Deployment:
-->
<ol start="2">
<li>
<p>将第二个 Deployment 暴露出来：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose deployment web2 --port<span style="color:#666">=</span><span style="color:#666">8080</span> --type<span style="color:#666">=</span>NodePort
</code></pre></div><!-- The output should be:  -->
<p>输出：</p>
<pre><code>service/web2 exposed
</code></pre></li>
</ol>
<!--
## Edit the existing Ingress {#edit-ingress}

1. Edit the existing `example-ingress.yaml` manifest, and add the
   following lines at the end:
-->
<h2 id="edit-ingress">编辑现有的 Ingress</h2>
<ol>
<li>
<p>编辑现有的 <code>example-ingress.yaml</code>，在文件最后添加以下行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#bbb">           </span>- <span style="color:#008000;font-weight:bold">path</span>:<span style="color:#bbb"> </span>/v2<span style="color:#bbb">
</span><span style="color:#bbb">             </span><span style="color:#008000;font-weight:bold">pathType</span>:<span style="color:#bbb"> </span>Prefix<span style="color:#bbb">
</span><span style="color:#bbb">             </span><span style="color:#008000;font-weight:bold">backend</span>:<span style="color:#bbb">
</span><span style="color:#bbb">               </span><span style="color:#008000;font-weight:bold">service</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                 </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>web2<span style="color:#bbb">
</span><span style="color:#bbb">                 </span><span style="color:#008000;font-weight:bold">port</span>:<span style="color:#bbb">
</span><span style="color:#bbb">                   </span><span style="color:#008000;font-weight:bold">number</span>:<span style="color:#bbb"> </span><span style="color:#666">8080</span><span style="color:#bbb">
</span></code></pre></div></li>
</ol>
<!--
1. Apply the changes:
-->
<ol start="2">
<li>
<p>应用变更：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f example-ingress.yaml
</code></pre></div><!-- You should see: -->
<p>输出：</p>
<pre><code>ingress.networking/example-ingress configured
</code></pre></li>
</ol>
<!--
## Test Your Ingress

1. Access the 1st version of the Hello World app.
-->
<h2 id="测试你的-ingress">测试你的 Ingress</h2>
<ol>
<li>
<p>访问 HelloWorld 应用的第一个版本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl hello-world.info
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></li>
</ol>
<!--
1. Access the 2nd version of the Hello World app.
-->
<ol start="2">
<li>
<p>访问 HelloWorld 应用的第二个版本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl hello-world.info/v2
</code></pre></div><!-- The output is similar to: -->
<p>输出类似于：</p>
<pre><code>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre><!--
If you are running Minikube locally, you can visit hello-world.info and hello-world.info/v2 from your browser.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 如果你在本地运行 Minikube 环境，你可以使用浏览器来访问
hello-world.info 和 hello-world.info/v2。
</div>
</li>
</ol>
<h2 id="what-s-next">What's next</h2>
<!--
* Read more about [Ingress](/docs/concepts/services-networking/ingress/)
* Read more about [Ingress Controllers](/docs/concepts/services-networking/ingress-controllers/)
* Read more about [Services](/docs/concepts/services-networking/service/)
-->
<ul>
<li>进一步了解 <a href="/zh/docs/concepts/services-networking/ingress/">Ingress</a>。</li>
<li>进一步了解 <a href="/zh/docs/concepts/services-networking/ingress-controllers/">Ingress 控制器</a></li>
<li>进一步了解 <a href="/zh/docs/concepts/services-networking/service/">服务</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-322786b38586b210fab68f785259c5f6">9 - 为集群配置 DNS</h1>
    
	<!--
---
title: Configure DNS for a Cluster
weight: 120
content_type: concept
---
-->
<!-- overview -->
<!--
Kubernetes offers a DNS cluster addon, which most of the supported environments enable by default. In Kubernetes version 1.11 and later, CoreDNS is recommended and is installed by default with kubeadm.
-->
<p>Kubernetes 提供 DNS 集群插件，大多数支持的环境默认情况下都会启用。
在 Kubernetes 1.11 及其以后版本中，推荐使用 CoreDNS，
kubeadm 默认会安装 CoreDNS。</p>
<!-- body -->
<!--
For more information on how to configure CoreDNS for a Kubernetes cluster, see the [Customizing DNS Service](/docs/tasks/administer-cluster/dns-custom-nameservers/). An example demonstrating how to use Kubernetes DNS with kube-dns, see the [Kubernetes DNS sample plugin](https://github.com/kubernetes/examples/tree/master/staging/cluster-dns)
-->
<p>要了解关于如何为 Kubernetes 集群配置 CoreDNS 的更多信息，参阅
<a href="/zh/docs/tasks/administer-cluster/dns-custom-nameservers/">定制 DNS 服务</a>。
关于如何利用 kube-dns 配置 kubernetes DNS 的演示例子，参阅
<a href="https://github.com/kubernetes/examples/tree/master/staging/cluster-dns">Kubernetes DNS 插件示例</a>。</p>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-7c319a9981586e5fbcfa21b392720650">10 - 同 Pod 内的容器使用共享卷通信</h1>
    
	<!--
title: Communicate Between Containers in the Same Pod Using a Shared Volume
content_type: task
weight: 110
-->
<!-- overview -->
<!--
This page shows how to use a Volume to communicate between two Containers running
in the same Pod. See also how to allow processes to communicate by
[sharing process namespace](/docs/tasks/configure-pod-container/share-process-namespace/)
between containers.
-->
<p>本文旨在说明如何让一个 Pod 内的两个容器使用一个卷（Volume）进行通信。
参阅如何让两个进程跨容器通过
<a href="/zh/docs/tasks/configure-pod-container/share-process-namespace/">共享进程名字空间</a>。</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
##  Creating a Pod that runs two Containers

In this exercise, you create a Pod that runs two Containers. The two containers
share a Volume that they can use to communicate. Here is the configuration file
for the Pod:
-->
<h2 id="创建一个包含两个容器的-pod">创建一个包含两个容器的 Pod</h2>
<p>在这个练习中，你会创建一个包含两个容器的 Pod。两个容器共享一个卷用于他们之间的通信。
Pod 的配置文件如下：</p>


 













<div class="highlight">
    <div class="copy-code-icon" style="text-align:right">
    <a href="https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/two-container-pod.yaml" download="pods/two-container-pod.yaml"><code>pods/two-container-pod.yaml</code>
    </a>
    <img src="/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('pods-two-container-pod-yaml')" title="Copy pods/two-container-pod.yaml to clipboard">
    </img>
    </div>
    <div class="includecode" id="pods-two-container-pod-yaml">
    <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>two-containers<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">restartPolicy</span>:<span style="color:#bbb"> </span>Never<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">volumes</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>shared-data<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">emptyDir</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containers</span>:<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">volumeMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>shared-data<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">mountPath</span>:<span style="color:#bbb"> </span>/usr/share/nginx/html<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>debian-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>debian<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">volumeMounts</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>shared-data<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">mountPath</span>:<span style="color:#bbb"> </span>/pod-data<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">command</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;/bin/sh&#34;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">args</span>:<span style="color:#bbb"> </span>[<span style="color:#b44">&#34;-c&#34;</span>,<span style="color:#bbb"> </span><span style="color:#b44">&#34;echo Hello from the debian container &gt; /pod-data/index.html&#34;</span>]<span style="color:#bbb">
</span></code></pre></div>
    </div>
</div>


<!--
In the configuration file, you can see that the Pod has a Volume named
`shared-data`.

The first container listed in the configuration file runs an nginx server. The
mount path for the shared Volume is `/usr/share/nginx/html`.
The second container is based on the debian image, and has a mount path of
`/pod-data`. The second container runs the following command and then terminates.
-->
<p>在配置文件中，你可以看到 Pod 有一个共享卷，名为 <code>shared-data</code>。</p>
<p>配置文件中的第一个容器运行了一个 nginx 服务器。共享卷的挂载路径是 <code>/usr/share/nginx/html</code>。
第二个容器是基于 debian 镜像的，有一个 <code>/pod-data</code> 的挂载路径。第二个容器运行了下面的命令然后终止。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">echo</span> Hello from the debian container &gt; /pod-data/index.html
</code></pre></div><!--
Notice that the second container writes the `index.html` file in the root
directory of the nginx server.

Create the Pod and the two Containers:
-->
<p>注意，第二个容器在 nginx 服务器的根目录下写了 <code>index.html</code> 文件。</p>
<p>创建一个包含两个容器的 Pod：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre></div><!--
View information about the Pod and the Containers:
-->
<p>查看 Pod 和容器的信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pod two-containers --output<span style="color:#666">=</span>yaml
</code></pre></div><!--
Here is a portion of the output:
-->
<p>这是输出的一部分：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Pod<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">metadata</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>two-containers<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">spec</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>...<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">containerStatuses</span>:<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">containerID</span>:<span style="color:#bbb"> </span>docker://c1d8abd1 ...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>debian<span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">lastState</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">terminated</span>:<span style="color:#bbb">
</span><span style="color:#bbb">        </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>debian-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>- <span style="color:#008000;font-weight:bold">containerID</span>:<span style="color:#bbb"> </span>docker://96c1ff2c5bb ...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">image</span>:<span style="color:#bbb"> </span>nginx<span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>nginx-container<span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">state</span>:<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#008000;font-weight:bold">running</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>...<span style="color:#bbb">
</span></code></pre></div><!--
You can see that the debian Container has terminated, and the nginx Container
is still running.

Get a shell to nginx Container:
-->
<p>你可以看到 debian 容器已经被终止了，而 nginx 服务器依然在运行。</p>
<p>进入 nginx 容器的 shell：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl <span style="color:#a2f">exec</span> -it two-containers -c nginx-container -- /bin/bash
</code></pre></div><!--
In your shell, verify that nginx is running:
-->
<p>在 shell 中，确认 nginx 还在运行。</p>
<pre><code>root@two-containers:/# ps aux
</code></pre><!--
The output is similar to this:
-->
<p>输出类似于这样：</p>
<pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre><!--
Recall that the debian Container created the `index.html` file in the nginx root
directory. Use `curl` to send a GET request to the nginx server:
-->
<p>回忆一下，debian 容器在 nginx 的根目录下创建了 <code>index.html</code> 文件。
使用 <code>curl</code> 向 nginx 服务器发送一个 GET 请求：</p>
<pre><code>root@two-containers:/# curl localhost
</code></pre><p>输出表示 nginx 提供了 debian 容器写的页面：</p>
<pre><code>Hello from the debian container
</code></pre><!-- discussion -->
<!--
## Discussion

The primary reason that Pods can have multiple containers is to support
helper applications that assist a primary application. Typical examples of
helper applications are data pullers, data pushers, and proxies.
Helper and primary applications often need to communicate with each other.
Typically this is done through a shared filesystem, as shown in this exercise,
or through the loopback network interface, localhost. An example of this pattern is a
web server along with a helper program that polls a Git repository for new updates.
-->
<h2 id="讨论">讨论</h2>
<p>Pod 能有多个容器的主要原因是为了支持辅助应用（helper applications），以协助主应用（primary application）。
辅助应用的典型例子是数据抽取，数据推送和代理。辅助应用和主应用经常需要相互通信。
就如这个练习所示，通信通常是通过共享文件系统完成的，或者，也通过回环网络接口 localhost 完成。
举个网络接口的例子，web 服务器带有一个协助程序用于拉取 Git 仓库的更新。</p>
<!--
The Volume in this exercise provides a way for Containers to communicate during
the life of the Pod. If the Pod is deleted and recreated, any data stored in
the shared Volume is lost.
-->
<p>在本练习中的卷为 Pod 生命周期中的容器相互通信提供了一种方法。如果 Pod 被删除或者重建了，
任何共享卷中的数据都会丢失。</p>
<h2 id="what-s-next">What's next</h2>
<!--
* Learn more about [patterns for composite containers](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns).
* Learn about [composite containers for modular architecture](https://www.slideshare.net/Docker/slideshare-burns).
* See [Configuring a Pod to Use a Volume for Storage](/docs/tasks/configure-pod-container/configure-volume-storage/).
* See [Configure a Pod to share process namespace between containers in a Pod](/docs/tasks/configure-pod-container/share-process-namespace/)
* See [Volume](/docs/reference/generated/kubernetes-api/v1.23/#volume-v1-core).
* See [Pod](/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core).
-->
<ul>
<li>进一步了解<a href="https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns.html">复合容器的模式</a></li>
<li>学习<a href="https://www.slideshare.net/Docker/slideshare-burns">模块化架构中的复合容器</a></li>
<li>参见<a href="/zh/docs/tasks/configure-pod-container/configure-volume-storage/">配置 Pod 使用卷来存储数据</a></li>
<li>参考<a href="/zh/docs/tasks/configure-pod-container/share-process-namespace/">在 Pod 中的容器之间共享进程命名空间</a></li>
<li>参考 <a href="/docs/reference/generated/kubernetes-api/v1.23/#volume-v1-core">Volume</a></li>
<li>参考 <a href="/docs/reference/generated/kubernetes-api/v1.23/#pod-v1-core">Pod</a></li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-43591bb11cc02c39e278cf07f6546810">11 - 访问集群上运行的服务</h1>
    
	<!-- overview -->
<!--
This page shows how to connect to services running on the Kubernetes cluster.
-->
<p>本文展示了如何连接 Kubernetes 集群上运行的服务。</p>
<h2 id="before-you-begin">Before you begin</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>
 
 To check the version, enter <code>kubectl version</code>.
</p>
<!-- steps -->
<!--
## Accessing services running on the cluster

In Kubernetes, [nodes](/docs/concepts/architecture/nodes/),
[pods](/docs/concepts/workloads/pods/) and [services](/docs/concepts/services-networking/service/) all have
their own IPs.  In many cases, the node IPs, pod IPs, and some service IPs on a cluster will not be
routable, so they will not be reachable from a machine outside the cluster,
such as your desktop machine.
-->
<h2 id="访问集群上运行的服务">访问集群上运行的服务</h2>
<p>在 Kubernetes 里，<a href="/zh/docs/concepts/architecture/nodes/">节点</a>、
<a href="/zh/docs/concepts/workloads/pods/">Pod</a> 和
<a href="/zh/docs/concepts/services-networking/service/">服务</a> 都有自己的 IP。
许多情况下，集群上的节点 IP、Pod IP 和某些服务 IP 是路由不可达的，
所以不能从集群之外访问它们，例如从你自己的台式机。</p>
<!--
### Ways to connect

You have several options for connecting to nodes, pods and services from outside the cluster:
-->
<h3 id="ways-to-connect">连接方式  </h3>
<p>你有多种可选方式从集群外连接节点、Pod 和服务：</p>
<!--
  - Access services through public IPs.
    - Use a service with type `NodePort` or `LoadBalancer` to make the service reachable outside
      the cluster.  See the [services](/docs/concepts/services-networking/service/) and
      [kubectl expose](/docs/reference/generated/kubectl/kubectl-commands/#expose) documentation.
    - Depending on your cluster environment, this may only expose the service to your corporate network,
      or it may expose it to the internet.  Think about whether the service being exposed is secure.
      Does it do its own authentication?
    - Place pods behind services.  To access one specific pod from a set of replicas, such as for debugging,
      place a unique label on the pod and create a new service which selects this label.
    - In most cases, it should not be necessary for application developer to directly access
      nodes via their nodeIPs.
-->
<ul>
<li>通过公网 IP 访问服务
<ul>
<li>使用类型为 <code>NodePort</code> 或 <code>LoadBalancer</code> 的服务，可以从外部访问它们。
请查阅<a href="/zh/docs/concepts/services-networking/service/">服务</a> 和
<a href="/docs/reference/generated/kubectl/kubectl-commands/#expose">kubectl expose</a> 文档。</li>
<li>取决于你的集群环境，你可以仅把服务暴露在你的企业网络环境中，也可以将其暴露在
因特网上。需要考虑暴露的服务是否安全，它是否有自己的用户认证？</li>
<li>将 Pod 放置于服务背后。如果要访问一个副本集合中特定的 Pod，例如用于调试目的，
请给 Pod 指定一个独特的标签并创建一个新服务选择该标签。</li>
<li>大部分情况下，都不需要应用开发者通过节点 IP 直接访问节点。</li>
</ul>
</li>
</ul>
<!--
  - Access services, nodes, or pods using the Proxy Verb.
    - Does apiserver authentication and authorization prior to accessing the remote service.
      Use this if the services are not secure enough to expose to the internet, or to gain
      access to ports on the node IP, or for debugging.
    - Proxies may cause problems for some web applications.
    - Only works for HTTP/HTTPS.
    - Described [here](#manually-constructing-apiserver-proxy-urls).
-->
<ul>
<li>通过 Proxy 动词访问服务、节点或者 Pod
<ul>
<li>在访问远程服务之前，利用 API 服务器执行身份认证和鉴权。
如果你的服务不够安全，无法暴露到因特网中，或者需要访问节点 IP 上的端口，
又或者出于调试目的，可使用这种方式。</li>
<li>代理可能给某些应用带来麻烦</li>
<li>此方式仅适用于 HTTP/HTTPS</li>
<li>进一步的描述在<a href="#manually-constructing-apiserver-proxy-urls">这里</a></li>
<li>从集群中的 node 或者 pod 访问。</li>
</ul>
</li>
</ul>
<!--
  - Access from a node or pod in the cluster.
    - Run a pod, and then connect to a shell in it using [kubectl exec](/docs/reference/generated/kubectl/kubectl-commands/#exec).
      Connect to other nodes, pods, and services from that shell.
    - Some clusters may allow you to ssh to a node in the cluster. From there you may be able to
      access cluster services. This is a non-standard method, and will work on some clusters but
      not others. Browsers and other tools may or may not be installed. Cluster DNS may not work.
-->
<ul>
<li>从集群中的一个节点或 Pod 访问
<ul>
<li>运行一个 Pod，然后使用
<a href="/docs/reference/generated/kubectl/kubectl-commands/#exec">kubectl exec</a>
连接到它的 Shell。从那个 Shell 连接其他的节点、Pod 和 服务</li>
<li>某些集群可能允许你 SSH 到集群中的节点。你可能可以从那儿访问集群服务。
这是一个非标准的方式，可能在一些集群上能工作，但在另一些上却不能。
浏览器和其他工具可能已经安装也可能没有安装。集群 DNS 可能不会正常工作。</li>
</ul>
</li>
</ul>
<!--
### Discovering builtin services

Typically, there are several services which are started on a cluster by kube-system. Get a list of these
with the `kubectl cluster-info` command:
-->
<h3 id="discovering-builtin-services">发现内置服务  </h3>
<p>典型情况下，kube-system 名字空间中会启动集群的几个服务。
使用 <code>kubectl cluster-info</code> 命令获取这些服务的列表：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl cluster-info
</code></pre></div><!--
The output is similar to this:
-->
<p>输出类似于：</p>
<pre><code>Kubernetes master is running at https://104.197.5.247
elasticsearch-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre><!--
This shows the proxy-verb URL for accessing each service.
For example, this cluster has cluster-level logging enabled (using Elasticsearch), which can be reached
at `https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/` if suitable credentials are passed, or through a kubectl proxy at, for example:
`http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/`.
-->
<p>这一输出显示了用 proxy 动词访问每个服务时可用的 URL。例如，此集群
（使用 Elasticsearch）启用了集群层面的日志。如果提供合适的凭据，可以通过
<code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>
访问，或通过一个 <code>kubectl proxy</code> 来访问：
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>。</p>
<!--
See [Access Clusters Using the Kubernetes API](/docs/tasks/administer-cluster/access-cluster-api/#accessing-the-cluster-api) for how to pass credentials or use kubectl proxy.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 请参阅<a href="/zh/docs/tasks/administer-cluster/access-cluster-api/#accessing-the-cluster-api">使用 Kubernets API 访问集群</a>
了解如何传递凭据或如何使用 <code>kubectl proxy</code>。
</div>
<!--
#### Manually constructing apiserver proxy URLs

As mentioned above, you use the `kubectl cluster-info` command to retrieve the service's proxy URL. To create proxy URLs that include service endpoints, suffixes, and parameters, you append to the service's proxy URL:
`http://`*`kubernetes_master_address`*`/api/v1/namespaces/`*`namespace_name`*`/services/`*`[https:]service_name[:port_name]`*`/proxy`

If you haven't specified a name for your port, you don't have to specify *port_name* in the URL. You can also use the port number in place of the *port_name* for both named and unnamed ports.

By default, the API server proxies to your service using HTTP. To use HTTPS, prefix the service name with `https:`:
`http://<kubernetes_master_address>/api/v1/namespaces/<namespace_name>/services/<service_name>/proxy`

The supported formats for the `<service_name>` segment of the URL are:

* `<service_name>` - proxies to the default or unnamed port using http
* `<service_name>:<port_name>` - proxies to the specified port name or port number using http
* `https:<service_name>:` - proxies to the default or unnamed port using https (note the trailing colon)
* `https:<service_name>:<port_name>` - proxies to the specified port name or port number using https
-->
<h4 id="manually-constructing-apiserver-proxy-urls">手动构建 API 服务器代理 URLs  </h4>
<p>如前所述，你可以使用 <code>kubectl cluster-info</code> 命令取得服务的代理 URL。
为了创建包含服务末端、后缀和参数的代理 URLs，你可以在服务的代理 URL 中添加：
<code>http://</code><em><code>kubernetes_master_address</code></em><code>/api/v1/namespaces/</code><em><code>namespace_name</code></em><code>/services/</code><em><code>service_name[:port_name]</code></em><code>/proxy</code></p>
<p>如果还没有为你的端口指定名称，你可以不用在 URL 中指定 <em>port_name</em>。
对于命名和未命名端口，你还可以使用端口号代替 <em>port_name</em>。</p>
<p>默认情况下，API 服务器使用 HTTP 为你的服务提供代理。 要使用 HTTPS，请在服务名称前加上 <code>https:</code>：
<code>http://&lt;kubernetes_master_address&gt;/api/v1/namespaces/&lt;namespace_name&gt;/services/&lt;service_name&gt;/proxy</code>
URL 的 <code>&lt;service_name&gt;</code> 段支持的格式为：</p>
<ul>
<li><code>&lt;service_name&gt;</code> - 使用 http 代理到默认或未命名端口</li>
<li><code>&lt;service_name&gt;:&lt;port_name&gt;</code> - 使用 http 代理到指定的端口名称或端口号</li>
<li><code>https:&lt;service_name&gt;:</code> -  使用 https 代理到默认或未命名端口（注意尾随冒号）</li>
<li><code>https:&lt;service_name&gt;:&lt;port_name&gt;</code> - 使用 https 代理到指定的端口名称或端口号</li>
</ul>
<!--
##### Examples

* To access the Elasticsearch service endpoint `_search?q=user:kimchy`, you would use:
-->
<h5 id="示例">示例</h5>
<ul>
<li>
<p>如要访问 Elasticsearch 服务末端 <code>_search?q=user:kimchy</code>，你可以使用：</p>
<pre><code>http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy
</code></pre></li>
</ul>
<!--
* To access the Elasticsearch cluster health information `_cluster/health?pretty=true`, you would use:
-->
<ul>
<li>
<p>如要访问 Elasticsearch 集群健康信息<code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true`
</code></pre><!--
The health information is similar to this:
-->
<p>健康信息与下面的例子类似：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#008000;font-weight:bold">&#34;cluster_name&#34;</span> : <span style="color:#b44">&#34;kubernetes_logging&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;status&#34;</span> : <span style="color:#b44">&#34;yellow&#34;</span>,
  <span style="color:#008000;font-weight:bold">&#34;timed_out&#34;</span> : <span style="color:#a2f;font-weight:bold">false</span>,
  <span style="color:#008000;font-weight:bold">&#34;number_of_nodes&#34;</span> : <span style="color:#666">1</span>,
  <span style="color:#008000;font-weight:bold">&#34;number_of_data_nodes&#34;</span> : <span style="color:#666">1</span>,
  <span style="color:#008000;font-weight:bold">&#34;active_primary_shards&#34;</span> : <span style="color:#666">5</span>,
  <span style="color:#008000;font-weight:bold">&#34;active_shards&#34;</span> : <span style="color:#666">5</span>,
  <span style="color:#008000;font-weight:bold">&#34;relocating_shards&#34;</span> : <span style="color:#666">0</span>,
  <span style="color:#008000;font-weight:bold">&#34;initializing_shards&#34;</span> : <span style="color:#666">0</span>,
  <span style="color:#008000;font-weight:bold">&#34;unassigned_shards&#34;</span> : <span style="color:#666">5</span>
}
</code></pre></div></li>
</ul>
<!--
* To access the *https* Elasticsearch service health information `_cluster/health?pretty=true`, you would use:
-->
<ul>
<li>
<p>要访问 <em>https</em> Elasticsearch 服务健康信息 <code>_cluster/health?pretty=true</code>，你会使用：</p>
<pre><code>https://104.197.5.247/api/v1/namespaces/kube-system/services/https:elasticsearch-logging/proxy/_cluster/health?pretty=true
</code></pre></li>
</ul>
<!--
#### Using web browsers to access services running on the cluster

You may be able to put an apiserver proxy URL into the address bar of a browser. However:
-->
<h4 id="通过-web-浏览器访问集群中运行的服务">通过 Web 浏览器访问集群中运行的服务</h4>
<p>你或许能够将 API 服务器代理的 URL 放入浏览器的地址栏，然而：</p>
<!--
- Web browsers cannot usually pass tokens, so you may need to use basic (password) auth. Apiserver can be configured to accept basic auth,
    but your cluster may not be configured to accept basic auth.
- Some web apps may not work, particularly those with client side javascript that construct URLs in a
    way that is unaware of the proxy path prefix.
-->
<ul>
<li>Web 服务器通常不能传递令牌，所以你可能需要使用基本（密码）认证。
API 服务器可以配置为接受基本认证，但你的集群可能并没有这样配置。</li>
<li>某些 Web 应用可能无法工作，特别是那些使用客户端 Javascript 构造 URL 的
应用，所构造的 URL 可能并不支持代理路径前缀。</li>
</ul>

</div>



    
	
  
    
    
	
    

<div class="td-content" style="page-break-before: always">
    
	<h1 id="pg-5a233e14205d77fe1294917d2da6f876">12 - 配置对多集群的访问</h1>
    
	<!--
title: Configure Access to Multiple Clusters
content_type: task
weight: 30
card:
  name: tasks
  weight: 40
-->
<!-- overview -->
<!--
This page shows how to configure access to multiple clusters by using
configuration files. After your clusters, users, and contexts are defined in
one or more configuration files, you can quickly switch between clusters by using the
`kubectl config use-context` command.
-->
<p>本文展示如何使用配置文件来配置对多个集群的访问。 在将集群、用户和上下文定义在一个或多个配置文件中之后，用户可以使用 <code>kubectl config use-context</code> 命令快速地在集群之间进行切换。</p>
<!--
A file that is used to configure access to a cluster is sometimes called
a *kubeconfig file*. This is a generic way of referring to configuration files.
It does not mean that there is a file named `kubeconfig`.
-->
<div class="alert alert-info note callout" role="alert">
  <strong>Note:</strong> 用于配置集群访问的文件有时被称为 <em>kubeconfig 文件</em>。
这是一种引用配置文件的通用方式，并不意味着存在一个名为 <code>kubeconfig</code> 的文件。
</div>
<!--
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> Only use kubeconfig files from trusted sources. Using a specially-crafted kubeconfig file could result in malicious code execution or file exposure.
If you must use an untrusted kubeconfig file, inspect it carefully first, much as you would a shell script.
</div>


-->
<div class="alert alert-danger warning callout" role="alert">
  <strong>Warning:</strong> 只使用来源可靠的 kubeconfig 文件。使用特制的 kubeconfig 文件可能会导致恶意代码执行或文件暴露。
如果必须使用不受信任的 kubeconfig 文件，请首先像检查 shell 脚本一样仔细检查它。
</div>


<h2 id="before-you-begin">Before you begin</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href="https://minikube.sigs.k8s.io/docs/tutorials/multi_node/">Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<!--
You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. It is recommended to run this tutorial on a cluster with at least two nodes that are not acting as control plane hosts. If you do not already have a
cluster, you can create one by using
[minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/)
or you can use one of these Kubernetes playgrounds:
-->
<ul>
<li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
<li><a href="http://labs.play-with-k8s.com/">玩转 Kubernetes</a></li>
</ul>

<!--
To check that <a class='glossary-tooltip' title='kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。' data-toggle='tooltip' data-placement='top' href='/docs/user-guide/kubectl-overview/' target='_blank' aria-label='kubectl'>kubectl</a> is installed,
run `kubectl version --client`. The kubectl version should be
[within one minor version](/releases/version-skew-policy/#kubectl) of your
cluster's API server.
-->
<p>要检查 <a class='glossary-tooltip' title='kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。' data-toggle='tooltip' data-placement='top' href='/docs/user-guide/kubectl-overview/' target='_blank' aria-label='kubectl'>kubectl</a> 是否安装，
执行 <code>kubectl version --client</code> 命令。
kubectl 的版本应该与集群的 API 服务器
<a href="/zh/releases/version-skew-policy/#kubectl">使用同一次版本号</a>。</p>
<!-- steps -->
<!--
## Define clusters, users, and contexts

Suppose you have two clusters, one for development work and one for scratch work.
In the `development` cluster, your frontend developers work in a namespace called `frontend`,
and your storage developers work in a namespace called `storage`. In your `scratch` cluster,
developers work in the default namespace, or they create auxiliary namespaces as they
see fit. Access to the development cluster requires authentication by certificate. Access
to the scratch cluster requires authentication by username and password.

Create a directory named `config-exercise`. In your
`config-exercise` directory, create a file named `config-demo` with this content:
-->
<h2 id="定义集群-用户和上下文">定义集群、用户和上下文</h2>
<p>假设用户有两个集群，一个用于正式开发工作，一个用于其它临时用途（scratch）。
在 <code>development</code> 集群中，前端开发者在名为 <code>frontend</code> 的名字空间下工作，
存储开发者在名为 <code>storage</code> 的名字空间下工作。 在 <code>scratch</code> 集群中，
开发人员可能在默认名字空间下工作，也可能视情况创建附加的名字空间。
访问开发集群需要通过证书进行认证。
访问其它临时用途的集群需要通过用户名和密码进行认证。</p>
<p>创建名为 <code>config-exercise</code> 的目录。 在
<code>config-exercise</code> 目录中，创建名为 <code>config-demo</code> 的文件，其内容为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>scratch<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>experimenter<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-storage<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>exp-scratch<span style="color:#bbb">
</span></code></pre></div><!--
A configuration file describes clusters, users, and contexts. Your `config-demo` file
has the framework to describe two clusters, two users, and three contexts.

Go to your `config-exercise` directory. Enter these commands to add cluster details to
your configuration file:
-->
<p>配置文件描述了集群、用户名和上下文。<code>config-demo</code> 文件中含有描述两个集群、
两个用户和三个上下文的框架。</p>
<p>进入 <code>config-exercise</code> 目录。输入以下命令，将群集详细信息添加到配置文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-cluster development --server<span style="color:#666">=</span>https://1.2.3.4 --certificate-authority<span style="color:#666">=</span>fake-ca-file
kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-cluster scratch --server<span style="color:#666">=</span>https://5.6.7.8 --insecure-skip-tls-verify
</code></pre></div><!--
Add user details to your configuration file:
-->
<p>将用户详细信息添加到配置文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-credentials developer --client-certificate<span style="color:#666">=</span>fake-cert-file --client-key<span style="color:#666">=</span>fake-key-seefile
kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-credentials experimenter --username<span style="color:#666">=</span>exp --password<span style="color:#666">=</span>some-password
</code></pre></div><!--
- To delete a user you can run `kubectl --kubeconfig=config-demo config unset users.<name>`
- To remove a cluster, you can run `kubectl --kubeconfig=config-demo config unset clusters.<name>`
- To remove a context, you can run `kubectl --kubeconfig=config-demo config unset contexts.<name>`
-->
<p>注意：</p>
<ul>
<li>要删除用户，可以运行 <code>kubectl --kubeconfig=config-demo config unset users.&lt;name&gt;</code></li>
<li>要删除集群，可以运行 <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name&gt;</code></li>
<li>要删除上下文，可以运行 <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name&gt;</code></li>
</ul>
<!--
Add context details to your configuration file:
-->
<p>将上下文详细信息添加到配置文件中：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-context dev-frontend --cluster<span style="color:#666">=</span>development --namespace<span style="color:#666">=</span>frontend --user<span style="color:#666">=</span>developer
kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-context dev-storage --cluster<span style="color:#666">=</span>development --namespace<span style="color:#666">=</span>storage --user<span style="color:#666">=</span>developer
kubectl config --kubeconfig<span style="color:#666">=</span>config-demo set-context exp-scratch --cluster<span style="color:#666">=</span>scratch --namespace<span style="color:#666">=</span>default --user<span style="color:#666">=</span>experimenter
</code></pre></div><!--
Open your `config-demo` file to see the added details. As an alternative to opening the
`config-demo` file, you can use the `config view` command.
-->
<p>打开 <code>config-demo</code> 文件查看添加的详细信息。 也可以使用 <code>config view</code>
命令进行查看：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo view
</code></pre></div><!--
The output shows the two clusters, two users, and three contexts:
-->
<p>输出展示了两个集群、两个用户和三个上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>fake-ca-file<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://1.2.3.4<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">insecure-skip-tls-verify</span>:<span style="color:#bbb"> </span><span style="color:#a2f;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://5.6.7.8<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>scratch<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>storage<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-storage<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>scratch<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>experimenter<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>exp-scratch<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span><span style="color:#b44">&#34;&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>fake-cert-file<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>fake-key-file<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>experimenter<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">password</span>:<span style="color:#bbb"> </span>some-password<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">username</span>:<span style="color:#bbb"> </span>exp<span style="color:#bbb">
</span></code></pre></div><!--
The `fake-ca-file`, `fake-cert-file` and `fake-key-file` above are the placeholders
for the pathnames of the certificate files. You need to change these to the actual pathnames
of certificate files in your environment.

Sometimes you may want to use Base64-encoded data embedded here instead of separate
certificate files; in that case you need to add the suffix `-data` to the keys, for example,
`certificate-authority-data`, `client-certificate-data`, `client-key-data`.
-->
<p>其中的 <code>fake-ca-file</code>、<code>fake-cert-file</code> 和 <code>fake-key-file</code> 是证书文件路径名的占位符。
你需要更改这些值，使之对应你的环境中证书文件的实际路径名。</p>
<p>有时你可能希望在这里使用 BASE64 编码的数据而不是一个个独立的证书文件。
如果是这样，你需要在键名上添加 <code>-data</code> 后缀。例如，
<code>certificate-authority-data</code>、<code>client-certificate-data</code> 和 <code>client-key-data</code>。</p>
<!--
Each context is a triple (cluster, user, namespace). For example, the
`dev-frontend` context says, "Use the credentials of the `developer`
user to access the `frontend` namespace of the `development` cluster".

Set the current context:
-->
<p>每个上下文包含三部分（集群、用户和名字空间），例如，
<code>dev-frontend</code> 上下文表明：使用 <code>developer</code> 用户的凭证来访问 <code>development</code> 集群的
<code>frontend</code> 名字空间。</p>
<p>设置当前上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo use-context dev-frontend
</code></pre></div><!--
Now whenever you enter a `kubectl` command, the action will apply to the cluster,
and namespace listed in the `dev-frontend` context. And the command will use
the credentials of the user listed in the `dev-frontend` context.

To see only the configuration information associated with
the current context, use the `--minify` flag.
-->
<p>现在当输入 <code>kubectl</code> 命令时，相应动作会应用于 <code>dev-frontend</code> 上下文中所列的集群和名字空间，
同时，命令会使用 <code>dev-frontend</code> 上下文中所列用户的凭证。</p>
<p>使用 <code>--minify</code> 参数，来查看与当前上下文相关联的配置信息。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo view --minify
</code></pre></div><!--
The output shows configuration information associated with the `dev-frontend` context:
-->
<p>输出结果展示了 <code>dev-frontend</code> 上下文相关的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">clusters</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">certificate-authority</span>:<span style="color:#bbb"> </span>fake-ca-file<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">server</span>:<span style="color:#bbb"> </span>https://1.2.3.4<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">current-context</span>:<span style="color:#bbb"> </span>dev-frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">users</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-certificate</span>:<span style="color:#bbb"> </span>fake-cert-file<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">client-key</span>:<span style="color:#bbb"> </span>fake-key-file<span style="color:#bbb">
</span></code></pre></div><!--
Now suppose you want to work for a while in the scratch cluster.

Change the current context to `exp-scratch`:
-->
<p>现在假设用户希望在其它临时用途集群中工作一段时间。</p>
<p>将当前上下文更改为 <code>exp-scratch</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo use-context exp-scratch
</code></pre></div><!--
Now any `kubectl` command you give will apply to the default namespace of
the `scratch` cluster. And the command will use the credentials of the user
listed in the `exp-scratch` context.

View configuration associated with the new current context, `exp-scratch`.
-->
<p>现在你发出的所有 <code>kubectl</code> 命令都将应用于 <code>scratch</code> 集群的默认名字空间。
同时，命令会使用 <code>exp-scratch</code> 上下文中所列用户的凭证。</p>
<p>查看更新后的当前上下文 <code>exp-scratch</code> 相关的配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo view --minify
</code></pre></div><!--
Finally, suppose you want to work for a while in the `storage` namespace of the
`development` cluster.

Change the current context to `dev-storage`:
-->
<p>最后，假设用户希望在 <code>development</code> 集群中的 <code>storage</code> 名字空间下工作一段时间。</p>
<p>将当前上下文更改为 <code>dev-storage</code>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo use-context dev-storage
</code></pre></div><!--
View configuration associated with the new current context, `dev-storage`.
-->
<p>查看更新后的当前上下文 <code>dev-storage</code> 相关的配置：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config --kubeconfig<span style="color:#666">=</span>config-demo view --minify
</code></pre></div><!--
## Create a second configuration file

In your `config-exercise` directory, create a file named `config-demo-2` with this content:
-->
<h2 id="创建第二个配置文件">创建第二个配置文件</h2>
<p>在 <code>config-exercise</code> 目录中，创建名为 <code>config-demo-2</code> 的文件，其中包含以下内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">apiVersion</span>:<span style="color:#bbb"> </span>v1<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">kind</span>:<span style="color:#bbb"> </span>Config<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">preferences</span>:<span style="color:#bbb"> </span>{}<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>ramp<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-ramp-up<span style="color:#bbb">
</span></code></pre></div><!--
The preceding configuration file defines a new context named `dev-ramp-up`.
-->
<p>上述配置文件定义了一个新的上下文，名为 <code>dev-ramp-up</code>。</p>
<!--
## Set the KUBECONFIG environment variable

See whether you have an environment variable named `KUBECONFIG`. If so, save the
current value of your `KUBECONFIG` environment variable, so you can restore it later.
For example:
-->
<h2 id="设置-kubeconfig-环境变量">设置 KUBECONFIG 环境变量</h2>
<p>查看是否有名为 <code>KUBECONFIG</code> 的环境变量。
如有，保存 <code>KUBECONFIG</code> 环境变量当前的值，以便稍后恢复。
例如：</p>
<h3 id="linux">Linux</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">export</span> <span style="color:#b8860b">KUBECONFIG_SAVED</span><span style="color:#666">=</span><span style="color:#b8860b">$KUBECONFIG</span>
</code></pre></div><h3 id="windows-powershell">Windows PowerShell</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#b8860b">$Env:KUBECONFIG_SAVED</span>=<span style="color:#b8860b">$ENV:KUBECONFIG</span>
</code></pre></div><!--
 The `KUBECONFIG` environment variable is a list of paths to configuration files. The list is
colon-delimited for Linux and Mac, and semicolon-delimited for Windows. If you have
a `KUBECONFIG` environment variable, familiarize yourself with the configuration files
in the list.

Temporarily append two paths to your `KUBECONFIG` environment variable. For example:
-->
<p><code>KUBECONFIG</code> 环境变量是配置文件路径的列表，该列表在 Linux 和 Mac 中以冒号分隔，
在 Windows 中以分号分隔。
如果有 <code>KUBECONFIG</code> 环境变量，请熟悉列表中的配置文件。</p>
<p>临时添加两条路径到 <code>KUBECONFIG</code> 环境变量中。 例如：</p>
<h3 id="linux-1">Linux</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">export</span>  <span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b8860b">$KUBECONFIG</span>:config-demo:config-demo-2
</code></pre></div><h3 id="windows-powershell-1">Windows PowerShell</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#b8860b">$Env:KUBECONFIG</span>=(<span style="color:#b44">&#34;config-demo;config-demo-2&#34;</span>)
</code></pre></div><!--
In your `config-exercise` directory, enter this command:
-->
<p>在 <code>config-exercise</code> 目录中输入以下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><!--
The output shows merged information from all the files listed in your `KUBECONFIG`
environment variable. In particular, notice that the merged information has the
`dev-ramp-up` context from the `config-demo-2` file and the three contexts from
the `config-demo` file:
-->
<p>输出展示了 <code>KUBECONFIG</code> 环境变量中所列举的所有文件合并后的信息。
特别地，注意合并信息中包含来自 <code>config-demo-2</code> 文件的 <code>dev-ramp-up</code> 上下文和来自
<code>config-demo</code> 文件的三个上下文：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#008000;font-weight:bold">contexts</span>:<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>frontend<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-frontend<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>ramp<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-ramp-up<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>development<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>storage<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>developer<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>dev-storage<span style="color:#bbb">
</span><span style="color:#bbb"></span>- <span style="color:#008000;font-weight:bold">context</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">cluster</span>:<span style="color:#bbb"> </span>scratch<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">namespace</span>:<span style="color:#bbb"> </span>default<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#008000;font-weight:bold">user</span>:<span style="color:#bbb"> </span>experimenter<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#008000;font-weight:bold">name</span>:<span style="color:#bbb"> </span>exp-scratch<span style="color:#bbb">
</span></code></pre></div><!--
For more information about how kubeconfig files are merged, see
[Organizing Cluster Access Using kubeconfig Files](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
-->
<p>关于 kubeconfig 文件如何合并的更多信息，请参考
<a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">使用 kubeconfig 文件组织集群访问</a></p>
<!--
## Explore the $HOME/.kube directory

If you already have a cluster, and you can use `kubectl` to interact with
the cluster, then you probably have a file named `config` in the `$HOME/.kube`
directory.

Go to `$HOME/.kube`, and see what files are there. Typically, there is a file named
`config`. There might also be other configuration files in this directory. Briefly
familiarize yourself with the contents of these files.
-->
<h2 id="探索-home-kube-目录">探索 $HOME/.kube 目录</h2>
<p>如果用户已经拥有一个集群，可以使用 <code>kubectl</code> 与集群进行交互，
那么很可能在 <code>$HOME/.kube</code> 目录下有一个名为 <code>config</code> 的文件。</p>
<p>进入 <code>$HOME/.kube</code> 目录，看看那里有什么文件。通常会有一个名为
<code>config</code> 的文件，目录中可能还有其他配置文件。请简单地熟悉这些文件的内容。</p>
<!--
## Append $HOME/.kube/config to your KUBECONFIG environment variable

If you have a `$HOME/.kube/config` file, and it's not already listed in your
`KUBECONFIG` environment variable, append it to your `KUBECONFIG` environment variable now.
For example:
-->
<h2 id="将-home-kube-config-追加到-kubeconfig-环境变量中">将 $HOME/.kube/config 追加到 KUBECONFIG 环境变量中</h2>
<p>如果有 <code>$HOME/.kube/config</code> 文件，并且还未列在 <code>KUBECONFIG</code> 环境变量中，
那么现在将它追加到 <code>KUBECONFIG</code> 环境变量中。
例如：</p>
<h3 id="linux-2">Linux</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">export</span> <span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b8860b">$KUBECONFIG</span>:<span style="color:#b8860b">$HOME</span>/.kube/config
</code></pre></div><h3 id="windows-powershell-2">Windows Powershell</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#b8860b">$Env:KUBECONFIG</span>=<span style="color:#b44">&#34;$Env:KUBECONFIG;$HOME\.kube\config&#34;</span>
</code></pre></div><!--
View configuration information merged from all the files that are now listed
in your `KUBECONFIG` environment variable. In your config-exercise directory, enter:
-->
<p>在配置练习目录中输入以下命令，查看当前 <code>KUBECONFIG</code> 环境变量中列举的所有文件合并后的配置信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl config view
</code></pre></div><!--
## Clean up

Return your `KUBECONFIG` environment variable to its original value. For example:
-->
<h2 id="清理">清理</h2>
<p>将 <code>KUBECONFIG</code> 环境变量还原为原始值。 例如：</p>
<h3 id="linux-3">Linux</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#a2f">export</span> <span style="color:#b8860b">KUBECONFIG</span><span style="color:#666">=</span><span style="color:#b8860b">$KUBECONFIG_SAVED</span>
</code></pre></div><h3 id="windows-powershell-3">Windows PowerShell</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#b8860b">$Env:KUBECONFIG</span>=<span style="color:#b8860b">$ENV:KUBECONFIG_SAVED</span>
</code></pre></div><h2 id="what-s-next">What's next</h2>
<!--
* [Organizing Cluster Access Using kubeconfig Files](/docs/concepts/configuration/organize-cluster-access-kubeconfig/)
* [kubectl config](/docs/reference/generated/kubectl/kubectl-commands#config)
-->
<ul>
<li><a href="/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/">使用 kubeconfig 文件组织集群访问</a></li>
<li><a href="/docs/reference/generated/kubectl/kubectl-commands#config">kubectl config</a></li>
</ul>

</div>



    
	
  



          </main>
        </div>
      </div>
      
<footer class="d-print-none">
  <div class="footer__links">
    <nav>
      
      
      
      <a class="text-white" href="/zh/docs/home/">主页</a>
      
      <a class="text-white" href="/zh/blog/">博客</a>
      
      <a class="text-white" href="/zh/training/">培训</a>
      
      <a class="text-white" href="/zh/partners/">合作伙伴</a>
      
      <a class="text-white" href="/zh/community/">社区</a>
      
      <a class="text-white" href="/zh/case-studies/">案例分析</a>
      
    </nav>
  </div>
  <div class="container-fluid">
    <div class="row">
      <div class="col-6 col-sm-2 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" href="https://discuss.kubernetes.io">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Twitter" aria-label="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/kubernetesio">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Calendar" aria-label="Calendar">
    <a class="text-white" target="_blank" href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
      <i class="fas fa-calendar-alt"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Youtube" aria-label="Youtube">
    <a class="text-white" target="_blank" href="https://youtube.com/kubernetescommunity">
      <i class="fab fa-youtube"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/kubernetes/kubernetes">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Slack" aria-label="Slack">
    <a class="text-white" target="_blank" href="https://slack.k8s.io">
      <i class="fab fa-slack"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Contribute" aria-label="Contribute">
    <a class="text-white" target="_blank" href="https://git.k8s.io/community/contributors/guide">
      <i class="fas fa-edit"></i>
    </a>
  </li>
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="Stack Overflow" aria-label="Stack Overflow">
    <a class="text-white" target="_blank" href="https://stackoverflow.com/questions/tagged/kubernetes">
      <i class="fab fa-stack-overflow"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-8 text-center order-sm-2">
        <small class="text-white">&copy; 2024 The Kubernetes Authors | Documentation Distributed under <a href="https://git.k8s.io/website/LICENSE" class="light-text">CC BY 4.0</a></small>
        <br/>
        <small class="text-white">Copyright &copy; 2024 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage" class="light-text">Trademark Usage page</a></small>
        <br/>
        <small class="text-white">ICP license: 京ICP备17074266号-3</small>
        
        
          
        
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="/js/popper-1.14.3.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="/js/bootstrap-4.3.1.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>










<script src="/js/main.js"></script>






  </body>
</html>
