<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gRPC â€“ Kotlin</title>
    <link>https://grpc.io/docs/languages/kotlin/</link>
    <description>Recent content in Kotlin on gRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="https://grpc.io/docs/languages/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://grpc.io/docs/languages/kotlin/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/languages/kotlin/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kotlinlang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 1.3 or higher&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jdk.java.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JDK&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 7 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; https://github.com/grpc/grpc-kotlin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-kotlin/examples
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew installDist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./server/build/install/server/bin/hello-world-server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./client/build/install/client/bin/hello-world-client
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Received: Hello world
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server app with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section, you&amp;rsquo;ll update the app with an extra server method. The app&amp;rsquo;s
gRPC service, named &lt;code&gt;Greeter&lt;/code&gt;, is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn
more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt; file, see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.
For now, all you need to know is that both the server and the client stub have a
&lt;code&gt;SayHello()&lt;/code&gt; RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client
and returns a &lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;code&gt;helloworld/hello_world.proto&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/protos/src/main/proto/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protos/src/main/proto/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder, and add a
new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;When you build the example, the build process regenerates &lt;code&gt;HelloWorldProtoGrpcKt.kt&lt;/code&gt;,
which contains the generated gRPC client and server classes. This also
regenerates classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;p&gt;However, you still need to implement and call the new method in the
hand-written parts of the example app.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;helloworld/HelloWorldServer.kt&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/server/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;server/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder. Implement the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloWorldService&lt;/span&gt; : GreeterGrpcKt.GreeterCoroutineImplBase() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHello&lt;/span&gt;(request: HelloRequest) = helloReply {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    message = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${request.name}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHelloAgain&lt;/span&gt;(request: HelloRequest) = helloReply {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    message = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${request.name}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;helloworld/HelloWorldClient.kt&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/client/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;client/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder. Call the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloWorldClient&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; channel: ManagedChannel
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) : Closeable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stub: GreeterCoroutineStub = GreeterCoroutineStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;greet&lt;/span&gt;(name: String) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = helloRequest { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.name = name }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; response = stub.sayHello(request)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${response.message}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; againResponse = stub.sayHelloAgain(request)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${againResponse.message}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;close&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    channel.shutdown().awaitTermination(&lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;, TimeUnit.SECONDS)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew installDist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./server/build/install/server/bin/hello-world-server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client. This time, add a name as a
command-line argument:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./client/build/install/client/bin/hello-world-client Alice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Received: Hello Alice
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Received: Hello again Alice
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://grpc.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://grpc.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://grpc.io/docs/languages/kotlin/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/languages/kotlin/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Kotlin programmer&amp;rsquo;s introduction to
working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a &lt;code&gt;.proto&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Kotlin gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You should already be familiar gRPC and protocol buffers; if not, see
&lt;a href=&#34;https://grpc.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and the proto3 &lt;a href=&#34;https://protobuf.dev/programming-guides/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet â€”
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;
&lt;p&gt;This tutorial has the same &lt;a href=&#34;../quickstart/#prerequisites&#34;&gt;prerequisites&lt;/a&gt; as the &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;. Install the
necessary SDKs and tools before proceeding.&lt;/p&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --depth &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt; https://github.com/grpc/grpc-kotlin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-kotlin/examples
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Your first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://grpc.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to define
the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using &lt;a href=&#34;https://protobuf.dev/programming-guides/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;d like to follow along by looking at the complete &lt;code&gt;.proto&lt;/code&gt; file, see
&lt;code&gt;routeguide/route_guide.proto&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/protos/src/main/proto/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protos/src/main/proto/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in the &lt;code&gt;.proto&lt;/code&gt; file like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used by the service methods &amp;ndash; for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next, you need to generate the gRPC client and server interfaces from the &lt;code&gt;.proto&lt;/code&gt;
service definition. You do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
special gRPC Kotlin and Java plugins.&lt;/p&gt;
&lt;p&gt;When using Gradle or Maven, the &lt;code&gt;protoc&lt;/code&gt; build plugin will generate the
necessary code as part of the build process. For a Gradle example, see
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/blob/master/examples/stub/build.gradle.kts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stub/build.gradle.kts&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you run &lt;code&gt;./gradlew installDist&lt;/code&gt; from the examples folder, the following files
are generated from the service definition &amp;ndash; you&amp;rsquo;ll find the generated files in
subdirectories below &lt;code&gt;stub/build/generated/source/proto/main&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Feature.java&lt;/code&gt;, &lt;code&gt;Point.java&lt;/code&gt;, &lt;code&gt;Rectangle.java&lt;/code&gt;, and others, which contain all
the protocol buffer code to populate, serialize, and retrieve our request and
response message types.&lt;/p&gt;
&lt;p&gt;You&amp;rsquo;ll find these files in the &lt;code&gt;java/io/grpc/examples/routeguide&lt;/code&gt;
subdirectory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RouteGuideOuterClassGrpcKt.kt&lt;/code&gt;, which contains, among other things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpcKt.RouteGuideCoroutineImplBase&lt;/code&gt;, an abstract base class for
&lt;code&gt;RouteGuide&lt;/code&gt; servers to implement, with all the methods defined in the
&lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpcKt.RouteGuideCoroutineStub&lt;/code&gt;, a class that clients use to talk
to a &lt;code&gt;RouteGuide&lt;/code&gt; server.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You&amp;rsquo;ll find this Kotlin file under &lt;code&gt;grpckt/io/grpc/examples/routeguide&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First consider how to create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only interested in
creating gRPC clients, skip ahead to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; &amp;ndash; though
you might find this section interesting anyway!&lt;/p&gt;
&lt;p&gt;There are two main things that you need to do when creating a &lt;code&gt;RouteGuide&lt;/code&gt;
server:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;RouteGuideCoroutineImplBase&lt;/code&gt; service base class to do the actual
service work.&lt;/li&gt;
&lt;li&gt;Create and run a gRPC server to listen for requests from clients and return
the service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Open the example &lt;code&gt;RouteGuide&lt;/code&gt; server code in &lt;code&gt;routeguide/RouteGuideServer.kt&lt;/code&gt;
under the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/server/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;server/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, the server has a &lt;code&gt;RouteGuideService&lt;/code&gt; class that extends the
generated service base class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideService&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; features: Collection&amp;lt;Feature&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) : RouteGuideGrpcKt.RouteGuideCoroutineImplBase() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RouteGuideService&lt;/code&gt; implements all the service methods. Consider the simplest
method first, &lt;code&gt;GetFeature()&lt;/code&gt;, which gets a &lt;code&gt;Point&lt;/code&gt; from the client and returns a
&lt;code&gt;Feature&lt;/code&gt; built from the corresponding feature information in the database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;getFeature&lt;/span&gt;(request: Point): Feature =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    features.find { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.location &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; request } &lt;span style=&#34;color:#555&#34;&gt;?:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// No feature was found, return an unnamed feature.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    Feature.newBuilder().apply { location = request }.build()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method accepts a client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt; message request as a parameter, and it
returns a &lt;code&gt;Feature&lt;/code&gt; message as a response. The method populates the &lt;code&gt;Feature&lt;/code&gt;
with the appropriate information, and then returns it to the gRPC framework,
which sends it back to the client.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, consider one of the streaming RPCs. &lt;code&gt;ListFeatures()&lt;/code&gt; is a server-side
streaming RPC, so the server gets to send back multiple &lt;code&gt;Feature&lt;/code&gt; messages to
the client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;listFeatures&lt;/span&gt;(request: Rectangle): Flow&amp;lt;Feature&amp;gt; =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  features.asFlow().filter { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.exists() &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.location &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; request }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The request object is a &lt;code&gt;Rectangle&lt;/code&gt;. The server collects, and returns to the
client, all the &lt;code&gt;Feature&lt;/code&gt; objects in its collection that are inside the given
&lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now consider something a little more complicated: the client-side streaming
method &lt;code&gt;RecordRoute()&lt;/code&gt;, where the server gets a stream of &lt;code&gt;Point&lt;/code&gt; objects from
the client, and returns a single &lt;code&gt;RouteSummary&lt;/code&gt; with information about their
trip through the given points.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;(requests: Flow&amp;lt;Point&amp;gt;): RouteSummary {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; pointCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; featureCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; distance = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; previous: Point? = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stopwatch = Stopwatch.createStarted(ticker)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  requests.collect { request &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pointCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (getFeature(request).exists()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      featureCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; prev = previous
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (prev &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; prev distanceTo request
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    previous = request
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; RouteSummary.newBuilder().apply {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.pointCount = pointCount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.featureCount = featureCount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.distance = distance
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.elapsedTime = Durations.fromMicros(stopwatch.elapsed(TimeUnit.MICROSECONDS))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }.build()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The request parameter is a stream of client request messages represented as a
Kotlin &lt;a href=&#34;https://kotlinlang.org/docs/reference/coroutines/flow.html#flows&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flow&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. The server returns a single response just like in the simple
RPC case.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, consider the bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;(requests: Flow&amp;lt;RouteNote&amp;gt;): Flow&amp;lt;RouteNote&amp;gt; =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  flow {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// could use transform, but it&amp;#39;s currently experimental
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requests.collect { note &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; notes: MutableList&amp;lt;RouteNote&amp;gt; = routeNotes.computeIfAbsent(note.location) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Collections.synchronizedList(mutableListOf&amp;lt;RouteNote&amp;gt;())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (prevNote &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; notes.toTypedArray()) { &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// thread-safe snapshot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        emit(prevNote)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      notes &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; note
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Similar to the client-side streaming example, for this method, the server gets a
stream of &lt;code&gt;RouteNote&lt;/code&gt; objects as a &lt;code&gt;Flow&lt;/code&gt;. However, this time the server returns
&lt;code&gt;RouteNote&lt;/code&gt; instances via the method&amp;rsquo;s returned stream &lt;em&gt;while&lt;/em&gt; the client is still
writing messages to &lt;em&gt;its&lt;/em&gt; message stream.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once all the server&amp;rsquo;s methods are implemented, you need code to create a gRPC
server instance, something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideServer&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; port: Int,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; features: Collection&amp;lt;Feature&amp;gt; = Database.features(),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; server: Server =
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ServerBuilder.forPort(port)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .addService(RouteGuideService(features)).build()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;start&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    server.start()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Server started, listening on &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$port&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;main&lt;/span&gt;(args: Array&amp;lt;String&amp;gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; port = &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; server = RouteGuideServer(port)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  server.start()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  server.awaitTermination()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A server instance is built and started using a &lt;code&gt;ServerBuilder&lt;/code&gt; as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Specify the port, that the server will listen for client requests on, using
&lt;code&gt;forPort()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create an instance of the service implementation class &lt;code&gt;RouteGuideService&lt;/code&gt;
and pass it to the builder&amp;rsquo;s &lt;code&gt;addService()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;build()&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt; on the builder to create and start an RPC server
for the route guide service.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;awaitTermination()&lt;/code&gt; on the server to block the main function until
the application receives a signal to terminate.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, you&amp;rsquo;ll look at a client for the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/p&gt;
&lt;p&gt;For the complete client code, open &lt;code&gt;routeguide/RouteGuideClient.kt&lt;/code&gt;
under the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/client/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;client/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;h4 id=&#34;instantiating-a-stub&#34;&gt;Instantiating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, you first need to create a gRPC &lt;em&gt;channel&lt;/em&gt; using a
&lt;code&gt;ManagedChannelBuilder&lt;/code&gt;. You&amp;rsquo;ll use this channel to communicate with the server.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; channel = ManagedChannelBuilder.forAddress(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;).usePlaintext().build()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the gRPC channel is setup, you need a client &lt;em&gt;stub&lt;/em&gt; to perform RPCs. Get it
by instantiating &lt;code&gt;RouteGuideCoroutineStub&lt;/code&gt;, which is available from the package
that was generated from the &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stub = RouteGuideCoroutineStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now consider how you&amp;rsquo;ll call service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature()&lt;/code&gt; is as straightforward as calling a local
method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = point(latitude, longitude)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = stub.getFeature(request)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stub method &lt;code&gt;getFeature()&lt;/code&gt; executes the corresponding RPC, suspending until
the RPC completes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;getFeature&lt;/span&gt;(latitude: Int, longitude: Int) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = point(latitude, longitude)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = stub.getFeature(request)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.exists()) { &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;server-side-streaming-rpc-1&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, consider the server-side streaming &lt;code&gt;ListFeatures()&lt;/code&gt; RPC, which returns a
stream of geographical features:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;listFeatures&lt;/span&gt;(lowLat: Int, lowLon: Int, hiLat: Int, hiLon: Int) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = Rectangle.newBuilder()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .setLo(point(lowLat, lowLon))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .setHi(point(hiLat, hiLon))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .build()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stub.listFeatures(request).collect { feature &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Result #&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${i++}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$feature&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stub &lt;code&gt;listFeatures()&lt;/code&gt; method returns a stream of features in the form of a
&lt;code&gt;Flow&amp;lt;Feature&amp;gt;&lt;/code&gt; instance. The flow &lt;code&gt;collect()&lt;/code&gt; method allows the client to
processes the server-provided features as they become available.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc-1&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;The client-side streaming &lt;code&gt;RecordRoute()&lt;/code&gt; RPC sends a stream of &lt;code&gt;Point&lt;/code&gt; messages
to the server and gets back a single &lt;code&gt;RouteSummary&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;(points: Flow&amp;lt;Point&amp;gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RecordRoute&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; summary = stub.recordRoute(points)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished trip with &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.pointCount}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; points.&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Passed &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.featureCount}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; features.&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Travelled &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.distance}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; meters.&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; duration = summary.elapsedTime.seconds
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;It took &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$duration&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; seconds.&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method generates the route points from the points associated with a randomly
selected list of features. The random selection is taken from a previously
loaded feature collection:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;generateRoutePoints&lt;/span&gt;(features: List&amp;lt;Feature&amp;gt;, numPoints: Int): Flow&amp;lt;Point&amp;gt; = flow {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1.&lt;/span&gt;.numPoints) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = features.random(random)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Visiting point &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${feature.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit(feature.location)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    delay(timeMillis = random.nextLong(&lt;span style=&#34;color:#f60&#34;&gt;500L&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;1500L&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that flow points are emitted lazily, that is, only once the server requests
them. Once a point has been emitted to the flow, the point generator suspends
until the server requests the next point.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, consider the bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. As in the case
of &lt;code&gt;RecordRoute()&lt;/code&gt;, you pass to the stub method a stream that you use to write
the request messages to; like in &lt;code&gt;ListFeatures()&lt;/code&gt;, you get back a stream that
you can use to read response messages from. However, this time you send values
via our method&amp;rsquo;s stream while the server is also writing messages to &lt;em&gt;its&lt;/em&gt;
message stream.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; requests = generateOutgoingNotes()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stub.routeChat(requests).collect { note &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Got message &lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.message}&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RouteChat&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;generateOutgoingNotes&lt;/span&gt;(): Flow&amp;lt;RouteNote&amp;gt; = flow {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; notes = listOf(&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (note &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; notes) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Sending message &lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.message}&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    emit(note)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    delay(&lt;span style=&#34;color:#f60&#34;&gt;500&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is very similar to the client-side and
server-side streaming methods. Although each side will always get the other&amp;rsquo;s
messages in the order they were written, both the client and server can read and
write in any order â€”- the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Run the following commands from the &lt;code&gt;grpc-kotlin/examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew installDist
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./server/build/install/server/bin/route-guide-server
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./client/build/install/client/bin/route-guide-client
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You&amp;rsquo;ll see client output like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;*** GetFeature: lat=409146138 lon=-746188906
Found feature called &amp;#34;Berkshire Valley Management Area Trail, Jefferson, NJ, USA&amp;#34; at 40.9146138, -74.6188906
*** GetFeature: lat=0 lon=0
Found no feature at 0.0, 0.0
*** ListFeatures: lowLat=400000000 lowLon=-750000000 hiLat=420000000 liLon=-730000000
Result #1: name: &amp;#34;Patriots Path, Mendham, NJ 07945, USA&amp;#34;
location {
  latitude: 407838351
  longitude: -746143763
}
...
Result #64: name: &amp;#34;3 Hasta Way, Newton, NJ 07860, USA&amp;#34;
location {
  latitude: 410248224
  longitude: -747127767
}

*** RecordRoute
Visiting point 40.0066188, -74.6793294
...
Visiting point 40.4318328, -74.0835638
Finished trip with 10 points.
Passed 3 features.
Travelled 93238790 meters.
It took 9 seconds.
*** RouteChat
Sending message &amp;#34;First message&amp;#34; at 0.0, 0.0
Sending message &amp;#34;Second message&amp;#34; at 0.0, 0.0
Got message &amp;#34;First message&amp;#34; at 0.0, 0.0
Sending message &amp;#34;Third message&amp;#34; at 1.0, 0.0
Sending message &amp;#34;Fourth message&amp;#34; at 1.0, 1.0
Sending message &amp;#34;Last message&amp;#34; at 0.0, 0.0
Got message &amp;#34;First message&amp;#34; at 0.0, 0.0
Got message &amp;#34;Second message&amp;#34; at 0.0, 0.0
Finished RouteChat
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://grpc.io/docs/languages/kotlin/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/languages/kotlin/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
