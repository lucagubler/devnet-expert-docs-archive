<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gRPC – What is gRPC?</title>
    <link>https://grpc.io/docs/what-is-grpc/</link>
    <description>Recent content in What is gRPC? on gRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="https://grpc.io/docs/what-is-grpc/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Introduction to gRPC</title>
      <link>https://grpc.io/docs/what-is-grpc/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/what-is-grpc/introduction/</guid>
      <description>
        
        
        &lt;p&gt;This page introduces you to gRPC and protocol buffers. gRPC can use
protocol buffers as both its Interface Definition Language (&lt;strong&gt;IDL&lt;/strong&gt;) and as its underlying message
interchange format. If you’re new to gRPC and/or protocol buffers, read this!
If you just want to dive in and see gRPC in action first,
&lt;a href=&#34;https://grpc.io/docs/languages/&#34;&gt;select a language&lt;/a&gt; and try its &lt;strong&gt;Quick start&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;youtube-video&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/njC24ts24Pg&#34; allowfullscreen title=&#34;gRPC in 5 minutes&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;In gRPC, a client application can directly call a method on a server application
on a different machine as if it were a local object, making it easier for you to
create distributed applications and services. As in many RPC systems, gRPC is
based around the idea of defining a service, specifying the methods that can be
called remotely with their parameters and return types. On the server side, the
server implements this interface and runs a gRPC server to handle client calls.
On the client side, the client has a stub (referred to as just a client in some
languages) that provides the same methods as the server.&lt;/p&gt;
&lt;p&gt;

&lt;figure class=&#34;text-center&#34;&gt;
  &lt;img class=&#34;modal-trigger&#34; src=&#34;https://grpc.io/img/landing-2.svg&#34; alt=&#34;Concept Diagram&#34; id=&#34;landing-2.svg&#34; data-toggle=&#34;modal&#34; data-target=&#34;#modal-landing-2.svg&#34;/&gt;

  &lt;div class=&#34;modal&#34; id=&#34;modal-landing-2.svg&#34;&gt;
    &lt;div class=&#34;modal-dialog modal-lg modal-dialog-centered&#34;&gt;
      &lt;div class=&#34;modal-body&#34;&gt;
        &lt;img src=&#34;https://grpc.io/img/landing-2.svg&#34; alt=&#34;Concept Diagram&#34;/&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;gRPC clients and servers can run and talk to each other in a variety of
environments - from servers inside Google to your own desktop - and can be
written in any of gRPC&amp;rsquo;s supported languages. So, for example, you can easily
create a gRPC server in Java with clients in Go, Python, or Ruby. In addition,
the latest Google APIs will have gRPC versions of their interfaces, letting you
easily build Google functionality into your applications.&lt;/p&gt;
&lt;h3 id=&#34;working-with-protocol-buffers&#34;&gt;Working with Protocol Buffers&lt;/h3&gt;
&lt;p&gt;By default, gRPC uses &lt;a href=&#34;https://protobuf.dev/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol Buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, Google’s
mature open source mechanism for serializing structured data (although it
can be used with other data formats such as JSON). Here&amp;rsquo;s a quick intro to how
it works. If you&amp;rsquo;re already familiar with protocol buffers, feel free to skip
ahead to the next section.&lt;/p&gt;
&lt;p&gt;The first step when working with protocol buffers is to define the structure
for the data you want to serialize in a &lt;em&gt;proto file&lt;/em&gt;: this is an ordinary text
file with a &lt;code&gt;.proto&lt;/code&gt; extension. Protocol buffer data is structured as
&lt;em&gt;messages&lt;/em&gt;, where each message is a small logical record of information
containing a series of name-value pairs called &lt;em&gt;fields&lt;/em&gt;. Here&amp;rsquo;s a simple
example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Person&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; id &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; has_ponycopter &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;3&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then, once you&amp;rsquo;ve specified your data structures, you use the protocol buffer
compiler &lt;code&gt;protoc&lt;/code&gt; to generate data access classes in your preferred language(s)
from your proto definition. These provide simple accessors for each field,
like &lt;code&gt;name()&lt;/code&gt; and &lt;code&gt;set_name()&lt;/code&gt;, as well as methods to serialize/parse
the whole structure to/from raw bytes. So, for instance, if your chosen
language is C++, running the compiler on the example above will generate a
class called &lt;code&gt;Person&lt;/code&gt;. You can then use this class in your application to
populate, serialize, and retrieve &lt;code&gt;Person&lt;/code&gt; protocol buffer messages.&lt;/p&gt;
&lt;p&gt;You define gRPC services
in ordinary proto files, with RPC method parameters and return types specified as
protocol buffer messages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeter service definition.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gRPC uses &lt;code&gt;protoc&lt;/code&gt; with a special gRPC plugin to
generate code from your proto file: you get
generated gRPC client and server code, as well as the regular protocol buffer
code for populating, serializing, and retrieving your message types. To learn more about protocol buffers, including how to install &lt;code&gt;protoc&lt;/code&gt; with the
gRPC plugin in your chosen language, see the &lt;a href=&#34;https://protobuf.dev/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;protocol-buffer-versions&#34;&gt;Protocol buffer versions&lt;/h2&gt;
&lt;p&gt;While &lt;a href=&#34;https://protobuf.dev/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; have been available to open source users for some time,
most examples from this site use protocol buffers version 3 (proto3), which has
a slightly simplified syntax, some useful new features, and supports more
languages. Proto3 is currently available in Java, C++, Dart, Python,
Objective-C, C#, a lite-runtime (Android Java), Ruby, and JavaScript from the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers GitHub repo&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, as well as a Go language generator from the
&lt;a href=&#34;https://pkg.go.dev/google.golang.org/protobuf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;golang/protobuf official package&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, with more languages in development. You can
find out more in the &lt;a href=&#34;https://protobuf.dev/programming-guides/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and the &lt;a href=&#34;https://protobuf.dev/reference&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reference
documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; available for each language. The reference documentation also
includes a &lt;a href=&#34;https://protobuf.dev/reference/protobuf/proto3-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;formal specification&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; for the &lt;code&gt;.proto&lt;/code&gt; file format.&lt;/p&gt;
&lt;p&gt;In general, while you can use proto2 (the current default protocol buffers
version), we recommend that you use proto3 with gRPC as it lets you use the
full range of gRPC-supported languages, as well as avoiding compatibility
issues with proto2 clients talking to proto3 servers and vice versa.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Core concepts, architecture and lifecycle</title>
      <link>https://grpc.io/docs/what-is-grpc/core-concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/what-is-grpc/core-concepts/</guid>
      <description>
        
        
        &lt;p&gt;Not familiar with gRPC? First read &lt;a href=&#34;../introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;. For
language-specific details, see the quick start, tutorial, and reference
documentation for your language of choice.&lt;/p&gt;

&lt;div class=&#34;youtube-video&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/sImWl7JyK_Q&#34; allowfullscreen title=&#34;Overview of gRPC&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;h4 id=&#34;service-definition&#34;&gt;Service definition&lt;/h4&gt;
&lt;p&gt;Like many RPC systems, gRPC is based around the idea of defining a service,
specifying the methods that can be called remotely with their parameters and
return types. By default, gRPC uses &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; as the Interface
Definition Language (IDL) for describing both the service interface and the
structure of the payload messages. It is possible to use other alternatives if
desired.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; HelloService {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; greeting &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloResponse&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gRPC lets you define four kinds of service method:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Unary RPCs where the client sends a single request to the server and gets a
single response back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello(HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Server streaming RPCs where the client sends a request to the server and gets
a stream to read a sequence of messages back. The client reads from the
returned stream until there are no more messages. gRPC guarantees message
ordering within an individual RPC call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; LotsOfReplies(HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream HelloResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Client streaming RPCs where the client writes a sequence of messages and sends
them to the server, again using a provided stream. Once the client has
finished writing the messages, it waits for the server to read them and return
its response.  Again gRPC guarantees message ordering within an individual RPC
call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; LotsOfGreetings(stream HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bidirectional streaming RPCs where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; BidiHello(stream HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream HelloResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You&amp;rsquo;ll learn more about the different types of RPC in the
&lt;a href=&#34;#rpc-life-cycle&#34;&gt;RPC life cycle&lt;/a&gt; section below.&lt;/p&gt;
&lt;h4 id=&#34;using-the-api&#34;&gt;Using the API&lt;/h4&gt;
&lt;p&gt;Starting from a service definition in a &lt;code&gt;.proto&lt;/code&gt; file, gRPC provides protocol
buffer compiler plugins that generate client- and server-side code. gRPC users
typically call these APIs on the client side and implement the corresponding API
on the server side.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On the server side, the server implements the methods declared by the service
and runs a gRPC server to handle client calls. The gRPC infrastructure decodes
incoming requests, executes service methods, and encodes service responses.&lt;/li&gt;
&lt;li&gt;On the client side, the client has a local object known as &lt;em&gt;stub&lt;/em&gt; (for some
languages, the preferred term is &lt;em&gt;client&lt;/em&gt;) that implements the same methods as
the service. The client can then just call those methods on the local object,
and the methods wrap the parameters for the call in the appropriate protocol buffer
message type, send the requests to the server, and return the server&amp;rsquo;s
protocol buffer responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;synchronous-vs-asynchronous&#34;&gt;Synchronous vs. asynchronous&lt;/h4&gt;
&lt;p&gt;Synchronous RPC calls that block until a response arrives from the server are
the closest approximation to the abstraction of a procedure call that RPC
aspires to. On the other hand, networks are inherently asynchronous and in many
scenarios it&amp;rsquo;s useful to be able to start RPCs without blocking the current
thread.&lt;/p&gt;
&lt;p&gt;The gRPC programming API in most languages comes in both synchronous and
asynchronous flavors. You can find out more in each language&amp;rsquo;s tutorial and
reference documentation (complete reference docs are coming soon).&lt;/p&gt;
&lt;h3 id=&#34;rpc-life-cycle&#34;&gt;RPC life cycle&lt;/h3&gt;
&lt;p&gt;In this section, you&amp;rsquo;ll take a closer look at what happens when a gRPC client
calls a gRPC server method. For complete implementation details, see the
language-specific pages.&lt;/p&gt;
&lt;h4 id=&#34;unary-rpc&#34;&gt;Unary RPC&lt;/h4&gt;
&lt;p&gt;First consider the simplest type of RPC where the client sends a single request
and gets back a single response.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Once the client calls a stub method, the server is
notified that the RPC has been invoked with the client&amp;rsquo;s &lt;a href=&#34;#metadata&#34;&gt;metadata&lt;/a&gt;
for this call, the method name, and the specified &lt;a href=&#34;#deadlines&#34;&gt;deadline&lt;/a&gt; if
applicable.&lt;/li&gt;
&lt;li&gt;The server can then either send back its own initial metadata (which must be
sent before any response) straight away, or wait for the client&amp;rsquo;s request
message. Which happens first, is application-specific.&lt;/li&gt;
&lt;li&gt;Once the server has the client&amp;rsquo;s request message, it does whatever work is
necessary to create and populate a response. The response is then returned
(if successful) to the client together with status details (status code and
optional status message) and optional trailing metadata.&lt;/li&gt;
&lt;li&gt;If the response status is OK, then the client gets the response, which
completes the call on the client side.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;server-streaming-rpc&#34;&gt;Server streaming RPC&lt;/h4&gt;
&lt;p&gt;A server-streaming RPC is similar to a unary RPC, except that the server returns
a stream of messages in response to a client&amp;rsquo;s request. After sending all its
messages, the server&amp;rsquo;s status details (status code and optional status message)
and optional trailing metadata are sent to the client. This completes processing
on the server side. The client completes once it has all the server&amp;rsquo;s messages.&lt;/p&gt;
&lt;h4 id=&#34;client-streaming-rpc&#34;&gt;Client streaming RPC&lt;/h4&gt;
&lt;p&gt;A client-streaming RPC is similar to a unary RPC, except that the client sends a
stream of messages to the server instead of a single message. The server
responds with a single message (along with its status details and optional
trailing metadata), typically but not necessarily after it has received all the
client&amp;rsquo;s messages.&lt;/p&gt;
&lt;h4 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h4&gt;
&lt;p&gt;In a bidirectional streaming RPC, the call is initiated by the client
invoking the method and the server receiving the client metadata, method name,
and deadline. The server can choose to send back its initial metadata or
wait for the client to start streaming messages.&lt;/p&gt;
&lt;p&gt;Client- and server-side stream processing is application specific. Since the two
streams are independent, the client and server can read and write messages in
any order. For example, a server can wait until it has received all of a
client&amp;rsquo;s messages before writing its messages, or the server and client can play
&amp;ldquo;ping-pong&amp;rdquo; &amp;ndash; the server gets a request, then sends back a response, then the
client sends another request based on the response, and so on.&lt;/p&gt;
&lt;h4 id=&#34;deadlines&#34;&gt;Deadlines/Timeouts&lt;/h4&gt;
&lt;p&gt;gRPC allows clients to specify how long they are willing to wait for an RPC to
complete before the RPC is terminated with a &lt;code&gt;DEADLINE_EXCEEDED&lt;/code&gt; error. On
the server side, the server can query to see if a particular RPC has timed out,
or how much time is left to complete the RPC.&lt;/p&gt;
&lt;p&gt;Specifying a deadline or timeout is language specific: some language APIs work
in terms of timeouts (durations of time), and some language APIs work in terms
of a deadline (a fixed point in time) and may or may not have a default deadline.&lt;/p&gt;
&lt;h4 id=&#34;rpc-termination&#34;&gt;RPC termination&lt;/h4&gt;
&lt;p&gt;In gRPC, both the client and server make independent and local determinations of
the success of the call, and their conclusions may not match. This means that,
for example, you could have an RPC that finishes successfully on the server side
(&amp;ldquo;I have sent all my responses!&amp;rdquo;) but fails on the client side (&amp;ldquo;The responses
arrived after my deadline!&amp;rdquo;). It&amp;rsquo;s also possible for a server to decide to
complete before a client has sent all its requests.&lt;/p&gt;
&lt;h4 id=&#34;cancelling-an-rpc&#34;&gt;Cancelling an RPC&lt;/h4&gt;
&lt;p&gt;Either the client or the server can cancel an RPC at any time. A cancellation
terminates the RPC immediately so that no further work is done.&lt;/p&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Warning&lt;/h4&gt;

    Changes made before a cancellation are not rolled back.

&lt;/div&gt;

&lt;h4 id=&#34;metadata&#34;&gt;Metadata&lt;/h4&gt;
&lt;p&gt;Metadata is information about a particular RPC call (such as &lt;a href=&#34;https://grpc.io/docs/guides/auth/&#34;&gt;authentication
details&lt;/a&gt;) in the form of a list of key-value pairs, where the
keys are strings and the values are typically strings, but can be binary data.&lt;/p&gt;
&lt;p&gt;Keys are case insensitive and consist of ASCII letters, digits, and special characters &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;,
&lt;code&gt;.&lt;/code&gt; and must not start with &lt;code&gt;grpc-&lt;/code&gt; (which is reserved for gRPC itself).
Binary-valued keys end in &lt;code&gt;-bin&lt;/code&gt; while ASCII-valued keys do not.&lt;/p&gt;
&lt;p&gt;User-defined metadata is not used by gRPC, which allows the client to provide information
associated with the call to the server and vice versa.&lt;/p&gt;
&lt;p&gt;Access to metadata is language dependent.&lt;/p&gt;
&lt;h4 id=&#34;channels&#34;&gt;Channels&lt;/h4&gt;
&lt;p&gt;A gRPC channel provides a connection to a gRPC server on a specified host and
port. It is used when creating a client stub. Clients can specify channel
arguments to modify gRPC&amp;rsquo;s default behavior, such as switching message
compression on or off. A channel has state, including &lt;code&gt;connected&lt;/code&gt; and &lt;code&gt;idle&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;How gRPC deals with closing a channel is language dependent. Some languages also
permit querying channel state.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: FAQ</title>
      <link>https://grpc.io/docs/what-is-grpc/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://grpc.io/docs/what-is-grpc/faq/</guid>
      <description>
        
        
        &lt;p&gt;Here are some frequently asked questions. Hope you find your answer here :-)&lt;/p&gt;
&lt;h3 id=&#34;what-is-grpc&#34;&gt;What is gRPC?&lt;/h3&gt;
&lt;p&gt;gRPC is a modern, open source remote procedure call (RPC) framework that can run anywhere. It enables client and server applications to communicate transparently, and makes it easier to build connected systems.&lt;/p&gt;
&lt;p&gt;Read the longer &lt;a href=&#34;https://grpc.io/blog/principles/&#34;&gt;Motivation &amp;amp; Design Principles&lt;/a&gt; post for background on why we created gRPC.&lt;/p&gt;
&lt;h3 id=&#34;what-does-grpc-stand-for&#34;&gt;What does gRPC stand for?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;g&lt;/strong&gt;RPC &lt;strong&gt;R&lt;/strong&gt;emote &lt;strong&gt;P&lt;/strong&gt;rocedure &lt;strong&gt;C&lt;/strong&gt;alls, of course!&lt;/p&gt;
&lt;h3 id=&#34;why-would-i-want-to-use-grpc&#34;&gt;Why would I want to use gRPC?&lt;/h3&gt;
&lt;p&gt;The main usage scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Low latency, highly scalable, distributed systems.&lt;/li&gt;
&lt;li&gt;Developing mobile clients which are communicating to a cloud server.&lt;/li&gt;
&lt;li&gt;Designing a new protocol that needs to be accurate, efficient and language independent.&lt;/li&gt;
&lt;li&gt;Layered design to enable extension eg. authentication, load balancing, logging and monitoring etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;whos-using-this-and-why&#34;&gt;Who&amp;rsquo;s using this and why?&lt;/h3&gt;
&lt;p&gt;gRPC is a &lt;a href=&#34;https://cncf.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Computing Foundation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; (CNCF) project.&lt;/p&gt;
&lt;p&gt;Google has been using a lot of the underlying technologies and concepts in gRPC for a long time. The current implementation is being used in several of Google’s cloud products and Google externally facing APIs. It is also being used by &lt;a href=&#34;https://corner.squareup.com/2015/02/grpc.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Square&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/Netflix/ribbon&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netflix&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/etcd-distributed-key-value-store-with-grpc-http2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CoreOS&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://blog.docker.com/2015/12/containerd-daemon-to-control-runc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/cockroachdb/cockroach&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CockroachDB&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/CiscoDevNet/grpc-getting-started&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cisco&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/Juniper/open-nti&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Juniper Networks&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and many other organizations and individuals.&lt;/p&gt;
&lt;h3 id=&#34;which-programming-languages-are-supported&#34;&gt;Which programming languages are supported?&lt;/h3&gt;
&lt;p&gt;For officially supported languages and platforms, see &lt;a href=&#34;https://grpc.io/docs/#official-support&#34;&gt;Official support&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-do-i-get-started-using-grpc&#34;&gt;How do I get started using gRPC?&lt;/h3&gt;
&lt;p&gt;You can start with installation of gRPC by following instructions &lt;a href=&#34;https://grpc.io/docs/quickstart/&#34;&gt;here&lt;/a&gt;. Or head over to the &lt;a href=&#34;https://github.com/grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC GitHub org page&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, pick the runtime or language you are interested in, and follow the README instructions.&lt;/p&gt;
&lt;h3 id=&#34;which-license-is-grpc-under&#34;&gt;Which license is gRPC under?&lt;/h3&gt;
&lt;p&gt;All implementations are licensed under &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/LICENSE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apache 2.0&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-can-i-contribute&#34;&gt;How can I contribute?&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://grpc.io/community/#contribute&#34;&gt;Contributors&lt;/a&gt; are highly welcome and the repositories are hosted on GitHub. We look forward to community feedback, additions and bugs. Both individual contributors and corporate contributors need to sign our CLA. If you have ideas for a project around gRPC, read guidelines and submit &lt;a href=&#34;https://github.com/grpc/grpc-contrib/blob/master/CONTRIBUTING.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. We have a growing list of projects under the &lt;a href=&#34;https://github.com/grpc-ecosystem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC Ecosystem&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; organization on GitHub.&lt;/p&gt;
&lt;h3 id=&#34;where-is-the-documentation&#34;&gt;Where is the documentation?&lt;/h3&gt;
&lt;p&gt;Check out the &lt;a href=&#34;https://grpc.io/docs/&#34;&gt;documentation&lt;/a&gt; right here on grpc.io.&lt;/p&gt;
&lt;h3 id=&#34;what-is-the-road-map&#34;&gt;What is the road map?&lt;/h3&gt;
&lt;p&gt;The gRPC project has an RFC process, through which new features are designed and approved for implementation. They are tracked in &lt;a href=&#34;https://github.com/grpc/proposal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this repository&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-long-are-grpc-releases-supported-for&#34;&gt;How long are gRPC releases supported for?&lt;/h3&gt;
&lt;p&gt;The gRPC project does not do LTS releases. Given the rolling release model above, we support the current, latest release and the release prior to that. Support here means bug fixes and security fixes.&lt;/p&gt;
&lt;h3 id=&#34;what-is-the-grpc-versioning-policy&#34;&gt;What is the gRPC versioning policy?&lt;/h3&gt;
&lt;p&gt;See the gRPC versioning policy &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/versioning.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;what-is-the-latest-grpc-version&#34;&gt;What is the latest gRPC Version?&lt;/h3&gt;
&lt;p&gt;The latest release tag is v1.66.0.&lt;/p&gt;
&lt;h3 id=&#34;when-do-grpc-releases-happen&#34;&gt;When do gRPC releases happen?&lt;/h3&gt;
&lt;p&gt;The gRPC project works in a model where the tip of the master branch is stable at all times. The project (across the various runtimes) targets to ship checkpoint releases every 6 weeks on a best effort basis. See the release schedule &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/grpc_release_schedule.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-can-i-report-a-security-vulnerability-in-grpc&#34;&gt;How can I report a security vulnerability in gRPC?&lt;/h3&gt;
&lt;p&gt;To report a security vulnerability in gRPC, please follow the process documented &lt;a href=&#34;https://github.com/grpc/proposal/blob/master/P4-grpc-cve-process.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;can-i-use-it-in-the-browser&#34;&gt;Can I use it in the browser?&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/grpc/grpc-web&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC-Web&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; project is Generally Available.&lt;/p&gt;
&lt;h3 id=&#34;can-i-use-grpc-with-my-favorite-data-format-json-protobuf-thrift-xml-&#34;&gt;Can I use gRPC with my favorite data format (JSON, Protobuf, Thrift, XML) ?&lt;/h3&gt;
&lt;p&gt;Yes. gRPC is designed to be extensible to support multiple content types. The initial release contains support for Protobuf and with external support for other content types such as FlatBuffers and Thrift, at varying levels of maturity.&lt;/p&gt;
&lt;h3 id=&#34;can-i-use-grpc-in-a-service-mesh&#34;&gt;Can I use gRPC in a service mesh?&lt;/h3&gt;
&lt;p&gt;Yes. gRPC applications can be deployed in a service mesh like any other application. gRPC also supports &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xDS APIs&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; which enables deploying gRPC applications in a service mesh without sidecar proxies. The proxyless service mesh features supported in gRPC are listed &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/doc/grpc_xds_features.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;how-does-grpc-help-in-mobile-application-development&#34;&gt;How does gRPC help in mobile application development?&lt;/h3&gt;
&lt;p&gt;gRPC and Protobuf provide an easy way to precisely define a service and auto generate reliable client libraries for iOS, Android and the servers providing the back end. The clients can take advantage of advanced streaming and connection features which help save bandwidth, do more over fewer TCP connections and save CPU usage and battery life.&lt;/p&gt;
&lt;h3 id=&#34;why-is-grpc-better-than-any-binary-blob-over-http2&#34;&gt;Why is gRPC better than any binary blob over HTTP/2?&lt;/h3&gt;
&lt;p&gt;This is largely what gRPC is on the wire. However gRPC is also a set of libraries that will provide higher-level features consistently across platforms that common HTTP libraries typically do not. Examples of such features include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interaction with flow-control at the application layer&lt;/li&gt;
&lt;li&gt;cascading call-cancellation&lt;/li&gt;
&lt;li&gt;load balancing &amp;amp; failover&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;why-is-grpc-betterworse-than-rest&#34;&gt;Why is gRPC better/worse than REST?&lt;/h3&gt;
&lt;p&gt;gRPC largely follows HTTP semantics over HTTP/2 but we explicitly allow for full-duplex streaming. We diverge from typical REST conventions as we use static paths for performance reasons during call dispatch as parsing call parameters from paths, query parameters and payload body adds latency and complexity. We have also formalized a set of errors that we believe are more directly applicable to API use cases than the HTTP status codes.&lt;/p&gt;
&lt;h3 id=&#34;how-do-you-pronounce-grpc&#34;&gt;How do you pronounce gRPC?&lt;/h3&gt;
&lt;p&gt;Jee-Arr-Pee-See.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
