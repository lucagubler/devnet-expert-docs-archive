{"pageProps":{"currentPath":"identity/secure-intro","frontMatter":{"layout":"guides","page_title":"Secure Introduction of Vault Clients - Guides","description":"This introductory guide walk through the mechanism of Vault clients to\nauthenticate with Vault. There are two approaches at a high-level: platform\nintegration, and trusted orchestrator."},"githubFileUrl":"https://github.com/hashicorp/vault/blob/main/website/content/guides/identity/secure-intro.mdx","mdxSource":{"compiledSource":"var p=Object.defineProperty;var s=Object.prototype.hasOwnProperty;var i=Object.getOwnPropertySymbols,o=Object.prototype.propertyIsEnumerable;var l=(a,t,n)=>t in a?p(a,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[t]=n,e=(a,t)=>{for(var n in t||(t={}))s.call(t,n)&&l(a,n,t[n]);if(i)for(var n of i(t))o.call(t,n)&&l(a,n,t[n]);return a};var h=(a,t)=>{var n={};for(var r in a)s.call(a,r)&&t.indexOf(r)<0&&(n[r]=a[r]);if(a!=null&&i)for(var r of i(a))t.indexOf(r)<0&&o.call(a,r)&&(n[r]=a[r]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var r=n,{components:a}=r,t=h(r,[\"components\"]);return mdx(MDXLayout,e(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"h1\",e({},{className:\"g-type-display-2\"}),mdx(\"a\",e({parentName:\"h1\"},{className:\"__permalink-h\",href:\"#secure-introduction-of-vault-clients\",\"aria-label\":\"secure introduction of vault clients permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h1\"},{className:\"__target-h\",id:\"secure-introduction-of-vault-clients\",\"aria-hidden\":\"\"})),\"Secure Introduction of Vault Clients\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"A \",mdx(\"em\",{parentName:\"p\"},\"secret\"),` is something that will elevate the risk if exposed to unauthorized\nentities and results in undesired consequences (e.g. unauthorized data access);\ntherefore, only the `,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},\"trusted entities\")),` should have an access to your\nsecrets.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`If you can securely get the first secret from an originator to a consumer, all\nsubsequent secrets transmitted between this originator and consumer can be\nauthenticated with the trust established by the successful distribution and user\nof that first secret. Getting the first secret to the consumer, is the `,mdx(\"strong\",{parentName:\"p\"},mdx(\"em\",{parentName:\"strong\"},`secure\nintroduction`)),\" challenge.\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-secure-intro-1.png\",alt:\"Secure Introduction\"}))),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`The Vault authentication process verifies the secret consumer's identity and\nthen generate a `,mdx(\"strong\",{parentName:\"p\"},\"token\"),` to associate with that identity.\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"/docs/concepts/tokens\"}),\"Tokens\"),` are the core method for authentication\nwithin Vault which means that the secret consumer must first acquire a valid\ntoken.`),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#challenge\",\"aria-label\":\"challenge permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"challenge\",\"aria-hidden\":\"\"})),\"Challenge\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`How does a secret consumer (an application or machine) prove that it is the\nlegitimate recipient for a secret so that it can acquire a token?`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`How can you avoid persisting raw token values during our secure\nintroduction?`),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#secure-introduction-approach\",\"aria-label\":\"secure introduction approach permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"secure-introduction-approach\",\"aria-hidden\":\"\"})),\"Secure Introduction Approach\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`Vault's auth methods perform authentication of its client and assigning a set of\npolicies which defines the permitted operations for the client.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-auth-method.png\",alt:\"Auth Method\"}))),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"There are three basic approaches to securely authenticate a secret consumer:\"),mdx(\"ul\",null,mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"#platform-integration\"}),\"Platform Integration\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"#trusted-orchestrator\"}),\"Trusted Orchestrator\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"#vault-agent\"}),\"Vault Agent\"))),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#platform-integration\",\"aria-label\":\"platform integration permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"platform-integration\",\"aria-hidden\":\"\"})),\"Platform Integration\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"In the \",mdx(\"strong\",{parentName:\"p\"},\"Platform Integration\"),` model, Vault trusts the underlying platform\n(e.g. AliCloud, AWS, Azure, GCP) which assigns a token or cryptographic identity\n(such as IAM token, signed JWT) to virtual machine, container, or serverless\nfunction.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`Vault uses the provided identifier to verify the identity of the client by\ninteracting with the underlying platform. After the client identity is verified,\nVault returns a token to the client that is bound to their identity and policies\nthat grant access to secrets.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-secure-intro-2.png\",alt:\"Platform Integration\"}))),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`For example, suppose we have an application running on a virtual machine in AWS\nEC2. When that instance is started, an IAM token is provided via the machine\nlocal metadata URL. That IAM token is provided to Vault, as part of the AWS Auth\nMethod, to login and authenticate the client. Vault uses that token to query the\nAWS API and verify the token validity and fetch additional metadata about the\ninstance (Account ID, VPC ID, AMI, Region, etc). These properties are used to\ndetermine the identity of the client and to distinguish between different roles\n(e.g. a Web server versus an API server).`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`Once validated and assigned to a role, Vault generates a token that is\nappropriately scoped and returns it to the client. All future requests from the\nclient are made with the associated token, allowing Vault to efficiently\nauthenticate the client and check for proper authorizations when consuming\nsecrets.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-aws-ec2-auth-flow.png\",alt:\"Vault AWS EC2 Authentication Flow\"}))),mdx(\"h3\",e({},{className:\"g-type-display-4\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"__permalink-h\",href:\"#use-case\",\"aria-label\":\"use case permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h3\"},{className:\"__target-h\",id:\"use-case\",\"aria-hidden\":\"\"})),\"Use Case\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`When the client app is running on a VM hosted on a supported cloud platform, you\ncan leverage the corresponding auth method to authenticate with Vault.`),mdx(\"h3\",e({},{className:\"g-type-display-4\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"__permalink-h\",href:\"#reference-materials\",\"aria-label\":\"reference materials permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h3\"},{className:\"__target-h\",id:\"reference-materials\",\"aria-hidden\":\"\"})),\"Reference Materials:\"),mdx(\"ul\",null,mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/aws\"}),\"AWS Auth Method\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/azure\"}),\"Azure Auth Method\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/gcp\"}),\"GCP Auth Method\"))),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#trusted-orchestrator\",\"aria-label\":\"trusted orchestrator permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"trusted-orchestrator\",\"aria-hidden\":\"\"})),\"Trusted Orchestrator\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"In the \",mdx(\"strong\",{parentName:\"p\"},\"Trusted Orchestrator\"),\" model, you have an \",mdx(\"em\",{parentName:\"p\"},\"orchestrator\"),` which is\nalready authenticated against Vault with privileged permissions. The\norchestrator launches new applications and inject a mechanism they can use to\nauthenticate (e.g. AppRole, PKI cert, token, etc) with Vault.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-secure-intro-3.png\",alt:\"Trusted Orchestrator\"}))),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"For example, suppose \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://www.terraform.io/\"}),\"Terraform\"),` is being used as a\ntrusted orchestrator. This means Terraform already has a Vault token, with\nenough capabilities to generate new tokens or create new mechanisms to\nauthenticate such as an AppRole. Terraform can interact with platforms such as\nVMware to provision new virtual machines. VMware does not provide a\ncryptographic identity, so a platform integration isn't possible. Instead,\nTerraform can provision a new AppRole credential, and SSH into the new machine\nto inject the credentials. Terraform is creating the new credential in Vault,\nand making that credential available to the new resource. In this way, Terraform\nis acting as a trusted orchestrator and extending trust to the new machine. The\nnew machine, or application running on it, can use the injected credentials to\nauthenticate against Vault.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-secure-intro-4.png\",alt:\"AppRole auth method workflow\"}))),mdx(\"h3\",e({},{className:\"g-type-display-4\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"__permalink-h\",href:\"#use-case-1\",\"aria-label\":\"use case permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h3\"},{className:\"__target-h\",id:\"use-case-1\",\"aria-hidden\":\"\"})),\"Use Case\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`When you are using an orchestrator tool such as Chef to launch applications,\nthis model can be applied regardless of where the applications are running.`),mdx(\"h3\",e({},{className:\"g-type-display-4\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"__permalink-h\",href:\"#reference-materials-1\",\"aria-label\":\"reference materials permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h3\"},{className:\"__target-h\",id:\"reference-materials-1\",\"aria-hidden\":\"\"})),\"Reference Materials:\"),mdx(\"ul\",null,mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/approle\"}),\"AppRole Auth Method\"),mdx(\"ul\",{parentName:\"li\"},mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/guides/identity/authentication\"}),\"AppRole Pull Authentication\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/guides/identity/approle-trusted-entities\"}),\"AppRole with Terraform and Chef Demo\")))),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/cert\"}),\"TLS Certificates Auth Method\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/auth/token\"}),\"Token Auth Method\"),mdx(\"ul\",{parentName:\"li\"},mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/guides/secret-mgmt/cubbyhole\"}),\"Cubbyhole Response Wrapping\"))))),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#vault-agent\",\"aria-label\":\"vault agent permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"vault-agent\",\"aria-hidden\":\"\"})),\"Vault Agent\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`Vault agent is a client daemon which automates the workflow of client login and\ntoken refresh. It can be used with either `,mdx(\"a\",e({parentName:\"p\"},{href:\"#platform-integration\"}),`platform\nintegration`),\" or \",mdx(\"a\",e({parentName:\"p\"},{href:\"#trusted-orchestrator\"}),`trusted\norchestrator`),\" approaches.\"),mdx(\"h4\",e({},{className:\"g-type-display-5\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"__permalink-h\",href:\"#vault-agent-auto-auth\",\"aria-label\":\"vault agent auto auth permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h4\"},{className:\"__target-h\",id:\"vault-agent-auto-auth\",\"aria-hidden\":\"\"})),\"Vault agent auto-auth:\"),mdx(\"ul\",null,mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),\"Automatically authenticates to Vault for those \",mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/agent/autoauth/methods\"}),\"supported auth methods\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),`Keeps token renewed (re-authenticates as needed) until the renewal is no\nlonger allowed`),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),\"Designed with robustness and fault tolerance\")),mdx(\"p\",e({},{className:\"g-type-long-body\"}),mdx(\"img\",e({parentName:\"p\"},{src:\"/img/vault-secure-intro-5.png\",alt:\"Vault Agent\"}))),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"To leverage this feature, run the vault binary in agent mode (\",mdx(\"inlineCode\",{parentName:\"p\"},\"vault agent -config=<config_file>\"),`) on the client. The agent configuration file must specify\nthe auth method and `,mdx(\"a\",e({parentName:\"p\"},{href:\"/docs/agent/autoauth/sinks\"}),\"sink\"),` locations\nwhere the token to be written.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`When the agent is started, it will attempt to acquire a Vault token using the\nauth method specified in the agent configuration file. On successful\nauthentication, the resulting token is written to the sink locations.\nOptionally, this token can be response-wrapped or encrypted. Whenever the\ncurrent token value changes, the agent writes to the sinks. If authentication\nfails, the agent waits for a while and then retry.`),mdx(\"p\",e({},{className:\"g-type-long-body\"}),`The client can simply retrieve the token from the sink and connect to Vault\nusing the token. This simplifies client integration since the Vault agent\nhandles the login and token refresh logic.`),mdx(\"h3\",e({},{className:\"g-type-display-4\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"__permalink-h\",href:\"#reference-materials-2\",\"aria-label\":\"reference materials permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h3\"},{className:\"__target-h\",id:\"reference-materials-2\",\"aria-hidden\":\"\"})),\"Reference Materials:\"),mdx(\"ul\",null,mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"https://youtu.be/zDnIqSB4tyA\"}),\"Streamline Secrets Management with Vault Agent and Vault 0.11\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/agent\"}),\"Vault Agent documentation\")),mdx(\"li\",e({parentName:\"ul\"},{className:\"g-type-long-body\"}),mdx(\"a\",e({parentName:\"li\"},{href:\"/docs/agent/autoauth\"}),\"Auto-Auth documentation\"))),mdx(\"h2\",e({},{className:\"g-type-display-3\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"__permalink-h\",href:\"#next-steps\",\"aria-label\":\"next steps permalink\"}),\"\\xBB\"),mdx(\"a\",e({parentName:\"h2\"},{className:\"__target-h\",id:\"next-steps\",\"aria-hidden\":\"\"})),\"Next steps\"),mdx(\"p\",e({},{className:\"g-type-long-body\"}),\"When a \",mdx(\"a\",e({parentName:\"p\"},{href:\"#platform-integration\"}),\"platform integration\"),` is available that should be\npreferred, as it is generally the simpler solution and works independent of the\norchestration mechanism. For a `,mdx(\"a\",e({parentName:\"p\"},{href:\"#trusted-orchestrator\"}),\"trusted orchestrator\"),`,\nspecific documentation for that orchestrator should be consulted on Vault\nintegration.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"navData":[{"title":"Getting Started","path":"getting-started","filePath":"content/guides/getting-started.mdx"},{"title":"Vault Operations","routes":[{"title":"Overview","path":"operations","filePath":"content/guides/operations/index.mdx"},{"title":"Reference Architecture","path":"operations/reference-architecture","filePath":"content/guides/operations/reference-architecture.mdx"},{"title":"Vault HA with Consul","path":"operations/vault-ha-consul","filePath":"content/guides/operations/vault-ha-consul.mdx"},{"title":"Production Hardening","path":"operations/production","filePath":"content/guides/operations/production.mdx"},{"title":"Root Token Generation","path":"operations/generate-root","filePath":"content/guides/operations/generate-root.mdx"},{"title":"Rekeying & Rotating","path":"operations/rekeying-and-rotating","filePath":"content/guides/operations/rekeying-and-rotating.mdx"},{"title":"Building Plugin Backends","path":"operations/plugin-backends","filePath":"content/guides/operations/plugin-backends.mdx"},{"divider":true},{"title":"Replication Setup & Guidance","path":"operations/replication","filePath":"content/guides/operations/replication.mdx"},{"title":"Disaster Recovery Setup","path":"operations/disaster-recovery","filePath":"content/guides/operations/disaster-recovery.mdx"},{"title":"Mount Filter","path":"operations/mount-filter","filePath":"content/guides/operations/mount-filter.mdx"},{"title":"Multi-Tenant: Namespaces","path":"operations/multi-tenant","filePath":"content/guides/operations/multi-tenant.mdx"},{"title":"Vault Auto-unseal with AWS KMS","path":"operations/autounseal-aws-kms","filePath":"content/guides/operations/autounseal-aws-kms.mdx"},{"title":"Seal Wrap / FIPS 140-2","path":"operations/seal-wrap","filePath":"content/guides/operations/seal-wrap.mdx"},{"title":"Vault Cluster Monitoring","path":"operations/monitoring","filePath":"content/guides/operations/monitoring.mdx"},{"title":"Vault Deployment Guide","path":"operations/deployment-guide","filePath":"content/guides/operations/deployment-guide.mdx"},{"title":"Performance Standby Nodes","path":"operations/performance-nodes","filePath":"content/guides/operations/performance-nodes.mdx"}]},{"title":"Identity and Access Management","routes":[{"title":"Overview","path":"identity","filePath":"content/guides/identity/index.mdx"},{"title":"Secure Introduction of Vault Clients","path":"identity/secure-intro","filePath":"content/guides/identity/secure-intro.mdx"},{"title":"Policies","path":"identity/policies","filePath":"content/guides/identity/policies.mdx"},{"title":"ACL Policy Path Templating","path":"identity/policy-templating","filePath":"content/guides/identity/policy-templating.mdx"},{"title":"AppRole Pull Authentication","path":"identity/authentication","filePath":"content/guides/identity/authentication.mdx"},{"title":"AppRole with Terraform and Chef","path":"identity/approle-trusted-entities","filePath":"content/guides/identity/approle-trusted-entities.mdx"},{"title":"Tokens and Leases","path":"identity/lease","filePath":"content/guides/identity/lease.mdx"},{"title":"Identity - Entities & Groups","path":"identity/identity","filePath":"content/guides/identity/identity.mdx"},{"divider":true},{"title":"Sentinel Policies","path":"identity/sentinel","filePath":"content/guides/identity/sentinel.mdx"},{"title":"Control Groups","path":"identity/control-groups","filePath":"content/guides/identity/control-groups.mdx"}]},{"title":"Secrets Management","routes":[{"title":"Overview","path":"secret-mgmt","filePath":"content/guides/secret-mgmt/index.mdx"},{"title":"Static Secrets","path":"secret-mgmt/static-secrets","filePath":"content/guides/secret-mgmt/static-secrets.mdx"},{"title":"Versioned KV Secret Engine","path":"secret-mgmt/versioned-kv","filePath":"content/guides/secret-mgmt/versioned-kv.mdx"},{"title":"Secret as a Service","path":"secret-mgmt/dynamic-secrets","filePath":"content/guides/secret-mgmt/dynamic-secrets.mdx"},{"title":"DB Root Credential Rotation","path":"secret-mgmt/db-root-rotation","filePath":"content/guides/secret-mgmt/db-root-rotation.mdx"},{"title":"Cubbyhole Response Wrapping","path":"secret-mgmt/cubbyhole","filePath":"content/guides/secret-mgmt/cubbyhole.mdx"},{"title":"One-Time SSH Password","path":"secret-mgmt/ssh-otp","filePath":"content/guides/secret-mgmt/ssh-otp.mdx"},{"title":"Build Your Own CA","path":"secret-mgmt/pki-engine","filePath":"content/guides/secret-mgmt/pki-engine.mdx"},{"title":"Direct Application Integration","path":"secret-mgmt/app-integration","filePath":"content/guides/secret-mgmt/app-integration.mdx"}]},{"title":"Encryption as a Service","routes":[{"title":"Overview","path":"encryption","filePath":"content/guides/encryption/index.mdx"},{"title":"Encryption as a Service","path":"encryption/transit","filePath":"content/guides/encryption/transit.mdx"},{"title":"Java Application Demo","path":"encryption/spring-demo","filePath":"content/guides/encryption/spring-demo.mdx"},{"title":"Transit Secrets Re-wrapping","path":"encryption/transit-rewrap","filePath":"content/guides/encryption/transit-rewrap.mdx"}]}],"versions":[]},"__N_SSG":true}